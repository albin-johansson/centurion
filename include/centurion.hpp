/*
 * MIT License
 *
 * Copyright (c) 2019-2021 Albin Johansson
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#ifndef CENTURION_CENTURION_HEADER
#define CENTURION_CENTURION_HEADER

#ifndef CENTURION_NO_PRAGMA_ONCE
#pragma once
#endif  // CENTURION_NO_PRAGMA_ONCE

// #include "centurion/audio/channels.hpp"
#ifndef CENTURION_CHANNELS_HEADER
#define CENTURION_CHANNELS_HEADER

#ifndef CENTURION_NO_SDL_MIXER

#include <SDL.h>
#include <SDL_mixer.h>

#include <optional>  // optional

// #include "../core/result.hpp"
#ifndef CENTURION_RESULT_HEADER
#define CENTURION_RESULT_HEADER

#include <ostream>  // ostream
#include <string>   // string

namespace cen {

/// \addtogroup core
/// \{

/**
 * \class result
 *
 * \brief A simple indicator for the result of different operations.
 *
 * \details The idea behind this class is to make results of various operations
 * unambiguous. Quite an amount of functions in the library may fail, and earlier versions
 * of Centurion would usually return a `bool` in those cases, where `true` and `false`
 * would indicate success and failure, respectively. This class is a development of that
 * practice. For instance, this class is contextually convertible to `bool`, where a
 * successful result is still converted to `true`, and vice versa. However, this class
 * also enables explicit checks against `success` and `failure` constants, which makes
 * code very easy to read and unambiguous.
 * \code{cpp}
 *   cen::window window;
 *
 *   if (window.set_opacity(0.4f))
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::success)
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::failure)
 *   {
 *     // Failure!
 *   }
 * \endcode
 *
 * \see `success`
 * \see `failure`
 *
 * \since 6.0.0
 */
class result final
{
 public:
  /**
   * \brief Creates a result.
   *
   * \param success `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  constexpr result(const bool success) noexcept  // NOLINT implicit
      : m_success{success}
  {}

  /// \name Comparison operators
  /// \{

  /**
   * \brief Indicates whether or not two results have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results are equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator==(const result other) const noexcept -> bool
  {
    return m_success == other.m_success;
  }

  /**
   * \brief Indicates whether or not two results don't have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results aren't equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator!=(const result other) const noexcept -> bool
  {
    return !(*this == other);
  }

  /// \} End of comparison operators

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not the result is successful.
   *
   * \return `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr explicit operator bool() const noexcept
  {
    return m_success;
  }

  /// \} End of conversions

 private:
  bool m_success{};
};

/// Represents a successful result.
/// \since 6.0.0
inline constexpr result success{true};

/// Represents a failure of some kind.
/// \since 6.0.0
inline constexpr result failure{false};

/// \name String conversions
/// \{

/**
 * \brief Returns a string that represents a result value.
 *
 * \note The returned string is in a slightly different format compared to other Centurion
 * components.
 *
 * \param result the value that will be converted.
 *
 * \return `"success"` for a successful result; `"failure"` otherwise.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto to_string(const result result) -> std::string
{
  return result ? "success" : "failure";
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a result value using a stream.
 *
 * \param stream the stream that will be used.
 * \param result the result value that will be printed.
 *
 * \return the used stream.
 *
 * \since 6.0.0
 */
inline auto operator<<(std::ostream& stream, const result result) -> std::ostream&
{
  return stream << to_string(result);
}

/// \} End of streaming

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_RESULT_HEADER

// #include "../core/time.hpp"
#ifndef CENTURION_TIME_HEADER
#define CENTURION_TIME_HEADER

#include <chrono>  // duration
#include <ratio>   // milli, micro, nano

// #include "integers.hpp"
#ifndef CENTURION_INTEGERS_HEADER
#define CENTURION_INTEGERS_HEADER

#include <SDL.h>

#include <cstddef>  // size_t

namespace cen {

/// \addtogroup core
/// \{

/// \name Integer aliases
/// \{

using usize = std::size_t;

/// Alias for an unsigned integer.
using uint = unsigned int;

/// Alias for the type used for integer literal operators.
using ulonglong = unsigned long long;

/// Alias for a 64-bit unsigned integer.
using u64 = Uint64;

/// Alias for a 32-bit unsigned integer.
using u32 = Uint32;

/// Alias for a 16-bit unsigned integer.
using u16 = Uint16;

/// Alias for an 8-bit unsigned integer.
using u8 = Uint8;

/// Alias for a 64-bit signed integer.
using i64 = Sint64;

/// Alias for a 32-bit signed integer.
using i32 = Sint32;

/// Alias for a 16-bit signed integer.
using i16 = Sint16;

/// Alias for an 8-bit signed integer.
using i8 = Sint8;

/// \} End of integer aliases

// clang-format off

/**
 * \brief Obtains the size of a container as an `int`.
 *
 * \tparam T a "container" that provides a `size()` member function.
 *
 * \param container the container to query the size of.
 *
 * \return the size of the container as an `int` value.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto isize(const T& container) noexcept(noexcept(container.size()))
    -> int
{
  return static_cast<int>(container.size());
}

// clang-format on

namespace literals {

/**
 * \brief Creates an 8-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u8(const ulonglong value) noexcept -> u8
{
  return static_cast<u8>(value);
}

/**
 * \brief Creates a 16-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u16(const ulonglong value) noexcept -> u16
{
  return static_cast<u16>(value);
}

/**
 * \brief Creates a 32-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u32(const ulonglong value) noexcept -> u32
{
  return static_cast<u32>(value);
}

/**
 * \brief Creates a 64-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u64(const ulonglong value) noexcept -> u64
{
  return static_cast<u64>(value);
}

/**
 * \brief Creates an 8-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i8(const ulonglong value) noexcept -> i8
{
  return static_cast<i8>(value);
}

/**
 * \brief Creates a 16-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i16(const ulonglong value) noexcept -> i16
{
  return static_cast<i16>(value);
}

/**
 * \brief Creates a 32-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i32(const ulonglong value) noexcept -> i32
{
  return static_cast<i32>(value);
}

/**
 * \brief Creates a 64-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i64(const ulonglong value) noexcept -> i64
{
  return static_cast<i64>(value);
}

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_INTEGERS_HEADER


namespace cen {

/// \addtogroup core
/// \{

/// \name Time (std::chrono) aliases
/// \{

/**
 * \typedef seconds
 *
 * \brief Templated alias for durations in seconds.
 */
template <typename T>
using seconds = std::chrono::duration<T>;

/**
 * \typedef milliseconds
 *
 * \brief Templated alias for durations in milliseconds.
 */
template <typename T>
using milliseconds = std::chrono::duration<T, std::milli>;

/**
 * \typedef microseconds
 *
 * \brief Templated alias for durations in microseconds.
 */
template <typename T>
using microseconds = std::chrono::duration<T, std::micro>;

/**
 * \typedef nanoseconds
 *
 * \brief Templated alias for durations in nanoseconds.
 */
template <typename T>
using nanoseconds = std::chrono::duration<T, std::nano>;

/**
 * \typedef minutes
 *
 * \brief Templated alias for durations in minutes.
 */
template <typename T>
using minutes = std::chrono::duration<T, std::ratio<60>>;

/// \} End of time (std::chrono) aliases

namespace literals {

// clang-format off

[[nodiscard]] constexpr auto operator"" _ns(const ulonglong value) noexcept(noexcept(nanoseconds<u32>{}))
    -> nanoseconds<u32>
{
  return nanoseconds<u32>{value};
}

[[nodiscard]] constexpr auto operator"" _us(const ulonglong value) noexcept(noexcept(microseconds<u32>{}))
    -> microseconds<u32>
{
  return microseconds<u32>{value};
}

[[nodiscard]] constexpr auto operator"" _ms(const ulonglong value) noexcept(noexcept(milliseconds<u32>{}))
    -> milliseconds<u32>
{
  return milliseconds<u32>{value};
}

[[nodiscard]] constexpr auto operator"" _s(const ulonglong value) noexcept(noexcept(seconds<u32>{}))
    -> seconds<u32>
{
  return seconds<u32>{value};
}

// clang-format on

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_TIME_HEADER


namespace cen {

/// \addtogroup audio
/// \{

using channel_index = int;

using group_index = int;

using channel_finished_callback = void(SDLCALL*)(channel_index) noexcept;

/// \} End of group audio

/// \namespace cen::channels
/// \brief Contains functions related to audio channels.
/// \ingroup audio
/// \since 6.0.0
namespace channels {

/// \addtogroup audio
/// \{

/// \name Channel functions
/// \{

/**
 * \brief Assigns a callback for when a channel finishes its playback.
 *
 * \param callback the callback that will be used; can safely be null to disable the
 * callback.
 *
 * \see `Mix_ChannelFinished`
 *
 * \since 6.0.0
 */
inline void on_finished(channel_finished_callback callback) noexcept
{
  Mix_ChannelFinished(callback);
}

/**
 * \brief Changes the amount of channels managed by the mixer.
 *
 * \note The the channel count is decreased, the removed channels are stopped.
 *
 * \param count the total amount of channels managed by the mixer.
 *
 * \return the number of allocated channels.
 *
 * \see `Mix_AllocateChannels`
 *
 * \since 6.0.0
 */
inline auto allocate(const int count) noexcept -> int
{
  return Mix_AllocateChannels(count);
}

/**
 * \brief Reserves a group of channels for the use of the application.
 *
 * \param count the desired amount of channels to be reserved.
 *
 * \return the number of reserved channels.
 *
 * \see `Mix_ReserveChannels`
 *
 * \since 6.0.0
 */
inline auto reserve(const int count) noexcept -> int
{
  return Mix_ReserveChannels(count);
}

/**
 * \brief Sets a channel to stop playing after the specified amount of time.
 *
 * \param channel the channel that will be affected.
 * \param ms the duration of the expiration.
 *
 * \return `success` if the operation was successful; `failure` otherwise.
 *
 * \see `Mix_ExpireChannel`
 *
 * \since 6.0.0
 */
inline auto expire(const channel_index channel,
                   const milliseconds<int> ms) noexcept(noexcept(ms.count())) -> result
{
  return Mix_ExpireChannel(channel, ms.count()) != 0;
}

/**
 * \brief Removes the current expiration from the specified channel.
 *
 * \param channel the channel that will be affected.
 *
 * \return `success` if the operation was successful; `failure` otherwise.
 *
 * \since 6.0.0
 */
inline auto remove_expiration(const channel_index channel) noexcept -> result
{
  return Mix_ExpireChannel(channel, -1) != 0;
}

/**
 * \brief Sets the group that a channel belongs to.
 *
 * \param channel the channel that will be affected.
 * \param group the group will be assigned to the channel.
 *
 * \return `success` if the group was assigned successfully; `failure` otherwise.
 *
 * \see `Mix_GroupChannel`
 *
 * \since 6.0.0
 */
inline auto set_group(const channel_index channel, const group_index group) noexcept -> result
{
  return Mix_GroupChannel(channel, group) == 1;
}

/**
 * \brief Resets the group that a channel is assigned to.
 *
 * \param channel the channel which reset to belong to the default channel group.
 *
 * \return `success` if the channel group was reset successfully; `failure` otherwise.
 *
 * \since 6.0.0
 */
inline auto reset_group(const channel_index channel) noexcept -> result
{
  return set_group(channel, -1);
}

/**
 * \brief Returns the number of channels in the specified group.
 *
 * \note If the supplied group is `-1`, then this function returns the total amount of
 * channels.
 *
 * \param group the index of the channel group that will be checked.
 *
 * \return the number of channels in the group.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto group_count(const group_index group = -1) noexcept -> int
{
  return Mix_GroupCount(group);
}

/**
 * \brief Returns the first available channel in the specified group.
 *
 * \param group the channel group that will be checked.
 *
 * \return an available channel index in the specified group; `std::nullopt` if no channel
 * was available.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto first_available(const group_index group) noexcept
    -> std::optional<channel_index>
{
  const auto channel = Mix_GroupAvailable(group);
  if (channel != -1) {
    return channel;
  }
  else {
    return std::nullopt;
  }
}

/**
 * \brief Returns the most recently playing channel in the specified group.
 *
 * \param group the channel group that will be checked.
 *
 * \return the most recently playing channel in the group; `std::nullopt` if it couldn't
 * be determined.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto most_recent(const group_index group) -> std::optional<channel_index>
{
  const auto channel = Mix_GroupNewer(group);
  if (channel != -1) {
    return channel;
  }
  else {
    return std::nullopt;
  }
}

/**
 * \brief Returns the oldest playing channel in the specified group.
 *
 * \param group the channel group that will be checked.
 *
 * \return the oldest playing channel in the group; `std::nullopt` if it couldn't be
 * determined.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto oldest(const group_index group) -> std::optional<channel_index>
{
  const auto channel = Mix_GroupOldest(group);
  if (channel != -1) {
    return channel;
  }
  else {
    return std::nullopt;
  }
}

/// \} End of channel functions

/// \} End of group audio

}  // namespace channels

}  // namespace cen

#endif  // CENTURION_NO_SDL_MIXER
#endif  // CENTURION_CHANNELS_HEADER

// #include "centurion/audio/fade_status.hpp"
#ifndef CENTURION_FADE_STATUS_HEADER
#define CENTURION_FADE_STATUS_HEADER

#ifndef CENTURION_NO_SDL_MIXER

#include <SDL_mixer.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER


namespace cen {

/// \addtogroup audio
/// \{

/**
 * \enum fade_status
 *
 * \brief Provides values that represent different fade playback states.
 *
 * \see `Mix_Fading`
 * \see `fade_status_count()`
 *
 * \since 3.0.0
 */
enum class fade_status
{
  none = MIX_NO_FADING,  ///< No currently fading music.
  in = MIX_FADING_IN,    ///< Currently fading in music.
  out = MIX_FADING_OUT   ///< Currently fading out music.
};

/**
 * \brief Returns the number of enumerators for the `fade_status` enum.
 *
 * \return the number of enumerators.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto fade_status_count() noexcept -> int
{
  return 3;
}

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied fade status.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(fade_status::in) == "in"`.
 *
 * \param status the fade status that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const fade_status status) -> std::string_view
{
  switch (status) {
    case fade_status::none:
      return "none";

    case fade_status::in:
      return "in";

    case fade_status::out:
      return "out";

    default:
      throw cen_error{"Did not recognize fade status!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a fade status enumerator.
 *
 * \param stream the output stream that will be used.
 * \param status the fade status that will be printed.
 *
 * \see `to_string(fade_status)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const fade_status status) -> std::ostream&
{
  return stream << to_string(status);
}

/// \} End of streaming

/// \name Fade status comparison operators
/// \{

/**
 * \brief Indicates whether or not the fading status values represent are the same.
 *
 * \param lhs the left-hand side fading status value.
 * \param rhs the right-hand side fading status value.
 *
 * \return `true` if the fading status values are the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const fade_status lhs, const Mix_Fading rhs) noexcept
    -> bool
{
  return static_cast<Mix_Fading>(lhs) == rhs;
}

/// \copydoc operator==(fade_status, Mix_Fading)
[[nodiscard]] constexpr auto operator==(const Mix_Fading lhs, const fade_status rhs) noexcept
    -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the fading status values represent aren't the same.
 *
 * \param lhs the left-hand side fading status value.
 * \param rhs the right-hand side fading status value.
 *
 * \return `true` if the fading status values aren't the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator!=(const fade_status lhs, const Mix_Fading rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(fade_status, Mix_Fading)
[[nodiscard]] constexpr auto operator!=(const Mix_Fading lhs, const fade_status rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \} End of fade status comparison operators

/// \} End of group audio

}  // namespace cen

#endif  // CENTURION_NO_SDL_MIXER
#endif  // CENTURION_FADE_STATUS_HEADER

// #include "centurion/audio/music.hpp"
#ifndef CENTURION_MUSIC_HEADER
#define CENTURION_MUSIC_HEADER

#ifndef CENTURION_NO_SDL_MIXER

#include <SDL_mixer.h>

#include <cassert>   // assert
#include <memory>    // unique_ptr
#include <optional>  // optional
#include <ostream>   // ostream
#include <string>    // string, to_string

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/not_null.hpp"
#ifndef CENTURION_NOT_NULL_HEADER
#define CENTURION_NOT_NULL_HEADER

// #include "sfinae.hpp"
#ifndef CENTURION_SFINAE_HEADER
#define CENTURION_SFINAE_HEADER

#include <type_traits>  // enable_if_t, is_same_v, is_integral_v, is_floating_point_v, ...

namespace cen {

/// \addtogroup core
/// \{

// clang-format off

/// Enables a template if the type is either integral of floating-point, but not a boolean.
template <typename T>
using enable_if_number_t = std::enable_if_t<!std::is_same_v<T, bool> &&
                                            (std::is_integral_v<T> ||
                                             std::is_floating_point_v<T>), int>;

// clang-format on

/// Enables a template if the type is a pointer.
template <typename T>
using enable_if_pointer_v = std::enable_if_t<std::is_pointer_v<T>, int>;

/// Enables a template if T is convertible to any of the specified types.
template <typename T, typename... Args>
using enable_if_convertible_t = std::enable_if_t<(std::is_convertible_v<T, Args> || ...), int>;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_SFINAE_HEADER


namespace cen {

/**
 * \typedef not_null
 *
 * \ingroup core
 *
 * \brief Tag used to indicate that a pointer cannot be null.
 *
 * \note This alias is equivalent to `T`, it is a no-op.
 *
 * \since 5.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using not_null = T;

}  // namespace cen

#endif  // CENTURION_NOT_NULL_HEADER

// #include "../core/result.hpp"

// #include "../core/str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER

// #include "../core/time.hpp"

// #include "../detail/address_of.hpp"
#ifndef CENTURION_DETAIL_ADDRESS_OF_HEADER
#define CENTURION_DETAIL_ADDRESS_OF_HEADER

#include <sstream>  // stringstream
#include <string>   // string

// #include "../compiler/compiler.hpp"
#ifndef CENTURION_COMPILER_HEADER
#define CENTURION_COMPILER_HEADER

#include <SDL.h>

namespace cen {

/// \addtogroup compiler
/// \{

/**
 * \brief Indicates whether or not a "debug" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a debug build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_debug_build() noexcept -> bool
{
#ifndef NDEBUG
  return true;
#else
  return false;
#endif  // NDEBUG
}

/**
 * \brief Indicates whether or not a "release" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a release build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_release_build() noexcept -> bool
{
  return !is_debug_build();
}

/**
 * \brief Indicates whether or not the compiler is MSVC.
 *
 * \return `true` if MSVC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_msvc() noexcept -> bool
{
#ifdef _MSC_VER
  return true;
#else
  return false;
#endif  // _MSC_VER
}

/**
 * \brief Indicates whether or not the compiler is GCC.
 *
 * \return `true` if GCC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_gcc() noexcept -> bool
{
#ifdef __GNUC__
  return true;
#else
  return false;
#endif  // __GNUC__
}

/**
 * \brief Indicates whether or not the compiler is Clang.
 *
 * \return `true` if Clang is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_clang() noexcept -> bool
{
#ifdef __clang__
  return true;
#else
  return false;
#endif  // __clang__
}

/**
 * \brief Indicates whether or not the compiler is Emscripten.
 *
 * \return `true` if Emscripten is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_emscripten() noexcept -> bool
{
#ifdef __EMSCRIPTEN__
  return true;
#else
  return false;
#endif  // __EMSCRIPTEN__
}

/**
 * \brief Indicates whether or not the compiler is Intel C++.
 *
 * \return `true` if Intel C++ is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_intel_cpp() noexcept -> bool
{
#ifdef __INTEL_COMPILER
  return true;
#else
  return false;
#endif  // __INTEL_COMPILER
}

/// \} End of compiler group

}  // namespace cen

#endif  // CENTURION_COMPILER_HEADER


/// \cond FALSE
namespace cen::detail {

/**
 * \brief Returns a string that represents the memory address of the supplied pointer.
 *
 * \details The empty string is returned if the supplied pointer is null.
 *
 * \tparam T the type of the pointer.
 * \param ptr the pointer that will be converted.
 *
 * \return a string that represents the memory address of the supplied pointer.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto address_of(const void* ptr) -> std::string
{
  if (ptr) {
    std::stringstream stream;

    if constexpr (on_msvc()) {
      stream << "0x";  // Only MSVC seems to omit this, add it for consistency
    }

    stream << ptr;
    return stream.str();
  }
  else {
    return std::string{};
  }
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_ADDRESS_OF_HEADER

// #include "../detail/any_eq.hpp"
#ifndef CENTURION_DETAIL_ANY_EQ_HEADER
#define CENTURION_DETAIL_ANY_EQ_HEADER

/// \cond FALSE
namespace cen::detail {

// clang-format off

/**
 * \brief Indicates whether or not any of the supplied values are equal to a specific value.
 *
 * \tparam T the type of the value to look for.
 *
 * \tparam Args the type of the arguments that will be checked.
 *
 * \param value the value to look for.
 * \param args the arguments that will be compared with the value.
 *
 * \return `true` if any of the supplied values are equal to `value`; `false` otherwise.
 *
 * \since 5.1.0
 */
template <typename T, typename... Args>
[[nodiscard]] constexpr auto any_eq(const T& value, Args&&... args)
    noexcept(noexcept( ((value == args) || ...) )) -> bool
{
  return ((value == args) || ...);
}

// clang-format on

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_ANY_EQ_HEADER

// #include "../detail/clamp.hpp"
#ifndef CENTURION_DETAIL_CLAMP_HEADER
#define CENTURION_DETAIL_CLAMP_HEADER

#include <cassert>  // assert

/// \cond FALSE
namespace cen::detail {

// clang-format off

/**
 * \brief Clamps a value to be within the range [min, max].
 *
 * \pre `min` must be less than or equal to `max`.
 *
 * \note The standard library provides `std::clamp`, but it isn't mandated to be
 * `noexcept` (although MSVC does mark it as `noexcept`), which is the reason this
 * function exists.
 *
 * \tparam T the type of the values.
 *
 * \param value the value that will be clamped.
 * \param min the minimum value (inclusive).
 * \param max the maximum value (inclusive).
 *
 * \return the clamped value.
 *
 * \since 5.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto clamp(const T& value,
                                   const T& min,
                                   const T& max)
    noexcept(noexcept(value < min) && noexcept(value > max)) -> T
{
  assert(min <= max);
  if (value < min)
  {
    return min;
  }
  else if (value > max)
  {
    return max;
  }
  else
  {
    return value;
  }
}

// clang-format on

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_CLAMP_HEADER

// #include "../detail/max.hpp"
#ifndef CENTURION_DETAIL_MAX_HEADER
#define CENTURION_DETAIL_MAX_HEADER

/// \cond FALSE
namespace cen::detail {

template <typename T>
[[nodiscard]] constexpr auto max(const T& a, const T& b) noexcept(noexcept(a < b)) -> T
{
  return (a < b) ? b : a;
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_MAX_HEADER

// #include "fade_status.hpp"
#ifndef CENTURION_FADE_STATUS_HEADER
#define CENTURION_FADE_STATUS_HEADER

#ifndef CENTURION_NO_SDL_MIXER

#include <SDL_mixer.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup audio
/// \{

/**
 * \enum fade_status
 *
 * \brief Provides values that represent different fade playback states.
 *
 * \see `Mix_Fading`
 * \see `fade_status_count()`
 *
 * \since 3.0.0
 */
enum class fade_status
{
  none = MIX_NO_FADING,  ///< No currently fading music.
  in = MIX_FADING_IN,    ///< Currently fading in music.
  out = MIX_FADING_OUT   ///< Currently fading out music.
};

/**
 * \brief Returns the number of enumerators for the `fade_status` enum.
 *
 * \return the number of enumerators.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto fade_status_count() noexcept -> int
{
  return 3;
}

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied fade status.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(fade_status::in) == "in"`.
 *
 * \param status the fade status that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const fade_status status) -> std::string_view
{
  switch (status) {
    case fade_status::none:
      return "none";

    case fade_status::in:
      return "in";

    case fade_status::out:
      return "out";

    default:
      throw cen_error{"Did not recognize fade status!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a fade status enumerator.
 *
 * \param stream the output stream that will be used.
 * \param status the fade status that will be printed.
 *
 * \see `to_string(fade_status)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const fade_status status) -> std::ostream&
{
  return stream << to_string(status);
}

/// \} End of streaming

/// \name Fade status comparison operators
/// \{

/**
 * \brief Indicates whether or not the fading status values represent are the same.
 *
 * \param lhs the left-hand side fading status value.
 * \param rhs the right-hand side fading status value.
 *
 * \return `true` if the fading status values are the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const fade_status lhs, const Mix_Fading rhs) noexcept
    -> bool
{
  return static_cast<Mix_Fading>(lhs) == rhs;
}

/// \copydoc operator==(fade_status, Mix_Fading)
[[nodiscard]] constexpr auto operator==(const Mix_Fading lhs, const fade_status rhs) noexcept
    -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the fading status values represent aren't the same.
 *
 * \param lhs the left-hand side fading status value.
 * \param rhs the right-hand side fading status value.
 *
 * \return `true` if the fading status values aren't the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator!=(const fade_status lhs, const Mix_Fading rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(fade_status, Mix_Fading)
[[nodiscard]] constexpr auto operator!=(const Mix_Fading lhs, const fade_status rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \} End of fade status comparison operators

/// \} End of group audio

}  // namespace cen

#endif  // CENTURION_NO_SDL_MIXER
#endif  // CENTURION_FADE_STATUS_HEADER

// #include "music_type.hpp"
#ifndef CENTURION_MUSIC_TYPE_HEADER
#define CENTURION_MUSIC_TYPE_HEADER

#ifndef CENTURION_NO_SDL_MIXER

#include <SDL_mixer.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup audio
/// \{

/**
 * \enum music_type
 *
 * \brief Provides values that represent different supported music types.
 *
 * \see `Mix_MusicType`
 * \see `music_type_count()`
 *
 * \since 3.0.0
 */
enum class music_type
{
  unknown = MUS_NONE,
  mp3 = MUS_MP3,
  wav = MUS_WAV,
  ogg = MUS_OGG,
  mod = MUS_MOD,
  midi = MUS_MID,
  cmd = MUS_CMD,
  flac = MUS_FLAC,
  opus = MUS_OPUS
};

/**
 * \brief Returns the number of enumerators for the `music_type` enum.
 *
 * \return the number of enumerators.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto music_type_count() noexcept -> int
{
  return 9;
}

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied music type.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(music_type::mp3) == "mp3"`.
 *
 * \param type the music type that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const music_type type) -> std::string_view
{
  switch (type) {
    case music_type::unknown:
      return "unknown";

    case music_type::mp3:
      return "mp3";

    case music_type::wav:
      return "wav";

    case music_type::ogg:
      return "ogg";

    case music_type::mod:
      return "mod";

    case music_type::midi:
      return "midi";

    case music_type::cmd:
      return "cmd";

    case music_type::flac:
      return "flac";

    case music_type::opus:
      return "opus";

    default:
      throw cen_error{"Did not recognize music type!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a music type enumerator.
 *
 * \param stream the output stream that will be used.
 * \param type the music type that will be printed.
 *
 * \see `to_string(music_type)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const music_type type) -> std::ostream&
{
  return stream << to_string(type);
}

/// \} End of streaming

/// \name Music type comparison operators
/// \{

/**
 * \brief Indicates whether or not the music type values are the same.
 *
 * \param lhs the left-hand side music type value.
 * \param rhs the right-hand side music type value.
 *
 * \return `true` if the music type values are the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const music_type lhs, const Mix_MusicType rhs) noexcept
    -> bool
{
  return static_cast<Mix_MusicType>(lhs) == rhs;
}

/// \copydoc operator==(music_type, Mix_MusicType)
[[nodiscard]] constexpr auto operator==(const Mix_MusicType lhs, const music_type rhs) noexcept
    -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the music type values aren't the same.
 *
 * \param lhs the left-hand side music type value.
 * \param rhs the right-hand side music type value.
 *
 * \return `true` if the music type values aren't the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator!=(const music_type lhs, const Mix_MusicType rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(music_type, Mix_MusicType)
[[nodiscard]] constexpr auto operator!=(const Mix_MusicType lhs, const music_type rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \} End of music type comparison operators

/// \} End of group audio

}  // namespace cen

#endif  // CENTURION_NO_SDL_MIXER
#endif  // CENTURION_MUSIC_TYPE_HEADER


namespace cen {

/// \addtogroup audio
/// \{

/**
 * \class music
 *
 * \brief Represents a music file.
 *
 * \details The supported audio formats are the following:
 *   - WAVE/RIFF (.wav)
 *   - AIFF (.aiff)
 *   - VOC (.voc)
 *   - MOD (.mod .xm .s3m .669 .it .med and more)
 *   - MIDI (.mid)
 *   - OggVorbis (.ogg)
 *   - MP3 (.mp3)
 *   - FLAC (.flac)
 *
 * \note Only one music instance can ever be playing at any time, which means that many of
 * the functions in this class are static.
 *
 * \todo Look into special effects API (also applies for sound effects).
 *
 * \see `Mix_Music`
 * \see `sound_effect`
 *
 * \since 3.0.0
 */
class music final
{
 public:
  /**
   * \brief A constant that indicates that the music should be looped indefinitely.
   *
   * \since 5.1.0
   */
  inline constexpr static int forever = -1;

  /// \name Construction
  /// \{

  /**
   * \brief Creates a `music` instance based on the file at the specified path.
   *
   * \param file the file path of the music file that will be loaded, cannot be null.
   *
   * \throws mix_error if the music file cannot be loaded.
   *
   * \since 3.0.0
   */
  explicit music(const not_null<str> file) : m_music{Mix_LoadMUS(file)}
  {
    if (!m_music) {
      throw mix_error{};
    }
  }

  /**
   * \brief Creates a `music` instance based on the file at the specified path.
   *
   * \param file the file path of the music file that will be loaded.
   *
   * \throws mix_error if the music file cannot be loaded.
   *
   * \since 5.3.0
   */
  explicit music(const std::string& file) : music{file.c_str()}
  {}

  /// \} End of construction

  /// \name Playback functions
  /// \{

  /**
   * \brief Plays the music associated with this instance.
   *
   * \details Any previously playing music will be halted. However, this function will
   * wait for music that was fading out to complete.
   *
   * \note The term loops is a little bit confusing here, even in the SDL_mixer
   * documentation. A negative value indicates that the music should be played forever.
   * Furthermore, the values 0 and 1 both results in the music being played *one time*.
   * Except for these "special" values, the function behaves as expected.
   *
   * \param nLoops the number of times to loop the music, `music::forever` can
   * be supplied to loop the music indefinitely.
   *
   * \return the channel used to play the music; `std::nullopt` on failure.
   *
   * \see `music::forever`
   *
   * \since 3.0.0
   */
  auto play(const int nLoops = 0) noexcept -> std::optional<int>
  {
    const auto channel = Mix_PlayMusic(m_music.get(), detail::max(nLoops, forever));
    if (channel != -1) {
      return channel;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Resumes playing the music.
   *
   * \details This function can safely be invoked with halted, paused and even currently
   * playing music.
   *
   * \since 3.0.0
   */
  static void resume() noexcept
  {
    Mix_ResumeMusic();
  }

  /**
   * \brief Pauses any currently playing music.
   *
   * \note This function only affects music that is currently playing, which doesn't
   * include music that is being faded in/out.
   *
   * \since 3.0.0
   */
  static void pause() noexcept
  {
    Mix_PauseMusic();
  }

  /**
   * \brief Stops ALL currently playing and fading music.
   *
   * \details Unlike `pause()`, this function affects all kinds of music.
   *
   * \since 3.0.0
   */
  static void halt() noexcept
  {
    Mix_HaltMusic();  // This appears to always return 0
  }

  /**
   * \brief Indicates whether or not any music is currently playing.
   *
   * \return `true` if music is currently being played; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] static auto is_playing() noexcept -> bool
  {
    return Mix_PlayingMusic();
  }

  /**
   * \brief Indicates whether or not any music is paused.
   *
   * \return `true` if the music is paused; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] static auto is_paused() noexcept -> bool
  {
    return Mix_PausedMusic();
  }

  /// \} Playback functions

  /// \name Fade functions
  /// \{

  /**
   * \brief Plays the music by fading it in by the specified amount of time.
   *
   * \pre `ms` must be greater than zero.
   *
   * \details The fade effect is only applied to the first iteration of the playback of
   * the music. Any previously playing music will be halted. However, if other music is
   * currently being faded out, this music will wait for that to complete.
   *
   * \note The term loops is a little bit confusing here, even in the SDL_mixer
   * documentation. A negative value indicates that the music should be played forever.
   * Furthermore, the values 0 and 1 both results in the music being played *one time*.
   * Except for these "special" values, the function behaves as expected.
   *
   * \param ms the amount of time it takes for the fade to complete.
   *
   * \param nLoops the number of iterations to play the music, `music::forever` can be
   * supplied to loop the music indefinitely.
   *
   * \return `success` if the fade is successful; `failure` otherwise.
   *
   * \see `music::forever`
   *
   * \since 3.0.0
   */
  auto fade_in(const milliseconds<int> ms, const int nLoops = 0) noexcept(noexcept(ms.count()))
      -> result
  {
    assert(ms.count() > 0);
    return Mix_FadeInMusic(m_music.get(), detail::max(nLoops, forever), ms.count()) == 0;
  }

  /**
   * \brief Fades out any currently playing music over the specified amount of time.
   *
   * \pre `ms` must be greater than zero.
   *
   * \details This function only affects music that is currently playing and not currently
   * fading out. In other words, this function has no effect if music is currently being
   * faded by the time the function is invoked.
   *
   * \param ms the amount of time for the fade to complete, in milliseconds.
   *
   * \return `success` if the fade is successful; `failure` on failure.
   *
   * \since 3.0.0
   */
  static auto fade_out(const milliseconds<int> ms) noexcept(noexcept(ms.count())) -> result
  {
    assert(ms.count() > 0);
    if (!is_fading()) {
      return Mix_FadeOutMusic(ms.count()) != 0;
    }
    else {
      return failure;
    }
  }

  /**
   * \brief Indicates whether or not any music is currently being faded in or out.
   *
   * \return `true` if music is currently being faded in or out; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] static auto is_fading() noexcept -> bool
  {
    return detail::any_eq(get_fade_status(), fade_status::in, fade_status::out);
  }

  /**
   * \brief Returns the current fade status of the music playback.
   *
   * \return the current fade status.
   *
   * \since 3.0.0
   */
  [[nodiscard]] static auto get_fade_status() noexcept -> fade_status
  {
    return static_cast<fade_status>(Mix_FadingMusic());
  }

  /// \} End of fade functions

  /// \name Playback position functions
  /// \{

  /**
   * \brief Rewinds the music stream to the initial position.
   *
   * \see `Mix_RewindMusic`
   *
   * \since 6.0.0
   */
  static void rewind() noexcept
  {
    Mix_RewindMusic();
  }

  /**
   * \brief Sets the position in the music stream.
   *
   * \param position the new music stream position.
   *
   * \return `success` if the music position was successfully changed; `failure`
   * otherwise.
   *
   * \see `Mix_SetMusicPosition`
   *
   * \since 6.0.0
   */
  static auto set_position(const double position) noexcept -> result
  {
    return Mix_SetMusicPosition(position) == 0;
  }

  /// \} End of playback position functions

  /// \name Volume functions
  /// \{

  /**
   * \brief Sets the volume of all music.
   *
   * \param volume the volume that will be used, in the range [0, `music::max_volume()`].
   * An out-of-bounds value will be clamped to the closest valid value.
   *
   * \since 3.0.0
   */
  static void set_volume(const int volume) noexcept
  {
    Mix_VolumeMusic(detail::clamp(volume, 0, MIX_MAX_VOLUME));
  }

  /**
   * \brief Returns the volume of the music.
   *
   * \details The default value is set to `music::max_volume()`.
   *
   * \return the volume of the music, in the range [0, `music::max_volume()`].
   *
   * \since 3.0.0
   */
  [[nodiscard]] static auto volume() noexcept -> int
  {
    return Mix_VolumeMusic(-1);
  }

  /**
   * \brief Returns the maximum possible volume.
   *
   * \return the maximum possible volume value, equal to `MIX_MAX_VOLUME`.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr static auto max_volume() noexcept -> int
  {
    return MIX_MAX_VOLUME;
  }

  /// \} End of volume functions

  /// \name Conversions
  /// \{

  /**
   * \brief Converts to `Mix_Music*`.
   *
   * \return a pointer to the associated `Mix_Music` instance.
   *
   * \since 4.0.0
   */
  [[nodiscard]] explicit operator Mix_Music*() noexcept
  {
    return m_music.get();
  }

  /**
   * \brief Converts to `const Mix_Music*`.
   *
   * \return a pointer to the associated `Mix_Music` instance.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit operator const Mix_Music*() const noexcept
  {
    return m_music.get();
  }

  /// \} End of conversions

  /**
   * \brief Returns the type of the music.
   *
   * \return the type of the music.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto type() const noexcept -> music_type
  {
    return static_cast<music_type>(Mix_GetMusicType(m_music.get()));
  }

  /**
   * \brief Returns a pointer to the associated `Mix_Music` instance.
   *
   * \warning Don't take ownership of the returned pointer!
   *
   * \return a pointer to the associated `Mix_Music`.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get() const noexcept -> Mix_Music*
  {
    return m_music.get();
  }

  /// \name Hook functions
  /// \{

  using music_hook_callback = void(SDLCALL*)(void*, u8*, int) noexcept;

  /**
   * \brief Registers a custom music player or mixer function.
   *
   * \param callback the custom callback, can be null to use the default music player.
   * \param data optional data that will be supplied to the callback.
   *
   * \since 6.0.0
   */
  template <typename T = void>
  static void set_hook(music_hook_callback callback, T* data = nullptr) noexcept
  {
    Mix_HookMusic(callback, data);
  }

  /**
   * \brief Resets the music player to the default one.
   *
   * \since 6.0.0
   */
  static void reset_hook() noexcept
  {
    set_hook(nullptr);
  }

  /**
   * \brief Returns a pointer to the user data associated with the music player.
   *
   * \return a pointer to the music player data, might be null.
   *
   * \since 6.0.0
   */
  [[nodiscard]] static auto get_hook_data() noexcept -> void*
  {
    return Mix_GetMusicHookData();
  }

  /// \} End of hook functions

  /// \name Decoder functions
  /// \{

  /**
   * \brief Returns the name of the decoder associated with the specified index.
   *
   * \param index the index of the desired decoder.
   *
   * \return the name of the decoder associated with the specified index; a null string is
   * returned if the index is invalid.
   *
   * \see `Mix_GetMusicDecoder`
   *
   * \since 6.0.0
   */
  [[nodiscard]] static auto get_decoder(const int index) noexcept -> str
  {
    return Mix_GetMusicDecoder(index);
  }

  /**
   * \brief Indicates whether or not the system has the specified music decoder.
   *
   * \param name the name of the decoder to check.
   *
   * \return `true` if the system has the specified decoder; `false` otherwise.
   *
   * \see `Mix_HasMusicDecoder`
   *
   * \since 6.0.0
   */
  [[nodiscard]] static auto has_decoder(const str name) noexcept -> bool
  {
    return Mix_HasMusicDecoder(name) == SDL_TRUE;
  }

  /**
   * \brief Returns the number of available music decoders.
   *
   * \return the number of available music decoders.
   *
   * \see `Mix_GetNumMusicDecoders`
   *
   * \since 6.0.0
   */
  [[nodiscard]] static auto decoder_count() noexcept -> int
  {
    return Mix_GetNumMusicDecoders();
  }

  /// \} End of decoder functions

 private:
  struct deleter final
  {
    void operator()(Mix_Music* music) noexcept
    {
      Mix_FreeMusic(music);
    }
  };

  std::unique_ptr<Mix_Music, deleter> m_music;

#ifdef CENTURION_MOCK_FRIENDLY_MODE

 public:
  music() = default;
#endif
};

/// \name Callbacks
/// \{

using music_finished_callback = void(SDLCALL*)() noexcept;

/**
 * \brief Sets the callback that is invoked each time the music finishes playing or is
 * stopped as a result of `cen::music::halt()`.
 *
 * \warning Make sure that your callback doesn't throw (or at least doesn't leak) any
 * exceptions.
 *
 * \param callback the callback.
 *
 * \since 6.0.0
 */
inline void on_music_finished(music_finished_callback callback) noexcept
{
  Mix_HookMusicFinished(callback);
}

/// \} End of callbacks

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a `music` instance.
 *
 * \param music the instance that will be converted.
 *
 * \return a string that represents the `music` instance.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto to_string(const music& music) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("music{{data: {}, volume: {}}}",
                     detail::address_of(music.get()),
                     music::volume());
#else
  return "music{data: " + detail::address_of(music.get()) +
         ", volume: " + std::to_string(music::volume()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a `music` instance.
 *
 * \param stream the stream that will be used.
 * \param music the `music` instance that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
inline auto operator<<(std::ostream& stream, const music& music) -> std::ostream&
{
  return stream << to_string(music);
}

/// \} End of streaming

/// \} End of group audio

}  // namespace cen

#endif  // CENTURION_NO_SDL_MIXER
#endif  // CENTURION_MUSIC_HEADER
// #include "centurion/audio/music_type.hpp"
#ifndef CENTURION_MUSIC_TYPE_HEADER
#define CENTURION_MUSIC_TYPE_HEADER

#ifndef CENTURION_NO_SDL_MIXER

#include <SDL_mixer.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup audio
/// \{

/**
 * \enum music_type
 *
 * \brief Provides values that represent different supported music types.
 *
 * \see `Mix_MusicType`
 * \see `music_type_count()`
 *
 * \since 3.0.0
 */
enum class music_type
{
  unknown = MUS_NONE,
  mp3 = MUS_MP3,
  wav = MUS_WAV,
  ogg = MUS_OGG,
  mod = MUS_MOD,
  midi = MUS_MID,
  cmd = MUS_CMD,
  flac = MUS_FLAC,
  opus = MUS_OPUS
};

/**
 * \brief Returns the number of enumerators for the `music_type` enum.
 *
 * \return the number of enumerators.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto music_type_count() noexcept -> int
{
  return 9;
}

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied music type.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(music_type::mp3) == "mp3"`.
 *
 * \param type the music type that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const music_type type) -> std::string_view
{
  switch (type) {
    case music_type::unknown:
      return "unknown";

    case music_type::mp3:
      return "mp3";

    case music_type::wav:
      return "wav";

    case music_type::ogg:
      return "ogg";

    case music_type::mod:
      return "mod";

    case music_type::midi:
      return "midi";

    case music_type::cmd:
      return "cmd";

    case music_type::flac:
      return "flac";

    case music_type::opus:
      return "opus";

    default:
      throw cen_error{"Did not recognize music type!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a music type enumerator.
 *
 * \param stream the output stream that will be used.
 * \param type the music type that will be printed.
 *
 * \see `to_string(music_type)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const music_type type) -> std::ostream&
{
  return stream << to_string(type);
}

/// \} End of streaming

/// \name Music type comparison operators
/// \{

/**
 * \brief Indicates whether or not the music type values are the same.
 *
 * \param lhs the left-hand side music type value.
 * \param rhs the right-hand side music type value.
 *
 * \return `true` if the music type values are the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const music_type lhs, const Mix_MusicType rhs) noexcept
    -> bool
{
  return static_cast<Mix_MusicType>(lhs) == rhs;
}

/// \copydoc operator==(music_type, Mix_MusicType)
[[nodiscard]] constexpr auto operator==(const Mix_MusicType lhs, const music_type rhs) noexcept
    -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the music type values aren't the same.
 *
 * \param lhs the left-hand side music type value.
 * \param rhs the right-hand side music type value.
 *
 * \return `true` if the music type values aren't the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator!=(const music_type lhs, const Mix_MusicType rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(music_type, Mix_MusicType)
[[nodiscard]] constexpr auto operator!=(const Mix_MusicType lhs, const music_type rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \} End of music type comparison operators

/// \} End of group audio

}  // namespace cen

#endif  // CENTURION_NO_SDL_MIXER
#endif  // CENTURION_MUSIC_TYPE_HEADER

// #include "centurion/audio/sound_effect.hpp"
#ifndef CENTURION_SOUND_EFFECT_HEADER
#define CENTURION_SOUND_EFFECT_HEADER

#ifndef CENTURION_NO_SDL_MIXER

#include <SDL_mixer.h>

#include <cassert>   // assert
#include <memory>    // unique_ptr
#include <optional>  // optional
#include <ostream>   // ostream
#include <string>    // string, to_string

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/not_null.hpp"

// #include "../core/owner.hpp"
#ifndef CENTURION_OWNER_HEADER
#define CENTURION_OWNER_HEADER

// #include "sfinae.hpp"


namespace cen {

/**
 * \typedef owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote ownership of raw pointers directly in code.
 *
 * \details If a function takes an `owner<T*>` as a parameter, then the function will
 * claim ownership of that pointer. Subsequently, if a function returns an `owner<T*>`,
 * then ownership is transferred to the caller.
 */
template <typename T, enable_if_pointer_v<T> = 0>
using owner = T;

/**
 * \typedef maybe_owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote conditional ownership of raw pointers directly in code.
 *
 * \details This is primarily used in constructors of owner/handle classes, where the
 * owner version will claim ownership of the pointer, whilst the handle does not.
 *
 * \since 6.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using maybe_owner = T;

}  // namespace cen

#endif  // CENTURION_OWNER_HEADER
// #include "../core/result.hpp"

// #include "../core/str.hpp"

// #include "../core/time.hpp"

// #include "../detail/address_of.hpp"

// #include "../detail/clamp.hpp"

// #include "../detail/max.hpp"

// #include "../detail/owner_handle_api.hpp"
#ifndef CENTURION_DETAIL_OWNER_HANDLE_API_HEADER
#define CENTURION_DETAIL_OWNER_HANDLE_API_HEADER

#include <cassert>      // assert
#include <memory>       // unique_ptr
#include <type_traits>  // enable_if_t, is_same_v, true_type, false_type

// #include "../core/exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER


/// \cond FALSE
namespace cen::detail {

using owning_type = std::true_type;
using handle_type = std::false_type;

template <typename T>
using is_owner = std::enable_if_t<std::is_same_v<T, owning_type>, int>;

template <typename T>
using is_handle = std::enable_if_t<std::is_same_v<T, handle_type>, int>;

template <typename T>
[[nodiscard]] constexpr auto is_owning() noexcept -> bool
{
  return std::is_same_v<T, owning_type>;
}

template <typename B, typename Type, typename Deleter>
class pointer_manager final
{
  using managed_ptr = std::unique_ptr<Type, Deleter>;
  using raw_ptr = Type*;
  using pointer_type = std::conditional_t<B::value, managed_ptr, raw_ptr>;

 public:
  pointer_manager() noexcept = default;

  explicit pointer_manager(Type* ptr) noexcept : m_ptr{ptr}
  {}

  template <typename BB = B, is_owner<BB> = 0>
  void reset(Type* ptr) noexcept
  {
    m_ptr.reset(ptr);
  }

  auto operator->() noexcept -> Type*
  {
    return get();
  }

  auto operator->() const noexcept -> const Type*
  {
    return get();
  }

  auto operator*() noexcept -> Type&
  {
    assert(m_ptr);
    return *m_ptr;
  }

  auto operator*() const noexcept -> const Type&
  {
    assert(m_ptr);
    return *m_ptr;
  }

  explicit operator bool() const noexcept
  {
    return m_ptr != nullptr;
  }

  /*implicit*/ operator Type*() const noexcept
  {
    return get();
  }

  template <typename BB = B, is_owner<BB> = 0>
  [[nodiscard]] auto release() noexcept -> Type*
  {
    return m_ptr.release();
  }

  [[nodiscard]] auto get() const noexcept -> Type*
  {
    if constexpr (B::value) {
      return m_ptr.get();
    }
    else {
      return m_ptr;
    }
  }

 private:
  pointer_type m_ptr{};
};

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_OWNER_HANDLE_API_HEADER


namespace cen {

/// \addtogroup audio
/// \{

template <typename T>
class basic_sound_effect;

/**
 * \typedef sound_effect
 *
 * \brief Represents an owning sound effect.
 *
 * \since 6.0.0
 */
using sound_effect = basic_sound_effect<detail::owning_type>;

/**
 * \typedef sound_effect_handle
 *
 * \brief Represents a non-owning sound effect.
 *
 * \since 6.0.0
 */
using sound_effect_handle = basic_sound_effect<detail::handle_type>;

/**
 * \class basic_sound_effect
 *
 * \brief Represents a sound effect.
 *
 * \ownerhandle `sound_effect`/`sound_effect_handle`
 *
 * \details Unlike with the music API, multiple sound effects can be played at the same
 * time, which is the main difference between the `music` and `sound_effect` APIs.
 *
 * \details The supported file formats are the following:
 *   - WAVE/RIFF (.wav)
 *   - AIFF (.aiff)
 *   - VOC (.voc)
 *   - OGG (.ogg)
 *   - VOC (.voc)
 *
 * \since 3.0.0
 *
 * \see `Mix_Chunk`
 * \see `music`
 * \see `get_sound()`
 */
template <typename T>
class basic_sound_effect final
{
 public:
  /**
   * \brief Indicates that an audio snippet should be looped indefinitely.
   *
   * \since 5.1.0
   */
  inline constexpr static int forever = -1;

  /// \name Construction
  /// \{

  // clang-format off

  /**
   * \brief Creates a sound effect based on an existing SDL sound effect.
   *
   * \note The created sound effect claims ownership of the supplied pointer only if the
   * sound effect has owning semantics.
   *
   * \param sound a pointer to the associated chunk instance, cannot be null if the sound
   * effect is owning.
   *
   * \throws mix_error if the supplied pointer is null and the sound effect is owning.
   *
   * \since 6.0.0
   */
  explicit basic_sound_effect(maybe_owner<Mix_Chunk*> sound) noexcept(!detail::is_owning<T>())
      : m_chunk{sound}
  {
    if constexpr (detail::is_owning<T>())
    {
      if (!m_chunk)
      {
        throw mix_error{};
      }
    }
  }

  // clang-format on

  /**
   * \brief Creates a sound effect based on the audio file at the specified location.
   *
   * \param file the file path of the audio file, cannot be null.
   *
   * \throws mix_error if the audio file cannot be loaded.
   *
   * \since 3.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_sound_effect(const not_null<str> file) : m_chunk{Mix_LoadWAV(file)}
  {
    if (!m_chunk) {
      throw mix_error{};
    }
  }

  /**
   * \brief Creates a sound effect based on the audio file at the specified location.
   *
   * \param file the file path of the audio file.
   *
   * \throws mix_error if the audio file cannot be loaded.
   *
   * \since 5.3.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_sound_effect(const std::string& file) : basic_sound_effect{file.c_str()}
  {}

  /**
   * \brief Creates a sound effect handle to on an existing sound effect.
   *
   * \param owner the owning sound effect.
   *
   * \since 6.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit basic_sound_effect(const sound_effect& owner) noexcept : m_chunk{owner.get()}
  {}

  /// \} End of construction

  /// \name Playback functions
  /// \{

  /**
   * \brief Plays the sound effect.
   *
   * \note A negative value indicates that the sound effect should be looped forever.
   *
   * \param nLoops the amount of loops, `sound_effect::forever` can be used to loop the
   * sound effect indefinitely.
   *
   * \return `success` if the sound was played successfully; `failure` otherwise.
   *
   * \see `sound_effect::forever`
   *
   * \since 3.0.0
   */
  auto play(const int nLoops = 0) noexcept -> result
  {
    m_channel = Mix_PlayChannel(m_channel, m_chunk.get(), detail::max(nLoops, forever));
    return m_channel != -1;
  }

  /**
   * \brief Stops the sound effect from playing.
   *
   * \since 3.0.0
   */
  void stop() noexcept
  {
    if (is_playing()) {
      Mix_Pause(m_channel);
      m_channel = undefined_channel();
    }
  }

  /**
   * \brief Indicates whether or not the sound effect is currently playing.
   *
   * \return `true` if the sound effect is playing; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_playing() const noexcept -> bool
  {
    return (m_channel != undefined_channel()) && Mix_Playing(m_channel);
  }

  /**
   * \brief Indicates whether or not any sound effects are currently playing.
   *
   * \return `true` if any sound effect is playing on some channel; `false` otherwise.
   *
   * \since 5.1.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto is_any_playing() noexcept -> bool
  {
    return Mix_Playing(undefined_channel());
  }

  /// \} End of playback functions

  /// \name Fade functions
  /// \{

  /**
   * \brief Fades in the sound effect.
   *
   * \pre `ms` must be greater than zero.
   *
   * \details This function has no effect if the sound effect is currently playing.
   *
   * \param ms the duration to fade in, in milliseconds.
   *
   * \since 3.0.0
   */
  void fade_in(const milliseconds<int> ms) noexcept(noexcept(ms.count()))
  {
    assert(ms.count() > 0);
    if (!is_playing()) {
      m_channel = Mix_FadeInChannel(m_channel, get(), 0, ms.count());
    }
  }

  /**
   * \brief Fades out the sound effect.
   *
   * \pre `ms` must be greater than zero.
   *
   * \details This function has no effect if the sound effect isn't currently playing.
   *
   * \param ms the duration to fade in, in milliseconds.
   *
   * \since 3.0.0
   */
  void fade_out(const milliseconds<int> ms) noexcept(noexcept(ms.count()))  // NOLINT
  {
    assert(ms.count() > 0);
    if (is_playing()) {
      Mix_FadeOutChannel(m_channel, ms.count());
    }
  }

  /**
   * \brief Indicates whether or not the sound effect is being faded.
   *
   * \note If the sound effect is being faded, it's also playing so `is_playing()` will
   * also return `true`. Keep this in mind if you want to differentiate between the two.
   *
   * \return `true` if the sound effect is being faded; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto is_fading() const noexcept -> bool
  {
    return is_playing() && Mix_FadingChannel(m_channel);
  }

  /// \} End of fade functions

  /// \name Volume functions
  /// \{

  /**
   * \brief Sets the volume of the sound effect.
   *
   * \details This function will adjust input values outside the legal range to the
   * closest legal value.
   *
   * \param volume the volume of the sound effect, in the range [0,
   * `sound_effect::max_volume()`].
   *
   * \since 3.0.0
   */
  void set_volume(const int volume) noexcept
  {
    Mix_VolumeChunk(m_chunk.get(), detail::clamp(volume, 0, max_volume()));
  }

  /**
   * \brief Returns the current volume of the sound effect.
   *
   * \details By default, this property is set to 128.
   *
   * \return the current volume of the sound effect.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto volume() const noexcept -> int
  {
    return m_chunk->volume;
  }

  /**
   * \brief Returns the maximum possible volume value.
   *
   * \return the maximum possible volume value.
   *
   * \since 3.1.0
   */
  [[nodiscard]] constexpr static auto max_volume() noexcept -> int
  {
    return MIX_MAX_VOLUME;
  }

  /// \} End of volume functions

  /// \name Conversions
  /// \{

  /**
   * \brief Converts to `Mix_Chunk*`.
   *
   * \return a pointer to the associated `Mix_Chunk` instance.
   *
   * \since 4.0.0
   */
  [[nodiscard]] explicit operator Mix_Chunk*() noexcept
  {
    return m_chunk.get();
  }

  /**
   * \brief Converts to `const Mix_Chunk*`.
   *
   * \return a pointer to the associated `Mix_Chunk` instance.
   *
   * \since 4.0.0
   */
  [[nodiscard]] explicit operator const Mix_Chunk*() const noexcept
  {
    return m_chunk.get();
  }

  /// \} End of conversions

  /// \name Decoder functions
  /// \{

  /**
   * \brief Returns the name of the decoder associated with the specified index.
   *
   * \param index the index of the desired decoder.
   *
   * \return the name of the decoder associated with the specified index; a null string is
   * returned if the index is invalid.
   *
   * \see `Mix_GetChunkDecoder`
   *
   * \since 6.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto get_decoder(const int index) noexcept -> str
  {
    return Mix_GetChunkDecoder(index);
  }

  /**
   * \brief Indicates whether or not the system has the specified sound effect decoder.
   *
   * \param name the name of the decoder to check.
   *
   * \return `true` if the system has the specified decoder; `false` otherwise.
   *
   * \see `Mix_HasChunkDecoder`
   *
   * \since 6.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto has_decoder(const str name) noexcept -> bool
  {
    return Mix_HasChunkDecoder(name) == SDL_TRUE;
  }

  /**
   * \brief Returns the number of available sound effect decoders.
   *
   * \return the number of available sound effect decoders.
   *
   * \see `Mix_GetNumChunkDecoders`
   *
   * \since 6.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto decoder_count() noexcept -> int
  {
    return Mix_GetNumChunkDecoders();
  }

  /// \} End of decoder functions

  /**
   * \brief Returns the channel associated with the sound effect, if any.
   *
   * \note Channels are not associated with sound effects for long, and might change in
   * between playbacks.
   *
   * \return the channel currently associated with the sound effect; `std::nullopt` if
   * there is none.
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto channel() const noexcept -> std::optional<int>
  {
    if (m_channel != undefined_channel()) {
      return m_channel;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns a pointer to the associated `Mix_Chunk` instance.
   *
   * \warning Don't take ownership of the returned pointer!
   *
   * \return a pointer to the associated `Mix_Chunk`.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get() const noexcept -> Mix_Chunk*
  {
    return m_chunk.get();
  }

 private:
  struct deleter final
  {
    void operator()(Mix_Chunk* chunk) noexcept
    {
      Mix_FreeChunk(chunk);
    }
  };

  detail::pointer_manager<T, Mix_Chunk, deleter> m_chunk;
  int m_channel{undefined_channel()};

  [[nodiscard]] constexpr static auto undefined_channel() noexcept -> int
  {
    return -1;
  }

#ifdef CENTURION_MOCK_FRIENDLY_MODE

 public:
  void set_channel(const int channel) noexcept
  {
    m_channel = channel;
  }
#endif  // CENTURION_MOCK_FRIENDLY_MODE
};

/**
 * \brief Returns a handle to the sound effect currently associated with the specified
 * channel.
 *
 * \note There might not be a sound effect associated with the specified channel, in which
 * case the returned handle is null.
 *
 * \param channel the channel associated with the desired sound effect.
 *
 * \return a handle to the sound effect associated with the specified channel.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto get_sound(const int channel) noexcept -> sound_effect_handle
{
  return sound_effect_handle{Mix_GetChunk(channel)};
}

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a sound effect.
 *
 * \param sound the sound effect that will be converted.
 *
 * \return a string that represents the sound effect.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto to_string(const sound_effect& sound) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("sound_effect{{data: {}, volume: {}}}",
                     detail::address_of(sound.get()),
                     sound.volume());
#else
  return "sound_effect{data: " + detail::address_of(sound.get()) +
         ", volume: " + std::to_string(sound.volume()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a sound effect.
 *
 * \param stream the stream that will be used.
 * \param sound the sound effect that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
inline auto operator<<(std::ostream& stream, const sound_effect& sound) -> std::ostream&
{
  return stream << to_string(sound);
}

/// \} End of streaming

/// \} End of group audio

}  // namespace cen

#endif  // CENTURION_NO_SDL_MIXER
#endif  // CENTURION_SOUND_EFFECT_HEADER

// #include "centurion/audio/sound_fonts.hpp"
#ifndef CENTURION_SOUND_FONTS_HEADER
#define CENTURION_SOUND_FONTS_HEADER

#ifndef CENTURION_NO_SDL_MIXER

#include <SDL.h>
#include <SDL_mixer.h>

// #include "../core/result.hpp"

// #include "../core/str.hpp"


namespace cen {

/// \addtogroup audio
/// \{

using sound_font_visit_callback = int(SDLCALL*)(str, void*) noexcept;

/**
 * \brief Sets the paths to the available SoundFont files.
 *
 * \param paths a string of SoundFont paths, separated by semicolons.
 *
 * \return `success` if the operation was successful; `failure` otherwise.
 *
 * \see `Mix_SetSoundFonts`
 *
 * \since 6.0.0
 */
inline auto set_sound_fonts(const str paths) noexcept -> result
{
  return Mix_SetSoundFonts(paths) != 0;
}

/**
 * \brief Returns a path to a SoundFont file.
 *
 * \return a path to a SoundFonts file; can be null.
 *
 * \see `Mix_GetSoundFonts`
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto get_sound_fonts() noexcept -> str
{
  return Mix_GetSoundFonts();
}

/**
 * \brief Visits each available SoundFont path.
 *
 * \tparam T the type of the associated data.
 *
 * \param callable the callable that will be invoked for each SoundFont path.
 * \param data optional user data.
 *
 * \return `success` if the operation was successful; `failure` otherwise.
 *
 * \see `Mix_EachSoundFont`
 *
 * \since 6.0.0
 */
template <typename T = void>
auto each_sound_font(sound_font_visit_callback callable, T* data = nullptr) noexcept -> result
{
  return Mix_EachSoundFont(callable, static_cast<void*>(data)) != 0;
}

/// \} End of group audio

}  // namespace cen

#endif  // CENTURION_NO_SDL_MIXER
#endif  // CENTURION_SOUND_FONTS_HEADER

// #include "centurion/compiler/compiler.hpp"
#ifndef CENTURION_COMPILER_HEADER
#define CENTURION_COMPILER_HEADER

#include <SDL.h>

namespace cen {

/// \addtogroup compiler
/// \{

/**
 * \brief Indicates whether or not a "debug" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a debug build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_debug_build() noexcept -> bool
{
#ifndef NDEBUG
  return true;
#else
  return false;
#endif  // NDEBUG
}

/**
 * \brief Indicates whether or not a "release" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a release build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_release_build() noexcept -> bool
{
  return !is_debug_build();
}

/**
 * \brief Indicates whether or not the compiler is MSVC.
 *
 * \return `true` if MSVC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_msvc() noexcept -> bool
{
#ifdef _MSC_VER
  return true;
#else
  return false;
#endif  // _MSC_VER
}

/**
 * \brief Indicates whether or not the compiler is GCC.
 *
 * \return `true` if GCC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_gcc() noexcept -> bool
{
#ifdef __GNUC__
  return true;
#else
  return false;
#endif  // __GNUC__
}

/**
 * \brief Indicates whether or not the compiler is Clang.
 *
 * \return `true` if Clang is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_clang() noexcept -> bool
{
#ifdef __clang__
  return true;
#else
  return false;
#endif  // __clang__
}

/**
 * \brief Indicates whether or not the compiler is Emscripten.
 *
 * \return `true` if Emscripten is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_emscripten() noexcept -> bool
{
#ifdef __EMSCRIPTEN__
  return true;
#else
  return false;
#endif  // __EMSCRIPTEN__
}

/**
 * \brief Indicates whether or not the compiler is Intel C++.
 *
 * \return `true` if Intel C++ is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_intel_cpp() noexcept -> bool
{
#ifdef __INTEL_COMPILER
  return true;
#else
  return false;
#endif  // __INTEL_COMPILER
}

/// \} End of compiler group

}  // namespace cen

#endif  // CENTURION_COMPILER_HEADER

// #include "centurion/compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER

// #include "centurion/core/cast.hpp"
#ifndef CENTURION_CAST_HEADER
#define CENTURION_CAST_HEADER

namespace cen {

/**
 * \brief Casts a value to a value of another type.
 *
 * \ingroup core
 *
 * \details This is the default implementation, which simply attempts to use
 * `static_cast`. The idea is that this function will be specialized for various Centurion
 * and SDL types. This is useful because it isn't always possible to implement conversion
 * operators as members.
 *
 * \tparam To the type of the value that will be converted.
 * \tparam From the type that the value will be casted to.
 *
 * \param from the value that will be converted.
 *
 * \return the result of casting the supplied value to the specified type.
 *
 * \since 5.0.0
 */
template <typename To, typename From>
[[nodiscard]] constexpr auto cast(const From& from) noexcept -> To
{
  return static_cast<To>(from);
}

}  // namespace cen

#endif  // CENTURION_CAST_HEADER

// #include "centurion/core/exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER

// #include "centurion/core/integers.hpp"
#ifndef CENTURION_INTEGERS_HEADER
#define CENTURION_INTEGERS_HEADER

#include <SDL.h>

#include <cstddef>  // size_t

namespace cen {

/// \addtogroup core
/// \{

/// \name Integer aliases
/// \{

using usize = std::size_t;

/// Alias for an unsigned integer.
using uint = unsigned int;

/// Alias for the type used for integer literal operators.
using ulonglong = unsigned long long;

/// Alias for a 64-bit unsigned integer.
using u64 = Uint64;

/// Alias for a 32-bit unsigned integer.
using u32 = Uint32;

/// Alias for a 16-bit unsigned integer.
using u16 = Uint16;

/// Alias for an 8-bit unsigned integer.
using u8 = Uint8;

/// Alias for a 64-bit signed integer.
using i64 = Sint64;

/// Alias for a 32-bit signed integer.
using i32 = Sint32;

/// Alias for a 16-bit signed integer.
using i16 = Sint16;

/// Alias for an 8-bit signed integer.
using i8 = Sint8;

/// \} End of integer aliases

// clang-format off

/**
 * \brief Obtains the size of a container as an `int`.
 *
 * \tparam T a "container" that provides a `size()` member function.
 *
 * \param container the container to query the size of.
 *
 * \return the size of the container as an `int` value.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto isize(const T& container) noexcept(noexcept(container.size()))
    -> int
{
  return static_cast<int>(container.size());
}

// clang-format on

namespace literals {

/**
 * \brief Creates an 8-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u8(const ulonglong value) noexcept -> u8
{
  return static_cast<u8>(value);
}

/**
 * \brief Creates a 16-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u16(const ulonglong value) noexcept -> u16
{
  return static_cast<u16>(value);
}

/**
 * \brief Creates a 32-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u32(const ulonglong value) noexcept -> u32
{
  return static_cast<u32>(value);
}

/**
 * \brief Creates a 64-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u64(const ulonglong value) noexcept -> u64
{
  return static_cast<u64>(value);
}

/**
 * \brief Creates an 8-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i8(const ulonglong value) noexcept -> i8
{
  return static_cast<i8>(value);
}

/**
 * \brief Creates a 16-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i16(const ulonglong value) noexcept -> i16
{
  return static_cast<i16>(value);
}

/**
 * \brief Creates a 32-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i32(const ulonglong value) noexcept -> i32
{
  return static_cast<i32>(value);
}

/**
 * \brief Creates a 64-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i64(const ulonglong value) noexcept -> i64
{
  return static_cast<i64>(value);
}

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_INTEGERS_HEADER

// #include "centurion/core/is_stateless_callable.hpp"
#ifndef CENTURION_IS_STATELESS_CALLABLE_HEADER
#define CENTURION_IS_STATELESS_CALLABLE_HEADER

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER


#if CENTURION_HAS_FEATURE_CONCEPTS

#include <concepts>  // default_initializable, invocable

namespace cen {

/// \addtogroup core
/// \{

template <typename T, typename... Args>
concept is_stateless_callable = std::default_initializable<T> && std::invocable<T, Args...>;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_HAS_FEATURE_CONCEPTS
#endif  // CENTURION_IS_STATELESS_CALLABLE_HEADER

// #include "centurion/core/library.hpp"
/// \defgroup core Core
/// \brief Contains entities considered to be fundamental for the library.

/**
 * \defgroup hints Hints
 *
 * \brief Contains the API related to hints (configuration variables).
 *
 * \details Refer to the official SDL2 wiki or the `SDL_hints.hpp` header for details
 * regarding any specific hint type.
 *
 * \todo `WindowsIntResourceIcon`, `WindowsIntResourceIconSmall`, `X11WindowVisualID` are
 * string hints because the types of their values isn't known. Should be fixed if the type
 * isn't actually string.
 */

/// \defgroup event Events
/// \brief Contains entities related to events.

/// \defgroup thread Threads
/// \brief Provides threading utilities such as threads, mutexes, locks, etc.

/// \defgroup input Input
/// \brief Contains components related to input from mice, keyboards,
/// controllers, etc.

/// \defgroup video Video
/// \brief Contains components related to window-management, rendering, fonts,
/// etc.

/// \defgroup filesystem Filesystem
/// \brief Contains utilities related to files and directories.

/// \defgroup system System
/// \brief Contains various utilities related to system resources.

/// \defgroup compiler Compiler
/// \brief Provides `constexpr` utilities for querying the current compiler.
/// \note There is no guarantee that the compiler checks are mutually exclusive.

/// \defgroup math Math
/// \brief Contains basic mathematical components, used throughout the library.

/// \defgroup audio Audio
/// \brief Contains the audio API, for playing as sound effects and music.

#ifndef CENTURION_LIBRARY_HEADER
#define CENTURION_LIBRARY_HEADER

#include <SDL.h>

// #include "../compiler/features.hpp"


#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <cassert>   // assert
#include <optional>  // optional

// #include "exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER

// #include "integers.hpp"
#ifndef CENTURION_INTEGERS_HEADER
#define CENTURION_INTEGERS_HEADER

#include <SDL.h>

#include <cstddef>  // size_t

namespace cen {

/// \addtogroup core
/// \{

/// \name Integer aliases
/// \{

using usize = std::size_t;

/// Alias for an unsigned integer.
using uint = unsigned int;

/// Alias for the type used for integer literal operators.
using ulonglong = unsigned long long;

/// Alias for a 64-bit unsigned integer.
using u64 = Uint64;

/// Alias for a 32-bit unsigned integer.
using u32 = Uint32;

/// Alias for a 16-bit unsigned integer.
using u16 = Uint16;

/// Alias for an 8-bit unsigned integer.
using u8 = Uint8;

/// Alias for a 64-bit signed integer.
using i64 = Sint64;

/// Alias for a 32-bit signed integer.
using i32 = Sint32;

/// Alias for a 16-bit signed integer.
using i16 = Sint16;

/// Alias for an 8-bit signed integer.
using i8 = Sint8;

/// \} End of integer aliases

// clang-format off

/**
 * \brief Obtains the size of a container as an `int`.
 *
 * \tparam T a "container" that provides a `size()` member function.
 *
 * \param container the container to query the size of.
 *
 * \return the size of the container as an `int` value.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto isize(const T& container) noexcept(noexcept(container.size()))
    -> int
{
  return static_cast<int>(container.size());
}

// clang-format on

namespace literals {

/**
 * \brief Creates an 8-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u8(const ulonglong value) noexcept -> u8
{
  return static_cast<u8>(value);
}

/**
 * \brief Creates a 16-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u16(const ulonglong value) noexcept -> u16
{
  return static_cast<u16>(value);
}

/**
 * \brief Creates a 32-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u32(const ulonglong value) noexcept -> u32
{
  return static_cast<u32>(value);
}

/**
 * \brief Creates a 64-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u64(const ulonglong value) noexcept -> u64
{
  return static_cast<u64>(value);
}

/**
 * \brief Creates an 8-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i8(const ulonglong value) noexcept -> i8
{
  return static_cast<i8>(value);
}

/**
 * \brief Creates a 16-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i16(const ulonglong value) noexcept -> i16
{
  return static_cast<i16>(value);
}

/**
 * \brief Creates a 32-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i32(const ulonglong value) noexcept -> i32
{
  return static_cast<i32>(value);
}

/**
 * \brief Creates a 64-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i64(const ulonglong value) noexcept -> i64
{
  return static_cast<i64>(value);
}

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_INTEGERS_HEADER


/**
 * \namespace cen
 *
 * \brief The top-level namespace that all components of the library reside in.
 */
namespace cen {

/// \addtogroup core
/// \{

/**
 * \struct config
 *
 * \brief Used to specify how the library is initialized.
 *
 * \details All fields are initialized to the default values used by the library.
 *
 * \since 4.0.0
 *
 * \var config::initCore
 * Indicates whether or not the SDL2 core is initialized.
 *
 * \var config::initImage
 * Indicates whether or not SDL2_image is initialized.
 *
 * \var config::initMixer
 * Indicates whether or not SDL2_mixer is initialized.
 *
 * \var config::initTTF
 * Indicates whether or not SDL2_ttf is initialized.
 *
 * \var config::coreFlags
 * Flags passed on to `SDL_Init()`, if \ref config.initCore is `true`.
 *
 * \var config::imageFlags
 * Flags passed on to `IMG_Init()`, if \ref config.initImage is `true`.
 *
 * \var config::mixerFlags
 * Flags passed on to `Mix_Init()`, if \ref config.initMixer is `true`.
 *
 * \var config::mixerFreq
 * The frequency used by SDL2_mixer, if \ref config.initMixer is `true`.
 *
 * \var config::mixerFormat
 * The format used by SDL2_mixer, if \ref config.initMixer is `true`.
 *
 * \var config::mixerChannels
 * The amount of channels used by SDL2_mixer, if \ref config.initMixer is `true`.
 *
 * \var config::mixerChunkSize
 * The chunk size used by SDL2_mixer, if \ref config.initMixer is `true`.
 */
struct config final
{
  bool initCore{true};
  bool initImage{true};
  bool initMixer{true};
  bool initTTF{true};

  u32 coreFlags{SDL_INIT_EVERYTHING};

#ifndef CENTURION_NO_SDL_IMAGE
  int imageFlags{IMG_INIT_PNG | IMG_INIT_JPG | IMG_INIT_TIF | IMG_INIT_WEBP};
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
  int mixerFlags{MIX_INIT_MP3 | MIX_INIT_OGG | MIX_INIT_FLAC | MIX_INIT_MID | MIX_INIT_MOD |
                 MIX_INIT_OPUS};
  int mixerFreq{MIX_DEFAULT_FREQUENCY};
  u16 mixerFormat{MIX_DEFAULT_FORMAT};
  int mixerChannels{MIX_DEFAULT_CHANNELS};
  int mixerChunkSize{4096};
#endif  // CENTURION_NO_SDL_MIXER
};

/**
 * \class library
 *
 * \brief Used to initialize and de-initialize the library.
 *
 * \details The following is how you should use this class.
 * \code{cpp}
 *   #include <centurion.hpp>
 *
 *   int main(int argc, char** argv)
 *   {
 *     cen::library centurion;
 *
 *     // ...
 *
 *     return 0;
 *   }
 * \endcode
 *
 * \note The signature of the main-function must be `ìnt(int, char**)` when
 * using the Centurion library!
 *
 * \since 3.0.0
 */
class library final
{
 public:
  /**
   * \brief Initializes the library.
   *
   * \note Make sure to have the `library` instance as a local variable that will outlive
   * the duration of your main program. It's not sufficient to just call the constructor
   * but not store the result as a variable.
   *
   * \pre there mustn't exist any other instances of this class at the time of invocation
   * of this constructor.
   *
   * \throws sdl_error if the core SDL2 library can't be initialized.
   * \throws img_error if the SDL2_image library can't be initialized.
   * \throws ttf_error if the SDL2_ttf library can't be initialized.
   * \throws mix_error if the SDL2_mixer library can't be initialized.
   *
   * \since 3.0.0
   */
  CENTURION_NODISCARD_CTOR library()
  {
    init();
  }

  /**
   * \brief Initializes the library according to the supplied configuration.
   *
   * \pre there mustn't exist any other instances of this class at the time of invocation
   * of this constructor.
   *
   * \param cfg the configuration spec, determines what gets initialized.
   *
   * \throws sdl_error if the core SDL2 library can't be initialized.
   * \throws img_error if the SDL2_image library can't be initialized.
   * \throws ttf_error if the SDL2_ttf library can't be initialized.
   * \throws mix_error if the SDL2_mixer library can't be initialized.
   *
   * \since 4.0.0
   */
  CENTURION_NODISCARD_CTOR explicit library(const config& cfg) : m_cfg{cfg}
  {
    init();
  }

  library(const library&) = delete;

  library(library&&) = delete;

  auto operator=(const library&) -> library& = delete;

  auto operator=(library&&) -> library& = delete;

 private:
  struct sdl final
  {
    explicit sdl(const u32 flags)
    {
      if (SDL_Init(flags) < 0) {
        throw sdl_error{};
      }
    }

    ~sdl() noexcept
    {
      SDL_Quit();
    }
  };

#ifndef CENTURION_NO_SDL_TTF

  struct sdl_ttf final
  {
    explicit sdl_ttf()
    {
      if (TTF_Init() == -1) {
        throw ttf_error{};
      }
    }

    ~sdl_ttf() noexcept
    {
      TTF_Quit();
    }
  };

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

  struct sdl_mixer final
  {
    sdl_mixer(const int flags,
              const int freq,
              const u16 format,
              const int nChannels,
              const int chunkSize)
    {
      if (!Mix_Init(flags)) {
        throw mix_error{};
      }

      if (Mix_OpenAudio(freq, format, nChannels, chunkSize) == -1) {
        throw mix_error{};
      }
    }

    ~sdl_mixer() noexcept
    {
      Mix_CloseAudio();
      Mix_Quit();
    }
  };

#endif  // #ifndef CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_IMAGE

  struct sdl_image final
  {
    explicit sdl_image(const int flags)
    {
      if (!IMG_Init(flags)) {
        throw img_error{};
      }
    }

    ~sdl_image() noexcept
    {
      IMG_Quit();
    }
  };

#endif  // CENTURION_NO_SDL_IMAGE

  config m_cfg;
  std::optional<sdl> m_sdl;

#ifndef CENTURION_NO_SDL_IMAGE
  std::optional<sdl_image> m_img;
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF
  std::optional<sdl_ttf> m_ttf;
#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER
  std::optional<sdl_mixer> m_mixer;
#endif  // CENTURION_NO_SDL_MIXER

  void init()
  {
    if (m_cfg.initCore) {
      m_sdl.emplace(m_cfg.coreFlags);
    }

#ifndef CENTURION_NO_SDL_IMAGE
    if (m_cfg.initImage) {
      m_img.emplace(m_cfg.imageFlags);
    }
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF
    if (m_cfg.initTTF) {
      m_ttf.emplace();
    }
#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER
    if (m_cfg.initMixer) {
      m_mixer.emplace(m_cfg.mixerFlags,
                      m_cfg.mixerFreq,
                      m_cfg.mixerFormat,
                      m_cfg.mixerChannels,
                      m_cfg.mixerChunkSize);
    }
#endif  // CENTURION_NO_SDL_MIXER
  }
};

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_LIBRARY_HEADER

// #include "centurion/core/log.hpp"
#ifndef CENTURION_LOG_HEADER
#define CENTURION_LOG_HEADER

#include <SDL.h>

#include <array>        // array
#include <cassert>      // assert
#include <chrono>       // zoned_time, current_zone, system_clock
#include <iostream>     // clog
#include <string>       // string
#include <string_view>  // string_view
#include <utility>      // forward

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format_to_n

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "is_stateless_callable.hpp"
#ifndef CENTURION_IS_STATELESS_CALLABLE_HEADER
#define CENTURION_IS_STATELESS_CALLABLE_HEADER

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_CONCEPTS

#include <concepts>  // default_initializable, invocable

namespace cen {

/// \addtogroup core
/// \{

template <typename T, typename... Args>
concept is_stateless_callable = std::default_initializable<T> && std::invocable<T, Args...>;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_HAS_FEATURE_CONCEPTS
#endif  // CENTURION_IS_STATELESS_CALLABLE_HEADER

// #include "log_category.hpp"
#ifndef CENTURION_LOG_CATEGORY_HEADER
#define CENTURION_LOG_CATEGORY_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "exception.hpp"

// #include "sdl_log_category_workaround.hpp"
#ifndef CENTURION_SDL_LOG_CATEGORY_WORKAROUND_HEADER
#define CENTURION_SDL_LOG_CATEGORY_WORKAROUND_HEADER

#include <SDL.h>

// #include "version.hpp"
#ifndef CENTURION_VERSION_HEADER
#define CENTURION_VERSION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <cassert>  // assert

/// \addtogroup core
/// \{

/**
 * \def CENTURION_VERSION_MAJOR
 *
 * \brief Expands into the current major version of the library.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_MAJOR 6

/**
 * \def CENTURION_VERSION_MINOR
 *
 * \brief Expands into the current minor version of the library.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_MINOR 3

/**
 * \def CENTURION_VERSION_PATCH
 *
 * \brief Expands into the current patch version of the library.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_PATCH 0

/**
 * \def CENTURION_SDL_VERSION_IS
 *
 * \brief This macro is meant to be used when conditionally including code for a specific
 * version of SDL. It is useful for applying workarounds.
 *
 * \since 5.3.0
 */
#define CENTURION_SDL_VERSION_IS(x, y, z) \
  ((SDL_MAJOR_VERSION == (x)) && (SDL_MINOR_VERSION == (y)) && (SDL_PATCHLEVEL == (z)))

#ifdef CENTURION___DOXYGEN

#define CENTURION_MAKE_VERSION_NUMBER
#define CENTURION_VERSION_NUMBER
#define CENTURION_VERSION_AT_LEAST

#endif  // CENTURION___DOXYGEN

/**
 * \def CENTURION_MAKE_VERSION_NUMBER
 *
 * \brief Helper macro for creating version numbers from a set of major/minor/patch
 * numbers.
 *
 * \details For example, if the version is 8.4.2, the resulting version number would be
 * 8402.
 *
 * \since 6.0.0
 */
#define CENTURION_MAKE_VERSION_NUMBER(x, y, z) (((x)*1'000) + ((y)*100) + (z))

/**
 * \def CENTURION_VERSION_NUMBER
 *
 * \brief Expands into a version number based on the current Centurion version.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_NUMBER                         \
  CENTURION_MAKE_VERSION_NUMBER(CENTURION_VERSION_MAJOR, \
                                CENTURION_VERSION_MINOR, \
                                CENTURION_VERSION_PATCH)

/**
 * \def CENTURION_VERSION_AT_LEAST
 *
 * \brief This macro is intended to be used for conditional compilation, based on the
 * Centurion version.
 *
 * \details This macro is used in the same way as the `SDL_VERSION_ATLEAST`, where you use
 * it as the condition with `#if` statements.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_AT_LEAST(x, y, z) \
  CENTURION_VERSION_NUMBER >= CENTURION_MAKE_VERSION_NUMBER(x, y, z)

namespace cen {

/// \name Centurion version queries
/// \{

/**
 * \struct version
 *
 * \brief Represents a set of major/minor/patch version numbers.
 *
 * \details The members of this struct are by default initialized to the current Centurion
 * version values.
 *
 * \since 6.0.0
 */
struct version final
{
  int major{CENTURION_VERSION_MAJOR};
  int minor{CENTURION_VERSION_MINOR};
  int patch{CENTURION_VERSION_PATCH};
};

/**
 * \brief Indicates whether or not the current Centurion version is at least equal to the
 * specified version.
 *
 * \param major the major version value.
 * \param minor the minor version value.
 * \param patch the patch version value.
 *
 * \return `true` if the version of Centurion is at least the specified version; `false`
 * otherwise.
 *
 * \see `CENTURION_VERSION_AT_LEAST`
 *
 * \since 6.0.0
 */
[[nodiscard]] constexpr auto version_at_least(const int major,
                                              const int minor,
                                              const int patch) noexcept -> bool
{
  return CENTURION_VERSION_AT_LEAST(major, minor, patch);
}

/// \} End of centurion version queries

/// \name SDL version queries
/// \{

/**
 * \brief Returns the version of SDL2 that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL that the
 * program was compiled against.
 *
 * \return the linked version of SDL2.
 *
 * \since 5.2.0
 */
[[nodiscard]] inline auto sdl_linked_version() noexcept -> SDL_version
{
  SDL_version version{};
  SDL_GetVersion(&version);
  return version;
}

/**
 * \brief Returns the compile-time version of SDL2 that is being used.
 *
 * \return the compile-time version of SDL2 that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_version() noexcept -> SDL_version
{
  return {SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL};
}

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \brief Returns the version of SDL2_image that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL2_image that
 * the program was compiled against.
 *
 * \return the linked version of SDL2_image.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto sdl_image_linked_version() noexcept -> SDL_version
{
  const auto* version = IMG_Linked_Version();
  assert(version);  // Sanity check
  return *version;
}

/**
 * \brief Returns the compile-time version of SDL2_image that is being used.
 *
 * \return the compile-time version of SDL2_image that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_image_version() noexcept -> SDL_version
{
  return {SDL_IMAGE_MAJOR_VERSION, SDL_IMAGE_MINOR_VERSION, SDL_IMAGE_PATCHLEVEL};
}

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \brief Returns the version of SDL2_mixer that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL2_mixer that
 * the program was compiled against.
 *
 * \return the linked version of SDL2_mixer.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto sdl_mixer_linked_version() noexcept -> SDL_version
{
  const auto* version = Mix_Linked_Version();
  assert(version);  // Sanity check
  return *version;
}

/**
 * \brief Returns the compile-time version of SDL2_mixer that is being used.
 *
 * \return the compile-time version of SDL2_mixer that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_mixer_version() noexcept -> SDL_version
{
  return {SDL_MIXER_MAJOR_VERSION, SDL_MIXER_MINOR_VERSION, SDL_MIXER_PATCHLEVEL};
}

#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF

/**
 * \brief Returns the version of SDL2_ttf that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL2_ttf that the
 * program was compiled against.
 *
 * \return the linked version of SDL2_ttf.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto sdl_ttf_linked_version() noexcept -> SDL_version
{
  const auto* version = TTF_Linked_Version();
  assert(version);  // Sanity check
  return *version;
}

/**
 * \brief Returns the compile-time version of SDL2_ttf that is being used.
 *
 * \return the compile-time version of SDL2_ttf that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_ttf_version() noexcept -> SDL_version
{
  return {SDL_TTF_MAJOR_VERSION, SDL_TTF_MINOR_VERSION, SDL_TTF_PATCHLEVEL};
}

#endif  // CENTURION_NO_SDL_TTF

/// \} End of SDL version queries

}  // namespace cen

#if CENTURION_SDL_VERSION_IS(2, 0, 10)

// Workaround for this enum being completely anonymous in SDL 2.0.10. We include
// this here because multiple files (key_code.hpp and scan_code.hpp) depend on
// this definition.
using SDL_KeyCode = decltype(SDLK_UNKNOWN);

#endif  // CENTURION_SDL_VERSION_IS(2, 0, 10)

/// \} End of group core

#endif  // CENTURION_VERSION_HEADER


#if CENTURION_SDL_VERSION_IS(2, 0, 10)

// Workaround for this enum being completely anonymous in SDL 2.0.10
using SDL_LogCategory = decltype(SDL_LOG_CATEGORY_APPLICATION);

#endif  // CENTURION_SDL_VERSION_IS(2, 0, 10)

#endif  // CENTURION_SDL_LOG_CATEGORY_WORKAROUND_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \brief Represents different logging categories.
 *
 * \see `SDL_LogCategory`
 * \see `log_category_count()`
 *
 * \todo Centurion 7: rename `misc` enumerator to `custom`.
 *
 * \since 3.0.0
 */
enum class log_category : int
{
  app = SDL_LOG_CATEGORY_APPLICATION,
  error = SDL_LOG_CATEGORY_ERROR,
  assert = SDL_LOG_CATEGORY_ASSERT,
  system = SDL_LOG_CATEGORY_SYSTEM,
  audio = SDL_LOG_CATEGORY_AUDIO,
  video = SDL_LOG_CATEGORY_VIDEO,
  render = SDL_LOG_CATEGORY_RENDER,
  input = SDL_LOG_CATEGORY_INPUT,
  test = SDL_LOG_CATEGORY_TEST,
  misc = SDL_LOG_CATEGORY_CUSTOM
};

/**
 * \brief Returns the number of enumerators for the `log_category` enum.
 *
 * \return the number of enumerators.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto log_category_count() noexcept -> int
{
  return 10;
}

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied log category.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(log_category::app) == "app"`.
 *
 * \param category the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const log_category category) -> std::string_view
{
  switch (category) {
    case log_category::app:
      return "app";

    case log_category::error:
      return "error";

    case log_category::assert:
      return "assert";

    case log_category::system:
      return "system";

    case log_category::audio:
      return "audio";

    case log_category::video:
      return "video";

    case log_category::render:
      return "render";

    case log_category::input:
      return "input";

    case log_category::test:
      return "test";

    case log_category::misc:
      return "misc";

    default:
      throw cen_error{"Did not recognize log category!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a log category enumerator.
 *
 * \param stream the output stream that will be used.
 * \param priority the enumerator that will be printed.
 *
 * \see `to_string(log_category)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const log_category category) -> std::ostream&
{
  return stream << to_string(category);
}

/// \} End of streaming

/// \name Log category comparison operators
/// \{

/**
 * \brief Indicates whether or not the two log category values are the same.
 *
 * \param lhs the left-hand side log category value.
 * \param rhs the right-hand side log category value.
 *
 * \return `true` if the categories are the same; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator==(const log_category lhs,
                                        const SDL_LogCategory rhs) noexcept -> bool
{
  return static_cast<SDL_LogCategory>(lhs) == rhs;
}

/// \copydoc operator==(const log_category, const SDL_LogCategory)
[[nodiscard]] constexpr auto operator==(const SDL_LogCategory lhs,
                                        const log_category rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the two log category values are the same.
 *
 * \param lhs the left-hand side log category value.
 * \param rhs the right-hand side log category value.
 *
 * \return `true` if the categories are the same; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator!=(const log_category lhs,
                                        const SDL_LogCategory rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const log_category, const SDL_LogCategory)
[[nodiscard]] constexpr auto operator!=(const SDL_LogCategory lhs,
                                        const log_category rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of log category comparison operators

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_LOG_CATEGORY_HEADER

// #include "log_priority.hpp"
#ifndef CENTURION_LOG_PRIORITY_HEADER
#define CENTURION_LOG_PRIORITY_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "exception.hpp"


namespace cen {

/// \addtogroup core
/// \{

/**
 * \enum log_priority
 *
 * \brief Provides values that represent different logging priorities.
 *
 * \see `SDL_LogPriority`
 *
 * \since 3.0.0
 */
enum class log_priority : int
{
  verbose = SDL_LOG_PRIORITY_VERBOSE,
  debug = SDL_LOG_PRIORITY_DEBUG,
  info = SDL_LOG_PRIORITY_INFO,
  warn = SDL_LOG_PRIORITY_WARN,
  error = SDL_LOG_PRIORITY_ERROR,
  critical = SDL_LOG_PRIORITY_CRITICAL,
};

/**
 * \brief Returns the number of available log priorities.
 *
 * \return the number of log priorities.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto log_priority_count() noexcept -> int
{
  return SDL_NUM_LOG_PRIORITIES;
}

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied log priority.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(log_priority::debug) == "debug"`.
 *
 * \param priority the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const log_priority priority) -> std::string_view
{
  switch (priority) {
    case log_priority::verbose:
      return "verbose";

    case log_priority::debug:
      return "debug";

    case log_priority::info:
      return "info";

    case log_priority::warn:
      return "warn";

    case log_priority::error:
      return "error";

    case log_priority::critical:
      return "critical";

    default:
      throw cen_error{"Did not recognize log priority!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a log priority enumerator.
 *
 * \param stream the output stream that will be used.
 * \param priority the enumerator that will be printed.
 *
 * \see `to_string(log_priority)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const log_priority priority) -> std::ostream&
{
  return stream << to_string(priority);
}

/// \} End of streaming

/// \name Log priority comparison operators
/// \{

/**
 * \brief Indicates whether or not the two log priorities values are the same.
 *
 * \param lhs the left-hand side log priority value.
 * \param rhs the right-hand side log priority value.
 *
 * \return `true` if the priorities are the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const log_priority lhs,
                                        const SDL_LogPriority rhs) noexcept -> bool
{
  return static_cast<SDL_LogPriority>(lhs) == rhs;
}

/// \copydoc operator==(const log_priority, const SDL_LogPriority)
[[nodiscard]] constexpr auto operator==(const SDL_LogPriority lhs,
                                        const log_priority rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the two log priorities values aren't the same.
 *
 * \param lhs the left-hand side log priority value.
 * \param rhs the right-hand side log priority value.
 *
 * \return `true` if the priorities aren't the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator!=(const log_priority lhs,
                                        const SDL_LogPriority rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const log_priority, const SDL_LogPriority)
[[nodiscard]] constexpr auto operator!=(const SDL_LogPriority lhs,
                                        const log_priority rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of log priority comparison operators

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_LOG_PRIORITY_HEADER

// #include "not_null.hpp"
#ifndef CENTURION_NOT_NULL_HEADER
#define CENTURION_NOT_NULL_HEADER

// #include "sfinae.hpp"
#ifndef CENTURION_SFINAE_HEADER
#define CENTURION_SFINAE_HEADER

#include <type_traits>  // enable_if_t, is_same_v, is_integral_v, is_floating_point_v, ...

namespace cen {

/// \addtogroup core
/// \{

// clang-format off

/// Enables a template if the type is either integral of floating-point, but not a boolean.
template <typename T>
using enable_if_number_t = std::enable_if_t<!std::is_same_v<T, bool> &&
                                            (std::is_integral_v<T> ||
                                             std::is_floating_point_v<T>), int>;

// clang-format on

/// Enables a template if the type is a pointer.
template <typename T>
using enable_if_pointer_v = std::enable_if_t<std::is_pointer_v<T>, int>;

/// Enables a template if T is convertible to any of the specified types.
template <typename T, typename... Args>
using enable_if_convertible_t = std::enable_if_t<(std::is_convertible_v<T, Args> || ...), int>;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_SFINAE_HEADER


namespace cen {

/**
 * \typedef not_null
 *
 * \ingroup core
 *
 * \brief Tag used to indicate that a pointer cannot be null.
 *
 * \note This alias is equivalent to `T`, it is a no-op.
 *
 * \since 5.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using not_null = T;

}  // namespace cen

#endif  // CENTURION_NOT_NULL_HEADER

// #include "str.hpp"

// #include "to_underlying.hpp"
#ifndef CENTURION_TO_UNDERLYING_HEADER
#define CENTURION_TO_UNDERLYING_HEADER

#include <type_traits>  // underlying_type_t, enable_if_t, is_enum_v

namespace cen {

/**
 * \brief Converts an enum value to an integral value using the underlying type.
 *
 * \ingroup core
 *
 * \note If you're using C++23, see `std::to_underlying()`.
 *
 * \tparam Enum the enum type.
 *
 * \param value the enum value that will be converted.
 *
 * \return the value of the enum, in the underlying type.
 *
 * \since 6.0.0
 */
template <typename Enum, std::enable_if_t<std::is_enum_v<Enum>, int> = 0>
[[nodiscard]] constexpr auto to_underlying(const Enum value) noexcept
    -> std::underlying_type_t<Enum>
{
  return static_cast<std::underlying_type_t<Enum>>(value);
}

}  // namespace cen

#endif  // CENTURION_TO_UNDERLYING_HEADER


/// \namespace cen::log
/// \brief Contains easy-to-use logging facilities.
/// \ingroup core
/// \since 3.0.0
namespace cen::log {

/// \addtogroup core
/// \{

/**
 * \brief Logs a message with the specified priority and category.
 *
 * \details This function has no effect if the supplied string is null. Usage of this
 * function is quite bulky, so refer to the other logging methods for casual logging.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param priority the priority that will be used.
 * \param category the category that will be used.
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void msg(const log_priority priority,
         const log_category category,
         const not_null<str> fmt,
         Args&&... args) noexcept
{
  assert(fmt);
  const auto sdlCategory = static_cast<SDL_LogCategory>(category);
  const auto prio = static_cast<SDL_LogPriority>(priority);
  SDL_LogMessage(sdlCategory, prio, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::info` and the specified category.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param category the category that will be used.
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void info(const log_category category, const not_null<str> fmt, Args&&... args) noexcept
{
  log::msg(log_priority::info, category, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::info` and `log_category::app`.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void info(const not_null<str> fmt, Args&&... args) noexcept
{
  log::info(log_category::app, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::warn` and the specified category.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param category the category that will be used.
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void warn(const log_category category, const not_null<str> fmt, Args&&... args) noexcept
{
  log::msg(log_priority::warn, category, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::warn` and `log_category::app`.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void warn(const not_null<str> fmt, Args&&... args) noexcept
{
  log::warn(log_category::app, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::verbose` and the specified category.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param category the category that will be used.
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void verbose(const log_category category, const not_null<str> fmt, Args&&... args) noexcept
{
  log::msg(log_priority::verbose, category, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::verbose` and `log_category::app`.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void verbose(const not_null<str> fmt, Args&&... args) noexcept
{
  log::verbose(log_category::app, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::debug` and the specified category.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param category the category that will be used.
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void debug(const log_category category, const not_null<str> fmt, Args&&... args) noexcept
{
  log::msg(log_priority::debug, category, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::debug` and `log_category::app`.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void debug(const not_null<str> fmt, Args&&... args) noexcept
{
  log::debug(log_category::app, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::critical` and the specified category.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param category the category that will be used.
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void critical(const log_category category, const not_null<str> fmt, Args&&... args) noexcept
{
  log::msg(log_priority::critical, category, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::critical` and `log_category::app`.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void critical(const not_null<str> fmt, Args&&... args) noexcept
{
  log::critical(log_category::app, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::error` and the specified category.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param category the category that will be used.
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void error(const log_category category, const str fmt, Args&&... args) noexcept
{
  log::msg(log_priority::error, category, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with the `log_priority::error` and `log_category::app`.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void error(const not_null<str> fmt, Args&&... args) noexcept
{
  log::error(log_category::app, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a string.
 *
 * \details This function is meant to be used for casual logging, where you just want to
 * log a string. The message will be logged with `log_priority::info` and
 * `log_category::app`.
 *
 * \param str the string that will be logged.
 *
 * \since 5.0.0
 */
inline void put(const std::string& str) noexcept
{
  log::info("%s", str.c_str());
}

/// \copydoc put()
inline void put(const not_null<str> str) noexcept
{
  log::info("%s", str);
}

/**
 * \brief Resets all of the logging priorities.
 *
 * \since 3.0.0
 */
inline void reset_priorities() noexcept
{
  SDL_LogResetPriorities();
}

/**
 * \brief Sets the priority of all categories.
 *
 * \param priority the priority that will be used.
 *
 * \since 3.0.0
 */
inline void set_priority(const log_priority priority) noexcept
{
  const auto p = static_cast<SDL_LogPriority>(priority);
  SDL_LogSetAllPriority(p);

  // Apparently not set by SDL
  SDL_LogSetPriority(SDL_LOG_CATEGORY_TEST, p);
}

/**
 * \brief Sets the priority of the specified category.
 *
 * \param category the category that will have its priority changed.
 * \param priority the new priority value.
 *
 * \since 3.0.0
 */
inline void set_priority(const log_category category, const log_priority priority) noexcept
{
  SDL_LogSetPriority(to_underlying(category), static_cast<SDL_LogPriority>(priority));
}

/**
 * \brief Returns the priority of the specified category.
 *
 * \param category the category to return the priority of.
 * \return the priority of the specified category.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto get_priority(const log_category category) noexcept -> log_priority
{
  return static_cast<log_priority>(SDL_LogGetPriority(to_underlying(category)));
}

/**
 * \brief Returns the maximum size, i.e the maximum amount of characters that a string can
 * contain and successfully be logged without being truncated.
 *
 * \note Strings longer that this value will be truncated.
 *
 * \return the maximum amount of characters that a loggable string can contain.
 *
 * \see `SDL_MAX_LOG_MESSAGE`
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto max_message_size() noexcept -> int
{
  return SDL_MAX_LOG_MESSAGE;
}

#if CENTURION_HAS_FEATURE_CONCEPTS

/**
 * \brief Sets the logging output function that will be used.
 *
 * \tparam Callable the type of the function object.
 *
 * \param callable the function object that will be used as the new logging output
 * function.
 *
 * \see `use_preset_output_function()`
 *
 * \since 6.2.0
 */
template <is_stateless_callable<log_category, log_priority, str> Callable>
inline void set_output_function([[maybe_unused]] Callable callable) noexcept
{
  const auto wrapper = [](void* /*erased*/,
                          const int category,
                          const SDL_LogPriority priority,
                          const str message) {
    Callable tmp;
    tmp(static_cast<log_category>(category), static_cast<log_priority>(priority), message);
  };

  SDL_LogSetOutputFunction(wrapper, nullptr);
}

/**
 * \brief Sets the logging output function that will be used.
 *
 * \tparam UserData the type of the user data.
 * \tparam Callable the type of the function object.
 *
 * \param callable the function object that will be used as the new logging output
 * function.
 * \param data a pointer to the user data, can safely be null. However, see the other
 * overload of this function if you do not need the user data.
 *
 * \see `use_preset_output_function()`
 *
 * \since 6.2.0
 */
template <typename UserData,
          is_stateless_callable<UserData*, log_category, log_priority, str> Callable>
inline void set_output_function([[maybe_unused]] Callable callable, UserData* data) noexcept
{
  const auto wrapper =
      [](void* erased, const int category, const SDL_LogPriority priority, const str message) {
        Callable tmp;
        tmp(static_cast<UserData*>(erased),
            static_cast<log_category>(category),
            static_cast<log_priority>(priority),
            message);
      };

  SDL_LogSetOutputFunction(wrapper, data);
}

#if CENTURION_HAS_FEATURE_FORMAT && CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES

/**
 * \brief Sets the logging output function to a convenient preset.
 *
 * \details Calling this function will make the logging output be channeled through
 * `std::clog`, and use an output format that includes the current time (taking the
 * current time zone into account) and the log priority associated with each message.
 *
 * \see `set_output_function()`
 *
 * \since 6.2.0
 */
inline void use_preset_output_function() noexcept
{
  using std::chrono::current_zone;
  using std::chrono::system_clock;
  using std::chrono::zoned_time;

  set_output_function([](const log_category, const log_priority priority, const str message) {
    const zoned_time time{current_zone(), system_clock::now()};

    std::array<char, 512> buffer;  // NOLINT
    const auto result = std::format_to_n(buffer.data(),
                                         buffer.size() - 1,
                                         "LOG {:%T} [{}] > {}\n",
                                         time,
                                         to_string(priority),
                                         message);
    *result.out = '\0';

    std::clog << std::string_view{buffer.data(), result.out};
  });
}

#endif  // CENTURION_HAS_FEATURE_FORMAT && CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES

#endif  // CENTURION_HAS_FEATURE_CONCEPTS

/// \} End of group core

}  // namespace cen::log

#endif  // CENTURION_LOG_HEADER

// #include "centurion/core/log_category.hpp"
#ifndef CENTURION_LOG_CATEGORY_HEADER
#define CENTURION_LOG_CATEGORY_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "exception.hpp"

// #include "sdl_log_category_workaround.hpp"


namespace cen {

/// \addtogroup core
/// \{

/**
 * \brief Represents different logging categories.
 *
 * \see `SDL_LogCategory`
 * \see `log_category_count()`
 *
 * \todo Centurion 7: rename `misc` enumerator to `custom`.
 *
 * \since 3.0.0
 */
enum class log_category : int
{
  app = SDL_LOG_CATEGORY_APPLICATION,
  error = SDL_LOG_CATEGORY_ERROR,
  assert = SDL_LOG_CATEGORY_ASSERT,
  system = SDL_LOG_CATEGORY_SYSTEM,
  audio = SDL_LOG_CATEGORY_AUDIO,
  video = SDL_LOG_CATEGORY_VIDEO,
  render = SDL_LOG_CATEGORY_RENDER,
  input = SDL_LOG_CATEGORY_INPUT,
  test = SDL_LOG_CATEGORY_TEST,
  misc = SDL_LOG_CATEGORY_CUSTOM
};

/**
 * \brief Returns the number of enumerators for the `log_category` enum.
 *
 * \return the number of enumerators.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto log_category_count() noexcept -> int
{
  return 10;
}

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied log category.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(log_category::app) == "app"`.
 *
 * \param category the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const log_category category) -> std::string_view
{
  switch (category) {
    case log_category::app:
      return "app";

    case log_category::error:
      return "error";

    case log_category::assert:
      return "assert";

    case log_category::system:
      return "system";

    case log_category::audio:
      return "audio";

    case log_category::video:
      return "video";

    case log_category::render:
      return "render";

    case log_category::input:
      return "input";

    case log_category::test:
      return "test";

    case log_category::misc:
      return "misc";

    default:
      throw cen_error{"Did not recognize log category!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a log category enumerator.
 *
 * \param stream the output stream that will be used.
 * \param priority the enumerator that will be printed.
 *
 * \see `to_string(log_category)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const log_category category) -> std::ostream&
{
  return stream << to_string(category);
}

/// \} End of streaming

/// \name Log category comparison operators
/// \{

/**
 * \brief Indicates whether or not the two log category values are the same.
 *
 * \param lhs the left-hand side log category value.
 * \param rhs the right-hand side log category value.
 *
 * \return `true` if the categories are the same; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator==(const log_category lhs,
                                        const SDL_LogCategory rhs) noexcept -> bool
{
  return static_cast<SDL_LogCategory>(lhs) == rhs;
}

/// \copydoc operator==(const log_category, const SDL_LogCategory)
[[nodiscard]] constexpr auto operator==(const SDL_LogCategory lhs,
                                        const log_category rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the two log category values are the same.
 *
 * \param lhs the left-hand side log category value.
 * \param rhs the right-hand side log category value.
 *
 * \return `true` if the categories are the same; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator!=(const log_category lhs,
                                        const SDL_LogCategory rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const log_category, const SDL_LogCategory)
[[nodiscard]] constexpr auto operator!=(const SDL_LogCategory lhs,
                                        const log_category rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of log category comparison operators

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_LOG_CATEGORY_HEADER

// #include "centurion/core/log_macros.hpp"
#ifndef CENTURION_LOG_MACROS_HEADER
#define CENTURION_LOG_MACROS_HEADER

#include <SDL.h>

// #include "../compiler/features.hpp"

// #include "log.hpp"
#ifndef CENTURION_LOG_HEADER
#define CENTURION_LOG_HEADER

#include <SDL.h>

#include <array>        // array
#include <cassert>      // assert
#include <chrono>       // zoned_time, current_zone, system_clock
#include <iostream>     // clog
#include <string>       // string
#include <string_view>  // string_view
#include <utility>      // forward

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format_to_n

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "is_stateless_callable.hpp"

// #include "log_category.hpp"

// #include "log_priority.hpp"

// #include "not_null.hpp"

// #include "str.hpp"

// #include "to_underlying.hpp"


/// \namespace cen::log
/// \brief Contains easy-to-use logging facilities.
/// \ingroup core
/// \since 3.0.0
namespace cen::log {

/// \addtogroup core
/// \{

/**
 * \brief Logs a message with the specified priority and category.
 *
 * \details This function has no effect if the supplied string is null. Usage of this
 * function is quite bulky, so refer to the other logging methods for casual logging.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param priority the priority that will be used.
 * \param category the category that will be used.
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void msg(const log_priority priority,
         const log_category category,
         const not_null<str> fmt,
         Args&&... args) noexcept
{
  assert(fmt);
  const auto sdlCategory = static_cast<SDL_LogCategory>(category);
  const auto prio = static_cast<SDL_LogPriority>(priority);
  SDL_LogMessage(sdlCategory, prio, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::info` and the specified category.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param category the category that will be used.
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void info(const log_category category, const not_null<str> fmt, Args&&... args) noexcept
{
  log::msg(log_priority::info, category, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::info` and `log_category::app`.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void info(const not_null<str> fmt, Args&&... args) noexcept
{
  log::info(log_category::app, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::warn` and the specified category.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param category the category that will be used.
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void warn(const log_category category, const not_null<str> fmt, Args&&... args) noexcept
{
  log::msg(log_priority::warn, category, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::warn` and `log_category::app`.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void warn(const not_null<str> fmt, Args&&... args) noexcept
{
  log::warn(log_category::app, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::verbose` and the specified category.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param category the category that will be used.
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void verbose(const log_category category, const not_null<str> fmt, Args&&... args) noexcept
{
  log::msg(log_priority::verbose, category, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::verbose` and `log_category::app`.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void verbose(const not_null<str> fmt, Args&&... args) noexcept
{
  log::verbose(log_category::app, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::debug` and the specified category.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param category the category that will be used.
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void debug(const log_category category, const not_null<str> fmt, Args&&... args) noexcept
{
  log::msg(log_priority::debug, category, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::debug` and `log_category::app`.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void debug(const not_null<str> fmt, Args&&... args) noexcept
{
  log::debug(log_category::app, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::critical` and the specified category.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param category the category that will be used.
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void critical(const log_category category, const not_null<str> fmt, Args&&... args) noexcept
{
  log::msg(log_priority::critical, category, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::critical` and `log_category::app`.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void critical(const not_null<str> fmt, Args&&... args) noexcept
{
  log::critical(log_category::app, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::error` and the specified category.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param category the category that will be used.
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void error(const log_category category, const str fmt, Args&&... args) noexcept
{
  log::msg(log_priority::error, category, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with the `log_priority::error` and `log_category::app`.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void error(const not_null<str> fmt, Args&&... args) noexcept
{
  log::error(log_category::app, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a string.
 *
 * \details This function is meant to be used for casual logging, where you just want to
 * log a string. The message will be logged with `log_priority::info` and
 * `log_category::app`.
 *
 * \param str the string that will be logged.
 *
 * \since 5.0.0
 */
inline void put(const std::string& str) noexcept
{
  log::info("%s", str.c_str());
}

/// \copydoc put()
inline void put(const not_null<str> str) noexcept
{
  log::info("%s", str);
}

/**
 * \brief Resets all of the logging priorities.
 *
 * \since 3.0.0
 */
inline void reset_priorities() noexcept
{
  SDL_LogResetPriorities();
}

/**
 * \brief Sets the priority of all categories.
 *
 * \param priority the priority that will be used.
 *
 * \since 3.0.0
 */
inline void set_priority(const log_priority priority) noexcept
{
  const auto p = static_cast<SDL_LogPriority>(priority);
  SDL_LogSetAllPriority(p);

  // Apparently not set by SDL
  SDL_LogSetPriority(SDL_LOG_CATEGORY_TEST, p);
}

/**
 * \brief Sets the priority of the specified category.
 *
 * \param category the category that will have its priority changed.
 * \param priority the new priority value.
 *
 * \since 3.0.0
 */
inline void set_priority(const log_category category, const log_priority priority) noexcept
{
  SDL_LogSetPriority(to_underlying(category), static_cast<SDL_LogPriority>(priority));
}

/**
 * \brief Returns the priority of the specified category.
 *
 * \param category the category to return the priority of.
 * \return the priority of the specified category.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto get_priority(const log_category category) noexcept -> log_priority
{
  return static_cast<log_priority>(SDL_LogGetPriority(to_underlying(category)));
}

/**
 * \brief Returns the maximum size, i.e the maximum amount of characters that a string can
 * contain and successfully be logged without being truncated.
 *
 * \note Strings longer that this value will be truncated.
 *
 * \return the maximum amount of characters that a loggable string can contain.
 *
 * \see `SDL_MAX_LOG_MESSAGE`
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto max_message_size() noexcept -> int
{
  return SDL_MAX_LOG_MESSAGE;
}

#if CENTURION_HAS_FEATURE_CONCEPTS

/**
 * \brief Sets the logging output function that will be used.
 *
 * \tparam Callable the type of the function object.
 *
 * \param callable the function object that will be used as the new logging output
 * function.
 *
 * \see `use_preset_output_function()`
 *
 * \since 6.2.0
 */
template <is_stateless_callable<log_category, log_priority, str> Callable>
inline void set_output_function([[maybe_unused]] Callable callable) noexcept
{
  const auto wrapper = [](void* /*erased*/,
                          const int category,
                          const SDL_LogPriority priority,
                          const str message) {
    Callable tmp;
    tmp(static_cast<log_category>(category), static_cast<log_priority>(priority), message);
  };

  SDL_LogSetOutputFunction(wrapper, nullptr);
}

/**
 * \brief Sets the logging output function that will be used.
 *
 * \tparam UserData the type of the user data.
 * \tparam Callable the type of the function object.
 *
 * \param callable the function object that will be used as the new logging output
 * function.
 * \param data a pointer to the user data, can safely be null. However, see the other
 * overload of this function if you do not need the user data.
 *
 * \see `use_preset_output_function()`
 *
 * \since 6.2.0
 */
template <typename UserData,
          is_stateless_callable<UserData*, log_category, log_priority, str> Callable>
inline void set_output_function([[maybe_unused]] Callable callable, UserData* data) noexcept
{
  const auto wrapper =
      [](void* erased, const int category, const SDL_LogPriority priority, const str message) {
        Callable tmp;
        tmp(static_cast<UserData*>(erased),
            static_cast<log_category>(category),
            static_cast<log_priority>(priority),
            message);
      };

  SDL_LogSetOutputFunction(wrapper, data);
}

#if CENTURION_HAS_FEATURE_FORMAT && CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES

/**
 * \brief Sets the logging output function to a convenient preset.
 *
 * \details Calling this function will make the logging output be channeled through
 * `std::clog`, and use an output format that includes the current time (taking the
 * current time zone into account) and the log priority associated with each message.
 *
 * \see `set_output_function()`
 *
 * \since 6.2.0
 */
inline void use_preset_output_function() noexcept
{
  using std::chrono::current_zone;
  using std::chrono::system_clock;
  using std::chrono::zoned_time;

  set_output_function([](const log_category, const log_priority priority, const str message) {
    const zoned_time time{current_zone(), system_clock::now()};

    std::array<char, 512> buffer;  // NOLINT
    const auto result = std::format_to_n(buffer.data(),
                                         buffer.size() - 1,
                                         "LOG {:%T} [{}] > {}\n",
                                         time,
                                         to_string(priority),
                                         message);
    *result.out = '\0';

    std::clog << std::string_view{buffer.data(), result.out};
  });
}

#endif  // CENTURION_HAS_FEATURE_FORMAT && CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES

#endif  // CENTURION_HAS_FEATURE_CONCEPTS

/// \} End of group core

}  // namespace cen::log

#endif  // CENTURION_LOG_HEADER


#ifndef CENTURION_NO_DEBUG_LOG_MACROS
#ifdef NDEBUG

#define CENTURION_LOG_INFO(fmt, ...)
#define CENTURION_LOG_WARN(fmt, ...)
#define CENTURION_LOG_VERBOSE(fmt, ...)
#define CENTURION_LOG_DEBUG(fmt, ...)
#define CENTURION_LOG_CRITICAL(fmt, ...)
#define CENTURION_LOG_ERROR(fmt, ...)

#else

#if CENTURION_HAS_FEATURE_CPP20

// clang-format off
#define CENTURION_LOG_INFO(fmt, ...) cen::log::info(fmt __VA_OPT__(,) __VA_ARGS__)
#define CENTURION_LOG_WARN(fmt, ...) cen::log::warn(fmt __VA_OPT__(,) __VA_ARGS__)
#define CENTURION_LOG_VERBOSE(fmt, ...) cen::log::verbose(fmt __VA_OPT__(,) __VA_ARGS__)
#define CENTURION_LOG_DEBUG(fmt, ...) cen::log::debug(fmt __VA_OPT__(,) __VA_ARGS__)
#define CENTURION_LOG_CRITICAL(fmt, ...) cen::log::critical(fmt __VA_OPT__(,) __VA_ARGS__)
#define CENTURION_LOG_ERROR(fmt, ...) cen::log::error(fmt __VA_OPT__(,) __VA_ARGS__)
// clang-format on

#else

// clang-format off
#define CENTURION_LOG_INFO(fmt, ...) cen::log::info(fmt, __VA_ARGS__)
#define CENTURION_LOG_WARN(fmt, ...) cen::log::warn(fmt, __VA_ARGS__)
#define CENTURION_LOG_VERBOSE(fmt, ...) cen::log::verbose(fmt, __VA_ARGS__)
#define CENTURION_LOG_DEBUG(fmt, ...) cen::log::debug(fmt, __VA_ARGS__)
#define CENTURION_LOG_CRITICAL(fmt, ...) cen::log::critical(fmt, __VA_ARGS__)
#define CENTURION_LOG_ERROR(fmt, ...) cen::log::error(fmt, __VA_ARGS__)
// clang-format on

#endif  // CENTURION_HAS_FEATURE_CPP20

#endif  // NDEBUG
#endif  // CENTURION_NO_DEBUG_LOG_MACROS

#endif  // CENTURION_LOG_MACROS_HEADER

// #include "centurion/core/log_priority.hpp"
#ifndef CENTURION_LOG_PRIORITY_HEADER
#define CENTURION_LOG_PRIORITY_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "exception.hpp"


namespace cen {

/// \addtogroup core
/// \{

/**
 * \enum log_priority
 *
 * \brief Provides values that represent different logging priorities.
 *
 * \see `SDL_LogPriority`
 *
 * \since 3.0.0
 */
enum class log_priority : int
{
  verbose = SDL_LOG_PRIORITY_VERBOSE,
  debug = SDL_LOG_PRIORITY_DEBUG,
  info = SDL_LOG_PRIORITY_INFO,
  warn = SDL_LOG_PRIORITY_WARN,
  error = SDL_LOG_PRIORITY_ERROR,
  critical = SDL_LOG_PRIORITY_CRITICAL,
};

/**
 * \brief Returns the number of available log priorities.
 *
 * \return the number of log priorities.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto log_priority_count() noexcept -> int
{
  return SDL_NUM_LOG_PRIORITIES;
}

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied log priority.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(log_priority::debug) == "debug"`.
 *
 * \param priority the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const log_priority priority) -> std::string_view
{
  switch (priority) {
    case log_priority::verbose:
      return "verbose";

    case log_priority::debug:
      return "debug";

    case log_priority::info:
      return "info";

    case log_priority::warn:
      return "warn";

    case log_priority::error:
      return "error";

    case log_priority::critical:
      return "critical";

    default:
      throw cen_error{"Did not recognize log priority!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a log priority enumerator.
 *
 * \param stream the output stream that will be used.
 * \param priority the enumerator that will be printed.
 *
 * \see `to_string(log_priority)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const log_priority priority) -> std::ostream&
{
  return stream << to_string(priority);
}

/// \} End of streaming

/// \name Log priority comparison operators
/// \{

/**
 * \brief Indicates whether or not the two log priorities values are the same.
 *
 * \param lhs the left-hand side log priority value.
 * \param rhs the right-hand side log priority value.
 *
 * \return `true` if the priorities are the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const log_priority lhs,
                                        const SDL_LogPriority rhs) noexcept -> bool
{
  return static_cast<SDL_LogPriority>(lhs) == rhs;
}

/// \copydoc operator==(const log_priority, const SDL_LogPriority)
[[nodiscard]] constexpr auto operator==(const SDL_LogPriority lhs,
                                        const log_priority rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the two log priorities values aren't the same.
 *
 * \param lhs the left-hand side log priority value.
 * \param rhs the right-hand side log priority value.
 *
 * \return `true` if the priorities aren't the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator!=(const log_priority lhs,
                                        const SDL_LogPriority rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const log_priority, const SDL_LogPriority)
[[nodiscard]] constexpr auto operator!=(const SDL_LogPriority lhs,
                                        const log_priority rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of log priority comparison operators

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_LOG_PRIORITY_HEADER

// #include "centurion/core/macros.hpp"
#ifndef CENTURION_MACROS_HEADER
#define CENTURION_MACROS_HEADER

#include <SDL.h>

/// \addtogroup core
/// \{

#ifndef __clang__

/**
 * \def CENTURION_HAS_STD_MEMORY_RESOURCE
 * \deprecated Since 6.2.0, this is not used by the library and will be removed shortly.
 * \since 5.3.0
 */
#define CENTURION_HAS_STD_MEMORY_RESOURCE

#endif  // __clang__

/// \} End of group core

#endif  // CENTURION_MACROS_HEADER

// #include "centurion/core/not_null.hpp"
#ifndef CENTURION_NOT_NULL_HEADER
#define CENTURION_NOT_NULL_HEADER

// #include "sfinae.hpp"


namespace cen {

/**
 * \typedef not_null
 *
 * \ingroup core
 *
 * \brief Tag used to indicate that a pointer cannot be null.
 *
 * \note This alias is equivalent to `T`, it is a no-op.
 *
 * \since 5.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using not_null = T;

}  // namespace cen

#endif  // CENTURION_NOT_NULL_HEADER

// #include "centurion/core/owner.hpp"
#ifndef CENTURION_OWNER_HEADER
#define CENTURION_OWNER_HEADER

// #include "sfinae.hpp"


namespace cen {

/**
 * \typedef owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote ownership of raw pointers directly in code.
 *
 * \details If a function takes an `owner<T*>` as a parameter, then the function will
 * claim ownership of that pointer. Subsequently, if a function returns an `owner<T*>`,
 * then ownership is transferred to the caller.
 */
template <typename T, enable_if_pointer_v<T> = 0>
using owner = T;

/**
 * \typedef maybe_owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote conditional ownership of raw pointers directly in code.
 *
 * \details This is primarily used in constructors of owner/handle classes, where the
 * owner version will claim ownership of the pointer, whilst the handle does not.
 *
 * \since 6.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using maybe_owner = T;

}  // namespace cen

#endif  // CENTURION_OWNER_HEADER
// #include "centurion/core/result.hpp"
#ifndef CENTURION_RESULT_HEADER
#define CENTURION_RESULT_HEADER

#include <ostream>  // ostream
#include <string>   // string

namespace cen {

/// \addtogroup core
/// \{

/**
 * \class result
 *
 * \brief A simple indicator for the result of different operations.
 *
 * \details The idea behind this class is to make results of various operations
 * unambiguous. Quite an amount of functions in the library may fail, and earlier versions
 * of Centurion would usually return a `bool` in those cases, where `true` and `false`
 * would indicate success and failure, respectively. This class is a development of that
 * practice. For instance, this class is contextually convertible to `bool`, where a
 * successful result is still converted to `true`, and vice versa. However, this class
 * also enables explicit checks against `success` and `failure` constants, which makes
 * code very easy to read and unambiguous.
 * \code{cpp}
 *   cen::window window;
 *
 *   if (window.set_opacity(0.4f))
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::success)
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::failure)
 *   {
 *     // Failure!
 *   }
 * \endcode
 *
 * \see `success`
 * \see `failure`
 *
 * \since 6.0.0
 */
class result final
{
 public:
  /**
   * \brief Creates a result.
   *
   * \param success `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  constexpr result(const bool success) noexcept  // NOLINT implicit
      : m_success{success}
  {}

  /// \name Comparison operators
  /// \{

  /**
   * \brief Indicates whether or not two results have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results are equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator==(const result other) const noexcept -> bool
  {
    return m_success == other.m_success;
  }

  /**
   * \brief Indicates whether or not two results don't have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results aren't equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator!=(const result other) const noexcept -> bool
  {
    return !(*this == other);
  }

  /// \} End of comparison operators

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not the result is successful.
   *
   * \return `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr explicit operator bool() const noexcept
  {
    return m_success;
  }

  /// \} End of conversions

 private:
  bool m_success{};
};

/// Represents a successful result.
/// \since 6.0.0
inline constexpr result success{true};

/// Represents a failure of some kind.
/// \since 6.0.0
inline constexpr result failure{false};

/// \name String conversions
/// \{

/**
 * \brief Returns a string that represents a result value.
 *
 * \note The returned string is in a slightly different format compared to other Centurion
 * components.
 *
 * \param result the value that will be converted.
 *
 * \return `"success"` for a successful result; `"failure"` otherwise.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto to_string(const result result) -> std::string
{
  return result ? "success" : "failure";
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a result value using a stream.
 *
 * \param stream the stream that will be used.
 * \param result the result value that will be printed.
 *
 * \return the used stream.
 *
 * \since 6.0.0
 */
inline auto operator<<(std::ostream& stream, const result result) -> std::ostream&
{
  return stream << to_string(result);
}

/// \} End of streaming

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_RESULT_HEADER

// #include "centurion/core/sdl_log_category_workaround.hpp"
#ifndef CENTURION_SDL_LOG_CATEGORY_WORKAROUND_HEADER
#define CENTURION_SDL_LOG_CATEGORY_WORKAROUND_HEADER

#include <SDL.h>

// #include "version.hpp"


#if CENTURION_SDL_VERSION_IS(2, 0, 10)

// Workaround for this enum being completely anonymous in SDL 2.0.10
using SDL_LogCategory = decltype(SDL_LOG_CATEGORY_APPLICATION);

#endif  // CENTURION_SDL_VERSION_IS(2, 0, 10)

#endif  // CENTURION_SDL_LOG_CATEGORY_WORKAROUND_HEADER

// #include "centurion/core/sdl_string.hpp"
#ifndef CENTURION_SDL_STRING_HEADER
#define CENTURION_SDL_STRING_HEADER

#include <SDL.h>

#include <memory>  // unique_ptr
#include <string>  // string

// #include "../detail/sdl_deleter.hpp"
#ifndef CENTURION_DETAIL_SDL_DELETER_HEADER
#define CENTURION_DETAIL_SDL_DELETER_HEADER

#include <SDL.h>

/// \cond FALSE
namespace cen::detail {

template <typename T>
struct sdl_deleter final
{
  void operator()(T* ptr) noexcept
  {
    SDL_free(ptr);
  }
};

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_SDL_DELETER_HEADER

// #include "owner.hpp"
#ifndef CENTURION_OWNER_HEADER
#define CENTURION_OWNER_HEADER

// #include "sfinae.hpp"


namespace cen {

/**
 * \typedef owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote ownership of raw pointers directly in code.
 *
 * \details If a function takes an `owner<T*>` as a parameter, then the function will
 * claim ownership of that pointer. Subsequently, if a function returns an `owner<T*>`,
 * then ownership is transferred to the caller.
 */
template <typename T, enable_if_pointer_v<T> = 0>
using owner = T;

/**
 * \typedef maybe_owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote conditional ownership of raw pointers directly in code.
 *
 * \details This is primarily used in constructors of owner/handle classes, where the
 * owner version will claim ownership of the pointer, whilst the handle does not.
 *
 * \since 6.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using maybe_owner = T;

}  // namespace cen

#endif  // CENTURION_OWNER_HEADER
// #include "str.hpp"


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class sdl_string
 *
 * \brief Represents an SDL string.
 *
 * \details Certain SDL APIs return `char*` strings that need to be freed using
 * `SDL_free`, this class serves as a small wrapper around such strings. Use the `copy()`
 * member function to convert the string into a corresponding `std::string`.
 *
 * \note Instances of `sdl_string` might manage null strings. Use the overloaded `operator
 * bool()` in order to determine whether or not any associated string is null.
 *
 * \since 5.0.0
 */
class sdl_string final
{
 public:
  /**
   * \brief Creates a string.
   *
   * \param str the string that will be claimed, can be null.
   *
   * \since 5.0.0
   */
  explicit sdl_string(owner<char*> str) noexcept : m_str{str}
  {}

  /**
   * \brief Returns the internal string, which might be null.
   *
   * \return the internal string; `nullptr` if there is none.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get() const noexcept -> str
  {
    return m_str.get();
  }

  /**
   * \brief Returns a copy of the internal string.
   *
   * \details This function returns the empty string if the internal string is a null
   * pointer.
   *
   * \return a copy of the internal string.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto copy() const -> std::string
  {
    if (m_str) {
      return std::string{get()};
    }
    else {
      return std::string{};
    }
  }

  /**
   * \brief Indicates whether or not the internal string is non-null.
   *
   * \return `true` if the internal string is non-null; `false` otherwise.
   *
   * \since 5.0.0
   */
  explicit operator bool() const noexcept
  {
    return m_str.operator bool();
  }

 private:
  std::unique_ptr<char, detail::sdl_deleter<char>> m_str;
};

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_SDL_STRING_HEADER

// #include "centurion/core/sfinae.hpp"
#ifndef CENTURION_SFINAE_HEADER
#define CENTURION_SFINAE_HEADER

#include <type_traits>  // enable_if_t, is_same_v, is_integral_v, is_floating_point_v, ...

namespace cen {

/// \addtogroup core
/// \{

// clang-format off

/// Enables a template if the type is either integral of floating-point, but not a boolean.
template <typename T>
using enable_if_number_t = std::enable_if_t<!std::is_same_v<T, bool> &&
                                            (std::is_integral_v<T> ||
                                             std::is_floating_point_v<T>), int>;

// clang-format on

/// Enables a template if the type is a pointer.
template <typename T>
using enable_if_pointer_v = std::enable_if_t<std::is_pointer_v<T>, int>;

/// Enables a template if T is convertible to any of the specified types.
template <typename T, typename... Args>
using enable_if_convertible_t = std::enable_if_t<(std::is_convertible_v<T, Args> || ...), int>;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_SFINAE_HEADER

// #include "centurion/core/str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER

// #include "centurion/core/str_or_na.hpp"
#ifndef CENTURION_STR_OR_NA_HEADER
#define CENTURION_STR_OR_NA_HEADER

// #include "not_null.hpp"

// #include "str.hpp"


namespace cen {

/// \addtogroup core
/// \{

/**
 * \brief Simply returns the string if it isn't null, returning a placeholder otherwise.
 *
 * \note This is mainly used in `to_string()` overloads.
 *
 * \param string the string that will be checked.
 *
 * \return the supplied string if it isn't null; "n/a" otherwise.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto str_or_na(const str string) noexcept -> not_null<str>
{
  return string ? string : "n/a";
}

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_OR_NA_HEADER

// #include "centurion/core/time.hpp"
#ifndef CENTURION_TIME_HEADER
#define CENTURION_TIME_HEADER

#include <chrono>  // duration
#include <ratio>   // milli, micro, nano

// #include "integers.hpp"


namespace cen {

/// \addtogroup core
/// \{

/// \name Time (std::chrono) aliases
/// \{

/**
 * \typedef seconds
 *
 * \brief Templated alias for durations in seconds.
 */
template <typename T>
using seconds = std::chrono::duration<T>;

/**
 * \typedef milliseconds
 *
 * \brief Templated alias for durations in milliseconds.
 */
template <typename T>
using milliseconds = std::chrono::duration<T, std::milli>;

/**
 * \typedef microseconds
 *
 * \brief Templated alias for durations in microseconds.
 */
template <typename T>
using microseconds = std::chrono::duration<T, std::micro>;

/**
 * \typedef nanoseconds
 *
 * \brief Templated alias for durations in nanoseconds.
 */
template <typename T>
using nanoseconds = std::chrono::duration<T, std::nano>;

/**
 * \typedef minutes
 *
 * \brief Templated alias for durations in minutes.
 */
template <typename T>
using minutes = std::chrono::duration<T, std::ratio<60>>;

/// \} End of time (std::chrono) aliases

namespace literals {

// clang-format off

[[nodiscard]] constexpr auto operator"" _ns(const ulonglong value) noexcept(noexcept(nanoseconds<u32>{}))
    -> nanoseconds<u32>
{
  return nanoseconds<u32>{value};
}

[[nodiscard]] constexpr auto operator"" _us(const ulonglong value) noexcept(noexcept(microseconds<u32>{}))
    -> microseconds<u32>
{
  return microseconds<u32>{value};
}

[[nodiscard]] constexpr auto operator"" _ms(const ulonglong value) noexcept(noexcept(milliseconds<u32>{}))
    -> milliseconds<u32>
{
  return milliseconds<u32>{value};
}

[[nodiscard]] constexpr auto operator"" _s(const ulonglong value) noexcept(noexcept(seconds<u32>{}))
    -> seconds<u32>
{
  return seconds<u32>{value};
}

// clang-format on

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_TIME_HEADER

// #include "centurion/core/to_underlying.hpp"
#ifndef CENTURION_TO_UNDERLYING_HEADER
#define CENTURION_TO_UNDERLYING_HEADER

#include <type_traits>  // underlying_type_t, enable_if_t, is_enum_v

namespace cen {

/**
 * \brief Converts an enum value to an integral value using the underlying type.
 *
 * \ingroup core
 *
 * \note If you're using C++23, see `std::to_underlying()`.
 *
 * \tparam Enum the enum type.
 *
 * \param value the enum value that will be converted.
 *
 * \return the value of the enum, in the underlying type.
 *
 * \since 6.0.0
 */
template <typename Enum, std::enable_if_t<std::is_enum_v<Enum>, int> = 0>
[[nodiscard]] constexpr auto to_underlying(const Enum value) noexcept
    -> std::underlying_type_t<Enum>
{
  return static_cast<std::underlying_type_t<Enum>>(value);
}

}  // namespace cen

#endif  // CENTURION_TO_UNDERLYING_HEADER

// #include "centurion/core/version.hpp"
#ifndef CENTURION_VERSION_HEADER
#define CENTURION_VERSION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <cassert>  // assert

/// \addtogroup core
/// \{

/**
 * \def CENTURION_VERSION_MAJOR
 *
 * \brief Expands into the current major version of the library.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_MAJOR 6

/**
 * \def CENTURION_VERSION_MINOR
 *
 * \brief Expands into the current minor version of the library.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_MINOR 3

/**
 * \def CENTURION_VERSION_PATCH
 *
 * \brief Expands into the current patch version of the library.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_PATCH 0

/**
 * \def CENTURION_SDL_VERSION_IS
 *
 * \brief This macro is meant to be used when conditionally including code for a specific
 * version of SDL. It is useful for applying workarounds.
 *
 * \since 5.3.0
 */
#define CENTURION_SDL_VERSION_IS(x, y, z) \
  ((SDL_MAJOR_VERSION == (x)) && (SDL_MINOR_VERSION == (y)) && (SDL_PATCHLEVEL == (z)))

#ifdef CENTURION___DOXYGEN

#define CENTURION_MAKE_VERSION_NUMBER
#define CENTURION_VERSION_NUMBER
#define CENTURION_VERSION_AT_LEAST

#endif  // CENTURION___DOXYGEN

/**
 * \def CENTURION_MAKE_VERSION_NUMBER
 *
 * \brief Helper macro for creating version numbers from a set of major/minor/patch
 * numbers.
 *
 * \details For example, if the version is 8.4.2, the resulting version number would be
 * 8402.
 *
 * \since 6.0.0
 */
#define CENTURION_MAKE_VERSION_NUMBER(x, y, z) (((x)*1'000) + ((y)*100) + (z))

/**
 * \def CENTURION_VERSION_NUMBER
 *
 * \brief Expands into a version number based on the current Centurion version.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_NUMBER                         \
  CENTURION_MAKE_VERSION_NUMBER(CENTURION_VERSION_MAJOR, \
                                CENTURION_VERSION_MINOR, \
                                CENTURION_VERSION_PATCH)

/**
 * \def CENTURION_VERSION_AT_LEAST
 *
 * \brief This macro is intended to be used for conditional compilation, based on the
 * Centurion version.
 *
 * \details This macro is used in the same way as the `SDL_VERSION_ATLEAST`, where you use
 * it as the condition with `#if` statements.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_AT_LEAST(x, y, z) \
  CENTURION_VERSION_NUMBER >= CENTURION_MAKE_VERSION_NUMBER(x, y, z)

namespace cen {

/// \name Centurion version queries
/// \{

/**
 * \struct version
 *
 * \brief Represents a set of major/minor/patch version numbers.
 *
 * \details The members of this struct are by default initialized to the current Centurion
 * version values.
 *
 * \since 6.0.0
 */
struct version final
{
  int major{CENTURION_VERSION_MAJOR};
  int minor{CENTURION_VERSION_MINOR};
  int patch{CENTURION_VERSION_PATCH};
};

/**
 * \brief Indicates whether or not the current Centurion version is at least equal to the
 * specified version.
 *
 * \param major the major version value.
 * \param minor the minor version value.
 * \param patch the patch version value.
 *
 * \return `true` if the version of Centurion is at least the specified version; `false`
 * otherwise.
 *
 * \see `CENTURION_VERSION_AT_LEAST`
 *
 * \since 6.0.0
 */
[[nodiscard]] constexpr auto version_at_least(const int major,
                                              const int minor,
                                              const int patch) noexcept -> bool
{
  return CENTURION_VERSION_AT_LEAST(major, minor, patch);
}

/// \} End of centurion version queries

/// \name SDL version queries
/// \{

/**
 * \brief Returns the version of SDL2 that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL that the
 * program was compiled against.
 *
 * \return the linked version of SDL2.
 *
 * \since 5.2.0
 */
[[nodiscard]] inline auto sdl_linked_version() noexcept -> SDL_version
{
  SDL_version version{};
  SDL_GetVersion(&version);
  return version;
}

/**
 * \brief Returns the compile-time version of SDL2 that is being used.
 *
 * \return the compile-time version of SDL2 that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_version() noexcept -> SDL_version
{
  return {SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL};
}

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \brief Returns the version of SDL2_image that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL2_image that
 * the program was compiled against.
 *
 * \return the linked version of SDL2_image.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto sdl_image_linked_version() noexcept -> SDL_version
{
  const auto* version = IMG_Linked_Version();
  assert(version);  // Sanity check
  return *version;
}

/**
 * \brief Returns the compile-time version of SDL2_image that is being used.
 *
 * \return the compile-time version of SDL2_image that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_image_version() noexcept -> SDL_version
{
  return {SDL_IMAGE_MAJOR_VERSION, SDL_IMAGE_MINOR_VERSION, SDL_IMAGE_PATCHLEVEL};
}

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \brief Returns the version of SDL2_mixer that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL2_mixer that
 * the program was compiled against.
 *
 * \return the linked version of SDL2_mixer.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto sdl_mixer_linked_version() noexcept -> SDL_version
{
  const auto* version = Mix_Linked_Version();
  assert(version);  // Sanity check
  return *version;
}

/**
 * \brief Returns the compile-time version of SDL2_mixer that is being used.
 *
 * \return the compile-time version of SDL2_mixer that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_mixer_version() noexcept -> SDL_version
{
  return {SDL_MIXER_MAJOR_VERSION, SDL_MIXER_MINOR_VERSION, SDL_MIXER_PATCHLEVEL};
}

#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF

/**
 * \brief Returns the version of SDL2_ttf that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL2_ttf that the
 * program was compiled against.
 *
 * \return the linked version of SDL2_ttf.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto sdl_ttf_linked_version() noexcept -> SDL_version
{
  const auto* version = TTF_Linked_Version();
  assert(version);  // Sanity check
  return *version;
}

/**
 * \brief Returns the compile-time version of SDL2_ttf that is being used.
 *
 * \return the compile-time version of SDL2_ttf that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_ttf_version() noexcept -> SDL_version
{
  return {SDL_TTF_MAJOR_VERSION, SDL_TTF_MINOR_VERSION, SDL_TTF_PATCHLEVEL};
}

#endif  // CENTURION_NO_SDL_TTF

/// \} End of SDL version queries

}  // namespace cen

#if CENTURION_SDL_VERSION_IS(2, 0, 10)

// Workaround for this enum being completely anonymous in SDL 2.0.10. We include
// this here because multiple files (key_code.hpp and scan_code.hpp) depend on
// this definition.
using SDL_KeyCode = decltype(SDLK_UNKNOWN);

#endif  // CENTURION_SDL_VERSION_IS(2, 0, 10)

/// \} End of group core

#endif  // CENTURION_VERSION_HEADER

// #include "centurion/detail/address_of.hpp"
#ifndef CENTURION_DETAIL_ADDRESS_OF_HEADER
#define CENTURION_DETAIL_ADDRESS_OF_HEADER

#include <sstream>  // stringstream
#include <string>   // string

// #include "../compiler/compiler.hpp"
#ifndef CENTURION_COMPILER_HEADER
#define CENTURION_COMPILER_HEADER

#include <SDL.h>

namespace cen {

/// \addtogroup compiler
/// \{

/**
 * \brief Indicates whether or not a "debug" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a debug build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_debug_build() noexcept -> bool
{
#ifndef NDEBUG
  return true;
#else
  return false;
#endif  // NDEBUG
}

/**
 * \brief Indicates whether or not a "release" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a release build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_release_build() noexcept -> bool
{
  return !is_debug_build();
}

/**
 * \brief Indicates whether or not the compiler is MSVC.
 *
 * \return `true` if MSVC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_msvc() noexcept -> bool
{
#ifdef _MSC_VER
  return true;
#else
  return false;
#endif  // _MSC_VER
}

/**
 * \brief Indicates whether or not the compiler is GCC.
 *
 * \return `true` if GCC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_gcc() noexcept -> bool
{
#ifdef __GNUC__
  return true;
#else
  return false;
#endif  // __GNUC__
}

/**
 * \brief Indicates whether or not the compiler is Clang.
 *
 * \return `true` if Clang is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_clang() noexcept -> bool
{
#ifdef __clang__
  return true;
#else
  return false;
#endif  // __clang__
}

/**
 * \brief Indicates whether or not the compiler is Emscripten.
 *
 * \return `true` if Emscripten is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_emscripten() noexcept -> bool
{
#ifdef __EMSCRIPTEN__
  return true;
#else
  return false;
#endif  // __EMSCRIPTEN__
}

/**
 * \brief Indicates whether or not the compiler is Intel C++.
 *
 * \return `true` if Intel C++ is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_intel_cpp() noexcept -> bool
{
#ifdef __INTEL_COMPILER
  return true;
#else
  return false;
#endif  // __INTEL_COMPILER
}

/// \} End of compiler group

}  // namespace cen

#endif  // CENTURION_COMPILER_HEADER


/// \cond FALSE
namespace cen::detail {

/**
 * \brief Returns a string that represents the memory address of the supplied pointer.
 *
 * \details The empty string is returned if the supplied pointer is null.
 *
 * \tparam T the type of the pointer.
 * \param ptr the pointer that will be converted.
 *
 * \return a string that represents the memory address of the supplied pointer.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto address_of(const void* ptr) -> std::string
{
  if (ptr) {
    std::stringstream stream;

    if constexpr (on_msvc()) {
      stream << "0x";  // Only MSVC seems to omit this, add it for consistency
    }

    stream << ptr;
    return stream.str();
  }
  else {
    return std::string{};
  }
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_ADDRESS_OF_HEADER

// #include "centurion/detail/any_eq.hpp"
#ifndef CENTURION_DETAIL_ANY_EQ_HEADER
#define CENTURION_DETAIL_ANY_EQ_HEADER

/// \cond FALSE
namespace cen::detail {

// clang-format off

/**
 * \brief Indicates whether or not any of the supplied values are equal to a specific value.
 *
 * \tparam T the type of the value to look for.
 *
 * \tparam Args the type of the arguments that will be checked.
 *
 * \param value the value to look for.
 * \param args the arguments that will be compared with the value.
 *
 * \return `true` if any of the supplied values are equal to `value`; `false` otherwise.
 *
 * \since 5.1.0
 */
template <typename T, typename... Args>
[[nodiscard]] constexpr auto any_eq(const T& value, Args&&... args)
    noexcept(noexcept( ((value == args) || ...) )) -> bool
{
  return ((value == args) || ...);
}

// clang-format on

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_ANY_EQ_HEADER

// #include "centurion/detail/array_utils.hpp"
#ifndef CENTURION_DETAIL_ARRAY_UTILS_HEADER
#define CENTURION_DETAIL_ARRAY_UTILS_HEADER

#include <array>  // array, to_array

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER

// #include "../core/integers.hpp"
#ifndef CENTURION_INTEGERS_HEADER
#define CENTURION_INTEGERS_HEADER

#include <SDL.h>

#include <cstddef>  // size_t

namespace cen {

/// \addtogroup core
/// \{

/// \name Integer aliases
/// \{

using usize = std::size_t;

/// Alias for an unsigned integer.
using uint = unsigned int;

/// Alias for the type used for integer literal operators.
using ulonglong = unsigned long long;

/// Alias for a 64-bit unsigned integer.
using u64 = Uint64;

/// Alias for a 32-bit unsigned integer.
using u32 = Uint32;

/// Alias for a 16-bit unsigned integer.
using u16 = Uint16;

/// Alias for an 8-bit unsigned integer.
using u8 = Uint8;

/// Alias for a 64-bit signed integer.
using i64 = Sint64;

/// Alias for a 32-bit signed integer.
using i32 = Sint32;

/// Alias for a 16-bit signed integer.
using i16 = Sint16;

/// Alias for an 8-bit signed integer.
using i8 = Sint8;

/// \} End of integer aliases

// clang-format off

/**
 * \brief Obtains the size of a container as an `int`.
 *
 * \tparam T a "container" that provides a `size()` member function.
 *
 * \param container the container to query the size of.
 *
 * \return the size of the container as an `int` value.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto isize(const T& container) noexcept(noexcept(container.size()))
    -> int
{
  return static_cast<int>(container.size());
}

// clang-format on

namespace literals {

/**
 * \brief Creates an 8-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u8(const ulonglong value) noexcept -> u8
{
  return static_cast<u8>(value);
}

/**
 * \brief Creates a 16-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u16(const ulonglong value) noexcept -> u16
{
  return static_cast<u16>(value);
}

/**
 * \brief Creates a 32-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u32(const ulonglong value) noexcept -> u32
{
  return static_cast<u32>(value);
}

/**
 * \brief Creates a 64-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u64(const ulonglong value) noexcept -> u64
{
  return static_cast<u64>(value);
}

/**
 * \brief Creates an 8-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i8(const ulonglong value) noexcept -> i8
{
  return static_cast<i8>(value);
}

/**
 * \brief Creates a 16-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i16(const ulonglong value) noexcept -> i16
{
  return static_cast<i16>(value);
}

/**
 * \brief Creates a 32-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i32(const ulonglong value) noexcept -> i32
{
  return static_cast<i32>(value);
}

/**
 * \brief Creates a 64-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i64(const ulonglong value) noexcept -> i64
{
  return static_cast<i64>(value);
}

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_INTEGERS_HEADER


/// \cond FALSE
namespace cen::detail {

template <typename T, usize Size>
constexpr void assign(const std::array<T, Size>& array, T (&out)[Size])
{
  usize index = 0;
  for (auto&& value : array) {
    out[index] = value;
    ++index;
  }
}

template <typename T, usize Size>
[[nodiscard]] constexpr auto to_array(const T (&data)[Size]) -> std::array<T, Size>
{
#if CENTURION_HAS_FEATURE_TO_ARRAY
  return std::to_array(data);
#else
  std::array<T, Size> array;  // NOLINT

  for (usize i = 0; i < Size; ++i) {
    array[i] = data[i];
  }

  return array;
#endif  // CENTURION_HAS_FEATURE_TO_ARRAY
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_ARRAY_UTILS_HEADER

// #include "centurion/detail/clamp.hpp"
#ifndef CENTURION_DETAIL_CLAMP_HEADER
#define CENTURION_DETAIL_CLAMP_HEADER

#include <cassert>  // assert

/// \cond FALSE
namespace cen::detail {

// clang-format off

/**
 * \brief Clamps a value to be within the range [min, max].
 *
 * \pre `min` must be less than or equal to `max`.
 *
 * \note The standard library provides `std::clamp`, but it isn't mandated to be
 * `noexcept` (although MSVC does mark it as `noexcept`), which is the reason this
 * function exists.
 *
 * \tparam T the type of the values.
 *
 * \param value the value that will be clamped.
 * \param min the minimum value (inclusive).
 * \param max the maximum value (inclusive).
 *
 * \return the clamped value.
 *
 * \since 5.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto clamp(const T& value,
                                   const T& min,
                                   const T& max)
    noexcept(noexcept(value < min) && noexcept(value > max)) -> T
{
  assert(min <= max);
  if (value < min)
  {
    return min;
  }
  else if (value > max)
  {
    return max;
  }
  else
  {
    return value;
  }
}

// clang-format on

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_CLAMP_HEADER

// #include "centurion/detail/convert_bool.hpp"
#ifndef CENTURION_DETAIL_CONVERT_BOOL_HEADER
#define CENTURION_DETAIL_CONVERT_BOOL_HEADER

#include <SDL.h>

/// \cond FALSE
namespace cen::detail {

/**
 * \brief Returns the corresponding `SDL_bool` value for the supplied boolean value.
 *
 * \param b the boolean value that will be converted.
 *
 * \return `SDL_TRUE` for `true`; `SDL_FALSE` for `false`.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto convert_bool(const bool b) noexcept -> SDL_bool
{
  return b ? SDL_TRUE : SDL_FALSE;
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_CONVERT_BOOL_HEADER

// #include "centurion/detail/czstring_compare.hpp"
#ifndef CENTURION_DETAIL_CZSTRING_COMPARE_HEADER
#define CENTURION_DETAIL_CZSTRING_COMPARE_HEADER

// #include "../core/str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER

// #include "czstring_eq.hpp"
#ifndef CENTURION_DETAIL_CZSTRING_EQ_HEADER
#define CENTURION_DETAIL_CZSTRING_EQ_HEADER

#include <cstring>  // strcmp

// #include "../core/str.hpp"


/// \cond FALSE
namespace cen::detail {

/**
 * \brief Indicates whether or not two C-style strings are equal.
 *
 * \param lhs the left-hand side string, can safely be null.
 * \param rhs the right-hand side string, can safely be null.
 *
 * \return `true` if the strings are equal; `false` otherwise.
 *
 * \since 4.1.0
 */
[[nodiscard]] inline auto czstring_eq(const str lhs, const str rhs) noexcept -> bool
{
  if (lhs && rhs) {
    return std::strcmp(lhs, rhs) == 0;
  }
  else {
    return false;
  }
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_CZSTRING_EQ_HEADER


/// \cond FALSE
namespace cen::detail {

struct czstring_compare final
{
  auto operator()(const str lhs, const str rhs) const noexcept -> bool
  {
    return detail::czstring_eq(lhs, rhs);
  }
};

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_CZSTRING_COMPARE_HEADER

// #include "centurion/detail/czstring_eq.hpp"
#ifndef CENTURION_DETAIL_CZSTRING_EQ_HEADER
#define CENTURION_DETAIL_CZSTRING_EQ_HEADER

#include <cstring>  // strcmp

// #include "../core/str.hpp"


/// \cond FALSE
namespace cen::detail {

/**
 * \brief Indicates whether or not two C-style strings are equal.
 *
 * \param lhs the left-hand side string, can safely be null.
 * \param rhs the right-hand side string, can safely be null.
 *
 * \return `true` if the strings are equal; `false` otherwise.
 *
 * \since 4.1.0
 */
[[nodiscard]] inline auto czstring_eq(const str lhs, const str rhs) noexcept -> bool
{
  if (lhs && rhs) {
    return std::strcmp(lhs, rhs) == 0;
  }
  else {
    return false;
  }
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_CZSTRING_EQ_HEADER

// #include "centurion/detail/from_string.hpp"
#ifndef CENTURION_DETAIL_FROM_STRING_HEADER
#define CENTURION_DETAIL_FROM_STRING_HEADER

#include <charconv>      // from_chars
#include <optional>      // optional
#include <string>        // string, stof
#include <string_view>   // string_view
#include <system_error>  // errc
#include <type_traits>   // is_floating_point_v

// #include "../compiler/compiler.hpp"


/// \cond FALSE
namespace cen::detail {

template <typename T>
[[nodiscard]] auto from_string(const std::string_view str,
                               const int base = 10) noexcept(on_msvc()) -> std::optional<T>
{
  T value{};

  const auto begin = str.data();
  const auto end = str.data() + str.size();

  const char* mismatch = end;
  std::errc error{};

  if constexpr (std::is_floating_point_v<T>) {
    if constexpr (on_gcc() || on_clang()) {
      try {
        value = std::stof(std::string{str});
      }
      catch (...) {
        return std::nullopt;
      }
    }
    else {
      const auto [ptr, err] = std::from_chars(begin, end, value);
      mismatch = ptr;
      error = err;
    }
  }
  else {
    const auto [ptr, err] = std::from_chars(begin, end, value, base);
    mismatch = ptr;
    error = err;
  }

  if (mismatch == end && error == std::errc{}) {
    return value;
  }
  else {
    return std::nullopt;
  }
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_FROM_STRING_HEADER

// #include "centurion/detail/hints_impl.hpp"
#ifndef CENTURION_DETAIL_HINTS_IMPL_HEADER
#define CENTURION_DETAIL_HINTS_IMPL_HEADER

#include <optional>     // optional
#include <string>       // string, stoi, stoul, stof
#include <type_traits>  // enable_if_t, is_same_v, is_convertible_v

// #include "../core/integers.hpp"

// #include "../core/str.hpp"

// #include "czstring_compare.hpp"
#ifndef CENTURION_DETAIL_CZSTRING_COMPARE_HEADER
#define CENTURION_DETAIL_CZSTRING_COMPARE_HEADER

// #include "../core/str.hpp"

// #include "czstring_eq.hpp"


/// \cond FALSE
namespace cen::detail {

struct czstring_compare final
{
  auto operator()(const str lhs, const str rhs) const noexcept -> bool
  {
    return detail::czstring_eq(lhs, rhs);
  }
};

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_CZSTRING_COMPARE_HEADER

// #include "czstring_eq.hpp"

// #include "from_string.hpp"
#ifndef CENTURION_DETAIL_FROM_STRING_HEADER
#define CENTURION_DETAIL_FROM_STRING_HEADER

#include <charconv>      // from_chars
#include <optional>      // optional
#include <string>        // string, stof
#include <string_view>   // string_view
#include <system_error>  // errc
#include <type_traits>   // is_floating_point_v

// #include "../compiler/compiler.hpp"


/// \cond FALSE
namespace cen::detail {

template <typename T>
[[nodiscard]] auto from_string(const std::string_view str,
                               const int base = 10) noexcept(on_msvc()) -> std::optional<T>
{
  T value{};

  const auto begin = str.data();
  const auto end = str.data() + str.size();

  const char* mismatch = end;
  std::errc error{};

  if constexpr (std::is_floating_point_v<T>) {
    if constexpr (on_gcc() || on_clang()) {
      try {
        value = std::stof(std::string{str});
      }
      catch (...) {
        return std::nullopt;
      }
    }
    else {
      const auto [ptr, err] = std::from_chars(begin, end, value);
      mismatch = ptr;
      error = err;
    }
  }
  else {
    const auto [ptr, err] = std::from_chars(begin, end, value, base);
    mismatch = ptr;
    error = err;
  }

  if (mismatch == end && error == std::errc{}) {
    return value;
  }
  else {
    return std::nullopt;
  }
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_FROM_STRING_HEADER

// #include "static_bimap.hpp"
#ifndef CENTURION_DETAIL_STATIC_BIMAP_HEADER
#define CENTURION_DETAIL_STATIC_BIMAP_HEADER

#include <algorithm>  // find_if
#include <array>      // array
#include <utility>    // pair

// #include "../core/exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER


/// \cond FALSE
namespace cen::detail {

/**
 * \class static_bimap
 *
 * \brief A bidirectional associative container for when keys and values are known at
 * compile-time.
 *
 * \note This class is only meant to be used in constexpr contexts.
 *
 * \remarks This class was inspired by Jason Turners C++ Weekly video on constexpr maps!
 *
 * \tparam Key the type of the keys, must provide an overloaded `operator==`.
 * \tparam Value the type of the values.
 * \tparam ValueCmp the predicate used to lookup values from keys.
 * \tparam size the amount of key-value pairs.
 *
 * \since 5.0.0
 */
template <typename Key, typename Value, typename ValueCmp, std::size_t Size>
class static_bimap final
{
  using pair_type = std::pair<Key, Value>;
  using storage_type = std::array<pair_type, Size>;

 public:
  storage_type data;

  constexpr auto find(const Key& key) const -> const Value&
  {
    const auto it = std::find_if(data.begin(), data.end(), [&](const pair_type& pair) {
      return pair.first == key;
    });

    if (it != data.end()) {
      return it->second;
    }
    else {
      throw cen_error{"Failed to find element in static map!"};
    }
  }

  constexpr auto key_from(const Value& value) const -> const Key&
  {
    const auto it = std::find_if(data.begin(), data.end(), [&](const pair_type& pair) {
      ValueCmp predicate;
      return predicate(pair.second, value);
    });

    if (it != data.end()) {
      return it->first;
    }
    else {
      throw cen_error{"Failed to find key in static map!"};
    }
  }
};

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_STATIC_BIMAP_HEADER


/// \cond FALSE

namespace cen::detail {

template <typename Hint, typename T>
using enable_if_hint_arg_t = std::enable_if_t<Hint::template valid_arg<T>(), int>;

template <typename Key, usize Size>
using string_map = static_bimap<Key, str, czstring_compare, Size>;

template <typename Derived, typename Arg>
struct crtp_hint
{
  using value_type = Arg;

  template <typename T>
  [[nodiscard]] constexpr static auto valid_arg() noexcept -> bool
  {
    return std::is_same_v<T, value_type>;
  }
};

// A hint class that only accepts booleans
template <typename Hint>
struct bool_hint : crtp_hint<bool_hint<Hint>, bool>
{
  [[nodiscard]] static auto current_value() noexcept -> std::optional<bool>
  {
    return SDL_GetHintBoolean(Hint::name(), SDL_FALSE) == SDL_TRUE;
  }

  [[nodiscard]] static auto from_string(const str str) noexcept -> bool
  {
    return czstring_eq(str, "1") ? true : false;
  }

  [[nodiscard]] static auto to_string(const bool value) -> std::string
  {
    return value ? "1" : "0";
  }
};

// A hint class that only accepts strings
template <typename Hint>
struct string_hint : crtp_hint<string_hint<Hint>, str>
{
  [[nodiscard]] static auto current_value() noexcept -> std::optional<str>
  {
    if (const str value = SDL_GetHint(Hint::name())) {
      return value;
    }
    else {
      return std::nullopt;
    }
  }

  [[nodiscard]] static auto from_string(const str value) noexcept -> str
  {
    return value;
  }

  [[nodiscard]] static auto to_string(const str value) -> std::string
  {
    return value;
  }
};

// A hint class that only accepts integers
template <typename Hint>
struct int_hint : crtp_hint<int_hint<Hint>, int>
{
  [[nodiscard]] static auto current_value() -> std::optional<int>
  {
    if (const str value = SDL_GetHint(Hint::name())) {
      return std::stoi(value);
    }
    else {
      return std::nullopt;
    }
  }

  [[nodiscard]] static auto from_string(const str value) -> int
  {
    return detail::from_string<int>(value).value();
  }

  [[nodiscard]] static auto to_string(const int value) -> std::string
  {
    return std::to_string(value);
  }
};

// A hint class that only accepts unsigned integers
template <typename Hint>
struct uint_hint : crtp_hint<uint_hint<Hint>, uint>
{
  [[nodiscard]] static auto current_value() -> std::optional<uint>
  {
    if (const str value = SDL_GetHint(Hint::name())) {
      return static_cast<uint>(std::stoul(value));
    }
    else {
      return std::nullopt;
    }
  }

  [[nodiscard]] static auto from_string(const str value) -> uint
  {
    return detail::from_string<uint>(value).value();
  }

  [[nodiscard]] static auto to_string(const uint value) -> std::string
  {
    return std::to_string(value);
  }
};

// A hint class that only accepts floats
template <typename Hint>
struct float_hint : crtp_hint<float_hint<Hint>, float>
{
  [[nodiscard]] static auto current_value() -> std::optional<float>
  {
    if (const str value = SDL_GetHint(Hint::name())) {
      return std::stof(value);
    }
    else {
      return std::nullopt;
    }
  }

  [[nodiscard]] static auto from_string(const str value) -> float
  {
    return detail::from_string<float>(value).value();
  }

  [[nodiscard]] static auto to_string(const float value) -> std::string
  {
    return std::to_string(value);
  }
};

}  // namespace cen::detail

/// \endcond

#endif  // CENTURION_DETAIL_HINTS_IMPL_HEADER

// #include "centurion/detail/lerp.hpp"
#ifndef CENTURION_DETAIL_LERP_HEADER
#define CENTURION_DETAIL_LERP_HEADER

#include <cmath>  // lerp

// #include "../compiler/features.hpp"


/// \cond FALSE

namespace cen::detail {

[[nodiscard]] constexpr auto lerp(const float a, const float b, const float bias) noexcept
    -> float
{
#if CENTURION_HAS_FEATURE_LERP
  return std::lerp(a, b, bias);
#else
  return (a * (1.0f - bias)) + (b * bias);
#endif  // CENTURION_HAS_FEATURE_LERP
}

}  // namespace cen::detail

/// \endcond

#endif  // CENTURION_DETAIL_LERP_HEADER

// #include "centurion/detail/max.hpp"
#ifndef CENTURION_DETAIL_MAX_HEADER
#define CENTURION_DETAIL_MAX_HEADER

/// \cond FALSE
namespace cen::detail {

template <typename T>
[[nodiscard]] constexpr auto max(const T& a, const T& b) noexcept(noexcept(a < b)) -> T
{
  return (a < b) ? b : a;
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_MAX_HEADER

// #include "centurion/detail/min.hpp"
#ifndef CENTURION_DETAIL_MIN_HEADER
#define CENTURION_DETAIL_MIN_HEADER

/// \cond FALSE
namespace cen::detail {

template <typename T>
[[nodiscard]] constexpr auto min(const T& a, const T& b) noexcept(noexcept(a < b)) -> T
{
  return (a < b) ? a : b;
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_MIN_HEADER

// #include "centurion/detail/owner_handle_api.hpp"
#ifndef CENTURION_DETAIL_OWNER_HANDLE_API_HEADER
#define CENTURION_DETAIL_OWNER_HANDLE_API_HEADER

#include <cassert>      // assert
#include <memory>       // unique_ptr
#include <type_traits>  // enable_if_t, is_same_v, true_type, false_type

// #include "../core/exception.hpp"


/// \cond FALSE
namespace cen::detail {

using owning_type = std::true_type;
using handle_type = std::false_type;

template <typename T>
using is_owner = std::enable_if_t<std::is_same_v<T, owning_type>, int>;

template <typename T>
using is_handle = std::enable_if_t<std::is_same_v<T, handle_type>, int>;

template <typename T>
[[nodiscard]] constexpr auto is_owning() noexcept -> bool
{
  return std::is_same_v<T, owning_type>;
}

template <typename B, typename Type, typename Deleter>
class pointer_manager final
{
  using managed_ptr = std::unique_ptr<Type, Deleter>;
  using raw_ptr = Type*;
  using pointer_type = std::conditional_t<B::value, managed_ptr, raw_ptr>;

 public:
  pointer_manager() noexcept = default;

  explicit pointer_manager(Type* ptr) noexcept : m_ptr{ptr}
  {}

  template <typename BB = B, is_owner<BB> = 0>
  void reset(Type* ptr) noexcept
  {
    m_ptr.reset(ptr);
  }

  auto operator->() noexcept -> Type*
  {
    return get();
  }

  auto operator->() const noexcept -> const Type*
  {
    return get();
  }

  auto operator*() noexcept -> Type&
  {
    assert(m_ptr);
    return *m_ptr;
  }

  auto operator*() const noexcept -> const Type&
  {
    assert(m_ptr);
    return *m_ptr;
  }

  explicit operator bool() const noexcept
  {
    return m_ptr != nullptr;
  }

  /*implicit*/ operator Type*() const noexcept
  {
    return get();
  }

  template <typename BB = B, is_owner<BB> = 0>
  [[nodiscard]] auto release() noexcept -> Type*
  {
    return m_ptr.release();
  }

  [[nodiscard]] auto get() const noexcept -> Type*
  {
    if constexpr (B::value) {
      return m_ptr.get();
    }
    else {
      return m_ptr;
    }
  }

 private:
  pointer_type m_ptr{};
};

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_OWNER_HANDLE_API_HEADER

// #include "centurion/detail/sdl_deleter.hpp"
#ifndef CENTURION_DETAIL_SDL_DELETER_HEADER
#define CENTURION_DETAIL_SDL_DELETER_HEADER

#include <SDL.h>

/// \cond FALSE
namespace cen::detail {

template <typename T>
struct sdl_deleter final
{
  void operator()(T* ptr) noexcept
  {
    SDL_free(ptr);
  }
};

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_SDL_DELETER_HEADER

// #include "centurion/detail/sdl_version_at_least.hpp"
#ifndef CENTURION_DETAIL_SDL_VERSION_AT_LEAST
#define CENTURION_DETAIL_SDL_VERSION_AT_LEAST

#include <SDL.h>

// #include "../core/version.hpp"
#ifndef CENTURION_VERSION_HEADER
#define CENTURION_VERSION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <cassert>  // assert

/// \addtogroup core
/// \{

/**
 * \def CENTURION_VERSION_MAJOR
 *
 * \brief Expands into the current major version of the library.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_MAJOR 6

/**
 * \def CENTURION_VERSION_MINOR
 *
 * \brief Expands into the current minor version of the library.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_MINOR 3

/**
 * \def CENTURION_VERSION_PATCH
 *
 * \brief Expands into the current patch version of the library.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_PATCH 0

/**
 * \def CENTURION_SDL_VERSION_IS
 *
 * \brief This macro is meant to be used when conditionally including code for a specific
 * version of SDL. It is useful for applying workarounds.
 *
 * \since 5.3.0
 */
#define CENTURION_SDL_VERSION_IS(x, y, z) \
  ((SDL_MAJOR_VERSION == (x)) && (SDL_MINOR_VERSION == (y)) && (SDL_PATCHLEVEL == (z)))

#ifdef CENTURION___DOXYGEN

#define CENTURION_MAKE_VERSION_NUMBER
#define CENTURION_VERSION_NUMBER
#define CENTURION_VERSION_AT_LEAST

#endif  // CENTURION___DOXYGEN

/**
 * \def CENTURION_MAKE_VERSION_NUMBER
 *
 * \brief Helper macro for creating version numbers from a set of major/minor/patch
 * numbers.
 *
 * \details For example, if the version is 8.4.2, the resulting version number would be
 * 8402.
 *
 * \since 6.0.0
 */
#define CENTURION_MAKE_VERSION_NUMBER(x, y, z) (((x)*1'000) + ((y)*100) + (z))

/**
 * \def CENTURION_VERSION_NUMBER
 *
 * \brief Expands into a version number based on the current Centurion version.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_NUMBER                         \
  CENTURION_MAKE_VERSION_NUMBER(CENTURION_VERSION_MAJOR, \
                                CENTURION_VERSION_MINOR, \
                                CENTURION_VERSION_PATCH)

/**
 * \def CENTURION_VERSION_AT_LEAST
 *
 * \brief This macro is intended to be used for conditional compilation, based on the
 * Centurion version.
 *
 * \details This macro is used in the same way as the `SDL_VERSION_ATLEAST`, where you use
 * it as the condition with `#if` statements.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_AT_LEAST(x, y, z) \
  CENTURION_VERSION_NUMBER >= CENTURION_MAKE_VERSION_NUMBER(x, y, z)

namespace cen {

/// \name Centurion version queries
/// \{

/**
 * \struct version
 *
 * \brief Represents a set of major/minor/patch version numbers.
 *
 * \details The members of this struct are by default initialized to the current Centurion
 * version values.
 *
 * \since 6.0.0
 */
struct version final
{
  int major{CENTURION_VERSION_MAJOR};
  int minor{CENTURION_VERSION_MINOR};
  int patch{CENTURION_VERSION_PATCH};
};

/**
 * \brief Indicates whether or not the current Centurion version is at least equal to the
 * specified version.
 *
 * \param major the major version value.
 * \param minor the minor version value.
 * \param patch the patch version value.
 *
 * \return `true` if the version of Centurion is at least the specified version; `false`
 * otherwise.
 *
 * \see `CENTURION_VERSION_AT_LEAST`
 *
 * \since 6.0.0
 */
[[nodiscard]] constexpr auto version_at_least(const int major,
                                              const int minor,
                                              const int patch) noexcept -> bool
{
  return CENTURION_VERSION_AT_LEAST(major, minor, patch);
}

/// \} End of centurion version queries

/// \name SDL version queries
/// \{

/**
 * \brief Returns the version of SDL2 that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL that the
 * program was compiled against.
 *
 * \return the linked version of SDL2.
 *
 * \since 5.2.0
 */
[[nodiscard]] inline auto sdl_linked_version() noexcept -> SDL_version
{
  SDL_version version{};
  SDL_GetVersion(&version);
  return version;
}

/**
 * \brief Returns the compile-time version of SDL2 that is being used.
 *
 * \return the compile-time version of SDL2 that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_version() noexcept -> SDL_version
{
  return {SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL};
}

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \brief Returns the version of SDL2_image that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL2_image that
 * the program was compiled against.
 *
 * \return the linked version of SDL2_image.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto sdl_image_linked_version() noexcept -> SDL_version
{
  const auto* version = IMG_Linked_Version();
  assert(version);  // Sanity check
  return *version;
}

/**
 * \brief Returns the compile-time version of SDL2_image that is being used.
 *
 * \return the compile-time version of SDL2_image that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_image_version() noexcept -> SDL_version
{
  return {SDL_IMAGE_MAJOR_VERSION, SDL_IMAGE_MINOR_VERSION, SDL_IMAGE_PATCHLEVEL};
}

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \brief Returns the version of SDL2_mixer that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL2_mixer that
 * the program was compiled against.
 *
 * \return the linked version of SDL2_mixer.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto sdl_mixer_linked_version() noexcept -> SDL_version
{
  const auto* version = Mix_Linked_Version();
  assert(version);  // Sanity check
  return *version;
}

/**
 * \brief Returns the compile-time version of SDL2_mixer that is being used.
 *
 * \return the compile-time version of SDL2_mixer that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_mixer_version() noexcept -> SDL_version
{
  return {SDL_MIXER_MAJOR_VERSION, SDL_MIXER_MINOR_VERSION, SDL_MIXER_PATCHLEVEL};
}

#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF

/**
 * \brief Returns the version of SDL2_ttf that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL2_ttf that the
 * program was compiled against.
 *
 * \return the linked version of SDL2_ttf.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto sdl_ttf_linked_version() noexcept -> SDL_version
{
  const auto* version = TTF_Linked_Version();
  assert(version);  // Sanity check
  return *version;
}

/**
 * \brief Returns the compile-time version of SDL2_ttf that is being used.
 *
 * \return the compile-time version of SDL2_ttf that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_ttf_version() noexcept -> SDL_version
{
  return {SDL_TTF_MAJOR_VERSION, SDL_TTF_MINOR_VERSION, SDL_TTF_PATCHLEVEL};
}

#endif  // CENTURION_NO_SDL_TTF

/// \} End of SDL version queries

}  // namespace cen

#if CENTURION_SDL_VERSION_IS(2, 0, 10)

// Workaround for this enum being completely anonymous in SDL 2.0.10. We include
// this here because multiple files (key_code.hpp and scan_code.hpp) depend on
// this definition.
using SDL_KeyCode = decltype(SDLK_UNKNOWN);

#endif  // CENTURION_SDL_VERSION_IS(2, 0, 10)

/// \} End of group core

#endif  // CENTURION_VERSION_HEADER


/// \cond FALSE
namespace cen::detail {

[[nodiscard]] constexpr auto sdl_version_at_least(const int major,
                                                  const int minor,
                                                  const int patch) noexcept -> bool
{
  return SDL_COMPILEDVERSION >= SDL_VERSIONNUM(major, minor, patch);
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_SDL_VERSION_AT_LEAST

// #include "centurion/detail/stack_resource.hpp"
#ifndef CENTURION_DETAIL_STACK_RESOURCE_HEADER
#define CENTURION_DETAIL_STACK_RESOURCE_HEADER

// #include "../compiler/features.hpp"

// #include "../core/integers.hpp"


#if CENTURION_HAS_FEATURE_MEMORY_RESOURCE

#include <array>            // array
#include <cstddef>          // byte
#include <memory_resource>  // memory_resource, monotonic_buffer_resource

/// \cond FALSE
namespace cen::detail {

template <usize BufferSize>
class stack_resource final
{
 public:
  [[nodiscard]] auto get() noexcept -> std::pmr::memory_resource*
  {
    return &m_pool;
  }

 private:
  std::array<std::byte, BufferSize> m_buffer{};
  std::pmr::monotonic_buffer_resource m_pool{m_buffer.data(), sizeof m_buffer};
};

}  // namespace cen::detail
   /// \endcond

#endif  // CENTURION_HAS_FEATURE_MEMORY_RESOURCE
#endif  // CENTURION_DETAIL_STACK_RESOURCE_HEADER

// #include "centurion/detail/static_bimap.hpp"
#ifndef CENTURION_DETAIL_STATIC_BIMAP_HEADER
#define CENTURION_DETAIL_STATIC_BIMAP_HEADER

#include <algorithm>  // find_if
#include <array>      // array
#include <utility>    // pair

// #include "../core/exception.hpp"


/// \cond FALSE
namespace cen::detail {

/**
 * \class static_bimap
 *
 * \brief A bidirectional associative container for when keys and values are known at
 * compile-time.
 *
 * \note This class is only meant to be used in constexpr contexts.
 *
 * \remarks This class was inspired by Jason Turners C++ Weekly video on constexpr maps!
 *
 * \tparam Key the type of the keys, must provide an overloaded `operator==`.
 * \tparam Value the type of the values.
 * \tparam ValueCmp the predicate used to lookup values from keys.
 * \tparam size the amount of key-value pairs.
 *
 * \since 5.0.0
 */
template <typename Key, typename Value, typename ValueCmp, std::size_t Size>
class static_bimap final
{
  using pair_type = std::pair<Key, Value>;
  using storage_type = std::array<pair_type, Size>;

 public:
  storage_type data;

  constexpr auto find(const Key& key) const -> const Value&
  {
    const auto it = std::find_if(data.begin(), data.end(), [&](const pair_type& pair) {
      return pair.first == key;
    });

    if (it != data.end()) {
      return it->second;
    }
    else {
      throw cen_error{"Failed to find element in static map!"};
    }
  }

  constexpr auto key_from(const Value& value) const -> const Key&
  {
    const auto it = std::find_if(data.begin(), data.end(), [&](const pair_type& pair) {
      ValueCmp predicate;
      return predicate(pair.second, value);
    });

    if (it != data.end()) {
      return it->first;
    }
    else {
      throw cen_error{"Failed to find key in static map!"};
    }
  }
};

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_STATIC_BIMAP_HEADER

// #include "centurion/detail/tuple_type_index.hpp"
#ifndef CENTURION_DETAIL_TUPLE_TYPE_INDEX_HEADER
#define CENTURION_DETAIL_TUPLE_TYPE_INDEX_HEADER

#include <tuple>        // tuple
#include <type_traits>  // is_same_v
#include <utility>      // index_sequence, index_sequence_for

// #include "../core/integers.hpp"


/// \cond FALSE
namespace cen::detail {

template <typename Target, typename Tuple>
class tuple_type_index;

template <typename Target, typename... T>
class tuple_type_index<Target, std::tuple<T...>>
{
  template <usize... Index>
  constexpr static auto find(std::index_sequence<Index...>) -> int
  {
    return -1 + ((std::is_same_v<Target, T> ? Index + 1 : 0) + ...);
  }

 public:
  inline constexpr static auto value = find(std::index_sequence_for<T...>{});
};

template <typename Target, typename... T>
inline constexpr int tuple_type_index_v = tuple_type_index<Target, T...>::value;

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_TUPLE_TYPE_INDEX_HEADER

// #include "centurion/events/audio_device_event.hpp"
#ifndef CENTURION_AUDIO_DEVICE_EVENT_HEADER
#define CENTURION_AUDIO_DEVICE_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"
#ifndef CENTURION_INTEGERS_HEADER
#define CENTURION_INTEGERS_HEADER

#include <SDL.h>

#include <cstddef>  // size_t

namespace cen {

/// \addtogroup core
/// \{

/// \name Integer aliases
/// \{

using usize = std::size_t;

/// Alias for an unsigned integer.
using uint = unsigned int;

/// Alias for the type used for integer literal operators.
using ulonglong = unsigned long long;

/// Alias for a 64-bit unsigned integer.
using u64 = Uint64;

/// Alias for a 32-bit unsigned integer.
using u32 = Uint32;

/// Alias for a 16-bit unsigned integer.
using u16 = Uint16;

/// Alias for an 8-bit unsigned integer.
using u8 = Uint8;

/// Alias for a 64-bit signed integer.
using i64 = Sint64;

/// Alias for a 32-bit signed integer.
using i32 = Sint32;

/// Alias for a 16-bit signed integer.
using i16 = Sint16;

/// Alias for an 8-bit signed integer.
using i8 = Sint8;

/// \} End of integer aliases

// clang-format off

/**
 * \brief Obtains the size of a container as an `int`.
 *
 * \tparam T a "container" that provides a `size()` member function.
 *
 * \param container the container to query the size of.
 *
 * \return the size of the container as an `int` value.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto isize(const T& container) noexcept(noexcept(container.size()))
    -> int
{
  return static_cast<int>(container.size());
}

// clang-format on

namespace literals {

/**
 * \brief Creates an 8-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u8(const ulonglong value) noexcept -> u8
{
  return static_cast<u8>(value);
}

/**
 * \brief Creates a 16-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u16(const ulonglong value) noexcept -> u16
{
  return static_cast<u16>(value);
}

/**
 * \brief Creates a 32-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u32(const ulonglong value) noexcept -> u32
{
  return static_cast<u32>(value);
}

/**
 * \brief Creates a 64-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u64(const ulonglong value) noexcept -> u64
{
  return static_cast<u64>(value);
}

/**
 * \brief Creates an 8-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i8(const ulonglong value) noexcept -> i8
{
  return static_cast<i8>(value);
}

/**
 * \brief Creates a 16-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i16(const ulonglong value) noexcept -> i16
{
  return static_cast<i16>(value);
}

/**
 * \brief Creates a 32-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i32(const ulonglong value) noexcept -> i32
{
  return static_cast<i32>(value);
}

/**
 * \brief Creates a 64-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i64(const ulonglong value) noexcept -> i64
{
  return static_cast<i64>(value);
}

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_INTEGERS_HEADER

// #include "common_event.hpp"
#ifndef CENTURION_COMMON_EVENT_HEADER
#define CENTURION_COMMON_EVENT_HEADER

#include <SDL.h>

#include <utility>  // move

// #include "../core/integers.hpp"

// #include "../core/to_underlying.hpp"
#ifndef CENTURION_TO_UNDERLYING_HEADER
#define CENTURION_TO_UNDERLYING_HEADER

#include <type_traits>  // underlying_type_t, enable_if_t, is_enum_v

namespace cen {

/**
 * \brief Converts an enum value to an integral value using the underlying type.
 *
 * \ingroup core
 *
 * \note If you're using C++23, see `std::to_underlying()`.
 *
 * \tparam Enum the enum type.
 *
 * \param value the enum value that will be converted.
 *
 * \return the value of the enum, in the underlying type.
 *
 * \since 6.0.0
 */
template <typename Enum, std::enable_if_t<std::is_enum_v<Enum>, int> = 0>
[[nodiscard]] constexpr auto to_underlying(const Enum value) noexcept
    -> std::underlying_type_t<Enum>
{
  return static_cast<std::underlying_type_t<Enum>>(value);
}

}  // namespace cen

#endif  // CENTURION_TO_UNDERLYING_HEADER

// #include "event_type.hpp"
#ifndef CENTURION_EVENT_TYPE_HEADER
#define CENTURION_EVENT_TYPE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \enum event_type
 *
 * \brief Represents the different event types.
 *
 * \see `SDL_EventType`
 *
 * \since 3.1.0
 */
enum class event_type : u32
{
  quit = SDL_QUIT,

  app_terminating = SDL_APP_TERMINATING,
  app_low_memory = SDL_APP_LOWMEMORY,
  app_will_enter_background = SDL_APP_WILLENTERBACKGROUND,
  app_did_enter_background = SDL_APP_DIDENTERBACKGROUND,
  app_will_enter_foreground = SDL_APP_WILLENTERFOREGROUND,
  app_did_enter_foreground = SDL_APP_DIDENTERFOREGROUND,

#if SDL_VERSION_ATLEAST(2, 0, 14)
  locale_changed = SDL_LOCALECHANGED,
#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  display = SDL_DISPLAYEVENT,

  window = SDL_WINDOWEVENT,
  system = SDL_SYSWMEVENT,

  key_down = SDL_KEYDOWN,
  key_up = SDL_KEYUP,
  text_editing = SDL_TEXTEDITING,
  text_input = SDL_TEXTINPUT,
  keymap_changed = SDL_KEYMAPCHANGED,

  mouse_motion = SDL_MOUSEMOTION,
  mouse_button_down = SDL_MOUSEBUTTONDOWN,
  mouse_button_up = SDL_MOUSEBUTTONUP,
  mouse_wheel = SDL_MOUSEWHEEL,

  joystick_axis_motion = SDL_JOYAXISMOTION,
  joystick_ball_motion = SDL_JOYBALLMOTION,
  joystick_hat_motion = SDL_JOYHATMOTION,
  joystick_button_down = SDL_JOYBUTTONDOWN,
  joystick_button_up = SDL_JOYBUTTONUP,
  joystick_device_added = SDL_JOYDEVICEADDED,
  joystick_device_removed = SDL_JOYDEVICEREMOVED,

  controller_axis_motion = SDL_CONTROLLERAXISMOTION,
  controller_button_down = SDL_CONTROLLERBUTTONDOWN,
  controller_button_up = SDL_CONTROLLERBUTTONUP,
  controller_device_added = SDL_CONTROLLERDEVICEADDED,
  controller_device_removed = SDL_CONTROLLERDEVICEREMOVED,
  controller_device_remapped = SDL_CONTROLLERDEVICEREMAPPED,

#if SDL_VERSION_ATLEAST(2, 0, 14)
  controller_touchpad_down = SDL_CONTROLLERTOUCHPADDOWN,
  controller_touchpad_up = SDL_CONTROLLERTOUCHPADUP,
  controller_touchpad_motion = SDL_CONTROLLERTOUCHPADMOTION,
  controller_sensor_update = SDL_CONTROLLERSENSORUPDATE,
#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  touch_down = SDL_FINGERDOWN,
  touch_up = SDL_FINGERUP,
  touch_motion = SDL_FINGERMOTION,

  dollar_gesture = SDL_DOLLARGESTURE,
  dollar_record = SDL_DOLLARRECORD,
  multi_gesture = SDL_MULTIGESTURE,

  clipboard_update = SDL_CLIPBOARDUPDATE,

  drop_file = SDL_DROPFILE,
  drop_text = SDL_DROPTEXT,
  drop_begin = SDL_DROPBEGIN,
  drop_complete = SDL_DROPCOMPLETE,

  audio_device_added = SDL_AUDIODEVICEADDED,
  audio_device_removed = SDL_AUDIODEVICEREMOVED,

  sensor_update = SDL_SENSORUPDATE,

  render_targets_reset = SDL_RENDER_TARGETS_RESET,
  render_device_reset = SDL_RENDER_DEVICE_RESET,

  user = SDL_USEREVENT
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied event type.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(event_type::mouse_motion) == "mouse_motion"`.
 *
 * \param type the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const event_type type) -> std::string_view
{
  switch (type) {
    case event_type::quit:
      return "quit";

    case event_type::app_terminating:
      return "app_terminating";

    case event_type::app_low_memory:
      return "app_low_memory";

    case event_type::app_will_enter_background:
      return "app_will_enter_background";

    case event_type::app_did_enter_background:
      return "app_did_enter_background";

    case event_type::app_will_enter_foreground:
      return "app_will_enter_foreground";

    case event_type::app_did_enter_foreground:
      return "app_did_enter_foreground";

#if SDL_VERSION_ATLEAST(2, 0, 14)
    case event_type::locale_changed:
      return "locale_changed";
#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

    case event_type::display:
      return "display";

    case event_type::window:
      return "window";

    case event_type::system:
      return "system";

    case event_type::key_down:
      return "key_down";

    case event_type::key_up:
      return "key_up";

    case event_type::text_editing:
      return "text_editing";

    case event_type::text_input:
      return "text_input";

    case event_type::keymap_changed:
      return "keymap_changed";

    case event_type::mouse_motion:
      return "mouse_motion";

    case event_type::mouse_button_down:
      return "mouse_button_down";

    case event_type::mouse_button_up:
      return "mouse_button_up";

    case event_type::mouse_wheel:
      return "mouse_wheel";

    case event_type::joystick_axis_motion:
      return "joystick_axis_motion";

    case event_type::joystick_ball_motion:
      return "joystick_ball_motion";

    case event_type::joystick_hat_motion:
      return "joystick_hat_motion";

    case event_type::joystick_button_down:
      return "joystick_button_down";

    case event_type::joystick_button_up:
      return "joystick_button_up";

    case event_type::joystick_device_added:
      return "joystick_device_added";

    case event_type::joystick_device_removed:
      return "joystick_device_removed";

    case event_type::controller_axis_motion:
      return "controller_axis_motion";

    case event_type::controller_button_down:
      return "controller_button_down";

    case event_type::controller_button_up:
      return "controller_button_up";

    case event_type::controller_device_added:
      return "controller_device_added";

    case event_type::controller_device_removed:
      return "controller_device_removed";

    case event_type::controller_device_remapped:
      return "controller_device_remapped";

#if SDL_VERSION_ATLEAST(2, 0, 14)
    case event_type::controller_touchpad_down:
      return "controller_touchpad_down";

    case event_type::controller_touchpad_up:
      return "controller_touchpad_up";

    case event_type::controller_touchpad_motion:
      return "controller_touchpad_motion";

    case event_type::controller_sensor_update:
      return "controller_sensor_update";
#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

    case event_type::touch_down:
      return "touch_down";

    case event_type::touch_up:
      return "touch_up";

    case event_type::touch_motion:
      return "touch_motion";

    case event_type::dollar_gesture:
      return "dollar_gesture";

    case event_type::dollar_record:
      return "dollar_record";

    case event_type::multi_gesture:
      return "multi_gesture";

    case event_type::clipboard_update:
      return "clipboard_update";

    case event_type::drop_file:
      return "drop_file";

    case event_type::drop_text:
      return "drop_text";

    case event_type::drop_begin:
      return "drop_begin";

    case event_type::drop_complete:
      return "drop_complete";

    case event_type::audio_device_added:
      return "audio_device_added";

    case event_type::audio_device_removed:
      return "audio_device_removed";

    case event_type::sensor_update:
      return "sensor_update";

    case event_type::render_targets_reset:
      return "render_targets_reset";

    case event_type::render_device_reset:
      return "render_device_reset";

    case event_type::user:
      return "user";

    default:
      throw cen_error{"Did not recognize event type!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of an event type enumerator.
 *
 * \param stream the output stream that will be used.
 * \param type the enumerator that will be printed.
 *
 * \see `to_string(event_type)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const event_type type) -> std::ostream&
{
  return stream << to_string(type);
}

/// \} End of streaming

/// \name Event type comparison operators
/// \{

/**
 * \brief Indicates whether or not two event type values are the same.
 *
 * \param lhs the left-hand side event type value
 * \param rhs the right-hand side event type value
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 3.1.0
 */
[[nodiscard]] constexpr auto operator==(const event_type lhs, const SDL_EventType rhs) noexcept
    -> bool
{
  return static_cast<SDL_EventType>(lhs) == rhs;
}

/// \copydoc operator==(const event_type, const SDL_EventType)
[[nodiscard]] constexpr auto operator==(const SDL_EventType lhs, const event_type rhs) noexcept
    -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two event type values aren't the same.
 *
 * \param lhs the left-hand side event type value
 * \param rhs the right-hand side event type value
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 3.1.0
 */
[[nodiscard]] constexpr auto operator!=(const event_type lhs, const SDL_EventType rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const event_type, const SDL_EventType)
[[nodiscard]] constexpr auto operator!=(const SDL_EventType lhs, const event_type rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \} End of event type comparison operators

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_EVENT_TYPE_HEADER

namespace cen {

/// \addtogroup event
/// \{

/**
 * \class common_event
 *
 * \brief The templated base class of all Centurion events.
 *
 * \details This class defines the common API of all events and provides the
 * storage of the SDL2 event.
 *
 * \tparam T an SDL event type.
 *
 * \since 4.0.0
 */
template <typename T>
class common_event
{
 public:
  /**
   * \brief Creates a `common_event` and zero-initializes the internal event
   * except for the timestamp and the supplied type.
   *
   * \param type the type of the event.
   *
   * \since 5.1.0
   */
  explicit common_event(const event_type type) noexcept
  {
    set_time(SDL_GetTicks());
    set_type(type);
  }

  /**
   * \brief Creates a common_event and copies the supplied event.
   *
   * \param event the event that will be copied.
   *
   * \since 4.0.0
   */
  explicit common_event(const T& event) : m_event{event}
  {}

  /**
   * \brief Creates a common_event and moves the contents of the supplied event.
   *
   * \param event the event that will be moved.
   *
   * \since 4.0.0
   */
  explicit common_event(T&& event) : m_event{std::move(event)}
  {}

  /**
   * \brief Sets the timestamp that is associated with the creation of the
   * event.
   *
   * \param timestamp the timestamp that should be associated with the creation
   * of the event.
   *
   * \since 4.0.0
   */
  void set_time(const u32 timestamp) noexcept
  {
    m_event.timestamp = timestamp;
  }

  /**
   * \brief Sets the event type value associated with the event.
   *
   * \param type the event type value associated with the event.
   *
   * \since 4.0.0
   */
  void set_type(const event_type type) noexcept
  {
    m_event.type = to_underlying(type);
  }

  /**
   * \brief Returns the timestamp associated with the creation of the event.
   *
   * \return the timestamp associated with the creation of the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto time() const noexcept -> u32
  {
    return m_event.timestamp;
  }

  /**
   * \brief Returns the event type value associated with the event.
   *
   * \return the event type value associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto type() const noexcept -> event_type
  {
    return static_cast<event_type>(m_event.type);
  }

  /**
   * \brief Returns the internal event.
   *
   * \return the internal event.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get() const noexcept -> const T&
  {
    return m_event;
  }

 protected:
  T m_event{};
};

/// \name SDL event conversions
/// \{

template <typename T>
[[nodiscard]] auto as_sdl_event(const common_event<T>& event) -> SDL_Event;

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_COMMON_EVENT_HEADER


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class audio_device_event
 *
 * \brief Represents an event that is associated with some sort of audio device, either
 * capture of output.
 *
 * \see `SDL_AudioDeviceEvent`
 *
 * \since 4.0.0
 */
class audio_device_event final : public common_event<SDL_AudioDeviceEvent>
{
 public:
  /**
   * \brief Creates an audio device event of type `audio_device_added`.
   *
   * \since 4.0.0
   */
  audio_device_event() noexcept : common_event{event_type::audio_device_added}
  {}

  /**
   * \brief Creates a audio device event based on the supplied SDL event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit audio_device_event(const SDL_AudioDeviceEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the audio device ID that is associated with the event.
   *
   * \param which the audio device ID that is associated with the event.
   *
   * \since 4.0.0
   */
  void set_which(const u32 which) noexcept
  {
    m_event.which = which;
  }

  /**
   * \brief Sets whether or not the audio device event is associated with a
   * capture device.
   *
   * \param capture `true` if the event is associated with a capture device;
   * `false` indicates that the event is associated with an output device.
   *
   * \since 4.0.0
   */
  void set_capture(const bool capture) noexcept
  {
    m_event.iscapture = capture;
  }

  /**
   * \brief Returns the audio device ID associated with the event.
   *
   * \return the audio device ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto which() const noexcept -> u32
  {
    return m_event.which;
  }

  /**
   * \brief Indicates whether or not the audio device event is associated with
   * an audio output device.
   *
   * \return `true` if the event is associated with an output device; false
   * otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto output() const noexcept -> bool
  {
    return !capture();
  }

  /**
   * \brief Indicates whether or not the audio device event is associated with
   * an audio capture device.
   *
   * \return `true` if the event is associated with a capture device; false
   * otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto capture() const noexcept -> bool
  {
    return m_event.iscapture;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_AudioDeviceEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.adevice = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_AUDIO_DEVICE_EVENT_HEADER

// #include "centurion/events/common_event.hpp"
#ifndef CENTURION_COMMON_EVENT_HEADER
#define CENTURION_COMMON_EVENT_HEADER

#include <SDL.h>

#include <utility>  // move

// #include "../core/integers.hpp"

// #include "../core/to_underlying.hpp"

// #include "event_type.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class common_event
 *
 * \brief The templated base class of all Centurion events.
 *
 * \details This class defines the common API of all events and provides the
 * storage of the SDL2 event.
 *
 * \tparam T an SDL event type.
 *
 * \since 4.0.0
 */
template <typename T>
class common_event
{
 public:
  /**
   * \brief Creates a `common_event` and zero-initializes the internal event
   * except for the timestamp and the supplied type.
   *
   * \param type the type of the event.
   *
   * \since 5.1.0
   */
  explicit common_event(const event_type type) noexcept
  {
    set_time(SDL_GetTicks());
    set_type(type);
  }

  /**
   * \brief Creates a common_event and copies the supplied event.
   *
   * \param event the event that will be copied.
   *
   * \since 4.0.0
   */
  explicit common_event(const T& event) : m_event{event}
  {}

  /**
   * \brief Creates a common_event and moves the contents of the supplied event.
   *
   * \param event the event that will be moved.
   *
   * \since 4.0.0
   */
  explicit common_event(T&& event) : m_event{std::move(event)}
  {}

  /**
   * \brief Sets the timestamp that is associated with the creation of the
   * event.
   *
   * \param timestamp the timestamp that should be associated with the creation
   * of the event.
   *
   * \since 4.0.0
   */
  void set_time(const u32 timestamp) noexcept
  {
    m_event.timestamp = timestamp;
  }

  /**
   * \brief Sets the event type value associated with the event.
   *
   * \param type the event type value associated with the event.
   *
   * \since 4.0.0
   */
  void set_type(const event_type type) noexcept
  {
    m_event.type = to_underlying(type);
  }

  /**
   * \brief Returns the timestamp associated with the creation of the event.
   *
   * \return the timestamp associated with the creation of the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto time() const noexcept -> u32
  {
    return m_event.timestamp;
  }

  /**
   * \brief Returns the event type value associated with the event.
   *
   * \return the event type value associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto type() const noexcept -> event_type
  {
    return static_cast<event_type>(m_event.type);
  }

  /**
   * \brief Returns the internal event.
   *
   * \return the internal event.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get() const noexcept -> const T&
  {
    return m_event;
  }

 protected:
  T m_event{};
};

/// \name SDL event conversions
/// \{

template <typename T>
[[nodiscard]] auto as_sdl_event(const common_event<T>& event) -> SDL_Event;

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_COMMON_EVENT_HEADER

// #include "centurion/events/controller_axis_event.hpp"
#ifndef CENTURION_CONTROLLER_AXIS_EVENT_HEADER
#define CENTURION_CONTROLLER_AXIS_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../input/controller.hpp"
#ifndef CENTURION_GAME_CONTROLLER_HEADER
#define CENTURION_GAME_CONTROLLER_HEADER

#include <SDL.h>

#include <array>        // array
#include <cassert>      // assert
#include <optional>     // optional
#include <ostream>      // ostream
#include <string>       // string
#include <string_view>  // string_view

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER

// #include "../core/integers.hpp"
#ifndef CENTURION_INTEGERS_HEADER
#define CENTURION_INTEGERS_HEADER

#include <SDL.h>

#include <cstddef>  // size_t

namespace cen {

/// \addtogroup core
/// \{

/// \name Integer aliases
/// \{

using usize = std::size_t;

/// Alias for an unsigned integer.
using uint = unsigned int;

/// Alias for the type used for integer literal operators.
using ulonglong = unsigned long long;

/// Alias for a 64-bit unsigned integer.
using u64 = Uint64;

/// Alias for a 32-bit unsigned integer.
using u32 = Uint32;

/// Alias for a 16-bit unsigned integer.
using u16 = Uint16;

/// Alias for an 8-bit unsigned integer.
using u8 = Uint8;

/// Alias for a 64-bit signed integer.
using i64 = Sint64;

/// Alias for a 32-bit signed integer.
using i32 = Sint32;

/// Alias for a 16-bit signed integer.
using i16 = Sint16;

/// Alias for an 8-bit signed integer.
using i8 = Sint8;

/// \} End of integer aliases

// clang-format off

/**
 * \brief Obtains the size of a container as an `int`.
 *
 * \tparam T a "container" that provides a `size()` member function.
 *
 * \param container the container to query the size of.
 *
 * \return the size of the container as an `int` value.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto isize(const T& container) noexcept(noexcept(container.size()))
    -> int
{
  return static_cast<int>(container.size());
}

// clang-format on

namespace literals {

/**
 * \brief Creates an 8-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u8(const ulonglong value) noexcept -> u8
{
  return static_cast<u8>(value);
}

/**
 * \brief Creates a 16-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u16(const ulonglong value) noexcept -> u16
{
  return static_cast<u16>(value);
}

/**
 * \brief Creates a 32-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u32(const ulonglong value) noexcept -> u32
{
  return static_cast<u32>(value);
}

/**
 * \brief Creates a 64-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u64(const ulonglong value) noexcept -> u64
{
  return static_cast<u64>(value);
}

/**
 * \brief Creates an 8-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i8(const ulonglong value) noexcept -> i8
{
  return static_cast<i8>(value);
}

/**
 * \brief Creates a 16-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i16(const ulonglong value) noexcept -> i16
{
  return static_cast<i16>(value);
}

/**
 * \brief Creates a 32-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i32(const ulonglong value) noexcept -> i32
{
  return static_cast<i32>(value);
}

/**
 * \brief Creates a 64-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i64(const ulonglong value) noexcept -> i64
{
  return static_cast<i64>(value);
}

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_INTEGERS_HEADER

// #include "../core/not_null.hpp"
#ifndef CENTURION_NOT_NULL_HEADER
#define CENTURION_NOT_NULL_HEADER

// #include "sfinae.hpp"
#ifndef CENTURION_SFINAE_HEADER
#define CENTURION_SFINAE_HEADER

#include <type_traits>  // enable_if_t, is_same_v, is_integral_v, is_floating_point_v, ...

namespace cen {

/// \addtogroup core
/// \{

// clang-format off

/// Enables a template if the type is either integral of floating-point, but not a boolean.
template <typename T>
using enable_if_number_t = std::enable_if_t<!std::is_same_v<T, bool> &&
                                            (std::is_integral_v<T> ||
                                             std::is_floating_point_v<T>), int>;

// clang-format on

/// Enables a template if the type is a pointer.
template <typename T>
using enable_if_pointer_v = std::enable_if_t<std::is_pointer_v<T>, int>;

/// Enables a template if T is convertible to any of the specified types.
template <typename T, typename... Args>
using enable_if_convertible_t = std::enable_if_t<(std::is_convertible_v<T, Args> || ...), int>;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_SFINAE_HEADER


namespace cen {

/**
 * \typedef not_null
 *
 * \ingroup core
 *
 * \brief Tag used to indicate that a pointer cannot be null.
 *
 * \note This alias is equivalent to `T`, it is a no-op.
 *
 * \since 5.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using not_null = T;

}  // namespace cen

#endif  // CENTURION_NOT_NULL_HEADER

// #include "../core/owner.hpp"
#ifndef CENTURION_OWNER_HEADER
#define CENTURION_OWNER_HEADER

// #include "sfinae.hpp"


namespace cen {

/**
 * \typedef owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote ownership of raw pointers directly in code.
 *
 * \details If a function takes an `owner<T*>` as a parameter, then the function will
 * claim ownership of that pointer. Subsequently, if a function returns an `owner<T*>`,
 * then ownership is transferred to the caller.
 */
template <typename T, enable_if_pointer_v<T> = 0>
using owner = T;

/**
 * \typedef maybe_owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote conditional ownership of raw pointers directly in code.
 *
 * \details This is primarily used in constructors of owner/handle classes, where the
 * owner version will claim ownership of the pointer, whilst the handle does not.
 *
 * \since 6.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using maybe_owner = T;

}  // namespace cen

#endif  // CENTURION_OWNER_HEADER
// #include "../core/result.hpp"
#ifndef CENTURION_RESULT_HEADER
#define CENTURION_RESULT_HEADER

#include <ostream>  // ostream
#include <string>   // string

namespace cen {

/// \addtogroup core
/// \{

/**
 * \class result
 *
 * \brief A simple indicator for the result of different operations.
 *
 * \details The idea behind this class is to make results of various operations
 * unambiguous. Quite an amount of functions in the library may fail, and earlier versions
 * of Centurion would usually return a `bool` in those cases, where `true` and `false`
 * would indicate success and failure, respectively. This class is a development of that
 * practice. For instance, this class is contextually convertible to `bool`, where a
 * successful result is still converted to `true`, and vice versa. However, this class
 * also enables explicit checks against `success` and `failure` constants, which makes
 * code very easy to read and unambiguous.
 * \code{cpp}
 *   cen::window window;
 *
 *   if (window.set_opacity(0.4f))
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::success)
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::failure)
 *   {
 *     // Failure!
 *   }
 * \endcode
 *
 * \see `success`
 * \see `failure`
 *
 * \since 6.0.0
 */
class result final
{
 public:
  /**
   * \brief Creates a result.
   *
   * \param success `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  constexpr result(const bool success) noexcept  // NOLINT implicit
      : m_success{success}
  {}

  /// \name Comparison operators
  /// \{

  /**
   * \brief Indicates whether or not two results have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results are equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator==(const result other) const noexcept -> bool
  {
    return m_success == other.m_success;
  }

  /**
   * \brief Indicates whether or not two results don't have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results aren't equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator!=(const result other) const noexcept -> bool
  {
    return !(*this == other);
  }

  /// \} End of comparison operators

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not the result is successful.
   *
   * \return `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr explicit operator bool() const noexcept
  {
    return m_success;
  }

  /// \} End of conversions

 private:
  bool m_success{};
};

/// Represents a successful result.
/// \since 6.0.0
inline constexpr result success{true};

/// Represents a failure of some kind.
/// \since 6.0.0
inline constexpr result failure{false};

/// \name String conversions
/// \{

/**
 * \brief Returns a string that represents a result value.
 *
 * \note The returned string is in a slightly different format compared to other Centurion
 * components.
 *
 * \param result the value that will be converted.
 *
 * \return `"success"` for a successful result; `"failure"` otherwise.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto to_string(const result result) -> std::string
{
  return result ? "success" : "failure";
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a result value using a stream.
 *
 * \param stream the stream that will be used.
 * \param result the result value that will be printed.
 *
 * \return the used stream.
 *
 * \since 6.0.0
 */
inline auto operator<<(std::ostream& stream, const result result) -> std::ostream&
{
  return stream << to_string(result);
}

/// \} End of streaming

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_RESULT_HEADER

// #include "../core/sdl_string.hpp"
#ifndef CENTURION_SDL_STRING_HEADER
#define CENTURION_SDL_STRING_HEADER

#include <SDL.h>

#include <memory>  // unique_ptr
#include <string>  // string

// #include "../detail/sdl_deleter.hpp"
#ifndef CENTURION_DETAIL_SDL_DELETER_HEADER
#define CENTURION_DETAIL_SDL_DELETER_HEADER

#include <SDL.h>

/// \cond FALSE
namespace cen::detail {

template <typename T>
struct sdl_deleter final
{
  void operator()(T* ptr) noexcept
  {
    SDL_free(ptr);
  }
};

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_SDL_DELETER_HEADER

// #include "owner.hpp"
#ifndef CENTURION_OWNER_HEADER
#define CENTURION_OWNER_HEADER

// #include "sfinae.hpp"


namespace cen {

/**
 * \typedef owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote ownership of raw pointers directly in code.
 *
 * \details If a function takes an `owner<T*>` as a parameter, then the function will
 * claim ownership of that pointer. Subsequently, if a function returns an `owner<T*>`,
 * then ownership is transferred to the caller.
 */
template <typename T, enable_if_pointer_v<T> = 0>
using owner = T;

/**
 * \typedef maybe_owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote conditional ownership of raw pointers directly in code.
 *
 * \details This is primarily used in constructors of owner/handle classes, where the
 * owner version will claim ownership of the pointer, whilst the handle does not.
 *
 * \since 6.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using maybe_owner = T;

}  // namespace cen

#endif  // CENTURION_OWNER_HEADER
// #include "str.hpp"


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class sdl_string
 *
 * \brief Represents an SDL string.
 *
 * \details Certain SDL APIs return `char*` strings that need to be freed using
 * `SDL_free`, this class serves as a small wrapper around such strings. Use the `copy()`
 * member function to convert the string into a corresponding `std::string`.
 *
 * \note Instances of `sdl_string` might manage null strings. Use the overloaded `operator
 * bool()` in order to determine whether or not any associated string is null.
 *
 * \since 5.0.0
 */
class sdl_string final
{
 public:
  /**
   * \brief Creates a string.
   *
   * \param str the string that will be claimed, can be null.
   *
   * \since 5.0.0
   */
  explicit sdl_string(owner<char*> str) noexcept : m_str{str}
  {}

  /**
   * \brief Returns the internal string, which might be null.
   *
   * \return the internal string; `nullptr` if there is none.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get() const noexcept -> str
  {
    return m_str.get();
  }

  /**
   * \brief Returns a copy of the internal string.
   *
   * \details This function returns the empty string if the internal string is a null
   * pointer.
   *
   * \return a copy of the internal string.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto copy() const -> std::string
  {
    if (m_str) {
      return std::string{get()};
    }
    else {
      return std::string{};
    }
  }

  /**
   * \brief Indicates whether or not the internal string is non-null.
   *
   * \return `true` if the internal string is non-null; `false` otherwise.
   *
   * \since 5.0.0
   */
  explicit operator bool() const noexcept
  {
    return m_str.operator bool();
  }

 private:
  std::unique_ptr<char, detail::sdl_deleter<char>> m_str;
};

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_SDL_STRING_HEADER

// #include "../core/str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER

// #include "../core/str_or_na.hpp"
#ifndef CENTURION_STR_OR_NA_HEADER
#define CENTURION_STR_OR_NA_HEADER

// #include "not_null.hpp"
#ifndef CENTURION_NOT_NULL_HEADER
#define CENTURION_NOT_NULL_HEADER

// #include "sfinae.hpp"


namespace cen {

/**
 * \typedef not_null
 *
 * \ingroup core
 *
 * \brief Tag used to indicate that a pointer cannot be null.
 *
 * \note This alias is equivalent to `T`, it is a no-op.
 *
 * \since 5.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using not_null = T;

}  // namespace cen

#endif  // CENTURION_NOT_NULL_HEADER

// #include "str.hpp"


namespace cen {

/// \addtogroup core
/// \{

/**
 * \brief Simply returns the string if it isn't null, returning a placeholder otherwise.
 *
 * \note This is mainly used in `to_string()` overloads.
 *
 * \param string the string that will be checked.
 *
 * \return the supplied string if it isn't null; "n/a" otherwise.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto str_or_na(const str string) noexcept -> not_null<str>
{
  return string ? string : "n/a";
}

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_OR_NA_HEADER

// #include "../core/time.hpp"
#ifndef CENTURION_TIME_HEADER
#define CENTURION_TIME_HEADER

#include <chrono>  // duration
#include <ratio>   // milli, micro, nano

// #include "integers.hpp"
#ifndef CENTURION_INTEGERS_HEADER
#define CENTURION_INTEGERS_HEADER

#include <SDL.h>

#include <cstddef>  // size_t

namespace cen {

/// \addtogroup core
/// \{

/// \name Integer aliases
/// \{

using usize = std::size_t;

/// Alias for an unsigned integer.
using uint = unsigned int;

/// Alias for the type used for integer literal operators.
using ulonglong = unsigned long long;

/// Alias for a 64-bit unsigned integer.
using u64 = Uint64;

/// Alias for a 32-bit unsigned integer.
using u32 = Uint32;

/// Alias for a 16-bit unsigned integer.
using u16 = Uint16;

/// Alias for an 8-bit unsigned integer.
using u8 = Uint8;

/// Alias for a 64-bit signed integer.
using i64 = Sint64;

/// Alias for a 32-bit signed integer.
using i32 = Sint32;

/// Alias for a 16-bit signed integer.
using i16 = Sint16;

/// Alias for an 8-bit signed integer.
using i8 = Sint8;

/// \} End of integer aliases

// clang-format off

/**
 * \brief Obtains the size of a container as an `int`.
 *
 * \tparam T a "container" that provides a `size()` member function.
 *
 * \param container the container to query the size of.
 *
 * \return the size of the container as an `int` value.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto isize(const T& container) noexcept(noexcept(container.size()))
    -> int
{
  return static_cast<int>(container.size());
}

// clang-format on

namespace literals {

/**
 * \brief Creates an 8-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u8(const ulonglong value) noexcept -> u8
{
  return static_cast<u8>(value);
}

/**
 * \brief Creates a 16-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u16(const ulonglong value) noexcept -> u16
{
  return static_cast<u16>(value);
}

/**
 * \brief Creates a 32-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u32(const ulonglong value) noexcept -> u32
{
  return static_cast<u32>(value);
}

/**
 * \brief Creates a 64-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u64(const ulonglong value) noexcept -> u64
{
  return static_cast<u64>(value);
}

/**
 * \brief Creates an 8-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i8(const ulonglong value) noexcept -> i8
{
  return static_cast<i8>(value);
}

/**
 * \brief Creates a 16-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i16(const ulonglong value) noexcept -> i16
{
  return static_cast<i16>(value);
}

/**
 * \brief Creates a 32-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i32(const ulonglong value) noexcept -> i32
{
  return static_cast<i32>(value);
}

/**
 * \brief Creates a 64-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i64(const ulonglong value) noexcept -> i64
{
  return static_cast<i64>(value);
}

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_INTEGERS_HEADER


namespace cen {

/// \addtogroup core
/// \{

/// \name Time (std::chrono) aliases
/// \{

/**
 * \typedef seconds
 *
 * \brief Templated alias for durations in seconds.
 */
template <typename T>
using seconds = std::chrono::duration<T>;

/**
 * \typedef milliseconds
 *
 * \brief Templated alias for durations in milliseconds.
 */
template <typename T>
using milliseconds = std::chrono::duration<T, std::milli>;

/**
 * \typedef microseconds
 *
 * \brief Templated alias for durations in microseconds.
 */
template <typename T>
using microseconds = std::chrono::duration<T, std::micro>;

/**
 * \typedef nanoseconds
 *
 * \brief Templated alias for durations in nanoseconds.
 */
template <typename T>
using nanoseconds = std::chrono::duration<T, std::nano>;

/**
 * \typedef minutes
 *
 * \brief Templated alias for durations in minutes.
 */
template <typename T>
using minutes = std::chrono::duration<T, std::ratio<60>>;

/// \} End of time (std::chrono) aliases

namespace literals {

// clang-format off

[[nodiscard]] constexpr auto operator"" _ns(const ulonglong value) noexcept(noexcept(nanoseconds<u32>{}))
    -> nanoseconds<u32>
{
  return nanoseconds<u32>{value};
}

[[nodiscard]] constexpr auto operator"" _us(const ulonglong value) noexcept(noexcept(microseconds<u32>{}))
    -> microseconds<u32>
{
  return microseconds<u32>{value};
}

[[nodiscard]] constexpr auto operator"" _ms(const ulonglong value) noexcept(noexcept(milliseconds<u32>{}))
    -> milliseconds<u32>
{
  return milliseconds<u32>{value};
}

[[nodiscard]] constexpr auto operator"" _s(const ulonglong value) noexcept(noexcept(seconds<u32>{}))
    -> seconds<u32>
{
  return seconds<u32>{value};
}

// clang-format on

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_TIME_HEADER

// #include "../detail/address_of.hpp"
#ifndef CENTURION_DETAIL_ADDRESS_OF_HEADER
#define CENTURION_DETAIL_ADDRESS_OF_HEADER

#include <sstream>  // stringstream
#include <string>   // string

// #include "../compiler/compiler.hpp"
#ifndef CENTURION_COMPILER_HEADER
#define CENTURION_COMPILER_HEADER

#include <SDL.h>

namespace cen {

/// \addtogroup compiler
/// \{

/**
 * \brief Indicates whether or not a "debug" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a debug build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_debug_build() noexcept -> bool
{
#ifndef NDEBUG
  return true;
#else
  return false;
#endif  // NDEBUG
}

/**
 * \brief Indicates whether or not a "release" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a release build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_release_build() noexcept -> bool
{
  return !is_debug_build();
}

/**
 * \brief Indicates whether or not the compiler is MSVC.
 *
 * \return `true` if MSVC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_msvc() noexcept -> bool
{
#ifdef _MSC_VER
  return true;
#else
  return false;
#endif  // _MSC_VER
}

/**
 * \brief Indicates whether or not the compiler is GCC.
 *
 * \return `true` if GCC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_gcc() noexcept -> bool
{
#ifdef __GNUC__
  return true;
#else
  return false;
#endif  // __GNUC__
}

/**
 * \brief Indicates whether or not the compiler is Clang.
 *
 * \return `true` if Clang is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_clang() noexcept -> bool
{
#ifdef __clang__
  return true;
#else
  return false;
#endif  // __clang__
}

/**
 * \brief Indicates whether or not the compiler is Emscripten.
 *
 * \return `true` if Emscripten is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_emscripten() noexcept -> bool
{
#ifdef __EMSCRIPTEN__
  return true;
#else
  return false;
#endif  // __EMSCRIPTEN__
}

/**
 * \brief Indicates whether or not the compiler is Intel C++.
 *
 * \return `true` if Intel C++ is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_intel_cpp() noexcept -> bool
{
#ifdef __INTEL_COMPILER
  return true;
#else
  return false;
#endif  // __INTEL_COMPILER
}

/// \} End of compiler group

}  // namespace cen

#endif  // CENTURION_COMPILER_HEADER


/// \cond FALSE
namespace cen::detail {

/**
 * \brief Returns a string that represents the memory address of the supplied pointer.
 *
 * \details The empty string is returned if the supplied pointer is null.
 *
 * \tparam T the type of the pointer.
 * \param ptr the pointer that will be converted.
 *
 * \return a string that represents the memory address of the supplied pointer.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto address_of(const void* ptr) -> std::string
{
  if (ptr) {
    std::stringstream stream;

    if constexpr (on_msvc()) {
      stream << "0x";  // Only MSVC seems to omit this, add it for consistency
    }

    stream << ptr;
    return stream.str();
  }
  else {
    return std::string{};
  }
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_ADDRESS_OF_HEADER

// #include "../detail/owner_handle_api.hpp"
#ifndef CENTURION_DETAIL_OWNER_HANDLE_API_HEADER
#define CENTURION_DETAIL_OWNER_HANDLE_API_HEADER

#include <cassert>      // assert
#include <memory>       // unique_ptr
#include <type_traits>  // enable_if_t, is_same_v, true_type, false_type

// #include "../core/exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER


/// \cond FALSE
namespace cen::detail {

using owning_type = std::true_type;
using handle_type = std::false_type;

template <typename T>
using is_owner = std::enable_if_t<std::is_same_v<T, owning_type>, int>;

template <typename T>
using is_handle = std::enable_if_t<std::is_same_v<T, handle_type>, int>;

template <typename T>
[[nodiscard]] constexpr auto is_owning() noexcept -> bool
{
  return std::is_same_v<T, owning_type>;
}

template <typename B, typename Type, typename Deleter>
class pointer_manager final
{
  using managed_ptr = std::unique_ptr<Type, Deleter>;
  using raw_ptr = Type*;
  using pointer_type = std::conditional_t<B::value, managed_ptr, raw_ptr>;

 public:
  pointer_manager() noexcept = default;

  explicit pointer_manager(Type* ptr) noexcept : m_ptr{ptr}
  {}

  template <typename BB = B, is_owner<BB> = 0>
  void reset(Type* ptr) noexcept
  {
    m_ptr.reset(ptr);
  }

  auto operator->() noexcept -> Type*
  {
    return get();
  }

  auto operator->() const noexcept -> const Type*
  {
    return get();
  }

  auto operator*() noexcept -> Type&
  {
    assert(m_ptr);
    return *m_ptr;
  }

  auto operator*() const noexcept -> const Type&
  {
    assert(m_ptr);
    return *m_ptr;
  }

  explicit operator bool() const noexcept
  {
    return m_ptr != nullptr;
  }

  /*implicit*/ operator Type*() const noexcept
  {
    return get();
  }

  template <typename BB = B, is_owner<BB> = 0>
  [[nodiscard]] auto release() noexcept -> Type*
  {
    return m_ptr.release();
  }

  [[nodiscard]] auto get() const noexcept -> Type*
  {
    if constexpr (B::value) {
      return m_ptr.get();
    }
    else {
      return m_ptr;
    }
  }

 private:
  pointer_type m_ptr{};
};

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_OWNER_HANDLE_API_HEADER

// #include "../detail/sdl_version_at_least.hpp"
#ifndef CENTURION_DETAIL_SDL_VERSION_AT_LEAST
#define CENTURION_DETAIL_SDL_VERSION_AT_LEAST

#include <SDL.h>

// #include "../core/version.hpp"
#ifndef CENTURION_VERSION_HEADER
#define CENTURION_VERSION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <cassert>  // assert

/// \addtogroup core
/// \{

/**
 * \def CENTURION_VERSION_MAJOR
 *
 * \brief Expands into the current major version of the library.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_MAJOR 6

/**
 * \def CENTURION_VERSION_MINOR
 *
 * \brief Expands into the current minor version of the library.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_MINOR 3

/**
 * \def CENTURION_VERSION_PATCH
 *
 * \brief Expands into the current patch version of the library.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_PATCH 0

/**
 * \def CENTURION_SDL_VERSION_IS
 *
 * \brief This macro is meant to be used when conditionally including code for a specific
 * version of SDL. It is useful for applying workarounds.
 *
 * \since 5.3.0
 */
#define CENTURION_SDL_VERSION_IS(x, y, z) \
  ((SDL_MAJOR_VERSION == (x)) && (SDL_MINOR_VERSION == (y)) && (SDL_PATCHLEVEL == (z)))

#ifdef CENTURION___DOXYGEN

#define CENTURION_MAKE_VERSION_NUMBER
#define CENTURION_VERSION_NUMBER
#define CENTURION_VERSION_AT_LEAST

#endif  // CENTURION___DOXYGEN

/**
 * \def CENTURION_MAKE_VERSION_NUMBER
 *
 * \brief Helper macro for creating version numbers from a set of major/minor/patch
 * numbers.
 *
 * \details For example, if the version is 8.4.2, the resulting version number would be
 * 8402.
 *
 * \since 6.0.0
 */
#define CENTURION_MAKE_VERSION_NUMBER(x, y, z) (((x)*1'000) + ((y)*100) + (z))

/**
 * \def CENTURION_VERSION_NUMBER
 *
 * \brief Expands into a version number based on the current Centurion version.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_NUMBER                         \
  CENTURION_MAKE_VERSION_NUMBER(CENTURION_VERSION_MAJOR, \
                                CENTURION_VERSION_MINOR, \
                                CENTURION_VERSION_PATCH)

/**
 * \def CENTURION_VERSION_AT_LEAST
 *
 * \brief This macro is intended to be used for conditional compilation, based on the
 * Centurion version.
 *
 * \details This macro is used in the same way as the `SDL_VERSION_ATLEAST`, where you use
 * it as the condition with `#if` statements.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_AT_LEAST(x, y, z) \
  CENTURION_VERSION_NUMBER >= CENTURION_MAKE_VERSION_NUMBER(x, y, z)

namespace cen {

/// \name Centurion version queries
/// \{

/**
 * \struct version
 *
 * \brief Represents a set of major/minor/patch version numbers.
 *
 * \details The members of this struct are by default initialized to the current Centurion
 * version values.
 *
 * \since 6.0.0
 */
struct version final
{
  int major{CENTURION_VERSION_MAJOR};
  int minor{CENTURION_VERSION_MINOR};
  int patch{CENTURION_VERSION_PATCH};
};

/**
 * \brief Indicates whether or not the current Centurion version is at least equal to the
 * specified version.
 *
 * \param major the major version value.
 * \param minor the minor version value.
 * \param patch the patch version value.
 *
 * \return `true` if the version of Centurion is at least the specified version; `false`
 * otherwise.
 *
 * \see `CENTURION_VERSION_AT_LEAST`
 *
 * \since 6.0.0
 */
[[nodiscard]] constexpr auto version_at_least(const int major,
                                              const int minor,
                                              const int patch) noexcept -> bool
{
  return CENTURION_VERSION_AT_LEAST(major, minor, patch);
}

/// \} End of centurion version queries

/// \name SDL version queries
/// \{

/**
 * \brief Returns the version of SDL2 that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL that the
 * program was compiled against.
 *
 * \return the linked version of SDL2.
 *
 * \since 5.2.0
 */
[[nodiscard]] inline auto sdl_linked_version() noexcept -> SDL_version
{
  SDL_version version{};
  SDL_GetVersion(&version);
  return version;
}

/**
 * \brief Returns the compile-time version of SDL2 that is being used.
 *
 * \return the compile-time version of SDL2 that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_version() noexcept -> SDL_version
{
  return {SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL};
}

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \brief Returns the version of SDL2_image that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL2_image that
 * the program was compiled against.
 *
 * \return the linked version of SDL2_image.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto sdl_image_linked_version() noexcept -> SDL_version
{
  const auto* version = IMG_Linked_Version();
  assert(version);  // Sanity check
  return *version;
}

/**
 * \brief Returns the compile-time version of SDL2_image that is being used.
 *
 * \return the compile-time version of SDL2_image that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_image_version() noexcept -> SDL_version
{
  return {SDL_IMAGE_MAJOR_VERSION, SDL_IMAGE_MINOR_VERSION, SDL_IMAGE_PATCHLEVEL};
}

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \brief Returns the version of SDL2_mixer that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL2_mixer that
 * the program was compiled against.
 *
 * \return the linked version of SDL2_mixer.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto sdl_mixer_linked_version() noexcept -> SDL_version
{
  const auto* version = Mix_Linked_Version();
  assert(version);  // Sanity check
  return *version;
}

/**
 * \brief Returns the compile-time version of SDL2_mixer that is being used.
 *
 * \return the compile-time version of SDL2_mixer that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_mixer_version() noexcept -> SDL_version
{
  return {SDL_MIXER_MAJOR_VERSION, SDL_MIXER_MINOR_VERSION, SDL_MIXER_PATCHLEVEL};
}

#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF

/**
 * \brief Returns the version of SDL2_ttf that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL2_ttf that the
 * program was compiled against.
 *
 * \return the linked version of SDL2_ttf.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto sdl_ttf_linked_version() noexcept -> SDL_version
{
  const auto* version = TTF_Linked_Version();
  assert(version);  // Sanity check
  return *version;
}

/**
 * \brief Returns the compile-time version of SDL2_ttf that is being used.
 *
 * \return the compile-time version of SDL2_ttf that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_ttf_version() noexcept -> SDL_version
{
  return {SDL_TTF_MAJOR_VERSION, SDL_TTF_MINOR_VERSION, SDL_TTF_PATCHLEVEL};
}

#endif  // CENTURION_NO_SDL_TTF

/// \} End of SDL version queries

}  // namespace cen

#if CENTURION_SDL_VERSION_IS(2, 0, 10)

// Workaround for this enum being completely anonymous in SDL 2.0.10. We include
// this here because multiple files (key_code.hpp and scan_code.hpp) depend on
// this definition.
using SDL_KeyCode = decltype(SDLK_UNKNOWN);

#endif  // CENTURION_SDL_VERSION_IS(2, 0, 10)

/// \} End of group core

#endif  // CENTURION_VERSION_HEADER


/// \cond FALSE
namespace cen::detail {

[[nodiscard]] constexpr auto sdl_version_at_least(const int major,
                                                  const int minor,
                                                  const int patch) noexcept -> bool
{
  return SDL_COMPILEDVERSION >= SDL_VERSIONNUM(major, minor, patch);
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_SDL_VERSION_AT_LEAST

// #include "../video/color.hpp"
#ifndef CENTURION_COLOR_HEADER
#define CENTURION_COLOR_HEADER

#include <SDL.h>

#include <cassert>      // assert
#include <cmath>        // round, abs, fmod, lerp
#include <iomanip>      // setfill, setw
#include <ios>          // uppercase, hex
#include <optional>     // optional
#include <ostream>      // ostream
#include <sstream>      // stringstream
#include <string>       // string, to_string
#include <string_view>  // string_view

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../compiler/compiler.hpp"
#ifndef CENTURION_COMPILER_HEADER
#define CENTURION_COMPILER_HEADER

#include <SDL.h>

namespace cen {

/// \addtogroup compiler
/// \{

/**
 * \brief Indicates whether or not a "debug" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a debug build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_debug_build() noexcept -> bool
{
#ifndef NDEBUG
  return true;
#else
  return false;
#endif  // NDEBUG
}

/**
 * \brief Indicates whether or not a "release" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a release build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_release_build() noexcept -> bool
{
  return !is_debug_build();
}

/**
 * \brief Indicates whether or not the compiler is MSVC.
 *
 * \return `true` if MSVC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_msvc() noexcept -> bool
{
#ifdef _MSC_VER
  return true;
#else
  return false;
#endif  // _MSC_VER
}

/**
 * \brief Indicates whether or not the compiler is GCC.
 *
 * \return `true` if GCC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_gcc() noexcept -> bool
{
#ifdef __GNUC__
  return true;
#else
  return false;
#endif  // __GNUC__
}

/**
 * \brief Indicates whether or not the compiler is Clang.
 *
 * \return `true` if Clang is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_clang() noexcept -> bool
{
#ifdef __clang__
  return true;
#else
  return false;
#endif  // __clang__
}

/**
 * \brief Indicates whether or not the compiler is Emscripten.
 *
 * \return `true` if Emscripten is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_emscripten() noexcept -> bool
{
#ifdef __EMSCRIPTEN__
  return true;
#else
  return false;
#endif  // __EMSCRIPTEN__
}

/**
 * \brief Indicates whether or not the compiler is Intel C++.
 *
 * \return `true` if Intel C++ is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_intel_cpp() noexcept -> bool
{
#ifdef __INTEL_COMPILER
  return true;
#else
  return false;
#endif  // __INTEL_COMPILER
}

/// \} End of compiler group

}  // namespace cen

#endif  // CENTURION_COMPILER_HEADER

// #include "../core/exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER

// #include "../core/integers.hpp"
#ifndef CENTURION_INTEGERS_HEADER
#define CENTURION_INTEGERS_HEADER

#include <SDL.h>

#include <cstddef>  // size_t

namespace cen {

/// \addtogroup core
/// \{

/// \name Integer aliases
/// \{

using usize = std::size_t;

/// Alias for an unsigned integer.
using uint = unsigned int;

/// Alias for the type used for integer literal operators.
using ulonglong = unsigned long long;

/// Alias for a 64-bit unsigned integer.
using u64 = Uint64;

/// Alias for a 32-bit unsigned integer.
using u32 = Uint32;

/// Alias for a 16-bit unsigned integer.
using u16 = Uint16;

/// Alias for an 8-bit unsigned integer.
using u8 = Uint8;

/// Alias for a 64-bit signed integer.
using i64 = Sint64;

/// Alias for a 32-bit signed integer.
using i32 = Sint32;

/// Alias for a 16-bit signed integer.
using i16 = Sint16;

/// Alias for an 8-bit signed integer.
using i8 = Sint8;

/// \} End of integer aliases

// clang-format off

/**
 * \brief Obtains the size of a container as an `int`.
 *
 * \tparam T a "container" that provides a `size()` member function.
 *
 * \param container the container to query the size of.
 *
 * \return the size of the container as an `int` value.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto isize(const T& container) noexcept(noexcept(container.size()))
    -> int
{
  return static_cast<int>(container.size());
}

// clang-format on

namespace literals {

/**
 * \brief Creates an 8-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u8(const ulonglong value) noexcept -> u8
{
  return static_cast<u8>(value);
}

/**
 * \brief Creates a 16-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u16(const ulonglong value) noexcept -> u16
{
  return static_cast<u16>(value);
}

/**
 * \brief Creates a 32-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u32(const ulonglong value) noexcept -> u32
{
  return static_cast<u32>(value);
}

/**
 * \brief Creates a 64-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u64(const ulonglong value) noexcept -> u64
{
  return static_cast<u64>(value);
}

/**
 * \brief Creates an 8-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i8(const ulonglong value) noexcept -> i8
{
  return static_cast<i8>(value);
}

/**
 * \brief Creates a 16-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i16(const ulonglong value) noexcept -> i16
{
  return static_cast<i16>(value);
}

/**
 * \brief Creates a 32-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i32(const ulonglong value) noexcept -> i32
{
  return static_cast<i32>(value);
}

/**
 * \brief Creates a 64-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i64(const ulonglong value) noexcept -> i64
{
  return static_cast<i64>(value);
}

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_INTEGERS_HEADER

// #include "../detail/clamp.hpp"
#ifndef CENTURION_DETAIL_CLAMP_HEADER
#define CENTURION_DETAIL_CLAMP_HEADER

#include <cassert>  // assert

/// \cond FALSE
namespace cen::detail {

// clang-format off

/**
 * \brief Clamps a value to be within the range [min, max].
 *
 * \pre `min` must be less than or equal to `max`.
 *
 * \note The standard library provides `std::clamp`, but it isn't mandated to be
 * `noexcept` (although MSVC does mark it as `noexcept`), which is the reason this
 * function exists.
 *
 * \tparam T the type of the values.
 *
 * \param value the value that will be clamped.
 * \param min the minimum value (inclusive).
 * \param max the maximum value (inclusive).
 *
 * \return the clamped value.
 *
 * \since 5.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto clamp(const T& value,
                                   const T& min,
                                   const T& max)
    noexcept(noexcept(value < min) && noexcept(value > max)) -> T
{
  assert(min <= max);
  if (value < min)
  {
    return min;
  }
  else if (value > max)
  {
    return max;
  }
  else
  {
    return value;
  }
}

// clang-format on

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_CLAMP_HEADER

// #include "../detail/from_string.hpp"
#ifndef CENTURION_DETAIL_FROM_STRING_HEADER
#define CENTURION_DETAIL_FROM_STRING_HEADER

#include <charconv>      // from_chars
#include <optional>      // optional
#include <string>        // string, stof
#include <string_view>   // string_view
#include <system_error>  // errc
#include <type_traits>   // is_floating_point_v

// #include "../compiler/compiler.hpp"
#ifndef CENTURION_COMPILER_HEADER
#define CENTURION_COMPILER_HEADER

#include <SDL.h>

namespace cen {

/// \addtogroup compiler
/// \{

/**
 * \brief Indicates whether or not a "debug" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a debug build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_debug_build() noexcept -> bool
{
#ifndef NDEBUG
  return true;
#else
  return false;
#endif  // NDEBUG
}

/**
 * \brief Indicates whether or not a "release" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a release build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_release_build() noexcept -> bool
{
  return !is_debug_build();
}

/**
 * \brief Indicates whether or not the compiler is MSVC.
 *
 * \return `true` if MSVC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_msvc() noexcept -> bool
{
#ifdef _MSC_VER
  return true;
#else
  return false;
#endif  // _MSC_VER
}

/**
 * \brief Indicates whether or not the compiler is GCC.
 *
 * \return `true` if GCC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_gcc() noexcept -> bool
{
#ifdef __GNUC__
  return true;
#else
  return false;
#endif  // __GNUC__
}

/**
 * \brief Indicates whether or not the compiler is Clang.
 *
 * \return `true` if Clang is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_clang() noexcept -> bool
{
#ifdef __clang__
  return true;
#else
  return false;
#endif  // __clang__
}

/**
 * \brief Indicates whether or not the compiler is Emscripten.
 *
 * \return `true` if Emscripten is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_emscripten() noexcept -> bool
{
#ifdef __EMSCRIPTEN__
  return true;
#else
  return false;
#endif  // __EMSCRIPTEN__
}

/**
 * \brief Indicates whether or not the compiler is Intel C++.
 *
 * \return `true` if Intel C++ is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_intel_cpp() noexcept -> bool
{
#ifdef __INTEL_COMPILER
  return true;
#else
  return false;
#endif  // __INTEL_COMPILER
}

/// \} End of compiler group

}  // namespace cen

#endif  // CENTURION_COMPILER_HEADER


/// \cond FALSE
namespace cen::detail {

template <typename T>
[[nodiscard]] auto from_string(const std::string_view str,
                               const int base = 10) noexcept(on_msvc()) -> std::optional<T>
{
  T value{};

  const auto begin = str.data();
  const auto end = str.data() + str.size();

  const char* mismatch = end;
  std::errc error{};

  if constexpr (std::is_floating_point_v<T>) {
    if constexpr (on_gcc() || on_clang()) {
      try {
        value = std::stof(std::string{str});
      }
      catch (...) {
        return std::nullopt;
      }
    }
    else {
      const auto [ptr, err] = std::from_chars(begin, end, value);
      mismatch = ptr;
      error = err;
    }
  }
  else {
    const auto [ptr, err] = std::from_chars(begin, end, value, base);
    mismatch = ptr;
    error = err;
  }

  if (mismatch == end && error == std::errc{}) {
    return value;
  }
  else {
    return std::nullopt;
  }
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_FROM_STRING_HEADER

// #include "../detail/lerp.hpp"
#ifndef CENTURION_DETAIL_LERP_HEADER
#define CENTURION_DETAIL_LERP_HEADER

#include <cmath>  // lerp

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER


/// \cond FALSE

namespace cen::detail {

[[nodiscard]] constexpr auto lerp(const float a, const float b, const float bias) noexcept
    -> float
{
#if CENTURION_HAS_FEATURE_LERP
  return std::lerp(a, b, bias);
#else
  return (a * (1.0f - bias)) + (b * bias);
#endif  // CENTURION_HAS_FEATURE_LERP
}

}  // namespace cen::detail

/// \endcond

#endif  // CENTURION_DETAIL_LERP_HEADER


namespace cen {

/// \addtogroup video
/// \{

/**
 * \class color
 *
 * \brief An 8-bit accuracy RGBA color.
 *
 * \serializable
 *
 * \details This class is designed to interact with the SDL colors, i.e. `SDL_Color` and
 * `SDL_MessageBoxColor`. For convenience, there are approximately 140 color constants
 * provided in the `colors` namespace,
 *
 * \since 3.0.0
 */
class color final
{
 public:
  /// \name Construction
  /// \{

  /**
   * \brief Creates a color. The created color will be equal to #000000FF.
   *
   * \since 3.0.0
   */
  constexpr color() noexcept = default;

  /**
   * \brief Creates a color.
   *
   * \param red the red component value, in the range [0, 255].
   * \param green the green component value, in the range [0, 255].
   * \param blue the blue component value, in the range [0, 255].
   * \param alpha the alpha component value, in the rage [0, 255]. Defaults to 255.
   *
   * \since 3.0.0
   */
  constexpr color(const u8 red, const u8 green, const u8 blue, const u8 alpha = max()) noexcept
      : m_color{red, green, blue, alpha}
  {}

  /**
   * \brief Creates a color that is a copy of the supplied `SDL_Color`.
   *
   * \param color the `SDL_Color` that will be copied.
   *
   * \since 3.0.0
   */
  constexpr explicit color(const SDL_Color& color) noexcept : m_color{color}
  {}

  /**
   * \brief Creates a color that is a copy of the supplied SDL_MessageBoxColor.
   *
   * \details Message box colors don't have an alpha component so the created color will
   * feature an alpha value of 255.
   *
   * \param color the message box color that will be copied.
   *
   * \since 3.0.0
   */
  constexpr explicit color(const SDL_MessageBoxColor& color) noexcept
      : m_color{color.r, color.g, color.b, max()}
  {}

  /**
   * \brief Creates a color from HSV-encoded values.
   *
   * \note The values will be clamped to be within their respective ranges.
   *
   * \param hue the hue of the color, in the range [0, 360].
   * \param saturation the saturation of the color, in the range [0, 100].
   * \param value the value of the color, in the range [0, 100].
   *
   * \return an RGBA color converted from the HSV values.
   *
   * \since 5.3.0
   */
  [[nodiscard]] static auto from_hsv(float hue, float saturation, float value) -> color
  {
    hue = detail::clamp(hue, 0.0f, 360.0f);
    saturation = detail::clamp(saturation, 0.0f, 100.0f);
    value = detail::clamp(value, 0.0f, 100.0f);

    const auto v = (value / 100.0f);
    const auto chroma = v * (saturation / 100.0f);
    const auto hp = hue / 60.0f;

    const auto x = chroma * (1.0f - std::abs(std::fmod(hp, 2.0f) - 1.0f));

    float red{};
    float green{};
    float blue{};

    if (0 <= hp && hp <= 1) {
      red = chroma;
      green = x;
      blue = 0;
    }
    else if (1 < hp && hp <= 2) {
      red = x;
      green = chroma;
      blue = 0;
    }
    else if (2 < hp && hp <= 3) {
      red = 0;
      green = chroma;
      blue = x;
    }
    else if (3 < hp && hp <= 4) {
      red = 0;
      green = x;
      blue = chroma;
    }
    else if (4 < hp && hp <= 5) {
      red = x;
      green = 0;
      blue = chroma;
    }
    else if (5 < hp && hp <= 6) {
      red = chroma;
      green = 0;
      blue = x;
    }

    const auto m = v - chroma;

    const auto r = static_cast<u8>(std::round((red + m) * 255.0f));
    const auto g = static_cast<u8>(std::round((green + m) * 255.0f));
    const auto b = static_cast<u8>(std::round((blue + m) * 255.0f));

    return color{r, g, b};
  }

  /**
   * \brief Creates a color from HSL-encoded values.
   *
   * \note The values will be clamped to be within their respective ranges.
   *
   * \param hue the hue of the color, in the range [0, 360].
   * \param saturation the saturation of the color, in the range [0, 100].
   * \param lightness the lightness of the color, in the range [0, 100].
   *
   * \return an RGBA color converted from the HSL values.
   *
   * \since 5.3.0
   */
  [[nodiscard]] static auto from_hsl(float hue, float saturation, float lightness) -> color
  {
    hue = detail::clamp(hue, 0.0f, 360.0f);
    saturation = detail::clamp(saturation, 0.0f, 100.0f);
    lightness = detail::clamp(lightness, 0.0f, 100.0f);

    const auto s = saturation / 100.0f;
    const auto l = lightness / 100.0f;

    const auto chroma = (1.0f - std::abs(2.0f * l - 1.0f)) * s;
    const auto hp = hue / 60.0f;

    const auto x = chroma * (1.0f - std::abs(std::fmod(hp, 2.0f) - 1.0f));

    float red{};
    float green{};
    float blue{};

    if (0 <= hp && hp < 1) {
      red = chroma;
      green = x;
      blue = 0;
    }
    else if (1 <= hp && hp < 2) {
      red = x;
      green = chroma;
      blue = 0;
    }
    else if (2 <= hp && hp < 3) {
      red = 0;
      green = chroma;
      blue = x;
    }
    else if (3 <= hp && hp < 4) {
      red = 0;
      green = x;
      blue = chroma;
    }
    else if (4 <= hp && hp < 5) {
      red = x;
      green = 0;
      blue = chroma;
    }
    else if (5 <= hp && hp < 6) {
      red = chroma;
      green = 0;
      blue = x;
    }

    const auto m = l - (chroma / 2.0f);

    const auto r = static_cast<u8>(std::round((red + m) * 255.0f));
    const auto g = static_cast<u8>(std::round((green + m) * 255.0f));
    const auto b = static_cast<u8>(std::round((blue + m) * 255.0f));

    return color{r, g, b};
  }

  /**
   * \brief Creates a color from a hexadecimal RGB color string.
   *
   * \details The supplied string must feature a leading '#' character, and be 7
   * characters long.
   *
   * \param rgb the hexadecimal RGB color string, using the format "#RRGGBB".
   *
   * \return a corresponding color; `std::nullopt` if something goes wrong.
   *
   * \see `from_rgba()`
   * \see `from_argb()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] static auto from_rgb(const std::string_view rgb) -> std::optional<color>
  {
    if (rgb.length() != 7 || rgb.at(0) != '#') {
      return std::nullopt;
    }

    const auto noHash = rgb.substr(1);

    const auto rr = noHash.substr(0, 2);
    const auto gg = noHash.substr(2, 2);
    const auto bb = noHash.substr(4, 2);

    const auto red = detail::from_string<u8>(rr, 16);
    const auto green = detail::from_string<u8>(gg, 16);
    const auto blue = detail::from_string<u8>(bb, 16);

    if (red && green && blue) {
      return cen::color{*red, *green, *blue};
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Creates a color from a hexadecimal RGBA color string.
   *
   * \details The supplied string must feature a leading '#' character, and be 9
   * characters long.
   *
   * \param rgba the hexadecimal RGBA color string, using the format "#RRGGBBAA".
   *
   * \return a corresponding color; `std::nullopt` if something goes wrong.
   *
   * \see `from_rgb()`
   * \see `from_argb()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] static auto from_rgba(const std::string_view rgba) -> std::optional<color>
  {
    if (rgba.length() != 9 || rgba.at(0) != '#') {
      return std::nullopt;
    }

    const auto noHash = rgba.substr(1);

    const auto rr = noHash.substr(0, 2);
    const auto gg = noHash.substr(2, 2);
    const auto bb = noHash.substr(4, 2);
    const auto aa = noHash.substr(6, 2);

    const auto red = detail::from_string<u8>(rr, 16);
    const auto green = detail::from_string<u8>(gg, 16);
    const auto blue = detail::from_string<u8>(bb, 16);
    const auto alpha = detail::from_string<u8>(aa, 16);

    if (red && green && blue && alpha) {
      return cen::color{*red, *green, *blue, *alpha};
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Creates a color from a hexadecimal ARGB color string.
   *
   * \details The supplied string must feature a leading '#' character, and be 9
   * characters long.
   *
   * \param argb the hexadecimal ARGB color string, using the format "#AARRGGBB".
   *
   * \return a corresponding color; `std::nullopt` if something goes wrong.
   *
   * \see `from_rgb()`
   * \see `from_rgba()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] static auto from_argb(const std::string_view argb) -> std::optional<color>
  {
    if (argb.length() != 9 || argb.at(0) != '#') {
      return std::nullopt;
    }

    const auto noHash = argb.substr(1);

    const auto aa = noHash.substr(0, 2);
    const auto rr = noHash.substr(2, 2);
    const auto gg = noHash.substr(4, 2);
    const auto bb = noHash.substr(6, 2);

    const auto alpha = detail::from_string<u8>(aa, 16);
    const auto red = detail::from_string<u8>(rr, 16);
    const auto green = detail::from_string<u8>(gg, 16);
    const auto blue = detail::from_string<u8>(bb, 16);

    if (alpha && red && green && blue) {
      return cen::color{*red, *green, *blue, *alpha};
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Creates a color from normalized color component values.
   *
   * \note The color components will be clamped to the range [0, 1].
   *
   * \param red the red component value, in the range [0, 1].
   * \param green the green component value, in the range [0, 1].
   * \param blue the blue component value, in the range [0, 1].
   * \param alpha the alpha component value, in the range [0, 1].
   *
   * \return a color with the supplied color components.
   *
   * \since 6.1.0
   */
  [[nodiscard]] static auto from_norm(float red,
                                      float green,
                                      float blue,
                                      float alpha = 1.0f) noexcept(on_msvc()) -> color
  {
    red = detail::clamp(red, 0.0f, 1.0f);
    green = detail::clamp(green, 0.0f, 1.0f);
    blue = detail::clamp(blue, 0.0f, 1.0f);
    alpha = detail::clamp(alpha, 0.0f, 1.0f);

    const auto r = static_cast<u8>(std::round(red * 255.0f));
    const auto g = static_cast<u8>(std::round(green * 255.0f));
    const auto b = static_cast<u8>(std::round(blue * 255.0f));
    const auto a = static_cast<u8>(std::round(alpha * 255.0f));

    return color{r, g, b, a};
  }

  /// \} End of construction

  /// \name Setters
  /// \{

  /**
   * \brief Sets the value of the red component.
   *
   * \param red the new value of the red component.
   *
   * \since 3.0.0
   */
  constexpr void set_red(const u8 red) noexcept
  {
    m_color.r = red;
  }

  /**
   * \brief Sets the value of the green component.
   *
   * \param green the new value of the green component.
   *
   * \since 3.0.0
   */
  constexpr void set_green(const u8 green) noexcept
  {
    m_color.g = green;
  }

  /**
   * \brief Sets the value of the blue component.
   *
   * \param blue the new value of the blue component.
   *
   * \since 3.0.0
   */
  constexpr void set_blue(const u8 blue) noexcept
  {
    m_color.b = blue;
  }

  /**
   * \brief Sets the value of the alpha component.
   *
   * \param alpha the new value of the alpha component.
   *
   * \since 3.0.0
   */
  constexpr void set_alpha(const u8 alpha) noexcept
  {
    m_color.a = alpha;
  }

  /// \} End of setters

  /// \name Getters
  /// \{

  /**
   * \brief Returns the value of the red component.
   *
   * \return the value of the red component, in the range [0, 255].
   *
   * \since 3.0.0
   */
  [[nodiscard]] constexpr auto red() const noexcept -> u8
  {
    return m_color.r;
  }

  /**
   * \brief Returns the value of the green component.
   *
   * \return the value of the green component, in the range [0, 255].
   *
   * \since 3.0.0
   */
  [[nodiscard]] constexpr auto green() const noexcept -> u8
  {
    return m_color.g;
  }

  /**
   * \brief Returns the value of the blue component.
   *
   * \return the value of the blue component, in the range [0, 255].
   *
   * \since 3.0.0
   */
  [[nodiscard]] constexpr auto blue() const noexcept -> u8
  {
    return m_color.b;
  }

  /**
   * \brief Returns the value of the alpha component.
   *
   * \return the value of the alpha component, in the range [0, 255].
   *
   * \since 3.0.0
   */
  [[nodiscard]] constexpr auto alpha() const noexcept -> u8
  {
    return m_color.a;
  }

  /**
   * \brief Returns the normalized red component of the color.
   *
   * \return the red component value, in the range [0, 1].
   *
   * \since 6.1.0
   */
  [[nodiscard]] constexpr auto red_norm() const noexcept -> float
  {
    return static_cast<float>(m_color.r) / 255.0f;
  }

  /**
   * \brief Returns the normalized green component of the color.
   *
   * \return the green component value, in the range [0, 1].
   *
   * \since 6.1.0
   */
  [[nodiscard]] constexpr auto green_norm() const noexcept -> float
  {
    return static_cast<float>(m_color.g) / 255.0f;
  }

  /**
   * \brief Returns the normalized blue component of the color.
   *
   * \return the blue component value, in the range [0, 1].
   *
   * \since 6.1.0
   */
  [[nodiscard]] constexpr auto blue_norm() const noexcept -> float
  {
    return static_cast<float>(m_color.b) / 255.0f;
  }

  /**
   * \brief Returns the normalized alpha component of the color.
   *
   * \return the alpha component value, in the range [0, 1].
   *
   * \since 6.1.0
   */
  [[nodiscard]] constexpr auto alpha_norm() const noexcept -> float
  {
    return static_cast<float>(m_color.a) / 255.0f;
  }

  /**
   * \brief Returns a pointer to the internal SDL color.
   *
   * \warning Do not cache the returned pointer!
   *
   * \return a pointer to the internal color instance.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto data() noexcept -> SDL_Color*
  {
    return &m_color;
  }

  /// \copydoc data()
  [[nodiscard]] auto data() const noexcept -> const SDL_Color*
  {
    return &m_color;
  }

  /**
   * \brief Returns the internal color instance.
   *
   * \return a reference to the internal color.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get() const noexcept -> const SDL_Color&
  {
    return m_color;
  }

  /// \} End of getters

  /// \name Color string conversions
  /// \{

  /**
   * \brief Returns a hexadecimal RGB color string that represents the color.
   *
   * \details The returned string is guaranteed to use uppercase hexadecimal digits (A-F).
   *
   * \return a hexadecimal color string representation, on the format "#RRGGBB".
   *
   * \see `as_rgba()`
   * \see `as_argb()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto as_rgb() const -> std::string
  {
    std::stringstream stream;
    stream << std::setfill('0') << std::hex << std::uppercase;

    stream << '#';
    stream << std::setw(2) << +m_color.r;
    stream << std::setw(2) << +m_color.g;
    stream << std::setw(2) << +m_color.b;

    return stream.str();
  }

  /**
   * \brief Returns a hexadecimal RGBA color string that represents the color.
   *
   * \details The returned string is guaranteed to use uppercase hexadecimal digits (A-F).
   *
   * \return a hexadecimal color string representation, on the format "#RRGGBBAA".
   *
   * \see `as_rgb()`
   * \see `as_argb()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto as_rgba() const -> std::string
  {
    std::stringstream stream;
    stream << std::setfill('0') << std::hex << std::uppercase;

    stream << '#';
    stream << std::setw(2) << +m_color.r;
    stream << std::setw(2) << +m_color.g;
    stream << std::setw(2) << +m_color.b;
    stream << std::setw(2) << +m_color.a;

    return stream.str();
  }

  /**
   * \brief Returns a hexadecimal ARGB color string that represents the color.
   *
   * \details The returned string is guaranteed to use uppercase hexadecimal digits (A-F).
   *
   * \return a hexadecimal color string representation, on the format "#AARRGGBB".
   *
   * \see `as_rgb()`
   * \see `as_rgba()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto as_argb() const -> std::string
  {
    std::stringstream stream;
    stream << std::setfill('0') << std::hex << std::uppercase;

    stream << '#';
    stream << std::setw(2) << +m_color.a;
    stream << std::setw(2) << +m_color.r;
    stream << std::setw(2) << +m_color.g;
    stream << std::setw(2) << +m_color.b;

    return stream.str();
  }

  /// \} End of color string conversions

  /// \name Conversions
  /// \{

  /**
   * \brief Converts the the color into an `SDL_Color`.
   *
   * \return an `SDL_Color` that is equivalent to this color.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit constexpr operator SDL_Color() const noexcept
  {
    return {red(), green(), blue(), alpha()};
  }

  /**
   * \brief Converts the the color into an `SDL_MessageBoxColor`.
   *
   * \note Message box colors don't feature an alpha value!
   *
   * \return an `SDL_MessageBoxColor` that is equivalent to this color.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit constexpr operator SDL_MessageBoxColor() const noexcept
  {
    return {red(), green(), blue()};
  }

  /**
   * \brief Converts the color to `SDL_Color*`.
   *
   * \warning The returned pointer is not to be freed or stored away!
   *
   * \return a pointer to the internal color instance.
   *
   * \since 4.0,0
   */
  [[nodiscard]] explicit operator SDL_Color*() noexcept
  {
    return &m_color;
  }

  /**
   * \brief Converts the color to `const SDL_Color*`.
   *
   * \warning The returned pointer is not to be freed or stored away!
   *
   * \return a pointer to the internal color instance.
   *
   * \since 4.0,0
   */
  [[nodiscard]] explicit operator const SDL_Color*() const noexcept
  {
    return &m_color;
  }

  /// \} End of conversions

  /**
   * \brief Serializes the color.
   *
   * \details This function expects that the archive provides an overloaded `operator()`,
   * used for serializing data. This API is based on the Cereal serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the color.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_color.r, m_color.g, m_color.b, m_color.a);
  }

  /**
   * \brief Returns a copy of the color with the specified alpha value.
   *
   * \param alpha the alpha component value that will be used by the new color.
   *
   * \return a color that is identical to the color except for the alpha component.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto with_alpha(const u8 alpha) const noexcept -> color
  {
    return {red(), green(), blue(), alpha};
  }

  /**
   * \brief Returns the maximum possible value of a color component.
   *
   * \return the maximum possible value of a color component.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr static auto max() noexcept -> u8
  {
    return 0xFF;
  }

 private:
  SDL_Color m_color{0, 0, 0, max()};
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of the color.
 *
 * \param color the color that will be converted.
 *
 * \return a textual representation of the color.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto to_string(const color& color) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("color{{r: {}, g: {}, b: {}: a: {}}}",
                     +color.red(),
                     +color.green(),
                     +color.blue(),
                     +color.alpha());
#else
  return "color{r: " + std::to_string(color.red()) + ", g: " + std::to_string(color.green()) +
         ", b: " + std::to_string(color.blue()) + ", a: " + std::to_string(color.alpha()) +
         "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a color.
 *
 * \param stream the stream that will be used.
 * \param color the color that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
inline auto operator<<(std::ostream& stream, const color& color) -> std::ostream&
{
  return stream << to_string(color);
}

/// \} End of streaming

/**
 * \brief Blends two colors according to the specified bias.
 *
 * \pre `bias` should be in the range [0, 1].
 *
 * \details This function applies a linear interpolation for each color component to
 * obtain the blended color. The bias parameter is the "alpha" for the interpolation,
 * which determines how the input colors are blended. For example, a bias of 0 or 1 will
 * simply result in the first or second color being returned, respectively.
 * Subsequently, a bias of 0.5 will blend the two colors evenly.
 *
 * \param a the first color.
 * \param b the second color.
 * \param bias the bias that determines how the colors are blended, in the range [0, 1].
 *
 * \return a color obtained by blending the two supplied colors.
 *
 * \todo Default the bias to 0.5 when the `double` overload has been removed.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto blend(const color& a, const color& b, const float bias) -> color
{
  assert(bias >= 0);
  assert(bias <= 1.0f);

  const auto red = detail::lerp(a.red_norm(), b.red_norm(), bias);
  const auto green = detail::lerp(a.green_norm(), b.green_norm(), bias);
  const auto blue = detail::lerp(a.blue_norm(), b.blue_norm(), bias);
  const auto alpha = detail::lerp(a.alpha_norm(), b.alpha_norm(), bias);

  return color::from_norm(red, green, blue, alpha);
}

/// \copydoc blend()
/// \deprecated Since 6.2.0, use the overload using a `float` bias parameter instead.
[[nodiscard, deprecated]] inline auto blend(const color& a,
                                            const color& b,
                                            const double bias = 0.5) -> color
{
  return blend(a, b, static_cast<float>(bias));
}

/// \name Color comparison operators
/// \{

/**
 * \brief Indicates whether or not the two colors are equal.
 *
 * \param lhs the left-hand side color.
 * \param rhs the right-hand side color.
 *
 * \return `true` if the colors are equal; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const color& lhs, const color& rhs) noexcept -> bool
{
  return (lhs.red() == rhs.red()) && (lhs.green() == rhs.green()) &&
         (lhs.blue() == rhs.blue()) && (lhs.alpha() == rhs.alpha());
}

/// \copydoc operator==(const color&, const color&)
[[nodiscard]] constexpr auto operator==(const color& lhs, const SDL_Color& rhs) noexcept
    -> bool
{
  return (lhs.red() == rhs.r) && (lhs.green() == rhs.g) && (lhs.blue() == rhs.b) &&
         (lhs.alpha() == rhs.a);
}

/// \copydoc operator==(const color&, const color&)
[[nodiscard]] constexpr auto operator==(const SDL_Color& lhs, const color& rhs) noexcept
    -> bool
{
  return rhs == lhs;
}

/**
 * \copybrief operator==(const color&, const color&)
 *
 * \note The alpha components are not taken into account.
 *
 * \param lhs the left-hand side color.
 * \param rhs the right-hand side color.
 *
 * \return `true` if the colors are equal; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const color& lhs,
                                        const SDL_MessageBoxColor& rhs) noexcept -> bool
{
  return (lhs.red() == rhs.r) && (lhs.green() == rhs.g) && (lhs.blue() == rhs.b);
}

/// \copydoc operator==(const color&, const SDL_MessageBoxColor&)
[[nodiscard]] constexpr auto operator==(const SDL_MessageBoxColor& lhs,
                                        const color& rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the two colors aren't equal.
 *
 * \param lhs the left-hand side color.
 * \param rhs the right-hand side color.
 *
 * \return `true` if the colors aren't equal; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator!=(const color& lhs, const color& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const color&, const color&)
[[nodiscard]] constexpr auto operator!=(const color& lhs, const SDL_Color& rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const color&, const color&)
[[nodiscard]] constexpr auto operator!=(const SDL_Color& lhs, const color& rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/**
 * \copybrief operator!=(const color&, const color&)
 *
 * \note The alpha components are not taken into account.
 *
 * \param lhs the left-hand side color.
 * \param rhs the right-hand side color.
 *
 * \return `true` if the colors aren't equal; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator!=(const color& lhs,
                                        const SDL_MessageBoxColor& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const color&, const SDL_MessageBoxColor&)
[[nodiscard]] constexpr auto operator!=(const SDL_MessageBoxColor& lhs,
                                        const color& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of color comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_COLOR_HEADER

// #include "button_state.hpp"
#ifndef CENTURION_BUTTON_STATE_HEADER
#define CENTURION_BUTTON_STATE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum button_state
 *
 * \ingroup input
 *
 * \brief Represents the two possible states for a button.
 *
 * \details Corresponds to the `SDL_RELEASED` and `SDL_PRESSED` macros.
 *
 * \since 3.1.0
 */
enum class button_state : u8
{
  released = SDL_RELEASED,  ///< Corresponds to `SDL_RELEASED`.
  pressed = SDL_PRESSED     ///< Corresponds to `SDL_PRESSED`.
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied button state.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(button_state::released) == "released"`.
 *
 * \param state the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const button_state state) -> std::string_view
{
  switch (state) {
    case button_state::released:
      return "released";

    case button_state::pressed:
      return "pressed";

    default:
      throw cen_error{"Did not recognize button state!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a button state enumerator.
 *
 * \param stream the output stream that will be used.
 * \param state the enumerator that will be printed.
 *
 * \see `to_string(button_state)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const button_state state) -> std::ostream&
{
  return stream << to_string(state);
}

/// \} End of streaming

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_BUTTON_STATE_HEADER
// #include "controller_axis.hpp"
#ifndef CENTURION_CONTROLLER_AXIS_HEADER
#define CENTURION_CONTROLLER_AXIS_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum controller_axis
 *
 * \brief Represents different game controller axes.
 *
 * \see `SDL_GameControllerAxis`
 *
 * \since 4.0.0
 */
enum class controller_axis
{
  invalid = SDL_CONTROLLER_AXIS_INVALID,
  left_x = SDL_CONTROLLER_AXIS_LEFTX,
  left_y = SDL_CONTROLLER_AXIS_LEFTY,
  right_x = SDL_CONTROLLER_AXIS_RIGHTX,
  right_y = SDL_CONTROLLER_AXIS_RIGHTY,
  trigger_left = SDL_CONTROLLER_AXIS_TRIGGERLEFT,
  trigger_right = SDL_CONTROLLER_AXIS_TRIGGERRIGHT,
  max = SDL_CONTROLLER_AXIS_MAX
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied controller axis.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(controller_axis::right_x) == "right_x"`.
 *
 * \param axis the controller axis that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const controller_axis axis) -> std::string_view
{
  switch (axis) {
    case controller_axis::invalid:
      return "invalid";

    case controller_axis::left_x:
      return "left_x";

    case controller_axis::left_y:
      return "left_y";

    case controller_axis::right_x:
      return "right_x";

    case controller_axis::right_y:
      return "right_y";

    case controller_axis::trigger_left:
      return "trigger_left";

    case controller_axis::trigger_right:
      return "trigger_right";

    case controller_axis::max:
      return "max";

    default:
      throw cen_error{"Did not recognize controller axis!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a controller axis enumerator.
 *
 * \param stream the output stream that will be used.
 * \param axis the controller axis that will be printed.
 *
 * \see `to_string(controller_axis)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const controller_axis axis) -> std::ostream&
{
  return stream << to_string(axis);
}

/// \} End of streaming

/// \name Controller axis comparison operators
/// \{

/**
 * \brief Indicates whether or not two game controller axis values are the same.
 *
 * \param lhs the left-hand-side game controller axis value.
 * \param rhs the right-hand-side game controller axis value.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator==(const controller_axis lhs,
                                        const SDL_GameControllerAxis rhs) noexcept -> bool
{
  return static_cast<SDL_GameControllerAxis>(lhs) == rhs;
}

/// \copydoc operator==(controller_axis, SDL_GameControllerAxis)
[[nodiscard]] constexpr auto operator==(const SDL_GameControllerAxis lhs,
                                        const controller_axis rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two game controller axis values aren't the
 * same.
 *
 * \param lhs the left-hand-side game controller axis value.
 * \param rhs the right-hand-side game controller axis value.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator!=(const controller_axis lhs,
                                        const SDL_GameControllerAxis rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(controller_axis, SDL_GameControllerAxis)
[[nodiscard]] constexpr auto operator!=(const SDL_GameControllerAxis lhs,
                                        const controller_axis rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of controller axis comparison operators

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_CONTROLLER_AXIS_HEADER

// #include "controller_bind_type.hpp"
#ifndef CENTURION_CONTROLLER_BIND_TYPE_HEADER
#define CENTURION_CONTROLLER_BIND_TYPE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum controller_bind_type
 *
 * \brief Represents different game controller bind types.
 *
 * \see `SDL_GameControllerBindType`
 *
 * \since 5.0.0
 */
enum class controller_bind_type
{
  none = SDL_CONTROLLER_BINDTYPE_NONE,
  button = SDL_CONTROLLER_BINDTYPE_BUTTON,
  axis = SDL_CONTROLLER_BINDTYPE_AXIS,
  hat = SDL_CONTROLLER_BINDTYPE_HAT
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied controller bind type.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(controller_bind_type::button) == "button"`.
 *
 * \param type the controller bind type that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const controller_bind_type type) -> std::string_view
{
  switch (type) {
    case controller_bind_type::none:
      return "none";

    case controller_bind_type::button:
      return "button";

    case controller_bind_type::axis:
      return "axis";

    case controller_bind_type::hat:
      return "hat";

    default:
      throw cen_error{"Did not recognzie controller bind type!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a controller bind type enumerator.
 *
 * \param stream the output stream that will be used.
 * \param type the controller bind type that will be printed.
 *
 * \see `to_string(controller_bind_type)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const controller_bind_type type) -> std::ostream&
{
  return stream << to_string(type);
}

/// \} End of streaming

/// \name Controller bind type comparison operators
/// \{

/**
 * \brief Indicates whether or not two controller bind type values are the same.
 *
 * \param lhs the left-hand-side controller bind type value.
 * \param rhs the right-hand-side controller bind type value.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator==(const controller_bind_type lhs,
                                        const SDL_GameControllerBindType rhs) noexcept -> bool
{
  return static_cast<SDL_GameControllerBindType>(lhs) == rhs;
}

/// \copydoc operator==(controller_bind_type, SDL_GameControllerBindType)
[[nodiscard]] constexpr auto operator==(const SDL_GameControllerBindType lhs,
                                        const controller_bind_type rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two controller bind type values aren't the
 * same.
 *
 * \param lhs the left-hand-side controller bind type value.
 * \param rhs the right-hand-side controller bind type value.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator!=(const controller_bind_type lhs,
                                        const SDL_GameControllerBindType rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(controller_bind_type, SDL_GameControllerBindType)
[[nodiscard]] constexpr auto operator!=(const SDL_GameControllerBindType lhs,
                                        const controller_bind_type rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of controller bind type comparison operators

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_CONTROLLER_BIND_TYPE_HEADER

// #include "controller_button.hpp"
#ifndef CENTURION_CONTROLLER_BUTTON_HEADER
#define CENTURION_CONTROLLER_BUTTON_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum controller_button
 *
 * \brief Represents different game controller buttons.
 *
 * \see `SDL_GameControllerButton`
 *
 * \since 4.0.0
 */
enum class controller_button
{
  invalid = SDL_CONTROLLER_BUTTON_INVALID,
  a = SDL_CONTROLLER_BUTTON_A,
  b = SDL_CONTROLLER_BUTTON_B,
  x = SDL_CONTROLLER_BUTTON_X,
  y = SDL_CONTROLLER_BUTTON_Y,
  back = SDL_CONTROLLER_BUTTON_BACK,
  guide = SDL_CONTROLLER_BUTTON_GUIDE,
  start = SDL_CONTROLLER_BUTTON_START,
  left_stick = SDL_CONTROLLER_BUTTON_LEFTSTICK,
  right_stick = SDL_CONTROLLER_BUTTON_RIGHTSTICK,
  left_shoulder = SDL_CONTROLLER_BUTTON_LEFTSHOULDER,
  right_shoulder = SDL_CONTROLLER_BUTTON_RIGHTSHOULDER,
  dpad_up = SDL_CONTROLLER_BUTTON_DPAD_UP,
  dpad_down = SDL_CONTROLLER_BUTTON_DPAD_DOWN,
  dpad_left = SDL_CONTROLLER_BUTTON_DPAD_LEFT,
  dpad_right = SDL_CONTROLLER_BUTTON_DPAD_RIGHT,

#if SDL_VERSION_ATLEAST(2, 0, 14)

  // clang-format off
  misc1 = SDL_CONTROLLER_BUTTON_MISC1, ///< Xbox Series X share button, PS5 microphone button, Nintendo Switch Pro capture button
  // clang-format on

  paddle1 = SDL_CONTROLLER_BUTTON_PADDLE1,    ///< Xbox Elite paddle P1
  paddle2 = SDL_CONTROLLER_BUTTON_PADDLE2,    ///< Xbox Elite paddle P3
  paddle3 = SDL_CONTROLLER_BUTTON_PADDLE3,    ///< Xbox Elite paddle P2
  paddle4 = SDL_CONTROLLER_BUTTON_PADDLE4,    ///< Xbox Elite paddle P4
  touchpad = SDL_CONTROLLER_BUTTON_TOUCHPAD,  ///< PS4/PS5 touchpad button

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  max = SDL_CONTROLLER_BUTTON_MAX
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied controller button.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(controller_button::start) == "start"`.
 *
 * \param button the controller button that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const controller_button button) -> std::string_view
{
  switch (button) {
    case controller_button::invalid:
      return "invalid";

    case controller_button::a:
      return "a";

    case controller_button::b:
      return "b";

    case controller_button::x:
      return "x";

    case controller_button::y:
      return "y";

    case controller_button::back:
      return "back";

    case controller_button::guide:
      return "guide";

    case controller_button::start:
      return "start";

    case controller_button::left_stick:
      return "left_stick";

    case controller_button::right_stick:
      return "right_stick";

    case controller_button::left_shoulder:
      return "left_shoulder";

    case controller_button::right_shoulder:
      return "right_shoulder";

    case controller_button::dpad_up:
      return "dpad_up";

    case controller_button::dpad_down:
      return "dpad_down";

    case controller_button::dpad_left:
      return "dpad_left";

    case controller_button::dpad_right:
      return "dpad_right";

#if SDL_VERSION_ATLEAST(2, 0, 14)

    case controller_button::misc1:
      return "misc1";

    case controller_button::paddle1:
      return "paddle1";

    case controller_button::paddle2:
      return "paddle2";

    case controller_button::paddle3:
      return "paddle3";

    case controller_button::paddle4:
      return "paddle4";

    case controller_button::touchpad:
      return "touchpad";

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

    case controller_button::max:
      return "max";

    default:
      throw cen_error{"Did not recognize controller button!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a controller button enumerator.
 *
 * \param stream the output stream that will be used.
 * \param button the controller button that will be printed.
 *
 * \see `to_string(controller_button)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const controller_button button) -> std::ostream&
{
  return stream << to_string(button);
}

/// \} End of streaming

/// \name Controller button comparison operators
/// \{

/**
 * \brief Indicates whether or not two game controller button values are the
 * same.
 *
 * \param lhs the left-hand side game controller button value.
 * \param rhs the right-hand side game controller button value.
 *
 * \return `true` if the game controller button values are the same; `false`
 * otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator==(const controller_button lhs,
                                        const SDL_GameControllerButton rhs) noexcept -> bool
{
  return static_cast<SDL_GameControllerButton>(lhs) == rhs;
}

/// \copydoc operator==(controller_button, SDL_GameControllerButton)
[[nodiscard]] constexpr auto operator==(const SDL_GameControllerButton lhs,
                                        const controller_button rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two game controller button values aren't the
 * same.
 *
 * \param lhs the left-hand side game controller button value.
 * \param rhs the right-hand side game controller button value.
 *
 * \return `true` if the game controller button values aren't the same; `false`
 * otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator!=(const controller_button lhs,
                                        const SDL_GameControllerButton rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(controller_button, SDL_GameControllerButton)
[[nodiscard]] constexpr auto operator!=(const SDL_GameControllerButton lhs,
                                        const controller_button rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of controller button comparison operators

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_CONTROLLER_BUTTON_HEADER

// #include "controller_type.hpp"
#ifndef CENTURION_CONTROLLER_TYPE_HEADER
#define CENTURION_CONTROLLER_TYPE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup input
/// \{

#if SDL_VERSION_ATLEAST(2, 0, 12)

/**
 * \enum controller_type
 *
 * \brief Represents different game controller types.
 *
 * \see `SDL_GameControllerType`
 *
 * \since 5.0.0
 */
enum class controller_type
{
  // clang-format off
  unknown = SDL_CONTROLLER_TYPE_UNKNOWN,   ///< An unknown controller.
  xbox_360 = SDL_CONTROLLER_TYPE_XBOX360,  ///< An Xbox 360 controller.
  xbox_one = SDL_CONTROLLER_TYPE_XBOXONE,  ///< An Xbox One controller.
  ps3 = SDL_CONTROLLER_TYPE_PS3,           ///< A PS3 controller.
  ps4 = SDL_CONTROLLER_TYPE_PS4,           ///< A PS4 controller.

#if SDL_VERSION_ATLEAST(2, 0, 14)

  ps5 = SDL_CONTROLLER_TYPE_PS5,       ///< A PS5 controller.
  virt = SDL_CONTROLLER_TYPE_VIRTUAL,  ///< A virtual controller.

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

#if SDL_VERSION_ATLEAST(2, 0, 16)

  amazon_luna = SDL_CONTROLLER_TYPE_AMAZON_LUNA,     ///< An Amazon Luna controller.
  google_stadia = SDL_CONTROLLER_TYPE_GOOGLE_STADIA, ///< A Google Stadia controller.

#endif // SDL_VERSION_ATLEAST(2, 0, 16)

  nintendo_switch_pro = SDL_CONTROLLER_TYPE_NINTENDO_SWITCH_PRO  ///< A Nintendo Switch Pro controller.
  // clang-format on
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied controller type.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(controller_type::ps4) == "ps4"`.
 *
 * \param type the controller type that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const controller_type type) -> std::string_view
{
  switch (type) {
    case controller_type::unknown:
      return "unknown";

    case controller_type::nintendo_switch_pro:
      return "nintendo_switch_pro";

    case controller_type::xbox_360:
      return "xbox_360";

    case controller_type::xbox_one:
      return "xbox_one";

    case controller_type::ps3:
      return "ps3";

    case controller_type::ps4:
      return "ps4";

#if SDL_VERSION_ATLEAST(2, 0, 14)

    case controller_type::ps5:
      return "ps5";

    case controller_type::virt:
      return "virt";

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

#if SDL_VERSION_ATLEAST(2, 0, 16)

    case controller_type::amazon_luna:
      return "amazon_luna";

    case controller_type::google_stadia:
      return "google_stadia";

#endif  // SDL_VERSION_ATLEAST(2, 0, 16)

    default:
      throw cen_error{"Did not recognize controller type!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a controller type enumerator.
 *
 * \param stream the output stream that will be used.
 * \param type the controller type that will be printed.
 *
 * \see `to_string(controller_type)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const controller_type type) -> std::ostream&
{
  return stream << to_string(type);
}

/// \} End of streaming

/// \name Controller type comparison operators
/// \{

/**
 * \brief Indicates whether or not to controller type values are the same.
 *
 * \param lhs the left-hand side controller type value.
 * \param rhs the right-hand side controller type value.
 *
 * \return `true` if the controller type values are the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator==(const controller_type lhs,
                                        const SDL_GameControllerType rhs) noexcept -> bool
{
  return static_cast<SDL_GameControllerType>(lhs) == rhs;
}

/// \copydoc operator==(controller_type, SDL_GameControllerType)
[[nodiscard]] constexpr auto operator==(const SDL_GameControllerType lhs,
                                        const controller_type rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not to controller type values aren't the same.
 *
 * \param lhs the left-hand side controller type value.
 * \param rhs the right-hand side controller type value.
 *
 * \return `true` if the controller type values aren't the same; `false`
 * otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator!=(const controller_type lhs,
                                        const SDL_GameControllerType rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(controller_type, SDL_GameControllerType)
[[nodiscard]] constexpr auto operator!=(const SDL_GameControllerType lhs,
                                        const controller_type rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of controller type comparison operators

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_CONTROLLER_TYPE_HEADER

// #include "joystick.hpp"
#ifndef CENTURION_JOYSTICK_HEADER
#define CENTURION_JOYSTICK_HEADER

#include <SDL.h>

#include <cassert>   // assert
#include <optional>  // optional
#include <ostream>   // ostream
#include <string>    // string, to_string

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/not_null.hpp"

// #include "../core/owner.hpp"

// #include "../core/result.hpp"

// #include "../core/str.hpp"

// #include "../core/str_or_na.hpp"

// #include "../core/time.hpp"

// #include "../core/to_underlying.hpp"
#ifndef CENTURION_TO_UNDERLYING_HEADER
#define CENTURION_TO_UNDERLYING_HEADER

#include <type_traits>  // underlying_type_t, enable_if_t, is_enum_v

namespace cen {

/**
 * \brief Converts an enum value to an integral value using the underlying type.
 *
 * \ingroup core
 *
 * \note If you're using C++23, see `std::to_underlying()`.
 *
 * \tparam Enum the enum type.
 *
 * \param value the enum value that will be converted.
 *
 * \return the value of the enum, in the underlying type.
 *
 * \since 6.0.0
 */
template <typename Enum, std::enable_if_t<std::is_enum_v<Enum>, int> = 0>
[[nodiscard]] constexpr auto to_underlying(const Enum value) noexcept
    -> std::underlying_type_t<Enum>
{
  return static_cast<std::underlying_type_t<Enum>>(value);
}

}  // namespace cen

#endif  // CENTURION_TO_UNDERLYING_HEADER

// #include "../detail/address_of.hpp"

// #include "../detail/owner_handle_api.hpp"

// #include "../detail/sdl_version_at_least.hpp"

// #include "../video/color.hpp"

// #include "button_state.hpp"

// #include "hat_state.hpp"
#ifndef CENTURION_HAT_STATE_HEADER
#define CENTURION_HAT_STATE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum hat_state
 *
 * \brief Represents the various states of a joystick "hat".
 *
 * \since 4.2.0
 */
enum class hat_state : u8
{
  centered = SDL_HAT_CENTERED,     ///< The hat is centered.
  up = SDL_HAT_UP,                 ///< The hat is directed "north".
  right = SDL_HAT_RIGHT,           ///< The hat is directed "east".
  down = SDL_HAT_DOWN,             ///< The hat is directed "south".
  left = SDL_HAT_LEFT,             ///< The hat is directed "west".
  right_up = SDL_HAT_RIGHTUP,      ///< The hat is directed "north-east".
  right_down = SDL_HAT_RIGHTDOWN,  ///< The hat is directed "south-east".
  left_up = SDL_HAT_LEFTUP,        ///< The hat is directed "north-west".
  left_down = SDL_HAT_LEFTDOWN,    ///< The hat is directed "south-west".
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied hat state.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(hat_state::down) == "down"`.
 *
 * \param state the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const hat_state state) -> std::string_view
{
  switch (state) {
    case hat_state::centered:
      return "centered";

    case hat_state::up:
      return "up";

    case hat_state::right:
      return "right";

    case hat_state::down:
      return "down";

    case hat_state::left:
      return "left";

    case hat_state::right_up:
      return "right_up";

    case hat_state::right_down:
      return "right_down";

    case hat_state::left_up:
      return "left_up";

    case hat_state::left_down:
      return "left_down";

    default:
      throw cen_error{"Did not recognize hat state!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a hat state enumerator.
 *
 * \param stream the output stream that will be used.
 * \param state the enumerator that will be printed.
 *
 * \see `to_string(hat_state)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const hat_state state) -> std::ostream&
{
  return stream << to_string(state);
}

/// \} End of streaming

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_HAT_STATE_HEADER

// #include "joystick_power.hpp"
#ifndef CENTURION_JOYSTICK_POWER_HEADER
#define CENTURION_JOYSTICK_POWER_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum joystick_power
 *
 * \brief Represents different power states of a joystick.
 *
 * \since 4.2.0
 */
enum class joystick_power
{
  unknown = SDL_JOYSTICK_POWER_UNKNOWN,  ///< Unknown power level.
  empty = SDL_JOYSTICK_POWER_EMPTY,      ///< Indicates <= 5% power.
  low = SDL_JOYSTICK_POWER_LOW,          ///< Indicates <= 20% power.
  medium = SDL_JOYSTICK_POWER_MEDIUM,    ///< Indicates <= 70% power.
  full = SDL_JOYSTICK_POWER_FULL,        ///< Indicates <= 100% power.
  wired = SDL_JOYSTICK_POWER_WIRED,      ///< No need to worry about power.
  max = SDL_JOYSTICK_POWER_MAX
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied joystick power.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(joystick_power::medium) == "medium"`.
 *
 * \param power the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const joystick_power power) -> std::string_view
{
  switch (power) {
    case joystick_power::unknown:
      return "unknown";

    case joystick_power::empty:
      return "empty";

    case joystick_power::low:
      return "low";

    case joystick_power::medium:
      return "medium";

    case joystick_power::full:
      return "full";

    case joystick_power::wired:
      return "wired";

    case joystick_power::max:
      return "max";

    default:
      throw cen_error{"Did not recognize joystick power!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a joystick power enumerator.
 *
 * \param stream the output stream that will be used.
 * \param power the enumerator that will be printed.
 *
 * \see `to_string(joystick_power)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const joystick_power power) -> std::ostream&
{
  return stream << to_string(power);
}

/// \} End of streaming

/// \name Joystick power comparison operators
/// \{

/**
 * \brief Indicates whether or not two joystick power values are the same.
 *
 * \param lhs the left-hand side power type.
 * \param rhs the right-hand side power type.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator==(const joystick_power lhs,
                                        const SDL_JoystickPowerLevel rhs) noexcept -> bool
{
  return static_cast<SDL_JoystickPowerLevel>(lhs) == rhs;
}

/**
 * \brief Indicates whether or not two joystick power values are the same.
 *
 * \param lhs the left-hand side power type.
 * \param rhs the right-hand side power type.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator==(const SDL_JoystickPowerLevel lhs,
                                        const joystick_power rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two joystick power values aren't the same.
 *
 * \param lhs the left-hand side power type.
 * \param rhs the right-hand side power type.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator!=(const joystick_power lhs,
                                        const SDL_JoystickPowerLevel rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/**
 * \brief Indicates whether or not two joystick power values aren't the same.
 *
 * \param lhs the left-hand side power type.
 * \param rhs the right-hand side power type.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator!=(const SDL_JoystickPowerLevel lhs,
                                        const joystick_power rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of joystick power comparison operators

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_JOYSTICK_POWER_HEADER

// #include "joystick_type.hpp"
#ifndef CENTURION_JOYSTICK_TYPE_HEADER
#define CENTURION_JOYSTICK_TYPE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum joystick_type
 *
 * \brief Provides values that represent different types of "joysticks".
 *
 * \since 4.2.0
 */
enum class joystick_type
{
  unknown = SDL_JOYSTICK_TYPE_UNKNOWN,
  game_controller = SDL_JOYSTICK_TYPE_GAMECONTROLLER,
  wheel = SDL_JOYSTICK_TYPE_WHEEL,
  arcade_stick = SDL_JOYSTICK_TYPE_ARCADE_STICK,
  flight_stick = SDL_JOYSTICK_TYPE_FLIGHT_STICK,
  dance_pad = SDL_JOYSTICK_TYPE_DANCE_PAD,
  guitar = SDL_JOYSTICK_TYPE_GUITAR,
  drum_kit = SDL_JOYSTICK_TYPE_DRUM_KIT,
  arcade_pad = SDL_JOYSTICK_TYPE_ARCADE_PAD,
  throttle = SDL_JOYSTICK_TYPE_THROTTLE
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied joystick type.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(joystick_type::guitar) == "guitar"`.
 *
 * \param type the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const joystick_type type) -> std::string_view
{
  switch (type) {
    case joystick_type::unknown:
      return "unknown";

    case joystick_type::game_controller:
      return "game_controller";

    case joystick_type::wheel:
      return "wheel";

    case joystick_type::arcade_stick:
      return "arcade_stick";

    case joystick_type::flight_stick:
      return "flight_stick";

    case joystick_type::dance_pad:
      return "dance_pad";

    case joystick_type::guitar:
      return "guitar";

    case joystick_type::drum_kit:
      return "drum_kit";

    case joystick_type::arcade_pad:
      return "arcade_pad";

    case joystick_type::throttle:
      return "throttle";

    default:
      throw cen_error{"Did not recognize joystick type!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a joystick type enumerator.
 *
 * \param stream the output stream that will be used.
 * \param type the enumerator that will be printed.
 *
 * \see `to_string(joystick_type)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const joystick_type type) -> std::ostream&
{
  return stream << to_string(type);
}

/// \} End of streaming

/// \name Joystick type comparison operators
/// \{

/**
 * \brief Indicates whether or not two joystick type values are the same.
 *
 * \param lhs the left-hand side joystick type value.
 * \param rhs the right-hand side joystick type value.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator==(const joystick_type lhs,
                                        const SDL_JoystickType rhs) noexcept -> bool
{
  return static_cast<SDL_JoystickType>(lhs) == rhs;
}

/**
 * \brief Indicates whether or not two joystick type values are the same.
 *
 * \param lhs the left-hand side joystick type value.
 * \param rhs the right-hand side joystick type value.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator==(const SDL_JoystickType lhs,
                                        const joystick_type rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two joystick type values aren't the same.
 *
 * \param lhs the left-hand side joystick type value.
 * \param rhs the right-hand side joystick type value.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator!=(const joystick_type lhs,
                                        const SDL_JoystickType rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/**
 * \brief Indicates whether or not two joystick type values aren't the same.
 *
 * \param lhs the left-hand side joystick type value.
 * \param rhs the right-hand side joystick type value.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator!=(const SDL_JoystickType lhs,
                                        const joystick_type rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of joystick type comparison operators

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_JOYSTICK_TYPE_HEADER


namespace cen {

/// \addtogroup input
/// \{

/**
 * \struct ball_axis_change
 *
 * \brief Represents the difference in a joystick ball axis position.
 *
 * \since 4.2.0
 */
struct ball_axis_change final
{
  int dx;  ///< Difference in x-axis position since last poll.
  int dy;  ///< Difference in y-axis position since last poll.
};

template <typename T>
class basic_joystick;

/**
 * \typedef joystick
 *
 * \brief Represents an owning joystick.
 *
 * \since 5.0.0
 */
using joystick = basic_joystick<detail::owning_type>;

/**
 * \typedef joystick_handle
 *
 * \brief Represents a non-owning joystick.
 *
 * \since 5.0.0
 */
using joystick_handle = basic_joystick<detail::handle_type>;

/**
 * \class basic_joystick
 *
 * \brief Represents a joystick device.
 *
 * \ownerhandle `joystick`/`joystick_handle`
 *
 * \details The game controller API is built on top of the joystick API, which means that
 * the game controller is higher-level and easier to use.
 *
 * \since 4.2.0
 *
 * \see joystick
 * \see joystick_handle
 */
template <typename T>
class basic_joystick final
{
 public:
  /// \name Construction
  /// \{

  // clang-format off

  /**
   * \brief Creates a joystick instance based on an existing SDL joystick.
   *
   * \note The created instance will only claim ownership of the supplied pointer if the
   * class has owning semantics, i.e. if it's a `joystick` instance.
   *
   * \param joystick a pointer to the existing joystick.
   *
   * \throws cen_error if the supplied pointer is null and the joystick is owning.
   */
  explicit basic_joystick(maybe_owner<SDL_Joystick*> joystick) noexcept(!detail::is_owning<T>())
      : m_joystick{joystick}
  {
    if constexpr (detail::is_owning<T>())
    {
      if (!m_joystick)
      {
        throw cen_error{"Cannot create joystick from null pointer!"};
      }
    }
  }

  // clang-format on

  /**
   * \brief Creates an owning joystick based on a joystick device index.
   *
   * \param index the device index of the joystick.
   *
   * \throws sdl_error if the joystick couldn't be opened.
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_joystick(const int index = 0) : m_joystick{SDL_JoystickOpen(index)}
  {
    if (!m_joystick) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates a handle to an owning joystick.
   *
   * \param owner the owning joystick instance.
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit basic_joystick(const joystick& owner) noexcept : m_joystick{owner.get()}
  {}

  /**
   * \brief Returns a handle to the joystick associated with the specified ID.
   *
   * \param id the joystick ID associated with the desired joystick.
   *
   * \return a handle to the joystick associated with the supplied ID, might be empty.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  [[nodiscard]] static auto from_instance_id(const SDL_JoystickID id) noexcept
      -> joystick_handle
  {
    return joystick_handle{SDL_JoystickFromInstanceID(id)};
  }

#if SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Returns a handle to the joystick associated with the specified player index.
   *
   * \param playerIndex the player index of the desired joystick.
   *
   * \return a handle to the associated joystick, which might be empty.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  [[nodiscard]] static auto from_player_index(const int playerIndex) noexcept
      -> joystick_handle
  {
    return joystick_handle{SDL_JoystickFromPlayerIndex(playerIndex)};
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

  /// \} End of construction

  /**
   * \brief Makes the joystick rumble.
   *
   * \details Invoking this function cancels any previous rumble effects. This function
   * has no effect if the joystick doesn't support rumble effects.
   *
   * \param lowFreq the intensity of the low frequency (left) motor.
   * \param highFreq the intensity of the high frequency (right) motor.
   * \param duration the duration of the rumble effect, in milliseconds.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 4.2.0
   */
  auto rumble(const u16 lowFreq,
              const u16 highFreq,
              const milliseconds<u32> duration) noexcept(noexcept(duration.count())) -> result
  {
    return SDL_JoystickRumble(m_joystick, lowFreq, highFreq, duration.count()) == 0;
  }

#if SDL_VERSION_ATLEAST(2, 0, 14)

  // clang-format off

  /**
   * \brief Starts a rumble effect in the joystick's triggers.
   *
   * \details Calls to this function cancels any previously active rumble effect.
   * Furthermore, supplying 0 as intensities will stop the rumble effect.
   *
   * \param left the intensity used by the left rumble motor.
   * \param right the intensity used by the right rumble motor.
   * \param duration the duration of the rumble.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto rumble_triggers(const u16 left,
                       const u16 right,
                       const milliseconds<u32> duration) noexcept(noexcept(duration.count()))
      -> result
  {
    return SDL_JoystickRumbleTriggers(m_joystick,
                                      left,
                                      right,
                                      duration.count()) == 0;
  }

  // clang-format on

  /**
   * \brief Sets the color of the LED light, if the joystick has one.
   *
   * \param color the color that will be used by the LED, note that the alpha component is
   * ignored.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto set_led(const color& color) noexcept -> result
  {
    return SDL_JoystickSetLED(m_joystick, color.red(), color.green(), color.blue()) == 0;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

#if SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Sets the player index to be associated with the joystick.
   *
   * \param index the player index that will be used.
   *
   * \since 4.2.0
   */
  void set_player_index(const int index) noexcept
  {
    SDL_JoystickSetPlayerIndex(m_joystick, index);
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

#if SDL_VERSION_ATLEAST(2, 0, 16)

  /**
   * \brief Sends a packet of joystick specific data.
   *
   * \param data the data that will be sent.
   * \param size the size of the data.
   *
   * \return `success` if the data was sent successfully; `failure` if the joystick
   * or driver doesn't support effect packets.
   *
   * \since 6.2.0
   */
  auto send_effect(const void* data, const int size) -> result
  {
    return SDL_JoystickSendEffect(m_joystick, data, size) == 0;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 16)

  /// \name Virtual joystick API
  /// \{

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Attaches a new virtual joystick.
   *
   * \param type the type of the virtual joystick.
   * \param nAxes the number of axes.
   * \param nButtons the number of buttons.
   * \param nHats the number of joystick hats.
   *
   * \return the device index of the virtual joystick; `std::nullopt` if something went
   * wrong.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto attach_virtual(const joystick_type type,
                                           const int nAxes,
                                           const int nButtons,
                                           const int nHats) noexcept -> std::optional<int>
  {
    const auto index =
        SDL_JoystickAttachVirtual(static_cast<SDL_JoystickType>(type), nAxes, nButtons, nHats);
    if (index != -1) {
      return index;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Detaches a virtual joystick.
   *
   * \param index the device index of the virtual joystick.
   *
   * \return `success` if the joystick was successfully disconnected; `failure` otherwise.
   *
   * \since 5.2.0
   */
  static auto detach_virtual(const int index) noexcept -> result
  {
    return SDL_JoystickDetachVirtual(index) == 0;
  }

  /**
   * \brief Sets the value of a virtual joystick axis.
   *
   * \param axis the axis that will be modified.
   * \param value the new value of the axis.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto set_virtual_axis(const int axis, const i16 value) noexcept -> result
  {
    return SDL_JoystickSetVirtualAxis(m_joystick, axis, value) == 0;
  }

  /**
   * \brief Sets the state of a virtual button.
   *
   * \param button the index of the button that will be set.
   * \param state the new button state.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto set_virtual_button(const int button, const button_state state) noexcept -> result
  {
    return SDL_JoystickSetVirtualButton(m_joystick, button, to_underlying(state)) == 0;
  }

  /**
   * \brief Sets the state of a virtual joystick hat.
   *
   * \param hat the index of the hat that will be changed.
   * \param state the new state of the virtual joystick hat.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto set_virtual_hat(const int hat, const hat_state state) noexcept -> result
  {
    return SDL_JoystickSetVirtualHat(m_joystick, hat, to_underlying(state)) == 0;
  }

  /**
   * \brief Indicates whether or not a joystick is virtual.
   *
   * \param index the device index of the joystick that will be queried.
   *
   * \return `true` if the specified joystick is virtual; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto is_virtual(const int index) noexcept -> bool
  {
    return SDL_JoystickIsVirtual(index) == SDL_TRUE;
  }

#endif  // #if SDL_VERSION_ATLEAST(2, 0, 14)

  /// \} End of virtual joystick API

  /// \name Instance-based queries
  /// \{

  /**
   * \brief Returns the player index of the joystick, if available.
   *
   * \details For XInput controllers this returns the XInput user index.
   *
   * \return the player index associated with the joystick; `std::nullopt` if it can't be
   * obtained
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto player_index() const noexcept -> std::optional<int>
  {
    const auto index = SDL_JoystickGetPlayerIndex(m_joystick);
    if (index != -1) {
      return index;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the type associated with the joystick.
   *
   * \return the type of the joystick.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto type() const noexcept -> joystick_type
  {
    return static_cast<joystick_type>(SDL_JoystickGetType(m_joystick));
  }

  /**
   * \brief Returns the USB vendor ID of the joystick.
   *
   * \return the USB vendor ID associated with the joystick; `std::nullopt` if it isn't
   * available.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto vendor() const noexcept -> std::optional<u16>
  {
    const auto vendor = SDL_JoystickGetVendor(m_joystick);
    if (vendor != 0) {
      return vendor;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the USB product ID of the joystick.
   *
   * \return the USB product ID associated with the joystick; `std::nullopt` if it isn't
   * available.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto product() const noexcept -> std::optional<u16>
  {
    const auto product = SDL_JoystickGetProduct(m_joystick);
    if (product != 0) {
      return product;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the product version of the joystick, if available.
   *
   * \return the product version of the joystick; `std::nullopt` if it isn't available.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto product_version() const noexcept -> std::optional<u16>
  {
    const auto version = SDL_JoystickGetProductVersion(m_joystick);
    if (version != 0) {
      return version;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the GUID associated with the joystick.
   *
   * \note The GUID is implementation-dependent.
   *
   * \return the GUID associated with the joystick.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto guid() noexcept -> SDL_JoystickGUID
  {
    return SDL_JoystickGetGUID(m_joystick);
  }

  /**
   * \brief Returns the name associated with the joystick.
   *
   * \note If no name can be found, this function returns a null string.
   *
   * \return the name of the joystick; a null pointer if no name is found.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto name() const noexcept -> str
  {
    return SDL_JoystickName(m_joystick);
  }

  /**
   * \brief Returns the instance ID associated with the joystick.
   *
   * \return the instance ID associated with the joystick.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto instance_id() const noexcept -> SDL_JoystickID
  {
    return SDL_JoystickInstanceID(m_joystick);
  }

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Returns the serial number associated with the joystick.
   *
   * \return the serial number of the joystick; a null pointer is returned if the serial
   * number isn't available.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto serial() const noexcept -> str
  {
    return SDL_JoystickGetSerial(m_joystick);
  }

  /**
   * \brief Indicates whether or not the joystick features a LED light.
   *
   * \return `true` if the joystick features a LED light; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_led() const noexcept -> bool
  {
    return SDL_JoystickHasLED(m_joystick) == SDL_TRUE;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  /// \} End of instance-based queries

  /// \name Index-based queries
  /// \{

  /**
   * \brief Returns the player index of the joystick associated with the specified device
   * index.
   *
   * \note This function can be called before any joysticks are opened.
   *
   * \param deviceIndex the device index of the joystick that will be queried.
   *
   * \return the player index of the desired joystick; `std::nullopt` if it can't be
   * obtained.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto player_index(const int deviceIndex) noexcept -> std::optional<int>
  {
    const auto index = SDL_JoystickGetDevicePlayerIndex(deviceIndex);
    if (index != -1) {
      return index;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the type of the joystick associated with the specified device index.
   *
   * \param deviceIndex the device index of the joystick that will be queried.
   *
   * \return the type of the specified joystick.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto type(const int deviceIndex) noexcept -> joystick_type
  {
    return static_cast<joystick_type>(SDL_JoystickGetDeviceType(deviceIndex));
  }

  /**
   * \brief Returns the USB vendor ID for the joystick associated with the specified
   * device index.
   *
   * \param deviceIndex the device index of the joystick that will be queried.
   *
   * \return the USB vendor ID of the desired joystick; `std::nullopt` if it can't be
   * obtained.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto vendor(const int deviceIndex) noexcept -> std::optional<u16>
  {
    const auto vendor = SDL_JoystickGetDeviceVendor(deviceIndex);
    if (vendor != 0) {
      return vendor;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the USB product ID for the joystick associated with the specified
   * device index.
   *
   * \param deviceIndex the device index of the joystick that will be queried.
   *
   * \return the USB product ID of the desired joystick; `std::nullopt` if it can't be
   * obtained.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto product(const int deviceIndex) noexcept -> std::optional<u16>
  {
    const auto product = SDL_JoystickGetDeviceProduct(deviceIndex);
    if (product != 0) {
      return product;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the product version for the joystick associated with the specified
   * device index.
   *
   * \param deviceIndex the device index of the joystick that will be queried.
   *
   * \return the product version of the desired joystick; `std::nullopt` if it can't be
   * obtained.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto product_version(const int deviceIndex) noexcept
      -> std::optional<u16>
  {
    const auto version = SDL_JoystickGetDeviceProductVersion(deviceIndex);
    if (version != 0) {
      return version;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the GUID for the joystick associated with the specified device index.
   *
   * \note The GUID is implementation-dependent.
   * \note This function can be called before any joysticks are opened.
   *
   * \param deviceIndex refers to the N'th joystick that is currently recognized by SDL.
   *
   * \return the GUID of the joystick associated with the device index.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto guid(const int deviceIndex) noexcept -> SDL_JoystickGUID
  {
    return SDL_JoystickGetDeviceGUID(deviceIndex);
  }

  /**
   * \brief Returns the associated with the joystick with the specified device index.
   *
   * \param deviceIndex refers to the N'th joystick that is currently recognized by SDL.
   *
   * \return the name associated with the joystick; a null string is returned if no name
   * is found.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto name(const int deviceIndex) noexcept -> str
  {
    return SDL_JoystickNameForIndex(deviceIndex);
  }

  /**
   * \brief Returns the instance ID for the joystick associated with the specified device
   * index.
   *
   * \param deviceIndex the device index of the joystick that will be queried.
   *
   * \return the instance ID of the desired joystick; `std::nullopt` if it can't be
   * obtained.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto instance_id(const int deviceIndex) noexcept
      -> std::optional<SDL_JoystickID>
  {
    const auto id = SDL_JoystickGetDeviceInstanceID(deviceIndex);
    if (id != -1) {
      return id;
    }
    else {
      return std::nullopt;
    }
  }

  /// \} End of index-based queries

  /**
   * \brief Returns the ball axis change since the last poll.
   *
   * \note Trackballs can only return relative motion since the last call, these motion
   * deltas are placed into the `BallAxisChange` struct.
   *
   * \param ball the ball index to check, start at 0.
   *
   * \return a `JoystickBallAxisChange` instance or `std::nullopt` if something goes
   * wrong.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto get_ball_axis_change(const int ball) const noexcept
      -> std::optional<ball_axis_change>
  {
    ball_axis_change change{};
    if (SDL_JoystickGetBall(m_joystick, ball, &change.dx, &change.dy) == 0) {
      return change;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the current position of the specified axis.
   *
   * \details Most modern joysticks let the X-axis be represented by 0 and the Y-axis
   * by 1. To account for jitter, it may be necessary to impose some kind of tolerance on
   * the returned value.
   *
   * \note Some joysticks use axes 2 and 3 for extra buttons.
   *
   * \param axis the ID of the axis to query.
   *
   * \return the position of the specified axis.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto axis_pos(const int axis) const noexcept -> i16
  {
    return SDL_JoystickGetAxis(m_joystick, axis);
  }

  /**
   * \brief Returns the initial state of the specified axis on the joystick.
   *
   * \param axis the axis that will be queried. Starts at 0.
   *
   * \return the initial state of the axis; `std::nullopt` if the axis doesn't have an
   * initial state.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto axis_initial_state(const int axis) const noexcept -> std::optional<i16>
  {
    i16 state{};
    if (SDL_JoystickGetAxisInitialState(m_joystick, axis, &state)) {
      return state;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Indicates whether or not the joystick is attached to the system.
   *
   * \return `true` if the joystick is attached to the system; false otherwise.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto is_attached() const noexcept -> bool
  {
    return SDL_JoystickGetAttached(m_joystick);
  }

  /**
   * \brief Returns the amount of hats on the joystick.
   *
   * \return the amount of hats on the joystick.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto hat_count() const noexcept -> int
  {
    return SDL_JoystickNumHats(m_joystick);
  }

  /**
   * \brief Returns the amount of general axis controls on the joystick.
   *
   * \return the amount of general axis controls on the joystick.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto axis_count() const noexcept -> int
  {
    return SDL_JoystickNumAxes(m_joystick);
  }

  /**
   * \brief Returns the amount of trackballs on the joystick.
   *
   * \return the amount of trackballs on the joystick.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto trackball_count() const noexcept -> int
  {
    return SDL_JoystickNumBalls(m_joystick);
  }

  /**
   * \brief Returns the amount of buttons on the joystick.
   *
   * \return the amount of buttons on the joystick.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto button_count() const noexcept -> int
  {
    return SDL_JoystickNumButtons(m_joystick);
  }

  /**
   * \brief Returns the current power level of the joystick.
   *
   * \return the current power level.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto get_power() const noexcept -> joystick_power
  {
    return static_cast<joystick_power>(SDL_JoystickCurrentPowerLevel(m_joystick));
  }

  /**
   * \brief Returns the button state of the button associated with the index.
   *
   * \param button the button index to get the state from, starting at 0.
   *
   * \return the state of the button.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto get_button_state(const int button) const noexcept -> button_state
  {
    return static_cast<button_state>(SDL_JoystickGetButton(m_joystick, button));
  }

  /**
   * \brief Returns the state of a specific joystick hat.
   *
   * \param hat the index of the hat to query, indices start at 0.
   *
   * \return the current state of the hat.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto get_hat_state(const int hat) const noexcept -> hat_state
  {
    return static_cast<hat_state>(SDL_JoystickGetHat(m_joystick, hat));
  }

  /**
   * \brief Updates the state of all open joysticks.
   *
   * \note This is done automatically by the event loop if any joystick events are
   * enabled.
   *
   * \since 4.2.0
   */
  static void update() noexcept
  {
    SDL_JoystickUpdate();
  }

  /**
   * \brief Locks the access to all joysticks.
   *
   * \details If you are using the joystick API from multiple threads you should use this
   * function to restrict access to the joysticks.
   *
   * \since 4.2.0
   */
  static void lock() noexcept
  {
    SDL_LockJoysticks();
  }

  /**
   * \brief Unlocks the access to all joysticks.
   *
   * \since 4.2.0
   */
  static void unlock() noexcept
  {
    SDL_UnlockJoysticks();
  }

  /**
   * \brief Specifies whether or not joystick event polling is enabled.
   *
   * \details If joystick event polling is disabled, then you must manually call
   * `basic_joystick::update()` in order to update the joystick state.
   *
   * \note It's recommended to leave joystick event polling enabled.
   *
   * \warning Calling this function might cause all events currently in the event queue to
   * be deleted.
   *
   * \param enabled `true` if joystick event polling should be enabled; `false` otherwise.
   *
   * \since 4.2.0
   */
  static void set_polling(const bool enabled) noexcept
  {
    SDL_JoystickEventState(enabled ? SDL_ENABLE : SDL_DISABLE);
  }

  /**
   * \brief Indicates whether or not joystick event polling is enabled.
   *
   * \return `true` if joystick event polling is enabled; `false` otherwise.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto is_polling() noexcept -> bool
  {
    return SDL_JoystickEventState(SDL_QUERY);
  }

  /**
   * \brief Returns the amount of currently available joysticks.
   *
   * \return the current amount of available joysticks; `std::nullopt` if something goes
   * wrong.
   *
   * \since 5.1.0
   */
  [[nodiscard]] static auto count() noexcept -> std::optional<int>
  {
    const auto result = SDL_NumJoysticks();
    if (result >= 0) {
      return result;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns a joystick GUID based on the supplied string.
   *
   * \param str the string used to obtain the GUID, can't be null.
   *
   * \return the obtained GUID.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto guid_from_string(const not_null<str> str) noexcept
      -> SDL_JoystickGUID
  {
    assert(str);
    return SDL_JoystickGetGUIDFromString(str);
  }

  /**
   * \brief Returns a joystick GUID based on the supplied string.
   *
   * \param str the string used to obtain the GUID.
   *
   * \return the obtained GUID.
   *
   * \since 5.3.0
   */
  [[nodiscard]] static auto guid_from_string(const std::string& str) noexcept
      -> SDL_JoystickGUID
  {
    return guid_from_string(str.c_str());
  }

  /**
   * \brief Returns the maximum possible value of an axis control on a joystick.
   *
   * \return the maximum possible value of an axis control.
   *
   * \since 4.2.0
   */
  [[nodiscard]] constexpr static auto axis_max() noexcept -> i16
  {
    return SDL_JOYSTICK_AXIS_MAX;
  }

  /**
   * \brief Returns the minimum possible value of an axis control on a joystick.
   *
   * \return the minimum possible value of an axis control.
   *
   * \since 4.2.0
   */
  [[nodiscard]] constexpr static auto axis_min() noexcept -> i16
  {
    return SDL_JOYSTICK_AXIS_MIN;
  }

  /**
   * \brief Indicates whether or not a handle holds a non-null pointer.
   *
   * \return `true` if the handle holds a non-null pointer; `false` otherwise.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit operator bool() const noexcept
  {
    return m_joystick != nullptr;
  }

  /**
   * \brief Returns a pointer to the associated `SDL_Joystick`.
   *
   * \warning Don't take ownership of the returned pointer!
   *
   * \return a pointer to the associated `SDL_Joystick`.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_Joystick*
  {
    return m_joystick.get();
  }

 private:
  struct deleter final
  {
    void operator()(SDL_Joystick* joystick) noexcept
    {
      if (SDL_JoystickGetAttached(joystick)) {
        SDL_JoystickClose(joystick);
      }
    }
  };
  detail::pointer_manager<T, SDL_Joystick, deleter> m_joystick;
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a joystick.
 *
 * \tparam T the ownership semantics tag for the joystick.
 *
 * \param joystick the joystick that will be converted.
 *
 * \return a string representation of the joystick.
 *
 * \since 6.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_joystick<T>& joystick) -> std::string
{
  str serial{};
  if constexpr (detail::sdl_version_at_least(2, 0, 14)) {
    serial = joystick.serial();
  }

#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("joystick{{data: {}, id: {}, name: {}, serial: {}}}",
                     detail::address_of(joystick.get()),
                     joystick.instance_id(),
                     str_or_na(joystick.name()),
                     str_or_na(joystick.serial()));
#else
  return "joystick{data: " + detail::address_of(joystick.get()) +
         ", id: " + std::to_string(joystick.instance_id()) +
         ", name: " + str_or_na(joystick.name()) + ", serial: " + str_or_na(serial) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a joystick using a stream.
 *
 * \tparam T the ownership semantics tag for the joystick.
 *
 * \param stream the stream that will be used to print the joystick.
 * \param joystick the joystick that will be printed.
 *
 * \return the used stream.
 *
 * \since 6.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_joystick<T>& joystick) -> std::ostream&
{
  return stream << to_string(joystick);
}

/// \} End of streaming

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_JOYSTICK_HEADER
// #include "sensor.hpp"
#ifndef CENTURION_SENSOR_HEADER
#define CENTURION_SENSOR_HEADER

#include <SDL.h>

#include <array>     // array
#include <optional>  // optional
#include <ostream>   // ostream
#include <string>    // string, to_string

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/owner.hpp"

// #include "../core/str.hpp"

// #include "../core/str_or_na.hpp"

// #include "../detail/address_of.hpp"

// #include "../detail/owner_handle_api.hpp"

// #include "sensor_type.hpp"
#ifndef CENTURION_SENSOR_TYPE_HEADER
#define CENTURION_SENSOR_TYPE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum sensor_type
 *
 * \brief Provides values that represent different sensor types.
 *
 * \see SDL_SensorType
 *
 * \since 5.2.0
 */
enum class sensor_type
{
  invalid = SDL_SENSOR_INVALID,      ///< Invalid sensor
  unknown = SDL_SENSOR_UNKNOWN,      ///< Unknown sensor
  accelerometer = SDL_SENSOR_ACCEL,  ///< Accelerometer
  gyroscope = SDL_SENSOR_GYRO        ///< Gyroscope
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied sensor type.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(sensor_type::gyroscope) == "gyroscope"`.
 *
 * \param type the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const sensor_type type) -> std::string_view
{
  switch (type) {
    case sensor_type::invalid:
      return "invalid";

    case sensor_type::unknown:
      return "unknown";

    case sensor_type::accelerometer:
      return "accelerometer";

    case sensor_type::gyroscope:
      return "gyroscope";

    default:
      throw cen_error{"Did not recognize sensor type!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a sensor type enumerator.
 *
 * \param stream the output stream that will be used.
 * \param type the enumerator that will be printed.
 *
 * \see `to_string(sensor_type)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const sensor_type type) -> std::ostream&
{
  return stream << to_string(type);
}

/// \} End of streaming

/// \name Sensor type comparison operators
/// \{

/**
 * \brief Indicates whether or not two sensor types values are equal.
 *
 * \param lhs the left-hand side sensor type.
 * \param rhs the right-hand side sensor type.
 *
 * \return `true` if the two sensor types are equal; `false` otherwise.
 *
 * \since 5.2.0
 */
[[nodiscard]] constexpr auto operator==(const sensor_type lhs,
                                        const SDL_SensorType rhs) noexcept -> bool
{
  return static_cast<SDL_SensorType>(lhs) == rhs;
}

/// \copydoc operator==(const sensor_type, const SDL_SensorType)
[[nodiscard]] constexpr auto operator==(const SDL_SensorType lhs,
                                        const sensor_type rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two sensor types values aren't equal.
 *
 * \param lhs the left-hand side sensor type.
 * \param rhs the right-hand side sensor type.
 *
 * \return `true` if the two sensor types aren't equal; `false` otherwise.
 *
 * \since 5.2.0
 */
[[nodiscard]] constexpr auto operator!=(const sensor_type lhs,
                                        const SDL_SensorType rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const sensor_type, const SDL_SensorType)
[[nodiscard]] constexpr auto operator!=(const SDL_SensorType lhs,
                                        const sensor_type rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of sensor type comparison operators

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_SENSOR_TYPE_HEADER


namespace cen {

/// \addtogroup input
/// \{

/**
 * \typedef sensor_id
 *
 * \brief Used for unique sensor instance identifiers.
 *
 * \since 5.2.0
 */
using sensor_id = SDL_SensorID;

template <typename T>
class basic_sensor;

/**
 * \typedef sensor
 *
 * \brief Represents an owning sensor device.
 *
 * \since 5.2.0
 */
using sensor = basic_sensor<detail::owning_type>;

/**
 * \typedef sensor_handle
 *
 * \brief Represents a non-owning sensor device.
 *
 * \since 5.2.0
 */
using sensor_handle = basic_sensor<detail::handle_type>;

/**
 * \class basic_sensor
 *
 * \brief Represents a sensor device.
 *
 * \ownerhandle `sensor`/`sensor_handle`
 *
 * \see `sensor`
 * \see `sensor_handle`
 *
 * \since 5.2.0
 */
template <typename T>
class basic_sensor final
{
 public:
  /// \name Construction
  /// \{

  /**
   * \brief Creates a sensor instance based on an existing pointer.
   *
   * \note The created instance will claim ownership of the supplied pointer if the class
   * has owning semantics.
   *
   * \param sensor a pointer to the SDL sensor data.
   *
   * \throws cen_error if the supplied pointer is null and the class has owning semantics.
   *
   * \since 5.2.0
   */
  explicit basic_sensor(maybe_owner<SDL_Sensor*> sensor) noexcept(!detail::is_owning<T>())
      : m_sensor{sensor}
  {
    if constexpr (detail::is_owning<T>()) {
      if (!m_sensor) {
        throw cen_error{"Null sensor pointer!"};
      }
    }
  }

  /**
   * \brief Creates an owning sensor instance based on a device index.
   *
   * \param index the device index of the sensor.
   *
   * \throws sdl_error if the sensor cannot be opened.
   *
   * \since 5.2.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_sensor(const int index = 0) : m_sensor{SDL_SensorOpen(index)}
  {
    if (!m_sensor) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates a sensor handle based on an owning sensor.
   *
   * \param owner the associated owning sensor.
   *
   * \since 5.2.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit basic_sensor(const sensor& owner) noexcept : m_sensor{owner.get()}
  {}

  /// \} End of construction

  /**
   * \brief Updates the state of all open sensors.
   *
   * \note This is done automatically by the event loop if sensor events are enabled.
   *
   * \since 5.2.0
   */
  static void update() noexcept
  {
    SDL_SensorUpdate();
  }

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Locks access to the sensors for multi-threading.
   *
   * \note Refer to the SDL documentation for more details regarding this.
   *
   * \see SDL_LockSensors
   *
   * \since 5.2.0
   */
  static void lock() noexcept
  {
    SDL_LockSensors();
  }

  /**
   * \brief Unlocks access to the sensors.
   *
   * \note Refer to the SDL documentation for more details regarding this.
   *
   * \see SDL_UnlockSensors
   *
   * \since 5.2.0
   */
  static void unlock() noexcept
  {
    SDL_UnlockSensors();
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Returns the amount of sensors currently attached to the system.
   *
   * \return the current amount of system sensors.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto count() noexcept -> int
  {
    return SDL_NumSensors();
  }

  /// \name Instance-based queries
  /// \{

  /**
   * \brief Returns the unique identifier associated with the sensor instance.
   *
   * \return a unique instance ID.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto id() const noexcept -> sensor_id
  {
    return SDL_SensorGetInstanceID(m_sensor);
  }

  /**
   * \brief Returns the name associated with the sensor device.
   *
   * \return the name of the sensor device; a null pointer is returned if the name isn't
   * available.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto name() const noexcept -> str
  {
    return SDL_SensorGetName(m_sensor);
  }

  /**
   * \brief Returns the type associated with the sensor device.
   *
   * \return the type of the sensor device.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto type() const noexcept -> sensor_type
  {
    return static_cast<sensor_type>(SDL_SensorGetType(m_sensor));
  }

  /**
   * \brief Returns the non-portable type associated with the sensor.
   *
   * \return a non-portable sensor type value.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto non_portable_type() const noexcept -> int
  {
    return SDL_SensorGetNonPortableType(m_sensor);
  }

  /**
   * \brief Returns the sensor-dependent data.
   *
   * \tparam Size the number of data elements, varies from sensor to sensor.
   *
   * \return the data associated with the sensor; `std::nullopt` if something goes wrong.
   *
   * \since 5.2.0
   */
  template <usize Size>
  [[nodiscard]] auto data() const noexcept -> std::optional<std::array<float, Size>>
  {
    std::array<float, Size> array{};
    if (SDL_SensorGetData(m_sensor, array.data(), isize(array)) != -1) {
      return array;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns a pointer to the associated SDL sensor.
   *
   * \warning Don't take ownership of the returned pointer!
   *
   * \return a pointer to the associated SDL sensor.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_Sensor*
  {
    return m_sensor.get();
  }

  /// \} End of instance-based queries

  /// \name Index-based queries
  /// \{

  /**
   * \brief Returns the unique identifier associated with a sensor instance.
   *
   * \param index the index of the sensor device that will be queried.
   *
   * \return the unique instance ID associated with a sensor; `std::nullopt` if the index
   * is invalid.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto id(const int index) noexcept -> std::optional<sensor_id>
  {
    const auto id = SDL_SensorGetDeviceInstanceID(index);
    if (id != -1) {
      return id;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the name associated with a sensor device.
   *
   * \param index the index of the sensor device that will be queried.
   *
   * \return the name of the sensor device; a null pointer is returned if the name isn't
   * available or if the index was invalid.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto name(const int index) noexcept -> str
  {
    return SDL_SensorGetDeviceName(index);
  }

  /**
   * \brief Returns the type associated with a sensor device.
   *
   * \param index the index of the sensor device that will be queried.
   *
   * \return the type of the sensor device.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto type(const int index) noexcept -> sensor_type
  {
    return static_cast<sensor_type>(SDL_SensorGetDeviceType(index));
  }

  /**
   * \brief Returns the non-portable type associated with a sensor.
   *
   * \param index the index of the sensor device that will be queried.
   *
   * \return a non-portable sensor type value; `std::nullopt` if the index is invalid.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto non_portable_type(const int index) noexcept -> std::optional<int>
  {
    const auto type = SDL_SensorGetDeviceNonPortableType(index);
    if (type != -1) {
      return type;
    }
    else {
      return std::nullopt;
    }
  }

  /// \} End of index-based queries

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not the handle holds a non-null pointer.
   *
   * \return `true` if the handle holds a non-null pointer; `false` otherwise.
   *
   * \since 5.2.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit operator bool() const noexcept
  {
    return m_sensor != nullptr;
  }

  /// \} End of conversions

 private:
  struct deleter final
  {
    void operator()(SDL_Sensor* sensor) noexcept
    {
      SDL_SensorClose(sensor);
    }
  };
  detail::pointer_manager<T, SDL_Sensor, deleter> m_sensor;
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a sensor instance.
 *
 * \param sensor the sensor that will be converted.
 *
 * \return a string that represents a sensor instance.
 *
 * \since 5.2.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_sensor<T>& sensor) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("sensor{{data: {}, id: {}, name: {}}}",
                     detail::address_of(sensor.get()),
                     sensor.id(),
                     str_or_na(sensor.name()));
#else
  return "sensor{data: " + detail::address_of(sensor.get()) +
         ", id: " + std::to_string(sensor.id()) + ", name: " + str_or_na(sensor.name()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a sensor instance using a stream.
 *
 * \param stream the stream that will be used.
 * \param sensor the sensor that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.2.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_sensor<T>& sensor) -> std::ostream&
{
  return stream << to_string(sensor);
}

/// \} End of streaming

/**
 * \brief Returns the standard gravity value.
 *
 * \return the standard gravity value.
 *
 * \since 5.2.0
 */
[[nodiscard]] constexpr auto standard_gravity() noexcept -> float
{
  return SDL_STANDARD_GRAVITY;
}

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_SENSOR_HEADER

// #include "touch.hpp"
#ifndef CENTURION_TOUCH_HEADER
#define CENTURION_TOUCH_HEADER

#include <SDL.h>

#include <optional>  // optional

// #include "../core/integers.hpp"

// #include "button_state.hpp"

// #include "touch_device_type.hpp"
#ifndef CENTURION_TOUCH_DEVICE_TYPE_HEADER
#define CENTURION_TOUCH_DEVICE_TYPE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

namespace touch {

/// \addtogroup input
/// \{

/**
 * \enum device_type
 *
 * \brief Provides values that represent different touch device types.
 *
 * \see `SDL_TouchDeviceType`
 *
 * \todo Centurion 7: Rename to touch_device_type and move out of touch namespace.
 *
 * \since 4.3.0
 */
enum class device_type
{
  // clang-format off
  invalid = SDL_TOUCH_DEVICE_INVALID,                      ///< Invalid touch device.
  direct = SDL_TOUCH_DEVICE_DIRECT,                        ///< Touch screen with window-relative coordinates.
  indirect_absolute = SDL_TOUCH_DEVICE_INDIRECT_ABSOLUTE,  ///< Trackpad with absolute device coordinates.
  indirect_relative = SDL_TOUCH_DEVICE_INDIRECT_RELATIVE   ///< Trackpad with screen cursor-relative coordinates.
  // clang-format on
};

/// \name Touch device comparison operators
/// \{

/**
 * \brief Indicates whether or not two touch device types are the same.
 *
 * \param lhs the left-hand side touch device type.
 * \param rhs the right-hand side touch device type.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator==(const device_type lhs,
                                        const SDL_TouchDeviceType rhs) noexcept -> bool
{
  return static_cast<SDL_TouchDeviceType>(lhs) == rhs;
}

/// \copydoc operator==(device_type, SDL_TouchDeviceType)
[[nodiscard]] constexpr auto operator==(const SDL_TouchDeviceType lhs,
                                        const device_type rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two touch device types aren't the same.
 *
 * \param lhs the left-hand side touch device type.
 * \param rhs the right-hand side touch device type.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator!=(const device_type lhs,
                                        const SDL_TouchDeviceType rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(device_type, SDL_TouchDeviceType)
[[nodiscard]] constexpr auto operator!=(const SDL_TouchDeviceType lhs,
                                        const device_type rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of touch device comparison operators

/// \} End of group input

}  // namespace touch

/// \addtogroup input
/// \{

// Added for consistency with rest of codebase (no classes in nested namespaces)
using touch_device_type = touch::device_type;

[[nodiscard]] constexpr auto to_string(touch_device_type type) -> std::string_view;

namespace touch {

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a touch device type enumerator.
 *
 * \param stream the output stream that will be used.
 * \param type the enumerator that will be printed.
 *
 * \see `to_string(touch_device_type)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const touch_device_type type) -> std::ostream&
{
  return stream << to_string(type);
}

/// \} End of streaming

}  // namespace touch

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied touch device type.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(device_type::direct) == "direct"`.
 *
 * \param type the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const touch_device_type type) -> std::string_view
{
  switch (type) {
    case touch_device_type::invalid:
      return "invalid";

    case touch_device_type::direct:
      return "direct";

    case touch_device_type::indirect_absolute:
      return "indirect_absolute";

    case touch_device_type::indirect_relative:
      return "indirect_relative";

    default:
      throw cen_error{"Did not recognize touch device type!"};
  }
}

/// \} End of string conversions

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_TOUCH_DEVICE_TYPE_HEADER


/**
 * \namespace cen::touch
 *
 * \ingroup input
 *
 * \brief Provides the touch API components and methods.
 *
 * \since 4.3.0
 */
namespace cen::touch {

/// \addtogroup input
/// \{

/**
 * \struct finger_state
 *
 * \brief Represents the state of a finger.
 *
 * \todo Centurion 7: Rename to touch_finger_state and move out of touch namespace.
 *
 * \since 5.2.0
 */
struct finger_state final
{
  button_state state;  ///< Whether or not the finger is pressed or release.
  float x;             ///< The current x-coordinate.
  float y;             ///< The current y-coordinate.
  float pressure;      ///< The current applied pressure.
};

/**
 * \brief Returns the number of registered touch devices.
 *
 * \return the number of registered touch devices.
 *
 * \since 4.3.0
 */
[[nodiscard]] inline auto device_count() noexcept -> int
{
  return SDL_GetNumTouchDevices();
}

/**
 * \brief Returns the touch device ID associated with the specified index.
 *
 * \param index the index of the desired touch device.
 *
 * \return the touch device ID associated with the index; `std::nullopt` if there is no
 * such value.
 *
 * \since 4.3.0
 */
[[nodiscard]] inline auto get_device(const int index) noexcept -> std::optional<SDL_TouchID>
{
  const auto device = SDL_GetTouchDevice(index);
  if (device != 0) {
    return device;
  }
  else {
    return std::nullopt;
  }
}

/**
 * \brief Returns the type of a touch device.
 *
 * \param id the touch device that will be queried.
 *
 * \return the type of the specified touch device.
 *
 * \since 4.3.0
 */
[[nodiscard]] inline auto type_of(const SDL_TouchID id) noexcept -> device_type
{
  return static_cast<device_type>(SDL_GetTouchDeviceType(id));
}

/**
 * \brief Returns the number of active fingers for a given touch device.
 *
 * \param id the touch device that will be queried.
 *
 * \return the amount of active fingers in a touch device.
 *
 * \since 4.3.0
 */
[[nodiscard]] inline auto finger_count(const SDL_TouchID id) noexcept -> int
{
  return SDL_GetNumTouchFingers(id);
}

/**
 * \brief Returns the finger associated with the specified touch ID and index.
 *
 * \param id the touch ID of the finger.
 * \param index the index of the finger object.
 *
 * \return the associated finger; `std::nullopt` if no such instance could be obtained.
 *
 * \since 4.3.0
 */
[[nodiscard]] inline auto get_finger(const SDL_TouchID id, const int index) noexcept
    -> std::optional<SDL_Finger>
{
  if (const auto* finger = SDL_GetTouchFinger(id, index)) {
    return *finger;
  }
  else {
    return std::nullopt;
  }
}

/**
 * \brief Returns the device ID used for mouse events simulated with touch input.
 *
 * \return a device ID.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto touch_mouse_id() noexcept -> u32
{
  return SDL_TOUCH_MOUSEID;
}

/**
 * \brief Returns the touch ID used by touch events simulated with mouse input.
 *
 * \return the touch ID used by touch events simulated with mouse input.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto mouse_touch_id() noexcept -> SDL_TouchID
{
  return SDL_MOUSE_TOUCHID;
}

/// \} End of group input

}  // namespace cen::touch

namespace cen {

/// \addtogroup input
/// \{

// Added for consistency with rest of codebase (no classes in nested namespaces)
using touch_finger_state = touch::finger_state;

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_TOUCH_HEADER

namespace cen {

/// \addtogroup input
/// \{

template <typename T>
class basic_controller;

/**
 * \typedef controller
 *
 * \brief Represents an owning game controller.
 *
 * \since 5.0.0
 */
using controller = basic_controller<detail::owning_type>;

/**
 * \typedef controller_handle
 *
 * \brief Represents a non-owning game controller.
 *
 * \since 5.0.0
 */
using controller_handle = basic_controller<detail::handle_type>;

/**
 * \class basic_controller
 *
 * \brief Represents a game controller, e.g. Xbox or Playstation controllers.
 *
 * \ownerhandle `controller`/`controller_handle`
 *
 * \details You may need to load appropriate game controller mappings before you can begin
 * using the game controller API with certain controllers. This can be accomplished using
 * the `cen::hint::controller::config_file` hint, or the `load_mappings()` and
 * `add_mapping()` functions.
 *
 * \details For a community managed database file of game controller mappings, see
 * `https://github.com/gabomdq/SDL_GameControllerDB` (if the link doesn’t work for some
 * reason, you should be able to find a copy in the Centurion test resources folder).
 *
 * \todo Centurion 7: Move `mapping_result` out of `basic_controller`.
 *
 * \since 5.0.0
 *
 * \see `controller`
 * \see `controller_handle`
 */
template <typename T>
class basic_controller final
{
 public:
  using mapping_index = int;
  using joystick_index = int;
  using player_index = int;

  /**
   * \brief Used to indicate the result of adding controller mappings.
   *
   * \since 5.1.0
   */
  enum class mapping_result
  {
    error,    ///< Something went wrong.
    updated,  ///< Updated a previous mapping.
    added     ///< Successfully added a new mapping.
  };

  /// \name Construction
  /// \{

  // clang-format off

  /**
   * \brief Creates a game controller from an existing SDL game controller.
   *
   * \note Ownership of the supplied pointer is claimed if the joystick has
   * owning semantics.
   *
   * \param controller a pointer to the associated game controller.
   *
   * \since 5.0.0
   */
  explicit basic_controller(maybe_owner<SDL_GameController*> controller) noexcept(!detail::is_owning<T>())
      : m_controller{controller}
  {
    if constexpr (detail::is_owning<T>()) 
    {
      if (!m_controller) 
      {
        throw cen_error{"Cannot create controller from null pointer!"};
      }
    }
  }

  // clang-format on

  /**
   * \brief Creates a handle to an existing controller instance.
   *
   * \param owner the controller that owns the `SDL_GameController` pointer.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit basic_controller(const controller& owner) noexcept : m_controller{owner.get()}
  {}

  /**
   * \brief Attempts to create a game controller.
   *
   * \details The joystick index is the same as the device index passed to the
   * `joystick` constructor. The index passed as an argument refers to the
   * n'th game controller on the system.
   *
   * \note The supplied index is not the value which will identify the
   * controller in controller events. Instead, the joystick's instance id
   * (`SDL_JoystickID`) will be used.
   *
   * \remark This constructor is only available for owning game controllers.
   *
   * \param index the device index, can't be >= than the amount of number of
   * joysticks.
   *
   * \throws sdl_error if the game controller cannot be opened.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_controller(const int index = 0) : m_controller{SDL_GameControllerOpen(index)}
  {
    if (!m_controller) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates a game controller from an existing joystick ID.
   *
   * \remark This function is only available for owning game controllers.
   *
   * \param id the identifier associated with the joystick to base the game
   * controller on.
   *
   * \return a game controller instance.
   *
   * \throws sdl_error if the game controller cannot be created.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto from_joystick(const SDL_JoystickID id) -> basic_controller
  {
    if (auto* ptr = SDL_GameControllerFromInstanceID(id)) {
      return basic_controller{ptr};
    }
    else {
      throw sdl_error{};
    }
  }

#if SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Creates a controller based on a player index.
   *
   * \param index the player index of the game controller.
   *
   * \return a game controller associated with the specified player index.
   *
   * \throws sdl_error if the game controller cannot be created.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto from_index(const player_index index) -> basic_controller
  {
    if (auto* ptr = SDL_GameControllerFromPlayerIndex(index)) {
      return basic_controller{ptr};
    }
    else {
      throw sdl_error{};
    }
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

  /// \} End of construction

  /**
   * \brief Updates the state of all open game controllers.
   *
   * \note This is done automatically if game controller events are enabled.
   *
   * \since 5.0.0
   */
  static void update()
  {
    SDL_GameControllerUpdate();
  }

  /**
   * \brief Indicates whether or not the specified value is usable as a
   * controller index.
   *
   * \param index the index that will be checked.
   *
   * \return `true` if the supplied index is supported; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] static auto is_supported(const joystick_index index) noexcept -> bool
  {
    return SDL_IsGameController(index) == SDL_TRUE;
  }

  /**
   * \brief Sets whether or not game controller event polling is enabled.
   *
   * \details If this property is set to `false`, then you have to call
   * `update` by yourself.
   *
   * \param polling `true` to enable automatic game controller event polling;
   * `false` otherwise.
   *
   * \since 5.0.0
   */
  static void set_polling(const bool polling) noexcept
  {
    SDL_GameControllerEventState(polling ? SDL_ENABLE : SDL_DISABLE);
  }

  /**
   * \brief Indicates whether or not game controller event polling is enabled.
   *
   * \return `true` if game controller event polling is enabled; `false`
   * otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] static auto is_polling() noexcept -> bool
  {
    return SDL_GameControllerEventState(SDL_QUERY);
  }

#if SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Sets the player index associated with the controller.
   *
   * \param index the player index that will be used.
   *
   * \since 5.0.0
   */
  void set_player_index(const player_index index) noexcept
  {
    SDL_GameControllerSetPlayerIndex(m_controller, index);
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

#if SDL_VERSION_ATLEAST(2, 0, 16)

  /**
   * \brief Sends a packet of controller specific data.
   *
   * \param data the data that will be sent.
   * \param size the size of the data.
   *
   * \return `success` if the data was sent successfully; `failure` if the controller
   * or driver doesn't support effect packets.
   *
   * \since 6.2.0
   */
  auto send_effect(const void* data, const int size) -> result
  {
    return SDL_GameControllerSendEffect(m_controller, data, size) == 0;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 16)

  /// \name Button and axis functions
  /// \{

  /**
   * \brief Returns the button associated with the specified string.
   *
   * \param str the string that represents a controller button, e.g "a".
   *
   * \return a game controller button value.
   *
   * \since 5.0.0
   */
  [[nodiscard]] static auto get_button(const not_null<str> str) noexcept -> controller_button
  {
    assert(str);
    return static_cast<controller_button>(SDL_GameControllerGetButtonFromString(str));
  }

  /**
   * \brief Returns the button associated with the specified string.
   *
   * \param str the string that represents a controller button, e.g "a".
   *
   * \return a game controller button value.
   *
   * \since 5.3.0
   */
  [[nodiscard]] static auto get_button(const std::string& str) noexcept -> controller_button
  {
    return get_button(str.c_str());
  }

  /**
   * \brief Returns a string representation of a controller axis.
   *
   * \param axis the controller axis that will be converted.
   *
   * \return a string that represents the axis, might be null.
   *
   * \since 5.0.0
   */
  [[nodiscard]] static auto stringify(const controller_axis axis) noexcept -> str
  {
    return SDL_GameControllerGetStringForAxis(static_cast<SDL_GameControllerAxis>(axis));
  }

  /**
   * \brief Returns a string representation of a controller button.
   *
   * \param button the controller button that will be converted.
   *
   * \return a string that represents the button, might be null.
   *
   * \since 5.0.0
   */
  [[nodiscard]] static auto stringify(const controller_button button) noexcept -> str
  {
    return SDL_GameControllerGetStringForButton(static_cast<SDL_GameControllerButton>(button));
  }

  /**
   * \brief Returns the bindings for a controller axis.
   *
   * \param axis the axis of the bindings.
   *
   * \return the bindings for a controller axis; `std::nullopt` on failure.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get_binding(const controller_axis axis) const
      -> std::optional<SDL_GameControllerButtonBind>
  {
    const auto result =
        SDL_GameControllerGetBindForAxis(m_controller,
                                         static_cast<SDL_GameControllerAxis>(axis));
    if (result.bindType != SDL_CONTROLLER_BINDTYPE_NONE) {
      return result;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the bindings for a controller button.
   *
   * \param button the button of the bindings.
   *
   * \return the bindings for a controller button; `std::nullopt` on failure.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get_binding(const controller_button button) noexcept
      -> std::optional<SDL_GameControllerButtonBind>
  {
    const auto result =
        SDL_GameControllerGetBindForButton(m_controller,
                                           static_cast<SDL_GameControllerButton>(button));
    if (result.bindType != SDL_CONTROLLER_BINDTYPE_NONE) {
      return result;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the state of the specified game controller button.
   *
   * \param button the button that will be checked.
   *
   * \return the current button state of the specified button.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get_state(const controller_button button) const noexcept -> button_state
  {
    const auto state =
        SDL_GameControllerGetButton(m_controller,
                                    static_cast<SDL_GameControllerButton>(button));
    return static_cast<button_state>(state);
  }

  /**
   * \brief Indicates if the specified button is pressed.
   *
   * \param button the button that will be checked.
   *
   * \return `true` if the specified button is pressed; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto is_pressed(const controller_button button) const noexcept -> bool
  {
    return get_state(button) == button_state::pressed;
  }

  /**
   * \brief Indicates if the specified button is released.
   *
   * \param button the button that will be checked.
   *
   * \return `true` if the specified button is released; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto is_released(const controller_button button) const noexcept -> bool
  {
    return get_state(button) == button_state::released;
  }

  /**
   * \brief Returns the axis associated with the specified string.
   *
   * \note You don't need this function unless you are parsing game controller
   * mappings by yourself.
   *
   * \param str the string that represents a game controller axis, e.g "rightx".
   *
   * \return a game controller axis value.
   *
   * \since 5.0.0
   */
  [[nodiscard]] static auto get_axis(const not_null<str> str) noexcept -> controller_axis
  {
    assert(str);
    return static_cast<controller_axis>(SDL_GameControllerGetAxisFromString(str));
  }

  /**
   * \brief Returns the axis associated with the specified string.
   *
   * \note You don't need this function unless you are parsing game controller
   * mappings by yourself.
   *
   * \param str the string that represents a game controller axis, e.g "rightx".
   *
   * \return a game controller axis value.
   *
   * \since 5.3.0
   */
  [[nodiscard]] static auto get_axis(const std::string& str) noexcept -> controller_axis
  {
    return get_axis(str.c_str());
  }

  /**
   * \brief Returns the value of the specified axis.
   *
   * \param axis the controller axis that will be checked.
   *
   * \return the current value of the specified axis.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get_axis(const controller_axis axis) const noexcept -> i16
  {
    return SDL_GameControllerGetAxis(m_controller, static_cast<SDL_GameControllerAxis>(axis));
  }

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Indicates whether or not the controller has the specified axis.
   *
   * \return `true` if the controller has the specified axis; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_axis(const controller_axis axis) const noexcept -> bool
  {
    const auto value = static_cast<SDL_GameControllerAxis>(axis);
    return SDL_GameControllerHasAxis(m_controller, value) == SDL_TRUE;
  }

  /**
   * \brief Indicates whether or not the controller has the specified button.
   *
   * \param button the button that will be checked.
   *
   * \return `true` if the controller features the specified button; `false`
   * otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_button(const controller_button button) const noexcept -> bool
  {
    const auto value = static_cast<SDL_GameControllerButton>(button);
    return SDL_GameControllerHasButton(m_controller, value) == SDL_TRUE;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  /// \} End of button and axis functions

  /// \name Rumble functions
  /// \{

  /**
   * \brief Starts a rumble effect.
   *
   * \details Calls to this function cancels any previously active rumble
   * effect. Furthermore, supplying 0 as intensities will stop the rumble
   * effect.
   *
   * \note This function has no effect if rumbling isn't supported by the
   * controller.
   *
   * \param lo the intensity of the low frequency motor.
   * \param hi the intensity of the high frequency motor.
   * \param duration the duration of the rumble effect.
   *
   * \return `success` if the rumble is successful; `failure` otherwise.
   *
   * \since 5.0.0
   */
  auto rumble(const u16 lo,
              const u16 hi,
              const milliseconds<u32> duration) noexcept(noexcept(duration.count())) -> result
  {
    return SDL_GameControllerRumble(m_controller, lo, hi, duration.count()) == 0;
  }

#if SDL_VERSION_ATLEAST(2, 0, 14)

  // clang-format off

  /**
   * \brief Starts a rumble effect in the controller's triggers.
   *
   * \details Calls to this function cancels any previously active rumble
   * effect. Furthermore, supplying 0 as intensities will stop the rumble
   * effect.
   *
   * \note This function has no effect if rumbling isn't supported by the
   * controller.
   *
   * \param lo the intensity of the low frequency motor.
   * \param hi the intensity of the high frequency motor.
   * \param duration the duration of the rumble effect.
   *
   * \return `success` if the rumble is successful; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto rumble_triggers(const u16 lo,
                       const u16 hi,
                       const milliseconds<u32> duration) noexcept(noexcept(duration.count()))
      -> result
  {
    return SDL_GameControllerRumbleTriggers(m_controller, lo, hi, duration.count()) == 0;
  }

  // clang-format on

#endif  // SDL_VERSION(2, 0, 14)

  /**
   * \brief Stops any currently active rumble effect.
   *
   * \since 5.0.0
   */
  void stop_rumble() noexcept
  {
    rumble(0, 0, milliseconds<u32>::zero());
  }

  /// \} End of rumble functions

  /// \name Queries
  /// \{

  /**
   * \brief Returns the USB product ID of the controller.
   *
   * \return the USB product ID; `std::nullopt` if the product ID isn't
   * available.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto product() const noexcept -> std::optional<u16>
  {
    const auto id = SDL_GameControllerGetProduct(m_controller);
    if (id != 0) {
      return id;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the USB vendor ID of the controller.
   *
   * \return the USB vendor ID; `std::nullopt` if the vendor ID isn't available.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto vendor() const noexcept -> std::optional<u16>
  {
    const auto id = SDL_GameControllerGetVendor(m_controller);
    if (id != 0) {
      return id;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the product version of the controller.
   *
   * \return the product version; `std::nullopt` if the product version isn't
   * available.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto product_version() const noexcept -> std::optional<u16>
  {
    const auto id = SDL_GameControllerGetProductVersion(m_controller);
    if (id != 0) {
      return id;
    }
    else {
      return std::nullopt;
    }
  }

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Returns the serial number associated with the controller.
   *
   * \return the serial number associated with the controller; a null pointer if
   * no serial number is available.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto serial() const noexcept -> str
  {
    return SDL_GameControllerGetSerial(m_controller);
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Returns the player index associated with the controller.
   *
   * \note If this is an XInput controller, the returned value is the user
   * index.
   *
   * \return the player index associated with the controller; `std::nullopt`
   * if the index isn't available.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto index() const noexcept -> std::optional<player_index>
  {
    const auto result = SDL_GameControllerGetPlayerIndex(m_controller);
    if (result != -1) {
      return result;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Indicates whether or not the game controller is currently connected.
   *
   * \return `true` if the game controller is connected; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto is_connected() const noexcept -> bool
  {
    return SDL_GameControllerGetAttached(m_controller) == SDL_TRUE;
  }

  /**
   * \brief Returns the name associated with the game controller.
   *
   * \note This function might return a null pointer if there is no name
   * associated with the game controller.
   *
   * \return the name of the game controller, might be null.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto name() const noexcept -> str
  {
    return SDL_GameControllerName(m_controller);
  }

#if SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Returns the type of the controller.
   *
   * \return the type of the controller.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto type() const noexcept -> controller_type
  {
    return static_cast<controller_type>(SDL_GameControllerGetType(m_controller));
  }

  /**
   * \brief Returns the type of the controller associated with the specified
   * joystick index.
   *
   * \param index the joystick index of the desired game controller.
   *
   * \return the type of the game controller associated with the index.
   *
   * \since 5.0.0
   */
  [[nodiscard]] static auto type(const joystick_index index) noexcept -> controller_type
  {
    return static_cast<controller_type>(SDL_GameControllerTypeForIndex(index));
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Returns a handle to the associated joystick.
   *
   * \return a handle to the associated joystick.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get_joystick() noexcept -> joystick_handle
  {
    return joystick_handle{SDL_GameControllerGetJoystick(m_controller)};
  }

  /**
   * \brief Returns the amount of available game controllers on the system.
   *
   * \return the amount of available game controllers.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto count() noexcept -> int
  {
    const auto joysticks = SDL_NumJoysticks();

    auto amount = 0;
    for (auto i = 0; i < joysticks; ++i) {
      if (is_supported(i)) {
        ++amount;
      }
    }

    return amount;
  }

  /**
   * \brief Returns a pointer to the associated SDL game controller.
   *
   * \warning Don't take ownership of the returned pointer!
   *
   * \return a pointer to the associated SDL game controller.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_GameController*
  {
    return m_controller.get();
  }

  /// \} End of queries

  /// \name Touchpad functions
  /// \{

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Returns the amount of touchpads on the controller.
   *
   * \return the amount of touchpads on the controller.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto touchpad_count() const noexcept -> int
  {
    return SDL_GameControllerGetNumTouchpads(m_controller);
  }

  /**
   * \brief Returns the amount of supported simultaneous fingers for a touchpad.
   *
   * \param touchpad the index associated with the touchpad that will be
   * queried.
   *
   * \return the maximum amount of supported simultaneous fingers for the
   * specified touchpad.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto touchpad_finger_capacity(const int touchpad) const noexcept -> int
  {
    return SDL_GameControllerGetNumTouchpadFingers(m_controller, touchpad);
  }

  /**
   * \brief Returns the state of a finger on a touchpad.
   *
   * \param touchpad the touchpad to query.
   * \param finger the index of the finger that will be queried.
   *
   * \return the current state of a touchpad finger; `std::nullopt` if something
   * goes wrong.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto touchpad_finger_state(const int touchpad, const int finger) const noexcept
      -> std::optional<touch::finger_state>
  {
    touch::finger_state result{};
    u8 state{};

    const auto res = SDL_GameControllerGetTouchpadFinger(m_controller,
                                                         touchpad,
                                                         finger,
                                                         &state,
                                                         &result.x,
                                                         &result.y,
                                                         &result.pressure);
    result.state = static_cast<button_state>(state);

    if (res != -1) {
      return result;
    }
    else {
      return std::nullopt;
    }
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  /// \} End of touchpad functions

  /// \name Sensor functions
  /// \{

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Sets whether or not data reporting is enabled for a sensor.
   *
   * \param type the type of the sensor that will be changed.
   * \param enabled `true` if data reporting should be enabled; `false`
   * otherwise.
   *
   * \return `success` if the sensor was successfully enabled or disabled;
   * `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto set_sensor_enabled(const sensor_type type, const bool enabled) noexcept -> result
  {
    const auto value = static_cast<SDL_SensorType>(type);
    const auto state = enabled ? SDL_TRUE : SDL_FALSE;
    return SDL_GameControllerSetSensorEnabled(m_controller, value, state) == 0;
  }

  /**
   * \brief Indicates whether or not the controller has a sensor.
   *
   * \param type the type of the sensor to look for.
   *
   * \return `true` if the controller has the specified sensor; `false`
   * otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_sensor(const sensor_type type) const noexcept -> bool
  {
    const auto value = static_cast<SDL_SensorType>(type);
    return SDL_GameControllerHasSensor(m_controller, value) == SDL_TRUE;
  }

  /**
   * \brief Indicates whether or not data reporting is enabled for a sensor.
   *
   * \param type the type of the sensor that will be queried.
   *
   * \return `true` if data reporting is enabled for the sensor; `false`
   * otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto is_sensor_enabled(const sensor_type type) const noexcept -> bool
  {
    const auto value = static_cast<SDL_SensorType>(type);
    return SDL_GameControllerIsSensorEnabled(m_controller, value) == SDL_TRUE;
  }

  /**
   * \brief Returns the state of the specified sensor.
   *
   * \tparam Size the amount of data elements.
   *
   * \param type the type of the sensor that will be queried.
   *
   * \return the sensor data; `std::nullopt` if something went wrong.
   *
   * \since 5.2.0
   */
  template <usize Size>
  [[nodiscard]] auto get_sensor_data(const sensor_type type) const noexcept
      -> std::optional<std::array<float, Size>>
  {
    std::array<float, Size> array{};
    if (SDL_GameControllerGetSensorData(m_controller,
                                        static_cast<SDL_SensorType>(type),
                                        array.data(),
                                        isize(array)) != -1)
    {
      return array;
    }
    else {
      return std::nullopt;
    }
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

#if SDL_VERSION_ATLEAST(2, 0, 16)

  /**
   * \brief Returns the data rate of a controller sensor, i.e. the number of supported
   * events per second.
   *
   * \param type the sensor type that will be queried.
   *
   * \return the data rate (may be zero if the data rate isn't available).
   *
   * \since 6.2.0
   */
  [[nodiscard]] auto get_sensor_data_rate(const sensor_type type) const noexcept -> float
  {
    return SDL_GameControllerGetSensorDataRate(m_controller,
                                               static_cast<SDL_SensorType>(type));
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 16)

  /// \} End of sensor functions

  /// \name LED functions
  /// \{

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Sets the color of the associated LED light.
   *
   * \param color the new color of the controller's LED.
   *
   * \return `success` if the color of the LED was set; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto set_led(const color& color) noexcept -> result
  {
    return SDL_GameControllerSetLED(m_controller, color.red(), color.green(), color.blue()) ==
           0;
  }

  /**
   * \brief Indicates whether or not the controller features a LED light.
   *
   * \return `true` if the controller features a LED light; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_led() const noexcept -> bool
  {
    return SDL_GameControllerHasLED(m_controller) == SDL_TRUE;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  /// \} End of LED functions

  /// \name Mapping functions
  /// \{

  /**
   * \brief Adds a game controller mapping.
   *
   * \param mapping the string that encodes the game controller mapping.
   *
   * \return `added` if a new mapping was added; `updated` if a previous mapping
   * was updated; `error` if something went wrong.
   *
   * \since 5.0.0
   */
  static auto add_mapping(const not_null<str> mapping) noexcept -> mapping_result
  {
    assert(mapping);
    const auto result = SDL_GameControllerAddMapping(mapping);
    if (result == 1) {
      return mapping_result::added;
    }
    else if (result == 0) {
      return mapping_result::updated;
    }
    else {
      return mapping_result::error;
    }
  }

  /**
   * \brief Adds a game controller mapping.
   *
   * \param mapping the string that encodes the game controller mapping.
   *
   * \return `added` if a new mapping was added; `updated` if a previous mapping
   * was updated; `error` if something went wrong.
   *
   * \since 5.3.0
   */
  static auto add_mapping(const std::string& mapping) noexcept -> mapping_result
  {
    return add_mapping(mapping.c_str());
  }

  /**
   * \brief Loads a set of game controller mappings from a file.
   *
   * \details A collection of game controller mappings can be found at <a
   * href="https://github.com/gabomdq/SDL_GameControllerDB">here</a>. New
   * mappings for previously known GUIDs will overwrite the previous mappings.
   * Furthermore, mappings for different platforms than the current platform
   * will be ignored.
   *
   * \remarks It's possible to call this function several times to use multiple
   * mapping files.
   *
   * \note The text database is stored entirely in memory during processing.
   *
   * \param file the path of the mapping file.
   *
   * \return the amount of mappings added; `std::nullopt` if something went
   * wrong.
   *
   * \since 5.0.0
   */
  static auto load_mappings(const not_null<str> file) noexcept -> std::optional<int>
  {
    assert(file);
    const auto result = SDL_GameControllerAddMappingsFromFile(file);
    if (result != -1) {
      return result;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Loads a set of game controller mappings from a file.
   *
   * \details A collection of game controller mappings can be found at <a
   * href="https://github.com/gabomdq/SDL_GameControllerDB">here</a>. New mappings for
   * previously known GUIDs will overwrite the previous mappings. Furthermore, mappings
   * for different platforms than the current platform will be ignored.
   *
   * \remarks It's possible to call this function several times to use multiple mapping
   * files.
   *
   * \note The text database is stored entirely in memory during processing.
   *
   * \param file the path of the mapping file.
   *
   * \return the amount of mappings added; `std::nullopt` if something went wrong.
   *
   * \since 5.3.0
   */
  static auto load_mappings(const std::string& file) noexcept -> std::optional<int>
  {
    return load_mappings(file.c_str());
  }

  /**
   * \brief Returns the mapping associated with the controller.
   *
   * \return the mapping string associated with the controller.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto mapping() const noexcept -> sdl_string
  {
    return sdl_string{SDL_GameControllerMapping(m_controller)};
  }

  /**
   * \brief Returns the mapping associated with a game controller.
   *
   * \param index the joystick index of the desired game controller.
   *
   * \return the mapping string associated with a controller.
   *
   * \since 5.0.0
   */
  [[nodiscard]] static auto mapping(const joystick_index index) noexcept -> sdl_string
  {
    return sdl_string{SDL_GameControllerMappingForDeviceIndex(index)};
  }

  /**
   * \brief Returns the mapping string associated with a joystick GUID.
   *
   * \param guid the GUID to obtain the mapping for.
   *
   * \return the mapping string for a GUID:
   *
   * \since 5.0.0
   */
  [[nodiscard]] static auto mapping(const SDL_JoystickGUID guid) noexcept -> sdl_string
  {
    return sdl_string{SDL_GameControllerMappingForGUID(guid)};
  }

  /**
   * \brief Returns the mapping at a specific index.
   *
   * \param index the index of the desired mapping.
   *
   * \return the mapping at the specified index.
   *
   * \since 5.0.0
   */
  [[nodiscard]] static auto mapping_by_index(const mapping_index index) noexcept -> sdl_string
  {
    return sdl_string{SDL_GameControllerMappingForIndex(index)};
  }

  /**
   * \brief Returns the number of installed mappings.
   *
   * \return the amount of installed mappings.
   *
   * \since 5.0.0
   */
  [[nodiscard]] static auto mapping_count() noexcept -> int
  {
    return SDL_GameControllerNumMappings();
  }

  /// \} End of mapping functions

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not the handle contains a non-null pointer.
   *
   * \return `true` if the handle holds a non-null pointer; `false` otherwise.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit operator bool() const noexcept
  {
    return m_controller != nullptr;
  }

  /// \} End of conversions

 private:
  struct deleter final
  {
    void operator()(SDL_GameController* controller) noexcept
    {
      SDL_GameControllerClose(controller);
    }
  };
  detail::pointer_manager<T, SDL_GameController, deleter> m_controller;
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied controller mapping result.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(controller::mapping_result::added) == "added"`.
 *
 * \param result the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] inline auto to_string(const controller::mapping_result result)
    -> std::string_view
{
  switch (result) {
    case controller::mapping_result::error:
      return "error";

    case controller::mapping_result::updated:
      return "updated";

    case controller::mapping_result::added:
      return "added";

    default:
      throw cen_error{"Did not recognize controller mapping result!"};
  }
}

/// \see to_string(controller::mapping_result)
[[nodiscard]] constexpr auto to_string(const controller_handle::mapping_result result)
    -> std::string_view
{
  switch (result) {
    case controller_handle::mapping_result::error:
      return "error";

    case controller_handle::mapping_result::updated:
      return "updated";

    case controller_handle::mapping_result::added:
      return "added";

    default:
      throw cen_error{"Did not recognize controller mapping result!"};
  }
}

/**
 * \brief Returns a textual representation of a game controller.
 *
 * \param controller the game controller that will be converted.
 *
 * \return a string that represents a game controller.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_controller<T>& controller) -> std::string
{
  const auto* name = controller.name();

  str serial{};
  if constexpr (detail::sdl_version_at_least(2, 0, 14)) {
    serial = controller.serial();
  }

#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("controller{{data: {}, name: {}, serial: {}}}",
                     detail::address_of(controller.get()),
                     str_or_na(name),
                     str_or_na(serial));
#else
  return "controller{data: " + detail::address_of(controller.get()) +
         ", name: " + str_or_na(name) + ", serial: " + str_or_na(serial) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a controller mapping result enumerator.
 *
 * \param stream the output stream that will be used.
 * \param result the enumerator that will be printed.
 *
 * \see `to_string(controller::mapping_result)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const controller::mapping_result result)
    -> std::ostream&
{
  return stream << to_string(result);
}

/// \see operator<<(std::ostream&, controller::mapping_result)
inline auto operator<<(std::ostream& stream, const controller_handle::mapping_result result)
    -> std::ostream&
{
  return stream << to_string(result);
}

/**
 * \brief Prints a textual representation of a game controller.
 *
 * \param stream the stream that will be used.
 * \param controller the game controller that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_controller<T>& controller) -> std::ostream&
{
  return stream << to_string(controller);
}

/// \} End of streaming

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_GAME_CONTROLLER_HEADER

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class controller_axis_event
 *
 * \brief Represents an event triggered by game controller axis motion.
 *
 * \since 4.0.0
 */
class controller_axis_event final : public common_event<SDL_ControllerAxisEvent>
{
 public:
  /**
   * \brief Creates a controller axis event of type `controller_axis_motion`.
   *
   * \since 4.0.0
   */
  controller_axis_event() noexcept : common_event{cen::event_type::controller_axis_motion}
  {}

  /**
   * \brief Creates a controller axis event that is based on the supplied SDL
   * controller axis event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit controller_axis_event(const SDL_ControllerAxisEvent& event) noexcept
      : common_event{event}
  {}

  /**
   * \brief Sets the joystick instance ID associated with the event.
   *
   * \param which the instance ID of the joystick that the event is
   * associated with.
   *
   * \since 4.0.0
   */
  void set_which(const SDL_JoystickID which) noexcept
  {
    m_event.which = which;
  }

  /**
   * \brief Sets the game controller axis value associated with the event.
   *
   * \param axis the game controller axis value associated with the event.
   *
   * \since 4.0.0
   */
  void set_axis(const controller_axis axis) noexcept
  {
    m_event.axis = static_cast<u8>(axis);
  }

  /**
   * \brief Sets the axis value associated with the event.
   *
   * \param value the new axis value associated with the event.
   *
   * \since 4.0.0
   */
  void set_value(const i16 value) noexcept
  {
    m_event.value = value;
  }

  /**
   * \brief Returns the joystick instance ID associated with the event.
   *
   * \return the joystick instance ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto which() const noexcept -> SDL_JoystickID
  {
    return m_event.which;
  }

  /**
   * \brief Returns the game controller axis value associated with the event.
   *
   * \return the game controller axis value associated with the event.
   *
   * \see `GameControllerAxis`
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto axis() const noexcept -> controller_axis
  {
    return static_cast<controller_axis>(m_event.axis);
  }

  /**
   * \brief Returns the axis value associated with the event.
   *
   * \return the axis value associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto value() const noexcept -> i16
  {
    return m_event.value;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_ControllerAxisEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.caxis = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_CONTROLLER_AXIS_EVENT_HEADER

// #include "centurion/events/controller_button_event.hpp"
#ifndef CENTURION_CONTROLLER_BUTTON_EVENT_HEADER
#define CENTURION_CONTROLLER_BUTTON_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../core/to_underlying.hpp"

// #include "../input/controller.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class controller_button_event
 *
 * \brief Represents events associated with the state of buttons of a game
 * controller.
 *
 * \see `SDL_ControllerButtonEvent`
 *
 * \since 4.0.0
 */
class controller_button_event final : public common_event<SDL_ControllerButtonEvent>
{
 public:
  /**
   * \brief Creates a controller button event of type `controller_button_down`.
   *
   * \since 4.0.0
   */
  controller_button_event() noexcept : common_event{event_type::controller_button_down}
  {}

  /**
   * \brief Creates a controller button event that is based on the supplied SDL
   * controller button event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit controller_button_event(const SDL_ControllerButtonEvent& event) noexcept
      : common_event{event}
  {}

  /**
   * \brief Sets the game controller button associated with the event.
   *
   * \param button the game controller button associated with the event.
   *
   * \since 4.0.0
   */
  void set_button(const controller_button button) noexcept
  {
    m_event.button = static_cast<u8>(button);
  }

  /**
   * \brief Sets the button state associated with the event.
   *
   * \param state the button state associated with the event.
   *
   * \since 4.0.0
   */
  void set_state(const button_state state) noexcept
  {
    m_event.state = to_underlying(state);
  }

  /**
   * \brief Sets the joystick instance ID associated with the event.
   *
   * \param id the instance ID of the joystick that the event is associated
   * with.
   *
   * \since 4.0.0
   */
  void set_which(const SDL_JoystickID id) noexcept
  {
    m_event.which = id;
  }

  /**
   * \brief Returns the game controller button associated with the event.
   *
   * \return the game controller button associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto button() const noexcept -> controller_button
  {
    return static_cast<controller_button>(m_event.button);
  }

  /**
   * \brief Returns the button state associated with the event.
   *
   * \return the button state associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto state() const noexcept -> button_state
  {
    return static_cast<button_state>(m_event.state);
  }

  /**
   * \brief Indicates whether or not the associated button is pressed.
   *
   * \return `true` if the associated button is pressed; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto pressed() const noexcept -> bool
  {
    return state() == button_state::pressed;
  }

  /**
   * \brief Indicates whether or not the associated button is released.
   *
   * \return `true` if the associated button is released; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto released() const noexcept -> bool
  {
    return state() == button_state::released;
  }

  /**
   * \brief Returns the joystick instance ID associated with the event.
   *
   * \return the joystick instance ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto which() const noexcept -> SDL_JoystickID
  {
    return m_event.which;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_ControllerButtonEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.cbutton = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_CONTROLLER_BUTTON_EVENT_HEADER

// #include "centurion/events/controller_device_event.hpp"
#ifndef CENTURION_CONTROLLER_DEVICE_EVENT_HEADER
#define CENTURION_CONTROLLER_DEVICE_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class controller_device_event
 *
 * \brief Represents events related to game controller devices such as adding
 * or removing game controller devices.
 *
 * \see `SDL_ControllerDeviceEvent`
 *
 * \since 4.0.0
 */
class controller_device_event final : public common_event<SDL_ControllerDeviceEvent>
{
 public:
  /**
   * \brief Creates a controller device event of type `controller_device_added`.
   *
   * \since 4.0.0
   */
  controller_device_event() noexcept : common_event{event_type::controller_device_added}
  {}

  /**
   * \brief Creates a controller device event that is based on the supplied SDL
   * controller device event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit controller_device_event(const SDL_ControllerDeviceEvent& event) noexcept
      : common_event{event}
  {}

  /**
   * \brief Sets the joystick device index or instance ID.
   *
   * \details If the event type is `Added`, then this value is the joystick
   * device index. If the type of the event is either `Removed` or
   * `Remapped`, then this value is the instance ID.
   *
   * \param which the joystick device index or instance ID.
   *
   * \since 4.0.0
   */
  void set_which(const i32 which) noexcept
  {
    m_event.which = which;
  }

  /**
   * \brief Returns the joystick device index or instance ID.
   *
   * \details Returns the joystick device index if the type of the event is
   * `Added`. Returns the instance ID if the type of the event is either
   * `Removed` or `Remapped`.
   *
   * \return the joystick device index or instance ID.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto which() const noexcept -> i32
  {
    return m_event.which;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_ControllerDeviceEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.cdevice = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_CONTROLLER_DEVICE_EVENT_HEADER

// #include "centurion/events/controller_sensor_event.hpp"
#ifndef CENTURION_CONTROLLER_SENSOR_EVENT_HEADER
#define CENTURION_CONTROLLER_SENSOR_EVENT_HEADER

#include <SDL.h>

#include <array>  // array

// #include "../core/to_underlying.hpp"

// #include "../detail/array_utils.hpp"
#ifndef CENTURION_DETAIL_ARRAY_UTILS_HEADER
#define CENTURION_DETAIL_ARRAY_UTILS_HEADER

#include <array>  // array, to_array

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER

// #include "../core/integers.hpp"
#ifndef CENTURION_INTEGERS_HEADER
#define CENTURION_INTEGERS_HEADER

#include <SDL.h>

#include <cstddef>  // size_t

namespace cen {

/// \addtogroup core
/// \{

/// \name Integer aliases
/// \{

using usize = std::size_t;

/// Alias for an unsigned integer.
using uint = unsigned int;

/// Alias for the type used for integer literal operators.
using ulonglong = unsigned long long;

/// Alias for a 64-bit unsigned integer.
using u64 = Uint64;

/// Alias for a 32-bit unsigned integer.
using u32 = Uint32;

/// Alias for a 16-bit unsigned integer.
using u16 = Uint16;

/// Alias for an 8-bit unsigned integer.
using u8 = Uint8;

/// Alias for a 64-bit signed integer.
using i64 = Sint64;

/// Alias for a 32-bit signed integer.
using i32 = Sint32;

/// Alias for a 16-bit signed integer.
using i16 = Sint16;

/// Alias for an 8-bit signed integer.
using i8 = Sint8;

/// \} End of integer aliases

// clang-format off

/**
 * \brief Obtains the size of a container as an `int`.
 *
 * \tparam T a "container" that provides a `size()` member function.
 *
 * \param container the container to query the size of.
 *
 * \return the size of the container as an `int` value.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto isize(const T& container) noexcept(noexcept(container.size()))
    -> int
{
  return static_cast<int>(container.size());
}

// clang-format on

namespace literals {

/**
 * \brief Creates an 8-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u8(const ulonglong value) noexcept -> u8
{
  return static_cast<u8>(value);
}

/**
 * \brief Creates a 16-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u16(const ulonglong value) noexcept -> u16
{
  return static_cast<u16>(value);
}

/**
 * \brief Creates a 32-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u32(const ulonglong value) noexcept -> u32
{
  return static_cast<u32>(value);
}

/**
 * \brief Creates a 64-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u64(const ulonglong value) noexcept -> u64
{
  return static_cast<u64>(value);
}

/**
 * \brief Creates an 8-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i8(const ulonglong value) noexcept -> i8
{
  return static_cast<i8>(value);
}

/**
 * \brief Creates a 16-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i16(const ulonglong value) noexcept -> i16
{
  return static_cast<i16>(value);
}

/**
 * \brief Creates a 32-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i32(const ulonglong value) noexcept -> i32
{
  return static_cast<i32>(value);
}

/**
 * \brief Creates a 64-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i64(const ulonglong value) noexcept -> i64
{
  return static_cast<i64>(value);
}

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_INTEGERS_HEADER


/// \cond FALSE
namespace cen::detail {

template <typename T, usize Size>
constexpr void assign(const std::array<T, Size>& array, T (&out)[Size])
{
  usize index = 0;
  for (auto&& value : array) {
    out[index] = value;
    ++index;
  }
}

template <typename T, usize Size>
[[nodiscard]] constexpr auto to_array(const T (&data)[Size]) -> std::array<T, Size>
{
#if CENTURION_HAS_FEATURE_TO_ARRAY
  return std::to_array(data);
#else
  std::array<T, Size> array;  // NOLINT

  for (usize i = 0; i < Size; ++i) {
    array[i] = data[i];
  }

  return array;
#endif  // CENTURION_HAS_FEATURE_TO_ARRAY
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_ARRAY_UTILS_HEADER

// #include "../input/sensor_type.hpp"
#ifndef CENTURION_SENSOR_TYPE_HEADER
#define CENTURION_SENSOR_TYPE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum sensor_type
 *
 * \brief Provides values that represent different sensor types.
 *
 * \see SDL_SensorType
 *
 * \since 5.2.0
 */
enum class sensor_type
{
  invalid = SDL_SENSOR_INVALID,      ///< Invalid sensor
  unknown = SDL_SENSOR_UNKNOWN,      ///< Unknown sensor
  accelerometer = SDL_SENSOR_ACCEL,  ///< Accelerometer
  gyroscope = SDL_SENSOR_GYRO        ///< Gyroscope
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied sensor type.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(sensor_type::gyroscope) == "gyroscope"`.
 *
 * \param type the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const sensor_type type) -> std::string_view
{
  switch (type) {
    case sensor_type::invalid:
      return "invalid";

    case sensor_type::unknown:
      return "unknown";

    case sensor_type::accelerometer:
      return "accelerometer";

    case sensor_type::gyroscope:
      return "gyroscope";

    default:
      throw cen_error{"Did not recognize sensor type!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a sensor type enumerator.
 *
 * \param stream the output stream that will be used.
 * \param type the enumerator that will be printed.
 *
 * \see `to_string(sensor_type)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const sensor_type type) -> std::ostream&
{
  return stream << to_string(type);
}

/// \} End of streaming

/// \name Sensor type comparison operators
/// \{

/**
 * \brief Indicates whether or not two sensor types values are equal.
 *
 * \param lhs the left-hand side sensor type.
 * \param rhs the right-hand side sensor type.
 *
 * \return `true` if the two sensor types are equal; `false` otherwise.
 *
 * \since 5.2.0
 */
[[nodiscard]] constexpr auto operator==(const sensor_type lhs,
                                        const SDL_SensorType rhs) noexcept -> bool
{
  return static_cast<SDL_SensorType>(lhs) == rhs;
}

/// \copydoc operator==(const sensor_type, const SDL_SensorType)
[[nodiscard]] constexpr auto operator==(const SDL_SensorType lhs,
                                        const sensor_type rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two sensor types values aren't equal.
 *
 * \param lhs the left-hand side sensor type.
 * \param rhs the right-hand side sensor type.
 *
 * \return `true` if the two sensor types aren't equal; `false` otherwise.
 *
 * \since 5.2.0
 */
[[nodiscard]] constexpr auto operator!=(const sensor_type lhs,
                                        const SDL_SensorType rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const sensor_type, const SDL_SensorType)
[[nodiscard]] constexpr auto operator!=(const SDL_SensorType lhs,
                                        const sensor_type rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of sensor type comparison operators

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_SENSOR_TYPE_HEADER

// #include "common_event.hpp"


namespace cen {

#if SDL_VERSION_ATLEAST(2, 0, 14)

/// \addtogroup event
/// \{

/**
 * \class controller_sensor_event
 *
 * \brief Represents events associated with controller sensor updates.
 *
 * \since 6.3.0
 */
class controller_sensor_event final : public common_event<SDL_ControllerSensorEvent>
{
 public:
  using data_type = std::array<float, 3>;

  /**
   * \brief Creates a controller sensor event.
   *
   * \since 6.3.0
   */
  controller_sensor_event() noexcept : common_event{event_type::controller_sensor_update}
  {}

  /**
   * \brief Creates a controller sensor event based on an SDL event.
   *
   * \param event the event that will be copied.
   *
   * \since 6.3.0
   */
  explicit controller_sensor_event(const SDL_ControllerSensorEvent& event) noexcept
      : common_event{event}
  {}

  /**
   * \brief Sets the joystick instance ID associated with the event.
   *
   * \param id the associated joystick instance ID.
   *
   * \since 6.3.0
   */
  void set_which(const SDL_JoystickID id) noexcept
  {
    m_event.which = id;
  }

  /**
   * \brief Sets the associated sensor type.
   *
   * \param sensor the type of the associated sensor.
   *
   * \since 6.3.0
   */
  void set_sensor(const sensor_type sensor) noexcept
  {
    m_event.sensor = to_underlying(sensor);
  }

  /**
   * \brief Sets the sensor values associated with the event.
   *
   * \param values the sensor values.
   *
   * \since 6.3.0
   */
  void set_data(const data_type& values)
  {
    detail::assign(values, m_event.data);
  }

  /**
   * \brief Returns the joystick instance ID associated with the event.
   *
   * \return the associated joystick instance ID.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto which() const noexcept -> SDL_JoystickID
  {
    return m_event.which;
  }

  /**
   * \brief Returns the type of the associated sensor.
   *
   * \return the associated sensor type.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto sensor() const noexcept -> sensor_type
  {
    return static_cast<sensor_type>(m_event.sensor);
  }

  /**
   * \brief Returns up to 3 values from the sensor.
   *
   * \return values from the sensor.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto data() const -> data_type
  {
    return detail::to_array(m_event.data);
  }
};

template <>
inline auto as_sdl_event(const common_event<SDL_ControllerSensorEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.csensor = event.get();
  return e;
}

/// \} End of group event

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

}  // namespace cen

#endif  // CENTURION_CONTROLLER_SENSOR_EVENT_HEADER

// #include "centurion/events/controller_touchpad_event.hpp"
#ifndef CENTURION_CONTROLLER_TOUCHPAD_EVENT_HEADER
#define CENTURION_CONTROLLER_TOUCHPAD_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../detail/clamp.hpp"
#ifndef CENTURION_DETAIL_CLAMP_HEADER
#define CENTURION_DETAIL_CLAMP_HEADER

#include <cassert>  // assert

/// \cond FALSE
namespace cen::detail {

// clang-format off

/**
 * \brief Clamps a value to be within the range [min, max].
 *
 * \pre `min` must be less than or equal to `max`.
 *
 * \note The standard library provides `std::clamp`, but it isn't mandated to be
 * `noexcept` (although MSVC does mark it as `noexcept`), which is the reason this
 * function exists.
 *
 * \tparam T the type of the values.
 *
 * \param value the value that will be clamped.
 * \param min the minimum value (inclusive).
 * \param max the maximum value (inclusive).
 *
 * \return the clamped value.
 *
 * \since 5.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto clamp(const T& value,
                                   const T& min,
                                   const T& max)
    noexcept(noexcept(value < min) && noexcept(value > max)) -> T
{
  assert(min <= max);
  if (value < min)
  {
    return min;
  }
  else if (value > max)
  {
    return max;
  }
  else
  {
    return value;
  }
}

// clang-format on

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_CLAMP_HEADER

// #include "common_event.hpp"


namespace cen {

#if SDL_VERSION_ATLEAST(2, 0, 14)

/// \addtogroup event
/// \{

/**
 * \class controller_touchpad_event
 *
 * \brief Represents events associated with controller touchpads.
 *
 * \since 6.3.0
 */
class controller_touchpad_event final : public common_event<SDL_ControllerTouchpadEvent>
{
 public:
  /**
   * \brief Creates a controller touchpad event with `controller_touchpad_down` as the specific
   * type.
   *
   * \see `event_type::controller_touchpad_down`
   * \see `event_type::controller_touchpad_up`
   * \see `event_type::controller_touchpad_motion`
   *
   * \since 6.3.0
   */
  controller_touchpad_event() noexcept : common_event{event_type::controller_touchpad_down}
  {}

  /**
   * \brief Creates a controller touchpad event based an SDL event.
   *
   * \param event the event that will be copied.
   *
   * \since 6.3.0
   */
  explicit controller_touchpad_event(const SDL_ControllerTouchpadEvent& event) noexcept
      : common_event{event}
  {}

  /**
   * \brief Sets the joystick instance ID associated with the event.
   *
   * \param id the associated joystick instance ID.
   *
   * \since 6.3.0
   */
  void set_which(const SDL_JoystickID id) noexcept
  {
    m_event.which = id;
  }

  /**
   * \brief Sets the touchpad index associated with the event.
   *
   * \param index the associated touchpad index.
   *
   * \since 6.3.0
   */
  void set_touchpad_index(const i32 index) noexcept
  {
    m_event.touchpad = index;
  }

  /**
   * \brief Sets the finger index on the touchpad associated with the event.
   *
   * \param index the associated finger index.
   *
   * \since 6.3.0
   */
  void set_finger_index(const i32 index) noexcept
  {
    m_event.finger = index;
  }

  /**
   * \brief Sets the associated x-coordinate.
   *
   * \details The supplied value is clamped within the range [0, 1].
   *
   * \param x the normalized x-coordinate.
   *
   * \since 6.3.0
   */
  void set_x(const float x) noexcept
  {
    m_event.x = detail::clamp(x, 0.0f, 1.0f);
  }

  /**
   * \brief Sets the associated y-coordinate.
   *
   * \details The supplied value is clamped within the range [0, 1].
   *
   * \param y the normalized y-coordinate.
   *
   * \since 6.3.0
   */
  void set_y(const float y) noexcept
  {
    m_event.y = detail::clamp(y, 0.0f, 1.0f);
  }

  /**
   * \brief Sets the associated pressure.
   *
   * \details The supplied value is clamped within the range [0, 1].
   *
   * \param pressure the normalized y-coordinate.
   *
   * \since 6.3.0
   */
  void set_pressure(const float pressure) noexcept
  {
    m_event.pressure = detail::clamp(pressure, 0.0f, 1.0f);
  }

  /**
   * \brief Returns the joystick instance ID associated with the event.
   *
   * \return the associated joystick instance ID.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto which() const noexcept -> SDL_JoystickID
  {
    return m_event.which;
  }

  /**
   * \brief Returns the touchpad index associated with the event.
   *
   * \return the associated touchpad index.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto touchpad_index() const noexcept -> i32
  {
    return m_event.touchpad;
  }

  /**
   * \brief Returns the finger index associated with the event.
   *
   * \return the associated finger index.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto finger_index() const noexcept -> i32
  {
    return m_event.finger;
  }

  /**
   * \brief Returns the associated x-coordinate.
   *
   * \return the normalized x-coordinate.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto x() const noexcept -> float
  {
    return m_event.x;
  }

  /**
   * \brief Returns the associated y-coordinate.
   *
   * \return the normalized y-coordinate.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto y() const noexcept -> float
  {
    return m_event.y;
  }

  /**
   * \brief Returns the associated pressure.
   *
   * \return the normalized pressure.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto pressure() const noexcept -> float
  {
    return m_event.pressure;
  }
};

template <>
inline auto as_sdl_event(const common_event<SDL_ControllerTouchpadEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.ctouchpad = event.get();
  return e;
}

/// \} End of group event

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

}  // namespace cen

#endif  // CENTURION_CONTROLLER_TOUCHPAD_EVENT_HEADER

// #include "centurion/events/display_event.hpp"
#ifndef CENTURION_DISPLAY_EVENT_HEADER
#define CENTURION_DISPLAY_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../core/to_underlying.hpp"

// #include "common_event.hpp"

// #include "display_event_id.hpp"
#ifndef CENTURION_DISPLAY_EVENT_ID_HEADER
#define CENTURION_DISPLAY_EVENT_ID_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

#if SDL_VERSION_ATLEAST(2, 0, 14)

/// \addtogroup event
/// \{

/**
 * \enum display_event_id
 *
 * \brief Represents the different variants of `display_event` events.
 *
 * \see `display_event_id_count()`
 * \see `display_event`
 *
 * \since 6.3.0
 */
enum class display_event_id
{
  none = SDL_DISPLAYEVENT_NONE,                  ///< Unused.
  orientation = SDL_DISPLAYEVENT_ORIENTATION,    ///< Display orientation changed.
  connected = SDL_DISPLAYEVENT_CONNECTED,        ///< A display was added.
  disconnected = SDL_DISPLAYEVENT_DISCONNECTED,  ///< A display was removed.
};

/**
 * \brief Returns the number of enumerators for the `display_event_id` enum.
 *
 * \return the number of enumerators.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto display_event_id_count() noexcept -> int
{
  return 4;
}

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied display event ID.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(display_event_id::connected) == "connected"`.
 *
 * \param id the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto to_string(const display_event_id id) -> std::string_view
{
  switch (id) {
    case display_event_id::none:
      return "none";

    case display_event_id::orientation:
      return "orientation";

    case display_event_id::connected:
      return "connected";

    case display_event_id::disconnected:
      return "disconnected";

    default:
      throw cen_error{"Did not recognize display event ID!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a display event ID enumerator.
 *
 * \param stream the output stream that will be used.
 * \param id the enumerator that will be printed.
 *
 * \see `to_string(display_event_id)`
 *
 * \return the used stream.
 *
 * \since 6.3.0
 */
inline auto operator<<(std::ostream& stream, const display_event_id id) -> std::ostream&
{
  return stream << to_string(id);
}

/// \} End of streaming

/// \} End of group event

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

}  // namespace cen

#endif  // CENTURION_DISPLAY_EVENT_ID_HEADER


namespace cen {

#if SDL_VERSION_ATLEAST(2, 0, 14)

/// \addtogroup event
/// \{

/**
 * \class display_event
 *
 * \brief Represents events related to displays.
 *
 * \see `SDL_DisplayEvent`
 *
 * \since 6.3.0
 */
class display_event final : public common_event<SDL_DisplayEvent>
{
 public:
  /**
   * \brief Creates a display event.
   *
   * \since 6.3.0
   */
  display_event() noexcept : common_event{event_type::display}
  {}

  /**
   * \brief Creates a display event based an SDL event.
   *
   * \param event the event that will be copied.
   *
   * \since 6.3.0
   */
  explicit display_event(const SDL_DisplayEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the associated display event ID.
   *
   * \param id the associated display event subtype.
   *
   * \since 6.3.0
   */
  void set_event_id(const display_event_id id) noexcept
  {
    m_event.event = static_cast<u8>(to_underlying(id));
  }

  /**
   * \brief Sets the associated display index.
   *
   * \param index the associated display index.
   *
   * \since 6.3.0
   */
  void set_index(const u32 index) noexcept
  {
    m_event.display = index;
  }

  /**
   * \brief Sets event type specific data.
   *
   * \param data the associated data value.
   *
   * \see `display_event_id`
   *
   * \since 6.3.0
   */
  void set_data_1(const i32 data) noexcept
  {
    m_event.data1 = data;
  }

  /**
   * \brief Returns the associated display event ID.
   *
   * \return the associated display event subtype.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto event_id() const noexcept -> display_event_id
  {
    return static_cast<display_event_id>(m_event.event);
  }

  /**
   * \brief Returns the index of the associated display.
   *
   * \return the associated display index.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto index() const noexcept -> u32
  {
    return m_event.display;
  }

  /**
   * \brief Returns subtype specific data.
   *
   * \details The returned value is the display orientation if the type of the event is
   * equivalent to `display_event_id::orientation`.
   *
   * \return subtype specific data.
   *
   * \see `screen_orientation`
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto data_1() const noexcept -> i32
  {
    return m_event.data1;
  }
};

template <>
inline auto as_sdl_event(const common_event<SDL_DisplayEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.display = event.get();
  return e;
}

/// \} End of group event

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

}  // namespace cen

#endif  // CENTURION_DISPLAY_EVENT_HEADER

// #include "centurion/events/display_event_id.hpp"
#ifndef CENTURION_DISPLAY_EVENT_ID_HEADER
#define CENTURION_DISPLAY_EVENT_ID_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

#if SDL_VERSION_ATLEAST(2, 0, 14)

/// \addtogroup event
/// \{

/**
 * \enum display_event_id
 *
 * \brief Represents the different variants of `display_event` events.
 *
 * \see `display_event_id_count()`
 * \see `display_event`
 *
 * \since 6.3.0
 */
enum class display_event_id
{
  none = SDL_DISPLAYEVENT_NONE,                  ///< Unused.
  orientation = SDL_DISPLAYEVENT_ORIENTATION,    ///< Display orientation changed.
  connected = SDL_DISPLAYEVENT_CONNECTED,        ///< A display was added.
  disconnected = SDL_DISPLAYEVENT_DISCONNECTED,  ///< A display was removed.
};

/**
 * \brief Returns the number of enumerators for the `display_event_id` enum.
 *
 * \return the number of enumerators.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto display_event_id_count() noexcept -> int
{
  return 4;
}

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied display event ID.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(display_event_id::connected) == "connected"`.
 *
 * \param id the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto to_string(const display_event_id id) -> std::string_view
{
  switch (id) {
    case display_event_id::none:
      return "none";

    case display_event_id::orientation:
      return "orientation";

    case display_event_id::connected:
      return "connected";

    case display_event_id::disconnected:
      return "disconnected";

    default:
      throw cen_error{"Did not recognize display event ID!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a display event ID enumerator.
 *
 * \param stream the output stream that will be used.
 * \param id the enumerator that will be printed.
 *
 * \see `to_string(display_event_id)`
 *
 * \return the used stream.
 *
 * \since 6.3.0
 */
inline auto operator<<(std::ostream& stream, const display_event_id id) -> std::ostream&
{
  return stream << to_string(id);
}

/// \} End of streaming

/// \} End of group event

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

}  // namespace cen

#endif  // CENTURION_DISPLAY_EVENT_ID_HEADER

// #include "centurion/events/dollar_gesture_event.hpp"
#ifndef CENTURION_DOLLAR_GESTURE_HEADER
#define CENTURION_DOLLAR_GESTURE_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class dollar_gesture_event
 *
 * \brief Provides information about dollar gestures from touch events.
 *
 * \see `SDL_DollarGestureEvent`
 *
 * \since 4.0.0
 */
class dollar_gesture_event final : public common_event<SDL_DollarGestureEvent>
{
 public:
  /**
   * \brief Creates a dollar gesture event of type `dollar_gesture`.
   *
   * \since 4.0.0
   */
  dollar_gesture_event() noexcept : common_event{event_type::dollar_gesture}
  {
    set_type(event_type::dollar_gesture);
  }

  /**
   * \brief Creates a dollar gesture event that is based on the supplied SDL
   * dollar gesture event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit dollar_gesture_event(const SDL_DollarGestureEvent& event) noexcept
      : common_event{event}
  {}

  /**
   * \brief Sets the touch device ID associated with the event.
   *
   * \param id the touch device ID associated with the event.
   *
   * \since 4.0.0
   */
  void set_touch_id(const SDL_TouchID id) noexcept
  {
    m_event.touchId = id;
  }

  /**
   * \brief Sets the gesture ID associated with the event.
   *
   * \param id the gesture ID associated with the event.
   *
   * \since 4.0.0
   */
  void set_gesture_id(const SDL_GestureID id) noexcept
  {
    m_event.gestureId = id;
  }

  /**
   * \brief Sets the amount of fingers used to draw the stroke.
   *
   * \param fingers the amount of fingers used to draw the stroke.
   *
   * \todo Centurion 7.0.0: Rename to set_finger_count.
   *
   * \since 4.0.0
   */
  void set_fingers(const u32 fingers) noexcept
  {
    m_event.numFingers = fingers;
  }

  /**
   * \brief Sets the error value for the performed stroke compared with the
   * gesture template associated with the event.
   *
   * \since 4.0.0
   */
  void set_error(const float error) noexcept
  {
    m_event.error = error;
  }

  /**
   * \brief Sets the normalized x-coordinate of the center of the gesture.
   *
   * \param x the normalized x-coordinate of the center of the gesture.
   *
   * \since 4.0.0
   */
  void set_x(const float x) noexcept
  {
    m_event.x = x;
  }

  /**
   * \brief Sets the normalized y-coordinate of the center of the gesture.
   *
   * \param y the normalized y-coordinate of the center of the gesture.
   *
   * \since 4.0.0
   */
  void set_y(const float y) noexcept
  {
    m_event.y = y;
  }

  /**
   * \brief Returns the touch device ID associated with the event.
   *
   * \return the touch device ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto touch_id() const noexcept -> SDL_TouchID
  {
    return m_event.touchId;
  }

  /**
   * \brief Returns the unique ID of the closest gesture to the performed
   * stroke.
   *
   * \return the unique ID of the closest gesture to the performed stroke.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto gesture_id() const noexcept -> SDL_GestureID
  {
    return m_event.gestureId;
  }

  /**
   * \brief Returns the amount of fingers used to draw the stroke.
   *
   * \return the amount of fingers used to draw the stroke.
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto finger_count() const noexcept -> u32
  {
    return m_event.numFingers;
  }

  /**
   * \brief Returns the difference between the gesture template and the
   * performed gesture.
   *
   * \details The lower the error, the better the match.
   *
   * \return the difference between the gesture template and the performed
   * gesture.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto error() const noexcept -> float
  {
    return m_event.error;
  }

  /**
   * \brief Returns the x-coordinate of the normalized center of the gesture.
   *
   * \return the x-coordinate of the normalized center of the gesture.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto x() const noexcept -> float
  {
    return m_event.x;
  }

  /**
   * \brief Returns the y-coordinate of the normalized center of the gesture.
   *
   * \return the y-coordinate of the normalized center of the gesture.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto y() const noexcept -> float
  {
    return m_event.y;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_DollarGestureEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.dgesture = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_DOLLAR_GESTURE_HEADER

// #include "centurion/events/drop_event.hpp"
#ifndef CENTURION_DROP_EVENT_HEADER
#define CENTURION_DROP_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class drop_event
 *
 * \brief Represents the event of requesting a file to be opened.
 *
 * \see `SDL_DropEvent`
 *
 * \since 4.0.0
 */
class drop_event final : public common_event<SDL_DropEvent>
{
 public:
  /**
   * \brief Creates a drop event of type `drop_file`.
   *
   * \since 4.0.0
   */
  drop_event() noexcept : common_event{event_type::drop_file}
  {}

  /**
   * \brief Creates a drop event based on the supplied event.
   *
   * \param event the SDL drop event that will be copied.
   *
   * \since 4.0.0
   */
  explicit drop_event(const SDL_DropEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Destroys the drop event.
   *
   * \details The associated file will be freed depending on the value
   * returned from the `will_free_file()` function.
   *
   * \since 4.0.0
   */
  ~drop_event() noexcept
  {
    if (m_event.file && m_willFreeFile) {
      SDL_free(m_event.file);
    }
  }

  /**
   * \brief Sets whether or not the associated file will be freed by this event.
   *
   * \details If you set this property to `false`, you **must** remember to
   * call `SDL_free` on the file pointer by yourself. Otherwise, you'll end
   * up with a memory leak!
   *
   * \param freeFile `true` if the associated file should be freed upon the
   * destruction of the event; `false` otherwise.
   *
   * \since 4.0.0
   */
  void set_will_free_file(const bool freeFile) noexcept
  {
    m_willFreeFile = freeFile;
  }

  /**
   * \brief Sets the file associated with the drop event.
   *
   * \details The ownership of the supplied pointer will, by default, not be
   * claimed by this event.
   *
   * \note The supplied pointer will be freed using `SDL_free` upon the
   * destruction of the event *if* the `will_free_file` property is set to
   * **true**.
   *
   * \note If the `will_free_file` property is `true`, then **the previously
   * set file pointer will be freed** by calling this function. However, if the
   * `will_free_file` property is `false`, then the old file pointer is
   * simply overridden. Of course, this may, if you're not careful, introduce a
   * memory leak in your program!
   *
   * \warning Make sure you know what you are doing when using this function.
   *
   * \param file a pointer to a file, can safely be null.
   *
   * \since 4.0.0
   */
  void set_file(char* file) noexcept
  {
    if (m_event.file && m_willFreeFile) {
      SDL_free(m_event.file);
    }
    m_event.file = file;
  }

  /**
   * \brief Sets the ID of the window that is the target of the drop event.
   *
   * \param id the ID of the window that is the target of the drop event.
   *
   * \since 4.0.0
   */
  void set_window_id(const u32 id) noexcept
  {
    m_event.windowID = id;
  }

  /**
   * \brief Indicates whether or not the associated file will be freed by
   * this event upon destruction.
   *
   * \details By default, this property is set to **false**.
   *
   * \return `true` if the associated file will be freed upon destruction;
   * `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto will_free_file() const noexcept -> bool
  {
    return m_willFreeFile;
  }

  /**
   * \brief Returns a pointer to the associated file.
   *
   * \warning Do **not** claim ownership of the returned pointer *without*
   * setting the `will_free_file` property to **false**.
   *
   * \note The returned pointer is always `nullptr` for `drop_begin` and
   * `drop_complete` drop events.
   *
   * \return a pointer to the file associated with the event, might be null.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto file() const noexcept -> char*
  {
    return m_event.file;
  }

  /**
   * \brief Returns the ID of the window that is the target of the drop
   * event, if there even is one.
   *
   * \return the ID of the window that is the target of the drop event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto window_id() const noexcept -> u32
  {
    return m_event.windowID;
  }

 private:
  bool m_willFreeFile{false};
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_DropEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.drop = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_DROP_EVENT_HEADER

// #include "centurion/events/event.hpp"
#ifndef CENTURION_EVENT_HEADER
#define CENTURION_EVENT_HEADER

#include <SDL.h>

#include <optional>  // optional
#include <utility>   // move
#include <variant>   // variant, holds_alternative, monostate, get, get_if

// #include "../core/result.hpp"
#ifndef CENTURION_RESULT_HEADER
#define CENTURION_RESULT_HEADER

#include <ostream>  // ostream
#include <string>   // string

namespace cen {

/// \addtogroup core
/// \{

/**
 * \class result
 *
 * \brief A simple indicator for the result of different operations.
 *
 * \details The idea behind this class is to make results of various operations
 * unambiguous. Quite an amount of functions in the library may fail, and earlier versions
 * of Centurion would usually return a `bool` in those cases, where `true` and `false`
 * would indicate success and failure, respectively. This class is a development of that
 * practice. For instance, this class is contextually convertible to `bool`, where a
 * successful result is still converted to `true`, and vice versa. However, this class
 * also enables explicit checks against `success` and `failure` constants, which makes
 * code very easy to read and unambiguous.
 * \code{cpp}
 *   cen::window window;
 *
 *   if (window.set_opacity(0.4f))
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::success)
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::failure)
 *   {
 *     // Failure!
 *   }
 * \endcode
 *
 * \see `success`
 * \see `failure`
 *
 * \since 6.0.0
 */
class result final
{
 public:
  /**
   * \brief Creates a result.
   *
   * \param success `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  constexpr result(const bool success) noexcept  // NOLINT implicit
      : m_success{success}
  {}

  /// \name Comparison operators
  /// \{

  /**
   * \brief Indicates whether or not two results have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results are equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator==(const result other) const noexcept -> bool
  {
    return m_success == other.m_success;
  }

  /**
   * \brief Indicates whether or not two results don't have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results aren't equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator!=(const result other) const noexcept -> bool
  {
    return !(*this == other);
  }

  /// \} End of comparison operators

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not the result is successful.
   *
   * \return `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr explicit operator bool() const noexcept
  {
    return m_success;
  }

  /// \} End of conversions

 private:
  bool m_success{};
};

/// Represents a successful result.
/// \since 6.0.0
inline constexpr result success{true};

/// Represents a failure of some kind.
/// \since 6.0.0
inline constexpr result failure{false};

/// \name String conversions
/// \{

/**
 * \brief Returns a string that represents a result value.
 *
 * \note The returned string is in a slightly different format compared to other Centurion
 * components.
 *
 * \param result the value that will be converted.
 *
 * \return `"success"` for a successful result; `"failure"` otherwise.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto to_string(const result result) -> std::string
{
  return result ? "success" : "failure";
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a result value using a stream.
 *
 * \param stream the stream that will be used.
 * \param result the result value that will be printed.
 *
 * \return the used stream.
 *
 * \since 6.0.0
 */
inline auto operator<<(std::ostream& stream, const result result) -> std::ostream&
{
  return stream << to_string(result);
}

/// \} End of streaming

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_RESULT_HEADER

// #include "../core/to_underlying.hpp"

// #include "audio_device_event.hpp"
#ifndef CENTURION_AUDIO_DEVICE_EVENT_HEADER
#define CENTURION_AUDIO_DEVICE_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class audio_device_event
 *
 * \brief Represents an event that is associated with some sort of audio device, either
 * capture of output.
 *
 * \see `SDL_AudioDeviceEvent`
 *
 * \since 4.0.0
 */
class audio_device_event final : public common_event<SDL_AudioDeviceEvent>
{
 public:
  /**
   * \brief Creates an audio device event of type `audio_device_added`.
   *
   * \since 4.0.0
   */
  audio_device_event() noexcept : common_event{event_type::audio_device_added}
  {}

  /**
   * \brief Creates a audio device event based on the supplied SDL event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit audio_device_event(const SDL_AudioDeviceEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the audio device ID that is associated with the event.
   *
   * \param which the audio device ID that is associated with the event.
   *
   * \since 4.0.0
   */
  void set_which(const u32 which) noexcept
  {
    m_event.which = which;
  }

  /**
   * \brief Sets whether or not the audio device event is associated with a
   * capture device.
   *
   * \param capture `true` if the event is associated with a capture device;
   * `false` indicates that the event is associated with an output device.
   *
   * \since 4.0.0
   */
  void set_capture(const bool capture) noexcept
  {
    m_event.iscapture = capture;
  }

  /**
   * \brief Returns the audio device ID associated with the event.
   *
   * \return the audio device ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto which() const noexcept -> u32
  {
    return m_event.which;
  }

  /**
   * \brief Indicates whether or not the audio device event is associated with
   * an audio output device.
   *
   * \return `true` if the event is associated with an output device; false
   * otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto output() const noexcept -> bool
  {
    return !capture();
  }

  /**
   * \brief Indicates whether or not the audio device event is associated with
   * an audio capture device.
   *
   * \return `true` if the event is associated with a capture device; false
   * otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto capture() const noexcept -> bool
  {
    return m_event.iscapture;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_AudioDeviceEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.adevice = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_AUDIO_DEVICE_EVENT_HEADER

// #include "common_event.hpp"

// #include "controller_axis_event.hpp"
#ifndef CENTURION_CONTROLLER_AXIS_EVENT_HEADER
#define CENTURION_CONTROLLER_AXIS_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../input/controller.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class controller_axis_event
 *
 * \brief Represents an event triggered by game controller axis motion.
 *
 * \since 4.0.0
 */
class controller_axis_event final : public common_event<SDL_ControllerAxisEvent>
{
 public:
  /**
   * \brief Creates a controller axis event of type `controller_axis_motion`.
   *
   * \since 4.0.0
   */
  controller_axis_event() noexcept : common_event{cen::event_type::controller_axis_motion}
  {}

  /**
   * \brief Creates a controller axis event that is based on the supplied SDL
   * controller axis event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit controller_axis_event(const SDL_ControllerAxisEvent& event) noexcept
      : common_event{event}
  {}

  /**
   * \brief Sets the joystick instance ID associated with the event.
   *
   * \param which the instance ID of the joystick that the event is
   * associated with.
   *
   * \since 4.0.0
   */
  void set_which(const SDL_JoystickID which) noexcept
  {
    m_event.which = which;
  }

  /**
   * \brief Sets the game controller axis value associated with the event.
   *
   * \param axis the game controller axis value associated with the event.
   *
   * \since 4.0.0
   */
  void set_axis(const controller_axis axis) noexcept
  {
    m_event.axis = static_cast<u8>(axis);
  }

  /**
   * \brief Sets the axis value associated with the event.
   *
   * \param value the new axis value associated with the event.
   *
   * \since 4.0.0
   */
  void set_value(const i16 value) noexcept
  {
    m_event.value = value;
  }

  /**
   * \brief Returns the joystick instance ID associated with the event.
   *
   * \return the joystick instance ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto which() const noexcept -> SDL_JoystickID
  {
    return m_event.which;
  }

  /**
   * \brief Returns the game controller axis value associated with the event.
   *
   * \return the game controller axis value associated with the event.
   *
   * \see `GameControllerAxis`
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto axis() const noexcept -> controller_axis
  {
    return static_cast<controller_axis>(m_event.axis);
  }

  /**
   * \brief Returns the axis value associated with the event.
   *
   * \return the axis value associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto value() const noexcept -> i16
  {
    return m_event.value;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_ControllerAxisEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.caxis = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_CONTROLLER_AXIS_EVENT_HEADER

// #include "controller_button_event.hpp"
#ifndef CENTURION_CONTROLLER_BUTTON_EVENT_HEADER
#define CENTURION_CONTROLLER_BUTTON_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../core/to_underlying.hpp"

// #include "../input/controller.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class controller_button_event
 *
 * \brief Represents events associated with the state of buttons of a game
 * controller.
 *
 * \see `SDL_ControllerButtonEvent`
 *
 * \since 4.0.0
 */
class controller_button_event final : public common_event<SDL_ControllerButtonEvent>
{
 public:
  /**
   * \brief Creates a controller button event of type `controller_button_down`.
   *
   * \since 4.0.0
   */
  controller_button_event() noexcept : common_event{event_type::controller_button_down}
  {}

  /**
   * \brief Creates a controller button event that is based on the supplied SDL
   * controller button event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit controller_button_event(const SDL_ControllerButtonEvent& event) noexcept
      : common_event{event}
  {}

  /**
   * \brief Sets the game controller button associated with the event.
   *
   * \param button the game controller button associated with the event.
   *
   * \since 4.0.0
   */
  void set_button(const controller_button button) noexcept
  {
    m_event.button = static_cast<u8>(button);
  }

  /**
   * \brief Sets the button state associated with the event.
   *
   * \param state the button state associated with the event.
   *
   * \since 4.0.0
   */
  void set_state(const button_state state) noexcept
  {
    m_event.state = to_underlying(state);
  }

  /**
   * \brief Sets the joystick instance ID associated with the event.
   *
   * \param id the instance ID of the joystick that the event is associated
   * with.
   *
   * \since 4.0.0
   */
  void set_which(const SDL_JoystickID id) noexcept
  {
    m_event.which = id;
  }

  /**
   * \brief Returns the game controller button associated with the event.
   *
   * \return the game controller button associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto button() const noexcept -> controller_button
  {
    return static_cast<controller_button>(m_event.button);
  }

  /**
   * \brief Returns the button state associated with the event.
   *
   * \return the button state associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto state() const noexcept -> button_state
  {
    return static_cast<button_state>(m_event.state);
  }

  /**
   * \brief Indicates whether or not the associated button is pressed.
   *
   * \return `true` if the associated button is pressed; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto pressed() const noexcept -> bool
  {
    return state() == button_state::pressed;
  }

  /**
   * \brief Indicates whether or not the associated button is released.
   *
   * \return `true` if the associated button is released; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto released() const noexcept -> bool
  {
    return state() == button_state::released;
  }

  /**
   * \brief Returns the joystick instance ID associated with the event.
   *
   * \return the joystick instance ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto which() const noexcept -> SDL_JoystickID
  {
    return m_event.which;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_ControllerButtonEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.cbutton = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_CONTROLLER_BUTTON_EVENT_HEADER

// #include "controller_device_event.hpp"
#ifndef CENTURION_CONTROLLER_DEVICE_EVENT_HEADER
#define CENTURION_CONTROLLER_DEVICE_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class controller_device_event
 *
 * \brief Represents events related to game controller devices such as adding
 * or removing game controller devices.
 *
 * \see `SDL_ControllerDeviceEvent`
 *
 * \since 4.0.0
 */
class controller_device_event final : public common_event<SDL_ControllerDeviceEvent>
{
 public:
  /**
   * \brief Creates a controller device event of type `controller_device_added`.
   *
   * \since 4.0.0
   */
  controller_device_event() noexcept : common_event{event_type::controller_device_added}
  {}

  /**
   * \brief Creates a controller device event that is based on the supplied SDL
   * controller device event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit controller_device_event(const SDL_ControllerDeviceEvent& event) noexcept
      : common_event{event}
  {}

  /**
   * \brief Sets the joystick device index or instance ID.
   *
   * \details If the event type is `Added`, then this value is the joystick
   * device index. If the type of the event is either `Removed` or
   * `Remapped`, then this value is the instance ID.
   *
   * \param which the joystick device index or instance ID.
   *
   * \since 4.0.0
   */
  void set_which(const i32 which) noexcept
  {
    m_event.which = which;
  }

  /**
   * \brief Returns the joystick device index or instance ID.
   *
   * \details Returns the joystick device index if the type of the event is
   * `Added`. Returns the instance ID if the type of the event is either
   * `Removed` or `Remapped`.
   *
   * \return the joystick device index or instance ID.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto which() const noexcept -> i32
  {
    return m_event.which;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_ControllerDeviceEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.cdevice = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_CONTROLLER_DEVICE_EVENT_HEADER

// #include "controller_sensor_event.hpp"
#ifndef CENTURION_CONTROLLER_SENSOR_EVENT_HEADER
#define CENTURION_CONTROLLER_SENSOR_EVENT_HEADER

#include <SDL.h>

#include <array>  // array

// #include "../core/to_underlying.hpp"

// #include "../detail/array_utils.hpp"

// #include "../input/sensor_type.hpp"

// #include "common_event.hpp"


namespace cen {

#if SDL_VERSION_ATLEAST(2, 0, 14)

/// \addtogroup event
/// \{

/**
 * \class controller_sensor_event
 *
 * \brief Represents events associated with controller sensor updates.
 *
 * \since 6.3.0
 */
class controller_sensor_event final : public common_event<SDL_ControllerSensorEvent>
{
 public:
  using data_type = std::array<float, 3>;

  /**
   * \brief Creates a controller sensor event.
   *
   * \since 6.3.0
   */
  controller_sensor_event() noexcept : common_event{event_type::controller_sensor_update}
  {}

  /**
   * \brief Creates a controller sensor event based on an SDL event.
   *
   * \param event the event that will be copied.
   *
   * \since 6.3.0
   */
  explicit controller_sensor_event(const SDL_ControllerSensorEvent& event) noexcept
      : common_event{event}
  {}

  /**
   * \brief Sets the joystick instance ID associated with the event.
   *
   * \param id the associated joystick instance ID.
   *
   * \since 6.3.0
   */
  void set_which(const SDL_JoystickID id) noexcept
  {
    m_event.which = id;
  }

  /**
   * \brief Sets the associated sensor type.
   *
   * \param sensor the type of the associated sensor.
   *
   * \since 6.3.0
   */
  void set_sensor(const sensor_type sensor) noexcept
  {
    m_event.sensor = to_underlying(sensor);
  }

  /**
   * \brief Sets the sensor values associated with the event.
   *
   * \param values the sensor values.
   *
   * \since 6.3.0
   */
  void set_data(const data_type& values)
  {
    detail::assign(values, m_event.data);
  }

  /**
   * \brief Returns the joystick instance ID associated with the event.
   *
   * \return the associated joystick instance ID.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto which() const noexcept -> SDL_JoystickID
  {
    return m_event.which;
  }

  /**
   * \brief Returns the type of the associated sensor.
   *
   * \return the associated sensor type.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto sensor() const noexcept -> sensor_type
  {
    return static_cast<sensor_type>(m_event.sensor);
  }

  /**
   * \brief Returns up to 3 values from the sensor.
   *
   * \return values from the sensor.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto data() const -> data_type
  {
    return detail::to_array(m_event.data);
  }
};

template <>
inline auto as_sdl_event(const common_event<SDL_ControllerSensorEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.csensor = event.get();
  return e;
}

/// \} End of group event

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

}  // namespace cen

#endif  // CENTURION_CONTROLLER_SENSOR_EVENT_HEADER

// #include "controller_touchpad_event.hpp"
#ifndef CENTURION_CONTROLLER_TOUCHPAD_EVENT_HEADER
#define CENTURION_CONTROLLER_TOUCHPAD_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../detail/clamp.hpp"

// #include "common_event.hpp"


namespace cen {

#if SDL_VERSION_ATLEAST(2, 0, 14)

/// \addtogroup event
/// \{

/**
 * \class controller_touchpad_event
 *
 * \brief Represents events associated with controller touchpads.
 *
 * \since 6.3.0
 */
class controller_touchpad_event final : public common_event<SDL_ControllerTouchpadEvent>
{
 public:
  /**
   * \brief Creates a controller touchpad event with `controller_touchpad_down` as the specific
   * type.
   *
   * \see `event_type::controller_touchpad_down`
   * \see `event_type::controller_touchpad_up`
   * \see `event_type::controller_touchpad_motion`
   *
   * \since 6.3.0
   */
  controller_touchpad_event() noexcept : common_event{event_type::controller_touchpad_down}
  {}

  /**
   * \brief Creates a controller touchpad event based an SDL event.
   *
   * \param event the event that will be copied.
   *
   * \since 6.3.0
   */
  explicit controller_touchpad_event(const SDL_ControllerTouchpadEvent& event) noexcept
      : common_event{event}
  {}

  /**
   * \brief Sets the joystick instance ID associated with the event.
   *
   * \param id the associated joystick instance ID.
   *
   * \since 6.3.0
   */
  void set_which(const SDL_JoystickID id) noexcept
  {
    m_event.which = id;
  }

  /**
   * \brief Sets the touchpad index associated with the event.
   *
   * \param index the associated touchpad index.
   *
   * \since 6.3.0
   */
  void set_touchpad_index(const i32 index) noexcept
  {
    m_event.touchpad = index;
  }

  /**
   * \brief Sets the finger index on the touchpad associated with the event.
   *
   * \param index the associated finger index.
   *
   * \since 6.3.0
   */
  void set_finger_index(const i32 index) noexcept
  {
    m_event.finger = index;
  }

  /**
   * \brief Sets the associated x-coordinate.
   *
   * \details The supplied value is clamped within the range [0, 1].
   *
   * \param x the normalized x-coordinate.
   *
   * \since 6.3.0
   */
  void set_x(const float x) noexcept
  {
    m_event.x = detail::clamp(x, 0.0f, 1.0f);
  }

  /**
   * \brief Sets the associated y-coordinate.
   *
   * \details The supplied value is clamped within the range [0, 1].
   *
   * \param y the normalized y-coordinate.
   *
   * \since 6.3.0
   */
  void set_y(const float y) noexcept
  {
    m_event.y = detail::clamp(y, 0.0f, 1.0f);
  }

  /**
   * \brief Sets the associated pressure.
   *
   * \details The supplied value is clamped within the range [0, 1].
   *
   * \param pressure the normalized y-coordinate.
   *
   * \since 6.3.0
   */
  void set_pressure(const float pressure) noexcept
  {
    m_event.pressure = detail::clamp(pressure, 0.0f, 1.0f);
  }

  /**
   * \brief Returns the joystick instance ID associated with the event.
   *
   * \return the associated joystick instance ID.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto which() const noexcept -> SDL_JoystickID
  {
    return m_event.which;
  }

  /**
   * \brief Returns the touchpad index associated with the event.
   *
   * \return the associated touchpad index.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto touchpad_index() const noexcept -> i32
  {
    return m_event.touchpad;
  }

  /**
   * \brief Returns the finger index associated with the event.
   *
   * \return the associated finger index.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto finger_index() const noexcept -> i32
  {
    return m_event.finger;
  }

  /**
   * \brief Returns the associated x-coordinate.
   *
   * \return the normalized x-coordinate.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto x() const noexcept -> float
  {
    return m_event.x;
  }

  /**
   * \brief Returns the associated y-coordinate.
   *
   * \return the normalized y-coordinate.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto y() const noexcept -> float
  {
    return m_event.y;
  }

  /**
   * \brief Returns the associated pressure.
   *
   * \return the normalized pressure.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto pressure() const noexcept -> float
  {
    return m_event.pressure;
  }
};

template <>
inline auto as_sdl_event(const common_event<SDL_ControllerTouchpadEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.ctouchpad = event.get();
  return e;
}

/// \} End of group event

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

}  // namespace cen

#endif  // CENTURION_CONTROLLER_TOUCHPAD_EVENT_HEADER

// #include "display_event.hpp"
#ifndef CENTURION_DISPLAY_EVENT_HEADER
#define CENTURION_DISPLAY_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../core/to_underlying.hpp"

// #include "common_event.hpp"

// #include "display_event_id.hpp"


namespace cen {

#if SDL_VERSION_ATLEAST(2, 0, 14)

/// \addtogroup event
/// \{

/**
 * \class display_event
 *
 * \brief Represents events related to displays.
 *
 * \see `SDL_DisplayEvent`
 *
 * \since 6.3.0
 */
class display_event final : public common_event<SDL_DisplayEvent>
{
 public:
  /**
   * \brief Creates a display event.
   *
   * \since 6.3.0
   */
  display_event() noexcept : common_event{event_type::display}
  {}

  /**
   * \brief Creates a display event based an SDL event.
   *
   * \param event the event that will be copied.
   *
   * \since 6.3.0
   */
  explicit display_event(const SDL_DisplayEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the associated display event ID.
   *
   * \param id the associated display event subtype.
   *
   * \since 6.3.0
   */
  void set_event_id(const display_event_id id) noexcept
  {
    m_event.event = static_cast<u8>(to_underlying(id));
  }

  /**
   * \brief Sets the associated display index.
   *
   * \param index the associated display index.
   *
   * \since 6.3.0
   */
  void set_index(const u32 index) noexcept
  {
    m_event.display = index;
  }

  /**
   * \brief Sets event type specific data.
   *
   * \param data the associated data value.
   *
   * \see `display_event_id`
   *
   * \since 6.3.0
   */
  void set_data_1(const i32 data) noexcept
  {
    m_event.data1 = data;
  }

  /**
   * \brief Returns the associated display event ID.
   *
   * \return the associated display event subtype.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto event_id() const noexcept -> display_event_id
  {
    return static_cast<display_event_id>(m_event.event);
  }

  /**
   * \brief Returns the index of the associated display.
   *
   * \return the associated display index.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto index() const noexcept -> u32
  {
    return m_event.display;
  }

  /**
   * \brief Returns subtype specific data.
   *
   * \details The returned value is the display orientation if the type of the event is
   * equivalent to `display_event_id::orientation`.
   *
   * \return subtype specific data.
   *
   * \see `screen_orientation`
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto data_1() const noexcept -> i32
  {
    return m_event.data1;
  }
};

template <>
inline auto as_sdl_event(const common_event<SDL_DisplayEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.display = event.get();
  return e;
}

/// \} End of group event

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

}  // namespace cen

#endif  // CENTURION_DISPLAY_EVENT_HEADER

// #include "dollar_gesture_event.hpp"
#ifndef CENTURION_DOLLAR_GESTURE_HEADER
#define CENTURION_DOLLAR_GESTURE_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class dollar_gesture_event
 *
 * \brief Provides information about dollar gestures from touch events.
 *
 * \see `SDL_DollarGestureEvent`
 *
 * \since 4.0.0
 */
class dollar_gesture_event final : public common_event<SDL_DollarGestureEvent>
{
 public:
  /**
   * \brief Creates a dollar gesture event of type `dollar_gesture`.
   *
   * \since 4.0.0
   */
  dollar_gesture_event() noexcept : common_event{event_type::dollar_gesture}
  {
    set_type(event_type::dollar_gesture);
  }

  /**
   * \brief Creates a dollar gesture event that is based on the supplied SDL
   * dollar gesture event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit dollar_gesture_event(const SDL_DollarGestureEvent& event) noexcept
      : common_event{event}
  {}

  /**
   * \brief Sets the touch device ID associated with the event.
   *
   * \param id the touch device ID associated with the event.
   *
   * \since 4.0.0
   */
  void set_touch_id(const SDL_TouchID id) noexcept
  {
    m_event.touchId = id;
  }

  /**
   * \brief Sets the gesture ID associated with the event.
   *
   * \param id the gesture ID associated with the event.
   *
   * \since 4.0.0
   */
  void set_gesture_id(const SDL_GestureID id) noexcept
  {
    m_event.gestureId = id;
  }

  /**
   * \brief Sets the amount of fingers used to draw the stroke.
   *
   * \param fingers the amount of fingers used to draw the stroke.
   *
   * \todo Centurion 7.0.0: Rename to set_finger_count.
   *
   * \since 4.0.0
   */
  void set_fingers(const u32 fingers) noexcept
  {
    m_event.numFingers = fingers;
  }

  /**
   * \brief Sets the error value for the performed stroke compared with the
   * gesture template associated with the event.
   *
   * \since 4.0.0
   */
  void set_error(const float error) noexcept
  {
    m_event.error = error;
  }

  /**
   * \brief Sets the normalized x-coordinate of the center of the gesture.
   *
   * \param x the normalized x-coordinate of the center of the gesture.
   *
   * \since 4.0.0
   */
  void set_x(const float x) noexcept
  {
    m_event.x = x;
  }

  /**
   * \brief Sets the normalized y-coordinate of the center of the gesture.
   *
   * \param y the normalized y-coordinate of the center of the gesture.
   *
   * \since 4.0.0
   */
  void set_y(const float y) noexcept
  {
    m_event.y = y;
  }

  /**
   * \brief Returns the touch device ID associated with the event.
   *
   * \return the touch device ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto touch_id() const noexcept -> SDL_TouchID
  {
    return m_event.touchId;
  }

  /**
   * \brief Returns the unique ID of the closest gesture to the performed
   * stroke.
   *
   * \return the unique ID of the closest gesture to the performed stroke.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto gesture_id() const noexcept -> SDL_GestureID
  {
    return m_event.gestureId;
  }

  /**
   * \brief Returns the amount of fingers used to draw the stroke.
   *
   * \return the amount of fingers used to draw the stroke.
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto finger_count() const noexcept -> u32
  {
    return m_event.numFingers;
  }

  /**
   * \brief Returns the difference between the gesture template and the
   * performed gesture.
   *
   * \details The lower the error, the better the match.
   *
   * \return the difference between the gesture template and the performed
   * gesture.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto error() const noexcept -> float
  {
    return m_event.error;
  }

  /**
   * \brief Returns the x-coordinate of the normalized center of the gesture.
   *
   * \return the x-coordinate of the normalized center of the gesture.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto x() const noexcept -> float
  {
    return m_event.x;
  }

  /**
   * \brief Returns the y-coordinate of the normalized center of the gesture.
   *
   * \return the y-coordinate of the normalized center of the gesture.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto y() const noexcept -> float
  {
    return m_event.y;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_DollarGestureEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.dgesture = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_DOLLAR_GESTURE_HEADER

// #include "drop_event.hpp"
#ifndef CENTURION_DROP_EVENT_HEADER
#define CENTURION_DROP_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class drop_event
 *
 * \brief Represents the event of requesting a file to be opened.
 *
 * \see `SDL_DropEvent`
 *
 * \since 4.0.0
 */
class drop_event final : public common_event<SDL_DropEvent>
{
 public:
  /**
   * \brief Creates a drop event of type `drop_file`.
   *
   * \since 4.0.0
   */
  drop_event() noexcept : common_event{event_type::drop_file}
  {}

  /**
   * \brief Creates a drop event based on the supplied event.
   *
   * \param event the SDL drop event that will be copied.
   *
   * \since 4.0.0
   */
  explicit drop_event(const SDL_DropEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Destroys the drop event.
   *
   * \details The associated file will be freed depending on the value
   * returned from the `will_free_file()` function.
   *
   * \since 4.0.0
   */
  ~drop_event() noexcept
  {
    if (m_event.file && m_willFreeFile) {
      SDL_free(m_event.file);
    }
  }

  /**
   * \brief Sets whether or not the associated file will be freed by this event.
   *
   * \details If you set this property to `false`, you **must** remember to
   * call `SDL_free` on the file pointer by yourself. Otherwise, you'll end
   * up with a memory leak!
   *
   * \param freeFile `true` if the associated file should be freed upon the
   * destruction of the event; `false` otherwise.
   *
   * \since 4.0.0
   */
  void set_will_free_file(const bool freeFile) noexcept
  {
    m_willFreeFile = freeFile;
  }

  /**
   * \brief Sets the file associated with the drop event.
   *
   * \details The ownership of the supplied pointer will, by default, not be
   * claimed by this event.
   *
   * \note The supplied pointer will be freed using `SDL_free` upon the
   * destruction of the event *if* the `will_free_file` property is set to
   * **true**.
   *
   * \note If the `will_free_file` property is `true`, then **the previously
   * set file pointer will be freed** by calling this function. However, if the
   * `will_free_file` property is `false`, then the old file pointer is
   * simply overridden. Of course, this may, if you're not careful, introduce a
   * memory leak in your program!
   *
   * \warning Make sure you know what you are doing when using this function.
   *
   * \param file a pointer to a file, can safely be null.
   *
   * \since 4.0.0
   */
  void set_file(char* file) noexcept
  {
    if (m_event.file && m_willFreeFile) {
      SDL_free(m_event.file);
    }
    m_event.file = file;
  }

  /**
   * \brief Sets the ID of the window that is the target of the drop event.
   *
   * \param id the ID of the window that is the target of the drop event.
   *
   * \since 4.0.0
   */
  void set_window_id(const u32 id) noexcept
  {
    m_event.windowID = id;
  }

  /**
   * \brief Indicates whether or not the associated file will be freed by
   * this event upon destruction.
   *
   * \details By default, this property is set to **false**.
   *
   * \return `true` if the associated file will be freed upon destruction;
   * `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto will_free_file() const noexcept -> bool
  {
    return m_willFreeFile;
  }

  /**
   * \brief Returns a pointer to the associated file.
   *
   * \warning Do **not** claim ownership of the returned pointer *without*
   * setting the `will_free_file` property to **false**.
   *
   * \note The returned pointer is always `nullptr` for `drop_begin` and
   * `drop_complete` drop events.
   *
   * \return a pointer to the file associated with the event, might be null.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto file() const noexcept -> char*
  {
    return m_event.file;
  }

  /**
   * \brief Returns the ID of the window that is the target of the drop
   * event, if there even is one.
   *
   * \return the ID of the window that is the target of the drop event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto window_id() const noexcept -> u32
  {
    return m_event.windowID;
  }

 private:
  bool m_willFreeFile{false};
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_DropEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.drop = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_DROP_EVENT_HEADER

// #include "event_type.hpp"

// #include "joy_axis_event.hpp"
#ifndef CENTURION_JOY_AXIS_EVENT_HEADER
#define CENTURION_JOY_AXIS_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class joy_axis_event
 *
 * \brief Represents an event that occurs whenever a user moves an axis on a
 * joystick.
 *
 * \see `SDL_JoyAxisEvent`
 *
 * \since 4.0.0
 */
class joy_axis_event final : public common_event<SDL_JoyAxisEvent>
{
 public:
  /**
   * \brief Creates a joy axis event.
   *
   * \since 4.0.0
   */
  joy_axis_event() noexcept : common_event{event_type::joystick_axis_motion}
  {}

  /**
   * \brief Creates a joy axis event based on the supplied SDL joy axis event.
   *
   * \param event the SDL joy axis event that will be copied.
   *
   * \since 4.0.0
   */
  explicit joy_axis_event(const SDL_JoyAxisEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the joystick instance ID associated with the event.
   *
   * \param which the joystick instance ID associated with the event.
   *
   * \since 4.0.0
   */
  void set_which(const SDL_JoystickID which) noexcept
  {
    m_event.which = which;
  }

  /**
   * \brief Sets the joystick axis index associated with the event.
   *
   * \param axis the joystick axis index associated with the event.
   *
   * \since 4.0.0
   */
  void set_axis(const u8 axis) noexcept
  {
    m_event.axis = axis;
  }

  /**
   * \brief Sets the joystick axis value associated with the event.
   *
   * \param value the joystick axis value associated with the event.
   *
   * \since 4.0.0
   */
  void set_value(const i16 value) noexcept
  {
    m_event.value = value;
  }

  /**
   * \brief Returns the joystick instance ID associated with the event.
   *
   * \return the joystick instance ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto which() const noexcept -> SDL_JoystickID
  {
    return m_event.which;
  }

  /**
   * \brief Returns the joystick axis index associated with the event.
   *
   * \return the joystick axis index associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto axis() const noexcept -> u8
  {
    return m_event.axis;
  }

  /**
   * \brief Returns the joystick axis value associated with the event.
   *
   * \return the joystick axis value associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto value() const noexcept -> i16
  {
    return m_event.value;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_JoyAxisEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.jaxis = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_JOY_AXIS_EVENT_HEADER

// #include "joy_ball_event.hpp"
#ifndef CENTURION_JOY_BALL_EVENT_HEADER
#define CENTURION_JOY_BALL_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class joy_ball_event
 *
 * \brief Represents the event that is triggered when a user moves a
 * trackball on a joystick.
 *
 * \see `SDL_JoyBallEvent`
 *
 * \since 4.0.0
 */
class joy_ball_event final : public common_event<SDL_JoyBallEvent>
{
 public:
  /**
   * \brief Creates a joy ball event.
   *
   * \since 4.0.0
   */
  joy_ball_event() noexcept : common_event{event_type::joystick_ball_motion}
  {}

  /**
   * \brief Creates a joy ball event based on the supplied SDL joy ball event.
   *
   * \param event the SDL joy ball event that will be copied.
   *
   * \since 4.0.0
   */
  explicit joy_ball_event(const SDL_JoyBallEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the joystick instance ID associated with the event.
   *
   * \param which the joystick instance ID.
   *
   * \since 4.0.0
   */
  void set_which(const SDL_JoystickID which) noexcept
  {
    m_event.which = which;
  }

  /**
   * \brief Sets the joystick trackball index associated with the event.
   *
   * \param ball the joystick trackball index.
   *
   * \since 4.0.0
   */
  void set_ball(const u8 ball) noexcept
  {
    m_event.ball = ball;
  }

  /**
   * \brief Sets the relative motion along the x-axis associated with the event.
   *
   * \param dx the relative motion along the x-axis.
   *
   * \since 4.0.0
   */
  void set_dx(const i16 dx) noexcept
  {
    m_event.xrel = dx;
  }

  /**
   * \brief Sets the relative motion along the y-axis associated with the event.
   *
   * \param dy the relative motion along the y-axis.
   *
   * \since 4.0.0
   */
  void set_dy(const i16 dy) noexcept
  {
    m_event.yrel = dy;
  }

  /**
   * \brief Returns the joystick instance ID associated with the event.
   *
   * \return the joystick instance ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto which() const noexcept -> SDL_JoystickID
  {
    return m_event.which;
  }

  /**
   * \brief Returns the joystick trackball index associated with the event.
   *
   * \return the joystick trackball index associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto ball() const noexcept -> u8
  {
    return m_event.ball;
  }

  /**
   * \brief Returns the relative motion along the x-axis.
   *
   * \note Trackballs only return relative motion, i.e this is the change in
   * position of the ball along the x-axis since it was last updated.
   *
   * \return the relative motion along the x-axis.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto dx() const noexcept -> i16
  {
    return m_event.xrel;
  }

  /**
   * \brief Returns the relative motion along the y-axis.
   *
   * \note Trackballs only return relative motion, i.e this is the change in
   * position of the ball along the y-axis since it was last updated.
   *
   * \return the relative motion along the y-axis.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto dy() const noexcept -> i16
  {
    return m_event.yrel;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_JoyBallEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.jball = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_JOY_BALL_EVENT_HEADER

// #include "joy_button_event.hpp"
#ifndef CENTURION_JOY_BUTTON_EVENT_HEADER
#define CENTURION_JOY_BUTTON_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../core/to_underlying.hpp"

// #include "../input/button_state.hpp"
#ifndef CENTURION_BUTTON_STATE_HEADER
#define CENTURION_BUTTON_STATE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum button_state
 *
 * \ingroup input
 *
 * \brief Represents the two possible states for a button.
 *
 * \details Corresponds to the `SDL_RELEASED` and `SDL_PRESSED` macros.
 *
 * \since 3.1.0
 */
enum class button_state : u8
{
  released = SDL_RELEASED,  ///< Corresponds to `SDL_RELEASED`.
  pressed = SDL_PRESSED     ///< Corresponds to `SDL_PRESSED`.
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied button state.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(button_state::released) == "released"`.
 *
 * \param state the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const button_state state) -> std::string_view
{
  switch (state) {
    case button_state::released:
      return "released";

    case button_state::pressed:
      return "pressed";

    default:
      throw cen_error{"Did not recognize button state!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a button state enumerator.
 *
 * \param stream the output stream that will be used.
 * \param state the enumerator that will be printed.
 *
 * \see `to_string(button_state)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const button_state state) -> std::ostream&
{
  return stream << to_string(state);
}

/// \} End of streaming

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_BUTTON_STATE_HEADER
// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class joy_button_event
 *
 * \brief Represents an event associated with the press or release of a
 * joystick button.
 *
 * \see `SDL_JoyButtonEvent`
 *
 * \since 4.0.0
 */
class joy_button_event final : public common_event<SDL_JoyButtonEvent>
{
 public:
  /**
   * \brief Creates a joystick button event of type `joystick_button_down`.
   *
   * \since 4.0.0
   */
  joy_button_event() noexcept : common_event{event_type::joystick_button_down}
  {}

  /**
   * \brief Creates a joy_button_event based on the supplied event.
   *
   * \param event the event that will be copied.
   *
   * \since 4.0.0
   */
  explicit joy_button_event(const SDL_JoyButtonEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the joystick instance ID associated with the event.
   *
   * \param which the joystick instance ID associated with the event.
   *
   * \since 4.0.0
   */
  void set_which(const SDL_JoystickID which) noexcept
  {
    m_event.which = which;
  }

  /**
   * \brief Sets the button index associated with the event.
   *
   * \param button the button index associated with the event.
   *
   * \since 4.0.0
   */
  void set_button(const u8 button) noexcept
  {
    m_event.button = button;
  }

  /**
   * \brief Sets the button state that is associated with the button that
   * triggered the event.
   *
   * \param state the button state that is associated with the button that
   * triggered the event.
   *
   * \since 4.0.0
   */
  void set_state(const button_state state) noexcept
  {
    m_event.state = to_underlying(state);
  }

  /**
   * \brief Returns the joystick instance ID associated with the event.
   *
   * \return the joystick instance ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto which() const noexcept -> SDL_JoystickID
  {
    return m_event.which;
  }

  /**
   * \brief Returns the index of the button that changed.
   *
   * \return the index of the button that changed.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto button() const noexcept -> u8
  {
    return m_event.button;
  }

  /**
   * \brief Returns the state of the button associated with the event.
   *
   * \return the state of the button associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto state() const noexcept -> button_state
  {
    return static_cast<button_state>(m_event.state);
  }

  /**
   * \brief Indicates whether or not the associated button is pressed.
   *
   * \return `true` if the associated button is pressed; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto pressed() const noexcept -> bool
  {
    return state() == button_state::pressed;
  }

  /**
   * \brief Indicates whether or not the associated button is released.
   *
   * \return `true` if the associated button is released; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto released() const noexcept -> bool
  {
    return state() == button_state::released;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_JoyButtonEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.jbutton = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_JOY_BUTTON_EVENT_HEADER

// #include "joy_device_event.hpp"
#ifndef CENTURION_JOY_DEVICE_EVENT_HEADER
#define CENTURION_JOY_DEVICE_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class joy_device_event
 *
 * \brief Represents an event triggered by adding or removing a joystick device.
 *
 * \see `SDL_JoyDeviceEvent`
 *
 * \since 4.0.0
 */
class joy_device_event final : public common_event<SDL_JoyDeviceEvent>
{
 public:
  /**
   * \brief Creates a joystick device event of type `joystick_device_added`.
   *
   * \since 4.0.0
   */
  joy_device_event() noexcept : common_event{event_type::joystick_device_added}
  {}

  /**
   * \brief Creates a joy_device_event that is based on the supplied SDL event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit joy_device_event(const SDL_JoyDeviceEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the joystick device index or instance ID, depending on the type
   * of the event.
   *
   * \param which the joystick device index or instance ID.
   *
   * \since 4.0.0
   */
  void set_which(const i32 which) noexcept
  {
    m_event.which = which;
  }

  /**
   * \brief Returns the joystick device index or instance ID.
   *
   * \details The returned value is the joystick device index if the type is
   * `JoystickDeviceAdded`, or the joystick instance ID if the type is
   * `JoystickDeviceRemoved`.
   *
   * \return the joystick device index or instance ID.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto which() const noexcept -> i32
  {
    return m_event.which;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_JoyDeviceEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.jdevice = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_JOY_DEVICE_EVENT_HEADER

// #include "joy_hat_event.hpp"
#ifndef CENTURION_JOY_HAT_EVENT_HEADER
#define CENTURION_JOY_HAT_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../core/to_underlying.hpp"

// #include "common_event.hpp"

// #include "joy_hat_position.hpp"
#ifndef CENTURION_JOY_HAT_POSITION_HEADER
#define CENTURION_JOY_HAT_POSITION_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \enum joy_hat_position
 *
 * \brief Serves as a wrapper for the `SDL_HAT_x` macro values.
 *
 * \see `joy_hat_position_count()`
 *
 * \since 4.0.0
 */
enum class joy_hat_position : u8
{
  left_up = SDL_HAT_LEFTUP,
  left = SDL_HAT_LEFT,
  left_down = SDL_HAT_LEFTDOWN,
  up = SDL_HAT_UP,
  centered = SDL_HAT_CENTERED,
  down = SDL_HAT_DOWN,
  right_up = SDL_HAT_RIGHTUP,
  right = SDL_HAT_RIGHT,
  right_down = SDL_HAT_RIGHTDOWN
};

/**
 * \brief Returns the number of enumerators for the `joy_hat_position` enum.
 *
 * \return the number of enumerators.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto joy_hat_position_count() noexcept -> int
{
  return 9;
}

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied joystick hat position.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(joy_hat_position::down) == "down"`.
 *
 * \param position the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const joy_hat_position position) -> std::string_view
{
  switch (position) {
    case joy_hat_position::left_up:
      return "left_up";

    case joy_hat_position::left:
      return "left";

    case joy_hat_position::left_down:
      return "left_down";

    case joy_hat_position::up:
      return "up";

    case joy_hat_position::centered:
      return "centered";

    case joy_hat_position::down:
      return "down";

    case joy_hat_position::right_up:
      return "right_up";

    case joy_hat_position::right:
      return "right";

    case joy_hat_position::right_down:
      return "right_down";

    default:
      throw cen_error{"Did not recognize joystick hat position!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a joystick hat position enumerator.
 *
 * \param stream the output stream that will be used.
 * \param position the enumerator that will be printed.
 *
 * \see `to_string(joy_hat_position)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const joy_hat_position position) -> std::ostream&
{
  return stream << to_string(position);
}

/// \} End of streaming

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_JOY_HAT_POSITION_HEADER


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class joy_hat_event
 *
 * \brief Represents an event that is triggered whenever a user moves a hat
 * on a joystick.
 *
 * \see `SDL_JoyHatEvent`
 *
 * \since 4.0.0
 */
class joy_hat_event final : public common_event<SDL_JoyHatEvent>
{
 public:
  /**
   * \brief Creates a joy hat event.
   *
   * \since 4.0.0
   */
  joy_hat_event() noexcept : common_event{event_type::joystick_hat_motion}
  {}

  /**
   * \brief Creates a joy hat event based on the supplied SDL event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit joy_hat_event(const SDL_JoyHatEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the hat index associated with the event.
   *
   * \param hat the hat index.
   *
   * \since 4.0.0
   */
  void set_hat(const u8 hat) noexcept
  {
    m_event.hat = hat;
  }

  /**
   * \brief Sets the joystick hat position associated with the event.
   *
   * \param value the joystick hat position associated with the event.
   *
   * \since 4.0.0
   */
  void set_position(const joy_hat_position value) noexcept
  {
    m_event.value = to_underlying(value);
  }

  /**
   * \brief Returns the index of the hat that changed.
   *
   * \return the index of the hat that changed.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto hat() const noexcept -> u8
  {
    return m_event.hat;
  }

  /**
   * \brief Returns the position of the associated joystick hat.
   *
   * \return the position of the associated joystick hat.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto position() const noexcept -> joy_hat_position
  {
    return static_cast<joy_hat_position>(m_event.value);
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_JoyHatEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.jhat = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_JOY_HAT_EVENT_HEADER

// #include "keyboard_event.hpp"
#ifndef CENTURION_KEYBOARD_EVENT_HEADER
#define CENTURION_KEYBOARD_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../core/to_underlying.hpp"

// #include "../input/button_state.hpp"

// #include "../input/key_code.hpp"
#ifndef CENTURION_KEY_CODE_HEADER
#define CENTURION_KEY_CODE_HEADER

#include <SDL.h>

#include <cassert>  // assert
#include <ostream>  // ostream
#include <string>   // string

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/not_null.hpp"

// #include "../core/str.hpp"

// #include "../core/version.hpp"
#ifndef CENTURION_VERSION_HEADER
#define CENTURION_VERSION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <cassert>  // assert

/// \addtogroup core
/// \{

/**
 * \def CENTURION_VERSION_MAJOR
 *
 * \brief Expands into the current major version of the library.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_MAJOR 6

/**
 * \def CENTURION_VERSION_MINOR
 *
 * \brief Expands into the current minor version of the library.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_MINOR 3

/**
 * \def CENTURION_VERSION_PATCH
 *
 * \brief Expands into the current patch version of the library.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_PATCH 0

/**
 * \def CENTURION_SDL_VERSION_IS
 *
 * \brief This macro is meant to be used when conditionally including code for a specific
 * version of SDL. It is useful for applying workarounds.
 *
 * \since 5.3.0
 */
#define CENTURION_SDL_VERSION_IS(x, y, z) \
  ((SDL_MAJOR_VERSION == (x)) && (SDL_MINOR_VERSION == (y)) && (SDL_PATCHLEVEL == (z)))

#ifdef CENTURION___DOXYGEN

#define CENTURION_MAKE_VERSION_NUMBER
#define CENTURION_VERSION_NUMBER
#define CENTURION_VERSION_AT_LEAST

#endif  // CENTURION___DOXYGEN

/**
 * \def CENTURION_MAKE_VERSION_NUMBER
 *
 * \brief Helper macro for creating version numbers from a set of major/minor/patch
 * numbers.
 *
 * \details For example, if the version is 8.4.2, the resulting version number would be
 * 8402.
 *
 * \since 6.0.0
 */
#define CENTURION_MAKE_VERSION_NUMBER(x, y, z) (((x)*1'000) + ((y)*100) + (z))

/**
 * \def CENTURION_VERSION_NUMBER
 *
 * \brief Expands into a version number based on the current Centurion version.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_NUMBER                         \
  CENTURION_MAKE_VERSION_NUMBER(CENTURION_VERSION_MAJOR, \
                                CENTURION_VERSION_MINOR, \
                                CENTURION_VERSION_PATCH)

/**
 * \def CENTURION_VERSION_AT_LEAST
 *
 * \brief This macro is intended to be used for conditional compilation, based on the
 * Centurion version.
 *
 * \details This macro is used in the same way as the `SDL_VERSION_ATLEAST`, where you use
 * it as the condition with `#if` statements.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_AT_LEAST(x, y, z) \
  CENTURION_VERSION_NUMBER >= CENTURION_MAKE_VERSION_NUMBER(x, y, z)

namespace cen {

/// \name Centurion version queries
/// \{

/**
 * \struct version
 *
 * \brief Represents a set of major/minor/patch version numbers.
 *
 * \details The members of this struct are by default initialized to the current Centurion
 * version values.
 *
 * \since 6.0.0
 */
struct version final
{
  int major{CENTURION_VERSION_MAJOR};
  int minor{CENTURION_VERSION_MINOR};
  int patch{CENTURION_VERSION_PATCH};
};

/**
 * \brief Indicates whether or not the current Centurion version is at least equal to the
 * specified version.
 *
 * \param major the major version value.
 * \param minor the minor version value.
 * \param patch the patch version value.
 *
 * \return `true` if the version of Centurion is at least the specified version; `false`
 * otherwise.
 *
 * \see `CENTURION_VERSION_AT_LEAST`
 *
 * \since 6.0.0
 */
[[nodiscard]] constexpr auto version_at_least(const int major,
                                              const int minor,
                                              const int patch) noexcept -> bool
{
  return CENTURION_VERSION_AT_LEAST(major, minor, patch);
}

/// \} End of centurion version queries

/// \name SDL version queries
/// \{

/**
 * \brief Returns the version of SDL2 that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL that the
 * program was compiled against.
 *
 * \return the linked version of SDL2.
 *
 * \since 5.2.0
 */
[[nodiscard]] inline auto sdl_linked_version() noexcept -> SDL_version
{
  SDL_version version{};
  SDL_GetVersion(&version);
  return version;
}

/**
 * \brief Returns the compile-time version of SDL2 that is being used.
 *
 * \return the compile-time version of SDL2 that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_version() noexcept -> SDL_version
{
  return {SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL};
}

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \brief Returns the version of SDL2_image that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL2_image that
 * the program was compiled against.
 *
 * \return the linked version of SDL2_image.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto sdl_image_linked_version() noexcept -> SDL_version
{
  const auto* version = IMG_Linked_Version();
  assert(version);  // Sanity check
  return *version;
}

/**
 * \brief Returns the compile-time version of SDL2_image that is being used.
 *
 * \return the compile-time version of SDL2_image that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_image_version() noexcept -> SDL_version
{
  return {SDL_IMAGE_MAJOR_VERSION, SDL_IMAGE_MINOR_VERSION, SDL_IMAGE_PATCHLEVEL};
}

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \brief Returns the version of SDL2_mixer that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL2_mixer that
 * the program was compiled against.
 *
 * \return the linked version of SDL2_mixer.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto sdl_mixer_linked_version() noexcept -> SDL_version
{
  const auto* version = Mix_Linked_Version();
  assert(version);  // Sanity check
  return *version;
}

/**
 * \brief Returns the compile-time version of SDL2_mixer that is being used.
 *
 * \return the compile-time version of SDL2_mixer that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_mixer_version() noexcept -> SDL_version
{
  return {SDL_MIXER_MAJOR_VERSION, SDL_MIXER_MINOR_VERSION, SDL_MIXER_PATCHLEVEL};
}

#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF

/**
 * \brief Returns the version of SDL2_ttf that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL2_ttf that the
 * program was compiled against.
 *
 * \return the linked version of SDL2_ttf.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto sdl_ttf_linked_version() noexcept -> SDL_version
{
  const auto* version = TTF_Linked_Version();
  assert(version);  // Sanity check
  return *version;
}

/**
 * \brief Returns the compile-time version of SDL2_ttf that is being used.
 *
 * \return the compile-time version of SDL2_ttf that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_ttf_version() noexcept -> SDL_version
{
  return {SDL_TTF_MAJOR_VERSION, SDL_TTF_MINOR_VERSION, SDL_TTF_PATCHLEVEL};
}

#endif  // CENTURION_NO_SDL_TTF

/// \} End of SDL version queries

}  // namespace cen

#if CENTURION_SDL_VERSION_IS(2, 0, 10)

// Workaround for this enum being completely anonymous in SDL 2.0.10. We include
// this here because multiple files (key_code.hpp and scan_code.hpp) depend on
// this definition.
using SDL_KeyCode = decltype(SDLK_UNKNOWN);

#endif  // CENTURION_SDL_VERSION_IS(2, 0, 10)

/// \} End of group core

#endif  // CENTURION_VERSION_HEADER


namespace cen {

/// \addtogroup input
/// \{

/**
 * \class key_code
 *
 * \brief Represents a key code (or virtual key).
 *
 * \serializable
 *
 * \details Key codes are mapped to the current layout of the keyboard and correlate to a
 * `scan_code`. Whilst scan codes identify the *location* of a key press, the
 * corresponding key codes give the key press *meaning* in the context of the current
 * keyboard layout.
 *
 * Keycodes are meant to be layout-dependent. Think of this as "the user pressed the key
 * that is labelled 'Q' on a specific keyboard."
 *
 * For example, if you pressed the key that's two keys to the right of CAPS LOCK on a US
 * QWERTY keyboard, it'll report a scancode of SDL_SCANCODE_S and a keycode of SDLK_S. The
 * same key on a Dvorak keyboard, will report a scancode of SDL_SCANCODE_S and a keycode
 * of SDLK_O.
 *
 * \note Key codes are sometimes referred to as "keysyms" in the SDL documentation.
 *
 * \since 5.0.0
 *
 * \see `scan_code`
 * \see `cen::keycodes`
 */
class key_code final
{
 public:
  /// \name Construction
  /// \{

  /**
   * \brief Creates a `key_code` instance with the `SDLK_UNKNOWN` key code.
   *
   * \since 5.0.0
   */
  constexpr key_code() noexcept = default;

  constexpr key_code(const key_code&) noexcept = default;

  constexpr key_code(key_code&&) noexcept = default;

  /**
   * \brief Creates a `key_code` instance with the specified key code.
   *
   * \param key the key code that will be used.
   *
   * \since 5.0.0
   */
  constexpr /*implicit*/ key_code(const SDL_KeyCode key) noexcept : m_key{key}
  {}

  /**
   * \brief Creates a `key_code` instance based on a scan code.
   *
   * \details The created `key_code` will use the key code obtained
   * by converting the specified scan code.
   *
   * \param scancode the scan code that will be converted and used.
   *
   * \see `SDL_GetKeyFromScancode`
   *
   * \since 5.0.0
   */
  explicit key_code(const SDL_Scancode scancode) noexcept
      : m_key{static_cast<SDL_KeyCode>(SDL_GetKeyFromScancode(scancode))}
  {}

  /**
   * \brief Creates a `key_code` instance based on the specified name.
   *
   * \details If the specified name isn't recognized, `SDLK_UNKNOWN` is used as
   * the key code.
   *
   * \param name the name of the key, mustn't be null.
   *
   * \see `SDL_GetKeyFromName`
   *
   * \since 5.0.0
   */
  explicit key_code(const not_null<str> name) noexcept
      : m_key{static_cast<SDL_KeyCode>(SDL_GetKeyFromName(name))}
  {}

  /**
   * \brief Creates a `key_code` instance based on the specified name.
   *
   * \details If the specified name isn't recognized, `SDLK_UNKNOWN` is used as
   * the key code.
   *
   * \param name the name of the key.
   *
   * \since 5.3.0
   */
  explicit key_code(const std::string& name) noexcept : key_code{name.c_str()}
  {}

  /// \} End of construction

  /// \name Assignment operators
  /// \{

  constexpr auto operator=(const key_code&) noexcept -> key_code& = default;

  constexpr auto operator=(key_code&&) noexcept -> key_code& = default;

  /**
   * \brief Sets the key code used to the specified key code.
   *
   * \param key the key code that will be used.
   *
   * \return the `key_code` instance.
   *
   * \since 5.0.0
   */
  constexpr auto operator=(const SDL_KeyCode key) noexcept -> key_code&
  {
    m_key = key;
    return *this;
  }

  /**
   * \brief Sets the key code used to be the converted version of the
   * supplied scan code.
   *
   * \param scancode the scan code that will be converted and used.
   *
   * \return the `key_code` instance.
   *
   * \since 5.0.0
   */
  auto operator=(const SDL_Scancode scancode) noexcept -> key_code&
  {
    m_key = static_cast<SDL_KeyCode>(SDL_GetKeyFromScancode(scancode));
    return *this;
  }

  /**
   * \brief Sets the key code used to be the one associated with the
   * specified name.
   *
   * \details If the specified name isn't recognized, `SDLK_UNKNOWN` is used as
   * the key code.
   *
   * \param name the name of the key, mustn't be null.
   *
   * \return the `key_code` instance.
   *
   * \since 5.0.0
   */
  auto operator=(const not_null<str> name) noexcept -> key_code&
  {
    assert(name);
    m_key = static_cast<SDL_KeyCode>(SDL_GetKeyFromName(name));
    return *this;
  }

  /**
   * \brief Sets the key code used to be the one associated with the specified name.
   *
   * \details If the specified name isn't recognized, `SDLK_UNKNOWN` is used as the key
   * code.
   *
   * \param name the name of the key.
   *
   * \return the `key_code` instance.
   *
   * \since 5.3.0
   */
  auto operator=(const std::string& name) noexcept -> key_code&
  {
    return this->operator=(name.c_str());  // NOLINT
  }

  /// \} End of assignment operators

  /// \name Queries
  /// \{

  /**
   * \brief Indicates whether or not the stored key code is `SDLK_UNKNOWN`.
   *
   * \return `true` if the internal key code is `SDLK_UNKNOWN`; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto unknown() const noexcept -> bool
  {
    return m_key == SDLK_UNKNOWN;
  }

  /**
   * \brief Returns the name associated with the key code.
   *
   * \return the name associated with the key code.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto name() const -> std::string
  {
    return SDL_GetKeyName(m_key);
  }

  /**
   * \brief Returns the corresponding `SDL_Scancode`.
   *
   * \return the scan code associated with the internal key code.
   *
   * \see `SDL_GetScancodeFromKey`
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto to_scan_code() const noexcept -> SDL_Scancode
  {
    return SDL_GetScancodeFromKey(m_key);
  }

  /**
   * \brief Returns the internal key code.
   *
   * \return the internal key code.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto get() const noexcept -> SDL_KeyCode
  {
    return m_key;
  }

  /// \} End of queries

  /// \name Conversions
  /// \{

  /**
   * \brief Converts to `SDL_KeyCode`.
   *
   * \return the internal key code.
   *
   * \since 5.0.0
   */
  constexpr explicit operator SDL_KeyCode() const noexcept
  {
    return m_key;
  }

  /**
   * \brief Converts to `SDL_Keycode`.
   *
   * \return the internal key code.
   *
   * \note `SDL_Keycode` is just an alias for `i32`.
   *
   * \since 5.0.0
   */
  constexpr explicit operator SDL_Keycode() const noexcept
  {
    return m_key;
  }

  /**
   * \brief Converts to `SDL_Scancode`.
   *
   * \return the scan code associated with the internal key code.
   *
   * \see `to_scan_code()`
   *
   * \since 5.0.0
   */
  explicit operator SDL_Scancode() const noexcept
  {
    return to_scan_code();
  }

  /// \} End of conversions

  /**
   * \brief Serializes the key code.
   *
   * \details This function expects that the archive provides an overloaded `operator()`,
   * used for serializing data. This API is based on the Cereal serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the key code.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_key);
  }

 private:
  SDL_KeyCode m_key{SDLK_UNKNOWN};
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a key code.
 *
 * \param keyCode the key code that will be converted.
 *
 * \return a textual representation of the key code.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto to_string(const key_code& keyCode) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("key_code{{key: {}}}", keyCode.name());
#else
  return "key_code{key: " + keyCode.name() + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a key code using a stream.
 *
 * \param stream the stream that will be used.
 * \param keyCode the key code that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
inline auto operator<<(std::ostream& stream, const key_code& keyCode) -> std::ostream&
{
  return stream << to_string(keyCode);
}

/// \} End of streaming

/// \name Key code comparison operators
/// \{

/**
 * \brief Indicates whether or not two key codes are the same.
 *
 * \param lhs the left-hand side key code.
 * \param rhs the right-hand side key code.
 *
 * \return `true` if the key codes are the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator==(const key_code& lhs, const key_code& rhs) noexcept
    -> bool
{
  return lhs.get() == rhs.get();
}

/**
 * \brief Indicates whether or not two key codes aren't the same.
 *
 * \param lhs the left-hand side key code.
 * \param rhs the right-hand side key code.
 *
 * \return `true` if the key codes aren't the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator!=(const key_code& lhs, const key_code& rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \} End of key code comparison operators

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_KEY_CODE_HEADER
// #include "../input/key_modifier.hpp"
#ifndef CENTURION_KEY_MODIFIER_HEADER
#define CENTURION_KEY_MODIFIER_HEADER

#include <SDL.h>

#include <ostream>  // ostream
#include <sstream>  // stringstream
#include <string>   // string

// #include "../core/integers.hpp"

// #include "../core/str.hpp"

// #include "../core/to_underlying.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum key_modifier
 *
 * \brief Represents different key modifiers.
 *
 * \note This is a flag enum, and provides overloads for the common bitwise operators.
 *
 * \todo Centurion 7: Rename this enum to `key_mod`.
 * \todo Centurion 7: Replace left_{}/right_{} prefixes with l{}/r{}.
 *
 * \see `key_mod`
 * \see `SDL_Keymod`
 * \see `operator~(key_mod)`
 * \see `operator|(key_mod, key_mod)`
 * \see `operator&(key_mod, key_mod)`
 *
 * \since 3.1.0
 */
enum class key_modifier : u16
{
  none = KMOD_NONE,
  left_shift = KMOD_LSHIFT,
  right_shift = KMOD_RSHIFT,
  left_ctrl = KMOD_LCTRL,
  right_ctrl = KMOD_RCTRL,
  left_alt = KMOD_LALT,
  right_alt = KMOD_RALT,
  left_gui = KMOD_LGUI,
  right_gui = KMOD_RGUI,
  shift = KMOD_SHIFT,
  ctrl = KMOD_CTRL,
  alt = KMOD_ALT,
  gui = KMOD_GUI,
  num = KMOD_NUM,
  caps = KMOD_CAPS,
  mode = KMOD_MODE,

  reserved = KMOD_RESERVED
};

/**
 * \typedef key_mod
 *
 * \brief Simple shorthand for `key_modifier`.
 *
 * \note In a future major release, `key_modifier` will likely be renamed to `key_mod`.
 *
 * \since 6.2.0
 */
using key_mod = key_modifier;

/**
 * \brief Sets the current key modifier flags.
 *
 * \param mods the modifier flags that will be used.
 *
 * \see `get_modifiers()`
 *
 * \since 6.2.0
 */
inline void set_modifiers(const key_mod mods) noexcept
{
  SDL_SetModState(static_cast<SDL_Keymod>(mods));
}

/**
 * \brief Returns the current key modifier state.
 *
 * \return the current key modifier flags.
 *
 * \see `set_modifiers()`
 *
 * \since 6.2.0
 */
[[nodiscard]] inline auto get_modifiers() noexcept -> key_mod
{
  return static_cast<key_mod>(SDL_GetModState());
}

/// \name Key modifier bitwise operators
/// \{

/**
 * \brief Returns the bitwise negation of the supplied modifiers.
 *
 * \param mods the modifiers that will be inverted.
 *
 * \return the bitwise negation of the supplied modifiers.
 *
 * \since 6.1.0
 */
[[nodiscard]] constexpr auto operator~(const key_mod mods) noexcept -> key_mod
{
  return static_cast<key_mod>(~to_underlying(mods));
}

/**
 * \brief Combines two groups of modifiers by applying bitwise OR.
 *
 * \param a the first group of modifiers.
 * \param b the second group of modifiers.
 *
 * \return the bitwise combination of the two groups of modifiers.
 *
 * \since 6.1.0
 */
[[nodiscard]] constexpr auto operator|(const key_mod a, const key_mod b) noexcept -> key_mod
{
  return static_cast<key_mod>(to_underlying(a) | to_underlying(b));
}

/**
 * \brief Combines two groups of modifiers by applying bitwise AND.
 *
 * \param a the first group of modifiers.
 * \param b the second group of modifiers.
 *
 * \return the result of applying bitwise AND between the two modifier groups.
 *
 * \since 6.1.0
 */
[[nodiscard]] constexpr auto operator&(const key_mod a, const key_mod b) noexcept -> key_mod
{
  return static_cast<key_mod>(to_underlying(a) & to_underlying(b));
}

/// \} End of key modifier bitwise operators

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied key modifiers.
 *
 * \details This function returns a string of comma separated values (CSV) if the supplied
 * enumerator is a composite of more than one key modifier. For example,
 * `to_string(key_mod::left_shift | key_mod::right_ctrl) == "left_shift,right_ctrl"`. The
 * order of the enumerators in the returned string mirrors the enumerator declaration
 * order.
 *
 * \details The comma is omitted if you supply an enumerator that only represents a single
 * key modifier.
 *
 * \details The empty string is returned if an invalid enumerator is provided.
 *
 * \details Composite enumerators, such as `key_mod::shift`, will be printed as separate
 * enumerators, i.e. `"left_shift,right_shift"` in the case of `key_mod::shift`.
 *
 * \param mods the key modifiers that will be converted.
 *
 * \return a string of comma separated values of key modifier names.
 *
 * \since 6.2.0
 */
[[nodiscard]] inline auto to_string(const key_mod mods) -> std::string
{
  if (mods == key_mod::none) {
    return "none";
  }

  const auto mask = to_underlying(mods);
  std::stringstream stream;

  auto check = [&stream, mask, count = 0](const key_mod mod, const str name) mutable {
    if (mask & to_underlying(mod)) {
      if (count != 0) {
        stream << ',';
      }

      stream << name;
      ++count;
    }
  };

  check(key_mod::left_shift, "left_shift");
  check(key_mod::right_shift, "right_shift");

  check(key_mod::left_ctrl, "left_ctrl");
  check(key_mod::right_ctrl, "right_ctrl");

  check(key_mod::left_alt, "left_alt");
  check(key_mod::right_alt, "right_alt");

  check(key_mod::left_gui, "left_gui");
  check(key_mod::right_gui, "right_gui");

  check(key_mod::num, "num");
  check(key_mod::caps, "caps");
  check(key_mod::mode, "mode");

  return stream.str();
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of the supplied key modifiers.
 *
 * \param stream the output stream that will be used.
 * \param mods the key modifiers that will be printed.
 *
 * \see `to_string(key_mod)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const key_mod mods) -> std::ostream&
{
  return stream << to_string(mods);
}

/// \} End of streaming

/// \} End of group input

/// \cond FALSE

namespace detail {

[[nodiscard]] inline auto is_active(const key_mod modifiers, const u16 currentMask) noexcept
    -> bool
{
  if (modifiers == key_mod::none) {
    return !currentMask;
  }
  else {
    return currentMask & to_underlying(modifiers);
  }
}

[[nodiscard]] inline auto is_only_active(const key_mod modifiers,
                                         const u16 currentMask) noexcept -> bool
{
  if (modifiers == key_mod::none) {
    return !currentMask;
  }

  const auto mask = to_underlying(modifiers);
  const auto hits = currentMask & mask;

  if (hits != mask) {
    return false;  // The specified modifiers were a combo that wasn't fully active
  }
  else {
    const auto others = currentMask & ~hits;
    return hits && !others;
  }
}

[[nodiscard]] inline auto is_only_any_of_active(const key_mod modifiers,
                                                const u16 currentMask) noexcept -> bool
{
  if (modifiers == key_mod::none) {
    return !currentMask;
  }

  const auto mask = to_underlying(modifiers);

  const auto hits = currentMask & mask;
  const auto others = currentMask & ~hits;

  return hits && !others;
}

}  // namespace detail

/// \endcond

}  // namespace cen

#endif  // CENTURION_KEY_MODIFIER_HEADER
// #include "../input/scan_code.hpp"
#ifndef CENTURION_SCAN_CODE_HEADER
#define CENTURION_SCAN_CODE_HEADER

#include <SDL.h>

#include <cassert>  // assert
#include <ostream>  // ostream
#include <string>   // string

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/not_null.hpp"

// #include "../core/str.hpp"

// #include "../core/version.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \class scan_code
 *
 * \brief Represents a scan code.
 *
 * \serializable
 *
 * \details Scan codes represent the physical location of a key on the
 * keyboard. Use the associated key code associated with the location to give
 * the key press meaning.
 *
 * Scan codes are meant to be layout-independent. Think of this as "the user
 * pressed the Q key as it would be on a US QWERTY keyboard" regardless of
 * whether this is actually a European keyboard or a Dvorak keyboard or
 * whatever. *The scancode is always the same key position.*
 *
 * \since 5.0.0
 *
 * \see `key_code`
 * \see `cen::scancodes`
 */
class scan_code final
{
 public:
  /// \name Construction
  /// \{

  /**
   * \brief Creates a `scan_code` instance with the `SDL_SCANCODE_UNKNOWN` scan
   * code.
   *
   * \since 5.0.0
   */
  constexpr scan_code() noexcept = default;

  constexpr scan_code(const scan_code&) noexcept = default;

  constexpr scan_code(scan_code&&) noexcept = default;

  /**
   * \brief Creates a `scan_code` instance with the specified scan code.
   *
   * \param scancode the scan code that will be used.
   *
   * \since 5.0.0
   */
  constexpr /*implicit*/ scan_code(const SDL_Scancode scancode) noexcept : m_code{scancode}
  {}

  /**
   * \brief Creates a `scan_code` instance based on a key code.
   *
   * \details The created `scan_code` will use the scan code obtained
   * by converting the specified key code.
   *
   * \param key the key code that will be converted and used.
   *
   * \since 5.0.0
   */
  explicit scan_code(const SDL_Keycode key) noexcept : m_code{SDL_GetScancodeFromKey(key)}
  {}

  /**
   * \brief Creates a `scan_code` instance based on the specified name.
   *
   * \details If the specified name isn't recognized, `SDL_SCANCODE_UNKNOWN` is
   * used as the scan code.
   *
   * \param name the name of the key, mustn't be null.
   *
   * \see `SDL_GetScancodeFromName`
   *
   * \since 5.0.0
   */
  explicit scan_code(const not_null<str> name) noexcept : m_code{SDL_GetScancodeFromName(name)}
  {}

  /**
   * \brief Creates a `scan_code` instance based on the specified name.
   *
   * \details If the specified name isn't recognized, `SDL_SCANCODE_UNKNOWN` is
   * used as the scan code.
   *
   * \param name the name of the key.
   *
   * \since 5.3.0
   */
  explicit scan_code(const std::string& name) noexcept : scan_code{name.c_str()}
  {}

  /// \} End of construction

  /// \name Assignment operators
  /// \{

  constexpr auto operator=(const scan_code&) noexcept -> scan_code& = default;

  constexpr auto operator=(scan_code&&) noexcept -> scan_code& = default;

  /**
   * \brief Sets the scan code used to the specified scan code.
   *
   * \param code the scan code that will be used.
   *
   * \return the `scan_code` instance.
   *
   * \since 5.0.0
   */
  constexpr auto operator=(const SDL_Scancode code) noexcept -> scan_code&
  {
    m_code = code;
    return *this;
  }

  /**
   * \brief Sets the scan code used to be the converted version of the
   * supplied key code.
   *
   * \param keycode the key code that will be converted and used.
   *
   * \return the `scan_code` instance.
   *
   * \since 5.0.0
   */
  auto operator=(const SDL_Keycode keycode) noexcept -> scan_code&
  {
    m_code = SDL_GetScancodeFromKey(keycode);
    return *this;
  }

  /**
   * \brief Sets the scan code used to be the one associated with the
   * specified name.
   *
   * \details If the specified name isn't recognized, `SDL_SCANCODE_UNKNOWN` is
   * used as the scan code.
   *
   * \param name the name of the key, mustn't be null.
   *
   * \return the `scan_code` instance.
   *
   * \since 5.0.0
   */
  auto operator=(const not_null<str> name) noexcept -> scan_code&
  {
    assert(name);
    m_code = SDL_GetScancodeFromName(name);
    return *this;
  }

  /**
   * \brief Sets the scan code used to be the one associated with the
   * specified name.
   *
   * \details If the specified name isn't recognized, `SDL_SCANCODE_UNKNOWN` is
   * used as the scan code.
   *
   * \param name the name of the key.
   *
   * \return the `scan_code` instance.
   *
   * \since 5.3.0
   */
  auto operator=(const std::string& name) noexcept -> scan_code&
  {
    return operator=(name.c_str());  // NOLINT
  }

  /// \} End of assignment operators

  /// \name Queries
  /// \{

  /**
   * \brief Returns the total amount of scan codes.
   *
   * \return the amount of scan codes.
   *
   * \since 5.1.0
   */
  [[nodiscard]] constexpr static auto count() noexcept -> int
  {
    return SDL_NUM_SCANCODES;
  }

  /**
   * \brief Indicates whether or not the stored scan code is
   * `SDL_SCANCODE_UNKNOWN`.
   *
   * \return `true` if the internal scan code is `SDL_SCANCODE_UNKNOWN`;
   * `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto unknown() const noexcept -> bool
  {
    return m_code == SDL_SCANCODE_UNKNOWN;
  }

  /**
   * \brief Returns the name associated with the scan code.
   *
   * \return the name associated with the scan code.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto name() const -> std::string
  {
    return SDL_GetScancodeName(m_code);
  }

  /**
   * \brief Returns the corresponding `SDL_KeyCode`.
   *
   * \return the key code associated with the internal scan code.
   *
   * \see `SDL_GetKeyFromScancode`
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto to_key_code() const noexcept -> SDL_KeyCode
  {
    return static_cast<SDL_KeyCode>(SDL_GetKeyFromScancode(m_code));
  }

  /**
   * \brief Returns the internal scan code.
   *
   * \return the internal scan code.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto get() const noexcept -> SDL_Scancode
  {
    return m_code;
  }

  /// \} End of queries

  /// \name Conversions
  /// \{

  /**
   * \brief Converts to `SDL_Scancode`.
   *
   * \return the internal scan code.
   *
   * \since 5.0.0
   */
  constexpr explicit operator SDL_Scancode() const noexcept
  {
    return m_code;
  }

  /**
   * \brief Converts to `SDL_KeyCode`.
   *
   * \return the key code associated with the internal scan code.
   *
   * \see `SDL_GetKeyFromScancode`
   *
   * \since 5.0.0
   */
  explicit operator SDL_KeyCode() const noexcept
  {
    return to_key_code();
  }

  /// \} End of conversions

  /**
   * \brief Serializes the scan code.
   *
   * \details This function expects that the archive provides an overloaded
   * `operator()`, used for serializing data. This API is based on the Cereal
   * serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the scan code.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_code);
  }

 private:
  SDL_Scancode m_code{SDL_SCANCODE_UNKNOWN};
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a scan code.
 *
 * \param code the scan code that will be converted.
 *
 * \return a textual representation of the scan code.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto to_string(const scan_code& code) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("scan_code{{key: {}}}", code.name());
#else
  return "scan_code{key: " + code.name() + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a scan code using a stream.
 *
 * \param stream the stream that will be used.
 * \param scanCode the scan code that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
inline auto operator<<(std::ostream& stream, const scan_code& scanCode) -> std::ostream&
{
  return stream << to_string(scanCode);
}

/// \} End of streaming

/// \name Scan code comparison operators
/// \{

/**
 * \brief Indicates whether or not two scan codes are the same.
 *
 * \param lhs the left-hand side scan code.
 * \param rhs the right-hand side scan code.
 *
 * \return `true` if the scan codes are the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator==(const scan_code& lhs, const scan_code& rhs) noexcept
    -> bool
{
  return lhs.get() == rhs.get();
}

/**
 * \brief Indicates whether or not two scan codes aren't the same.
 *
 * \param lhs the left-hand side scan code.
 * \param rhs the right-hand side scan code.
 *
 * \return `true` if the scan codes aren't the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator!=(const scan_code& lhs, const scan_code& rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \} End of scan code comparison operators

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_SCAN_CODE_HEADER
// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class keyboard_event
 *
 * \brief Represents an event associated with some sort of key action, such
 * as the release or pressing of a key.
 *
 * \see `SDL_KeyboardEvent`
 *
 * \since 4.0.0
 */
class keyboard_event final : public common_event<SDL_KeyboardEvent>
{
 public:
  /**
   * \brief Creates a keyboard event of type `key_down`.
   *
   * \since 4.0.0
   */
  keyboard_event() noexcept : common_event{event_type::key_down}
  {}

  /**
   * \brief Creates a keyboard event based on the supplied SDL event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit keyboard_event(const SDL_KeyboardEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the scan code that is associated with the event.
   *
   * \param code the scan code that will be associated with the event.
   *
   * \since 5.0.0
   */
  void set_scan_code(const scan_code& code) noexcept
  {
    m_event.keysym.scancode = code.get();
  }

  /**
   * \brief Sets the key code that is associated with the event.
   *
   * \param code the key code that will be associated with the event.
   *
   * \since 5.0.0
   */
  void set_key_code(const key_code& code) noexcept
  {
    m_event.keysym.sym = code.get();
  }

  /**
   * \brief Sets the button state associated with the event.
   *
   * \param state the button state that will be associated with the event
   *
   * \since 5.0.0
   */
  void set_button_state(const button_state state) noexcept
  {
    m_event.state = to_underlying(state);
  }

  /**
   * \brief Sets the status of key modifiers.
   *
   * \param modifiers the modifiers that will be affected.
   * \param active `true` if the modifiers should be active; `false` otherwise.
   *
   * \since 4.0.0
   */
  void set_modifier(const key_mod modifiers, const bool active) noexcept
  {
    if (active) {
      m_event.keysym.mod |= to_underlying(modifiers);
    }
    else {
      m_event.keysym.mod &= ~to_underlying(modifiers);
    }
  }

  /**
   * \brief Sets the flag that indicates whether or not the key associated with
   * this key event was repeatedly triggered.
   *
   * \param repeated `true` if the key was repeatedly triggered; `false`
   * otherwise.
   *
   * \since 4.0.0
   */
  void set_repeated(const bool repeated) noexcept
  {
    m_event.repeat = repeated;
  }

  /**
   * \brief Sets the window ID that is associated with this key event.
   *
   * \param id the window ID that should be associated with the key event.
   *
   * \since 4.0.0
   */
  void set_window_id(const u32 id) noexcept
  {
    m_event.windowID = id;
  }

  /**
   * \brief Indicates whether or not the event is associated with the
   * specified scan code.
   *
   * \param code the scan code that will be checked.
   *
   * \return `true` if the supplied scan code is associated with the event;
   * `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto is_active(const scan_code& code) const noexcept -> bool
  {
    return m_event.keysym.scancode == code.get();
  }

  /**
   * \brief Indicates whether or not the event is associated with the
   * specified key code.
   *
   * \param code the key code that will be checked.
   *
   * \return `true` if the supplied key code is associated with the event;
   * `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto is_active(const key_code& code) const noexcept -> bool
  {
    return static_cast<SDL_KeyCode>(m_event.keysym.sym) == code.get();
  }

  /**
   * \brief Indicates whether or not the specified modifiers are active.
   *
   * \note Multiple key modifiers can be active at the same time.
   *
   * \param modifiers the modifiers to check for.
   *
   * \return `true` if any of the specified modifiers are active; `false` otherwise.
   *
   * \see `is_only_active(key_mod)`
   * \see `is_only_any_of_active(key_mod)`
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto is_active(const key_mod modifiers) const noexcept -> bool
  {
    return detail::is_active(modifiers, m_event.keysym.mod);
  }

  /**
   * \brief Indicates whether or not the specified modifiers are solely active.
   *
   * \details This function differs from `is_active(key_mod)` in that this function
   * will return `false` if modifiers other than those specified are active. For example,
   * if the `shift` and `alt` modifiers are being pressed, then
   * `is_only_active(cen::key_mod::shift)` would evaluate to `false`.
   *
   * \param modifiers the modifiers to check for.
   *
   * \return `true` if *only* the specified modifiers are active; false otherwise.
   *
   * \see `is_active(key_mod)`
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto is_only_active(const key_mod modifiers) const noexcept -> bool
  {
    return detail::is_only_active(modifiers, m_event.keysym.mod);
  }

  /**
   * \brief Indicates whether or not only any of the specified modifiers are active.
   *
   * \details This function is very similar to `is_only_active()`, but differs in that not
   * all of the specified modifiers need to be active for this function to return `true`.
   * For example, if you supply `shift` to this function, and only the left shift key is
   * being pressed, then `is_only_any_of_active(cen::key_mod::shift)` would evaluate
   * to `true`. However, if some other modifiers were also being pressed other than the
   * left shift key, the same function call would instead evaluate to `false`.
   *
   * \param modifiers the modifiers to check for.
   *
   * \return `true` if *any* of the specified modifiers are active, but no other
   * modifiers; false otherwise.
   *
   * \see `is_only_active(key_mod)`
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto is_only_any_of_active(const key_mod modifiers) const noexcept -> bool
  {
    return detail::is_only_any_of_active(modifiers, m_event.keysym.mod);
  }

  /**
   * \brief Indicates whether or not the key associated with this key event has
   * been repeatedly triggered.
   *
   * \return `true` if the key associated with the event was repeated; false
   * otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto repeated() const noexcept -> bool
  {
    return m_event.repeat;
  }

  /**
   * \brief Returns the button state of the key associated with the event.
   *
   * \return the button state of the key associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto state() const noexcept -> button_state
  {
    return static_cast<button_state>(m_event.state);
  }

  /**
   * \brief Indicates whether or not the event is associated with the release
   * of a key.
   *
   * \note This function is equivalent to `state() ==  button_state::released`.
   *
   * \return `true` if the event is a key released event; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto released() const noexcept -> bool
  {
    return state() == button_state::released;
  }

  /**
   * \brief Indicates whether or not the event is associated with the press
   * of a key.
   *
   * \note This function is equivalent to `state() ==  button_state::pressed`.
   *
   * \return `true` if the event is a key pressed event; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto pressed() const noexcept -> bool
  {
    return state() == button_state::pressed;
  }

  /**
   * \brief Returns the scan code that is associated with the event.
   *
   * \return the scan code that is associated with the event.
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto scan() const noexcept -> scan_code
  {
    return m_event.keysym.scancode;
  }

  /**
   * \brief Equivalent to `scan()`.
   * \since 5.0.0
   */
  [[nodiscard]] auto get_scan_code() const noexcept -> scan_code
  {
    return scan();
  }

  /**
   * \brief Returns the key code that is associated with the event.
   *
   * \return the key code that is associated with the event.
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto key() const noexcept -> key_code
  {
    return static_cast<SDL_KeyCode>(m_event.keysym.sym);
  }

  /**
   * \brief Equivalent to `key()`.
   * \since 5.0.0
   */
  [[nodiscard]] auto get_key_code() const noexcept -> key_code
  {
    return key();
  }

  /**
   * \brief Returns the ID of the window associated with the event.
   *
   * \return the ID of the window associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto window_id() const noexcept -> u32
  {
    return m_event.windowID;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_KeyboardEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.key = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_KEYBOARD_EVENT_HEADER

// #include "mouse_button_event.hpp"
#ifndef CENTURION_MOUSE_BUTTON_EVENT_HEADER
#define CENTURION_MOUSE_BUTTON_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../core/to_underlying.hpp"

// #include "../input/button_state.hpp"

// #include "../input/mouse_button.hpp"
#ifndef CENTURION_MOUSE_BUTTON_HEADER
#define CENTURION_MOUSE_BUTTON_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum mouse_button
 *
 * \brief Provides values that represent various mouse buttons.
 *
 * \since 3.1.0
 */
enum class mouse_button : u8
{
  left = SDL_BUTTON_LEFT,
  middle = SDL_BUTTON_MIDDLE,
  right = SDL_BUTTON_RIGHT,
  x1 = SDL_BUTTON_X1,
  x2 = SDL_BUTTON_X2
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied mouse button.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(mouse_button::middle) == "middle"`.
 *
 * \param button the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const mouse_button button) -> std::string_view
{
  switch (button) {
    case mouse_button::left:
      return "left";

    case mouse_button::middle:
      return "middle";

    case mouse_button::right:
      return "right";

    case mouse_button::x1:
      return "x1";

    case mouse_button::x2:
      return "x2";

    default:
      throw cen_error{"Did not recognize mouse button!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a mouse button enumerator.
 *
 * \param stream the output stream that will be used.
 * \param button the enumerator that will be printed.
 *
 * \see `to_string(mouse_button)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const mouse_button button) -> std::ostream&
{
  return stream << to_string(button);
}

/// \} End of streaming

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_MOUSE_BUTTON_HEADER
// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class mouse_button_event
 *
 * \brief Represents an event triggered by mouse button presses or releases.
 *
 * \see `SDL_MouseButtonEvent`
 *
 * \since 4.0.0
 */
class mouse_button_event final : public common_event<SDL_MouseButtonEvent>
{
 public:
  /**
   * \brief Creates a mouse button event of type `mouse_button_down`.
   *
   * \since 4.0.0
   */
  mouse_button_event() noexcept : common_event{event_type::mouse_button_down}
  {}

  /**
   * \brief Creates a mouse_button_event that is based on the supplied SDL
   * event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit mouse_button_event(const SDL_MouseButtonEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the window ID associated with the event.
   *
   * \param id the window ID associated with the event.
   *
   * \since 4.0.0
   */
  void set_window_id(const u32 id) noexcept
  {
    m_event.windowID = id;
  }

  /**
   * \brief Sets the mouse instance ID.
   *
   * \param which the mouse instance ID.
   *
   * \since 4.0.0
   */
  void set_which(const u32 which) noexcept
  {
    m_event.which = which;
  }

  /**
   * \brief Sets the mouse button associated with the event.
   *
   * \param button the mouse button associated with the event.
   *
   * \since 4.0.0
   */
  void set_button(const mouse_button button) noexcept
  {
    m_event.button = to_underlying(button);
  }

  /**
   * \brief Sets the button state associated with the event.
   *
   * \param state the button state associated with the event.
   *
   * \since 4.0.0
   */
  void set_state(const button_state state) noexcept
  {
    m_event.state = to_underlying(state);
  }

  /**
   * \brief Sets the amount of clicks associated with the event.
   *
   * \param clicks the amount of clicks associated with the event.
   *
   * \since 4.0.0
   */
  void set_clicks(const u8 clicks) noexcept
  {
    m_event.clicks = clicks;
  }

  /**
   * \brief Sets the x-coordinate of the mouse relative to the window.
   *
   * \param x the x-coordinate of the mouse relative to the window.
   *
   * \since 4.0.0
   */
  void set_x(const i32 x) noexcept
  {
    m_event.x = x;
  }

  /**
   * \brief Sets the y-coordinate of the mouse relative to the window.
   *
   * \param y the y-coordinate of the mouse relative to the window.
   *
   * \since 4.0.0
   */
  void set_y(const i32 y) noexcept
  {
    m_event.y = y;
  }

  /**
   * \brief Returns the ID of the window associated with the event.
   *
   * \return the ID of the window associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto window_id() const noexcept -> u32
  {
    return m_event.windowID;
  }

  /**
   * \brief Returns the mouse instance ID, or SDL_TOUCH_MOUSEID if the event was
   * triggered by a touch input device.
   *
   * \return the mouse instance ID, or SDL_TOUCH_MOUSEID.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto which() const noexcept -> u32
  {
    return m_event.which;
  }

  /**
   * \brief Returns the mouse button associated with the event.
   *
   * \return the mouse button associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto button() const noexcept -> mouse_button
  {
    return static_cast<mouse_button>(m_event.button);
  }

  /**
   * \brief Returns the state of the mouse button associated with the event.
   *
   * \return the state of the mouse button associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto state() const noexcept -> button_state
  {
    return static_cast<button_state>(m_event.state);
  }

  /**
   * \brief Indicates whether or not the associated button is pressed.
   *
   * \return `true` if the associated button is pressed; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto pressed() const noexcept -> bool
  {
    return state() == button_state::pressed;
  }

  /**
   * \brief Indicates whether or not the associated button is released.
   *
   * \return `true` if the associated button is released; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto released() const noexcept -> bool
  {
    return state() == button_state::released;
  }

  /**
   * \brief Returns the number of mouse clicks associated with the event.
   *
   * \return the number of mouse clicks associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto clicks() const noexcept -> u8
  {
    return m_event.clicks;
  }

  /**
   * \brief Returns the x-coordinate of the mouse relative to the window.
   *
   * \return the x-coordinate of the mouse relative to the window.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto x() const noexcept -> i32
  {
    return m_event.x;
  }

  /**
   * \brief Returns the y-coordinate of the mouse relative to the window.
   *
   * \return the y-coordinate of the mouse relative to the window.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto y() const noexcept -> i32
  {
    return m_event.y;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_MouseButtonEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.button = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_MOUSE_BUTTON_EVENT_HEADER

// #include "mouse_motion_event.hpp"
#ifndef CENTURION_MOUSE_MOTION_EVENT_HEADER
#define CENTURION_MOUSE_MOTION_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../core/to_underlying.hpp"

// #include "../input/mouse_button.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class mouse_motion_event
 *
 * \brief Represents events that are triggered by the movement of the mouse.
 *
 * \see `SDL_MouseMotionEvent`
 *
 * \since 4.0.0
 */
class mouse_motion_event final : public common_event<SDL_MouseMotionEvent>
{
 public:
  /**
   * \brief Creates a mouse motion event.
   *
   * \since 4.0.0
   */
  mouse_motion_event() noexcept : common_event{event_type::mouse_motion}
  {}

  /**
   * \brief Creates an event based on an SDL event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit mouse_motion_event(const SDL_MouseMotionEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the window ID associated with the event.
   *
   * \param id the window ID associated with the event.
   *
   * \since 4.0.0
   */
  void set_window_id(const u32 id) noexcept
  {
    m_event.windowID = id;
  }

  /**
   * \brief Sets the mouse instance ID.
   *
   * \param which the mouse instance ID.
   *
   * \since 4.0.0
   */
  void set_which(const u32 which) noexcept
  {
    m_event.which = which;
  }

  /**
   * \brief Sets the mouse button state associated with the event.
   *
   * \details The state could be any of `SDL_BUTTON_LMASK`, `SDL_BUTTON_MMASK`,
   * `SDL_BUTTON_RMASK`, `SDL_BUTTON_X1MASK` and `SDL_BUTTON_X2MASK` OR'd
   * together.
   *
   * \param state the mouse button state associated with the event.
   *
   * \since 4.0.0
   */
  void set_state(const u32 state) noexcept
  {
    m_event.state = state;
  }

  /**
   * \brief Sets the x-coordinate of the mouse relative to the mouse that is
   * associated with the event.
   *
   * \param x the x-coordinate of the mouse.
   *
   * \since 4.0.0
   */
  void set_x(const i32 x) noexcept
  {
    m_event.x = x;
  }

  /**
   * \brief Sets the y-coordinate of the mouse relative to the mouse that is
   * associated with the event.
   *
   * \param y the y-coordinate of the mouse.
   *
   * \since 4.0.0
   */
  void set_y(const i32 y) noexcept
  {
    m_event.y = y;
  }

  /**
   * \brief Sets the value of the relative motion of the mouse along the x-axis.
   *
   * \param dx the value of the relative motion of the mouse along the x-axis.
   *
   * \since 4.0.0
   */
  void set_dx(const i32 dx) noexcept
  {
    m_event.xrel = dx;
  }

  /**
   * \brief Sets the value of the relative motion of the mouse along the y-axis.
   *
   * \param dy the value of the relative motion of the mouse along the y-axis.
   *
   * \since 4.0.0
   */
  void set_dy(const i32 dy) noexcept
  {
    m_event.yrel = dy;
  }

  /**
   * \brief Returns the window ID associated with the event.
   *
   * \return the window ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto window_id() const noexcept -> u32
  {
    return m_event.windowID;
  }

  /**
   * \brief Returns the mouse instance ID, or `SDL_TOUCH_MOUSEID`.
   *
   * \details The returned value might be `SDL_TOUCH_MOUSEID` for events that
   * were generated by a touch input device.
   *
   * \return the mouse instance ID, or `SDL_TOUCH_MOUSEID`.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto which() const noexcept -> u32
  {
    return m_event.which;
  }

  /**
   * \brief Returns a bitmask for the current mouse button state.
   *
   * \remark If you want to check if a specific mouse button is pressed or released, a
   * better alternative would be to use the `pressed()` function.
   *
   * \return a bitmask for the current mouse button state.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto state() const noexcept -> u32
  {
    return m_event.state;
  }

  /**
   * \brief Indicates whether or not a mouse button is pressed.
   *
   * \param button the mouse button that will be checked.
   *
   * \return `true` if the specified mouse button is pressed; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto pressed(const mouse_button button) const noexcept -> bool
  {
    return m_event.state & SDL_BUTTON(to_underlying(button));
  }

  /**
   * \brief Returns the x-coordinate of the mouse relative to the window.
   *
   * \return the x-coordinate of the mouse relative to the window.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto x() const noexcept -> i32
  {
    return m_event.x;
  }

  /**
   * \brief Returns the y-coordinate of the mouse relative to the window.
   *
   * \return the y-coordinate of the mouse relative to the window.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto y() const noexcept -> i32
  {
    return m_event.y;
  }

  /**
   * \brief Returns the relative motion of the mouse along the x-axis.
   *
   * \return the relative motion of the mouse along the x-axis.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto dx() const noexcept -> i32
  {
    return m_event.xrel;
  }

  /**
   * \brief Returns the relative motion of the mouse along the y-axis.
   *
   * \return the relative motion of the mouse along the y-axis.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto dy() const noexcept -> i32
  {
    return m_event.yrel;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_MouseMotionEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.motion = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_MOUSE_MOTION_EVENT_HEADER

// #include "mouse_wheel_event.hpp"
#ifndef CENTURION_MOUSE_WHEEL_EVENT_HEADER
#define CENTURION_MOUSE_WHEEL_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../core/to_underlying.hpp"

// #include "common_event.hpp"

// #include "mouse_wheel_direction.hpp"
#ifndef CENTURION_MOUSE_WHEEL_DIRECTION_HEADER
#define CENTURION_MOUSE_WHEEL_DIRECTION_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \enum mouse_wheel_direction
 *
 * \brief Represents mouse wheel directions.
 *
 * \see `SDL_MouseWheelDirection`
 * \see `mouse_wheel_direction_count()`
 *
 * \since 4.0.0
 */
enum class mouse_wheel_direction : u32
{
  normal = SDL_MOUSEWHEEL_NORMAL,   ///< The scroll direction is normal
  flipped = SDL_MOUSEWHEEL_FLIPPED  ///< The scroll direction is flipped natural
};

/**
 * \brief Returns the number of enumerators for the `mouse_wheel_direction` enum.
 *
 * \return the number of enumerators.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto mouse_wheel_direction_count() noexcept -> int
{
  return 2;
}

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied mouse wheel direction.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(mouse_wheel_direction::normal) == "normal"`.
 *
 * \param dir the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const mouse_wheel_direction dir) -> std::string_view
{
  switch (dir) {
    case mouse_wheel_direction::normal:
      return "normal";

    case mouse_wheel_direction::flipped:
      return "flipped";

    default:
      throw cen_error{"Did not recognize mouse wheel direction!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of an mouse wheel direction enumerator.
 *
 * \param stream the output stream that will be used.
 * \param dir the enumerator that will be printed.
 *
 * \see `to_string(mouse_wheel_direction)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const mouse_wheel_direction dir) -> std::ostream&
{
  return stream << to_string(dir);
}

/// \} End of streaming

/// \name Mouse wheel direction comparison operators
/// \{

/**
 * \brief Indicates whether or not two mouse wheel direction values are equal.
 *
 * \param lhs the left-hand side mouse wheel direction value.
 * \param rhs the right-hand side mouse wheel direction value.
 *
 * \return `true` if the two values are equal; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator==(const mouse_wheel_direction lhs,
                                        const SDL_MouseWheelDirection rhs) noexcept -> bool
{
  return lhs == static_cast<mouse_wheel_direction>(rhs);
}

/// \copydoc operator==(mouse_wheel_direction, SDL_MouseWheelDirection)
[[nodiscard]] constexpr auto operator==(const SDL_MouseWheelDirection lhs,
                                        const mouse_wheel_direction rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two mouse wheel direction values aren't
 * equal.
 *
 * \param lhs the left-hand side mouse wheel direction value.
 * \param rhs the right-hand side mouse wheel direction value.
 *
 * \return `true` if the two values aren't equal; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator!=(const mouse_wheel_direction lhs,
                                        const SDL_MouseWheelDirection rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(mouse_wheel_direction, SDL_MouseWheelDirection)
[[nodiscard]] constexpr auto operator!=(const SDL_MouseWheelDirection lhs,
                                        const mouse_wheel_direction rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of mouse wheel direction comparison operators

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_MOUSE_WHEEL_DIRECTION_HEADER


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class mouse_wheel_event
 *
 * \brief Represents events triggered when a user moves the mouse wheel.
 *
 * \see `SDL_MouseWheelEvent`
 *
 * \since 4.0.0
 */
class mouse_wheel_event final : public common_event<SDL_MouseWheelEvent>
{
 public:
  /**
   * \brief Creates a mouse wheel event.
   *
   * \since 4.0.0
   */
  mouse_wheel_event() noexcept : common_event{event_type::mouse_wheel}
  {}

  /**
   * \brief Creates an event based on the supplied SDL event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit mouse_wheel_event(const SDL_MouseWheelEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the window ID associated with the event.
   *
   * \param id the window ID associated with the event.
   *
   * \since 4.0.0
   */
  void set_window_id(const u32 id) noexcept
  {
    m_event.windowID = id;
  }

  /**
   * \brief Sets the mouse instance ID.
   *
   * \param which the mouse instance ID.
   *
   * \since 4.0.0
   */
  void set_which(const u32 which) noexcept
  {
    m_event.which = which;
  }

  /**
   * \brief Sets the horizontally scrolled distance.
   *
   * \details A positive value indicates that the user scrolled to the right
   * and a negative value indicates that the user scrolled to the left.
   *
   * \param xScroll the horizontally scrolled distance.
   *
   * \since 4.0.0
   */
  void set_x_scroll(const i32 xScroll) noexcept
  {
    m_event.x = xScroll;
  }

  /**
   * \brief Sets the vertically scrolled distance.
   *
   * \details A positive value indicates that the user scrolled to the right
   * and a negative value indicates that the user scrolled to the left.
   *
   * \param yScroll the vertically scrolled distance.
   *
   * \since 4.0.0
   */
  void set_y_scroll(const i32 yScroll) noexcept
  {
    m_event.y = yScroll;
  }

  /**
   * \brief Sets the mouse wheel direction mode associated with the event.
   *
   * \param direction the mouse wheel direction mode associated with the event.
   *
   * \since 4.0.0
   */
  void set_direction(const mouse_wheel_direction direction) noexcept
  {
    m_event.direction = to_underlying(direction);
  }

  /**
   * \brief Returns the ID of the window associated with the event.
   *
   * \return the ID of the window associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto window_id() const noexcept -> u32
  {
    return m_event.windowID;
  }

  /**
   * \brief Returns the mouse instance ID, or `SDL_TOUCH_MOUSEID` if the event
   * was triggered by a touch input device.
   *
   * \return the mouse instance ID, or `SDL_TOUCH_MOUSEID`.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto which() const noexcept -> u32
  {
    return m_event.which;
  }

  /**
   * \brief Returns the horizontally scrolled distance
   *
   * \details A positive value indicates that the user scrolled to the right
   * and a negative value indicates that the user scrolled to the left.
   *
   * \return the horizontally scrolled distance.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto x_scroll() const noexcept -> i32
  {
    return m_event.x;
  }

  /**
   * \brief Returns the vertically scrolled distance.
   *
   * \details A positive value indicates that the user scrolled to the right
   * and a negative value indicates that the user scrolled to the left.
   *
   * \return the vertically scrolled distance.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto y_scroll() const noexcept -> i32
  {
    return m_event.y;
  }

  /**
   * \brief Returns the mouse wheel direction mode associated with the event.
   *
   * \return the mouse wheel direction mode associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto direction() const noexcept -> mouse_wheel_direction
  {
    return static_cast<mouse_wheel_direction>(m_event.direction);
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_MouseWheelEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.wheel = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_MOUSE_WHEEL_EVENT_HEADER

// #include "multi_gesture_event.hpp"
#ifndef CENTURION_MULTI_GESTURE_EVENT_HEADER
#define CENTURION_MULTI_GESTURE_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class multi_gesture_event
 *
 * \brief Provides information about events related to touch events triggered
 * by multiple fingers.
 *
 * \see `SDL_MultiGestureEvent`
 *
 * \since 4.0.0
 */
class multi_gesture_event final : public common_event<SDL_MultiGestureEvent>
{
 public:
  /**
   * \brief Creates a multi-gesture event.
   *
   * \since 4.0.0
   */
  multi_gesture_event() noexcept : common_event{event_type::multi_gesture}
  {}

  /**
   * \brief Creates an event that is based on the supplied SDL event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit multi_gesture_event(const SDL_MultiGestureEvent& event) noexcept
      : common_event{event}
  {}

  /**
   * \brief Sets the touch device ID associated with the event.
   *
   * \param id the touch device ID associated with the event.
   *
   * \since 4.0.0
   */
  void set_touch_id(const SDL_TouchID id) noexcept
  {
    m_event.touchId = id;
  }

  /**
   * \brief Sets the amount that the fingers rotated during the gesture
   * associated with the event.
   *
   * \param dTheta the amount that the fingers rotated.
   *
   * \since 4.0.0
   */
  void set_delta_theta(const float dTheta) noexcept
  {
    m_event.dTheta = dTheta;
  }

  /**
   * \brief Sets the amount that the fingers pinched during the gesture
   * associated with the event.
   *
   * \param dDistance the amount that the fingers pinched.
   *
   * \since 4.0.0
   */
  void set_delta_distance(const float dDistance) noexcept
  {
    m_event.dDist = dDistance;
  }

  /**
   * \brief Sets the x-coordinate of the normalized center of the gesture
   * associated with the event.
   *
   * \param centerX the x-coordinate of the normalized center of the gesture
   * associated with the event.
   *
   * \since 4.0.0
   */
  void set_center_x(const float centerX) noexcept
  {
    m_event.x = centerX;
  }

  /**
   * \brief Sets the y-coordinate of the normalized center of the gesture
   * associated with the event.
   *
   * \param centerY the y-coordinate of the normalized center of the gesture
   * associated with the event.
   *
   * \since 4.0.0
   */
  void set_center_y(const float centerY) noexcept
  {
    m_event.y = centerY;
  }

  /**
   * \brief Sets the number of fingers that was used in the gesture associated
   * with the event.
   *
   * \param count the number of fingers that were use.
   *
   * \since 6.1.0
   */
  void set_finger_count(const u16 count) noexcept
  {
    m_event.numFingers = count;
  }

  /**
   * \brief Returns the touch device ID associated with the event.
   *
   * \return the touch device ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto touch_id() const noexcept -> SDL_TouchID
  {
    return m_event.touchId;
  }

  /**
   * \brief Returns the amount that the fingers rotated during the gesture
   * associated with the event.
   *
   * \return the amount that the fingers rotated.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto delta_theta() const noexcept -> float
  {
    return m_event.dTheta;
  }

  /**
   * \brief Returns the amount that the fingers pinched during the gesture
   * associated with the event.
   *
   * \return the amount that the fingers pinched.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto delta_distance() const noexcept -> float
  {
    return m_event.dDist;
  }

  /**
   * \brief Returns the x-coordinate of the normalized center of gesture
   * associated with the event.
   *
   * \return the x-coordinate of the normalized center of gesture associated
   * with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto center_x() const noexcept -> float
  {
    return m_event.x;
  }

  /**
   * \brief Returns the y-coordinate of the normalized center of gesture
   * associated with the event.
   *
   * \return the y-coordinate of the normalized center of gesture associated
   * with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto center_y() const noexcept -> float
  {
    return m_event.y;
  }

  /**
   * \brief Returns the amount of fingers used in the gesture associated with the event.
   *
   * \return the amount of fingers used in the gesture.
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto finger_count() const noexcept -> u16
  {
    return m_event.numFingers;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_MultiGestureEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.mgesture = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_MULTI_GESTURE_EVENT_HEADER

// #include "quit_event.hpp"
#ifndef CENTURION_QUIT_EVENT_HEADER
#define CENTURION_QUIT_EVENT_HEADER

#include <SDL.h>

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class quit_event
 *
 * \brief Represents the event of the user wanting to close the application,
 * usually by pressing the "X"-button on the window frame.
 *
 * \see `SDL_QuitEvent`
 *
 * \since 4.0.0
 */
class quit_event final : public common_event<SDL_QuitEvent>
{
 public:
  /**
   * \brief Creates a quit event.
   *
   * \since 4.0.0
   */
  quit_event() noexcept : common_event{event_type::quit}
  {}

  /**
   * \brief Creates a quit event based on the supplied SDL event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit quit_event(const SDL_QuitEvent& event) noexcept : common_event{event}
  {}
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_QuitEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.quit = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_QUIT_EVENT_HEADER

// #include "sensor_event.hpp"
#ifndef CENTURION_SENSOR_EVENT_HEADER
#define CENTURION_SENSOR_EVENT_HEADER

#include <SDL.h>

#include <array>  // array

// #include "../core/integers.hpp"

// #include "../detail/array_utils.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class sensor_event
 *
 * \brief Represents events related to updates of sensors.
 *
 * \since 6.3.0
 */
class sensor_event final : public common_event<SDL_SensorEvent>
{
 public:
  using data_type = std::array<float, 6>;

  /**
   * \brief Creates a sensor event.
   *
   * \since 6.3.0
   */
  sensor_event() noexcept : common_event{event_type::sensor_update}
  {}

  /**
   * \brief Creates a sensor event based on an SDL event.
   *
   * \param event the event that will be copied.
   *
   * \since 6.3.0
   */
  explicit sensor_event(const SDL_SensorEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the sensor instance ID associated with the event.
   *
   * \param id the sensor instance ID.
   *
   * \since 6.3.0
   */
  void set_which(const i32 id) noexcept
  {
    m_event.which = id;
  }

  /**
   * \brief Sets the sensor values associated with the event.
   *
   * \param values the sensor values.
   *
   * \since 6.3.0
   */
  void set_data(const data_type& values)
  {
    detail::assign(values, m_event.data);
  }

  /**
   * \brief Returns the instance ID of the associated sensor.
   *
   * \return the associated sensor instance ID.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto which() const noexcept -> i32
  {
    return m_event.which;
  }

  /**
   * \brief Returns up to 6 values from the sensor.
   *
   * \return values from the sensor.
   *
   * \see `basic_sensor::data()`
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto data() const -> data_type
  {
    return detail::to_array(m_event.data);
  }
};

template <>
inline auto as_sdl_event(const common_event<SDL_SensorEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.sensor = event.get();
  return e;
}

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_SENSOR_EVENT_HEADER

// #include "text_editing_event.hpp"
#ifndef CENTURION_TEXT_EDITING_EVENT_HEADER
#define CENTURION_TEXT_EDITING_EVENT_HEADER

#include <SDL.h>

#include <string_view>  // string_view

// #include "../core/integers.hpp"

// #include "../core/str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER

// #include "../detail/clamp.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class text_editing_event
 *
 * \brief Represents an event triggered by keyboard text editing.
 *
 * \note This class doesn't provide a setter for the text, since it's
 * impossible to assign a value to a variable of type `char[32]` in C++.
 *
 * \see `SDL_TextEditingEvent`
 *
 * \since 4.0.0
 */
class text_editing_event final : public common_event<SDL_TextEditingEvent>
{
 public:
  /**
   * \brief Creates a text editing event.
   *
   * \since 4.0.0
   */
  text_editing_event() noexcept : common_event{event_type::text_editing}
  {
    check_length();
  }

  /**
   * \brief Creates an event that is based on the supplied SDL event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit text_editing_event(const SDL_TextEditingEvent& event) noexcept : common_event{event}
  {
    check_length();
  }

  /**
   * \brief Sets the window ID associated with the event.
   *
   * \param id the window ID associated with the event.
   *
   * \since 4.0.0
   */
  void set_window_id(const u32 id) noexcept
  {
    m_event.windowID = id;
  }

  /**
   * \brief Sets the location to begin editing from.
   *
   * \param start the location to begin editing from.
   *
   * \since 4.0.0
   */
  void set_start(const i32 start) noexcept
  {
    m_event.start = start;
  }

  /**
   * \brief Sets the number of characters to edit from the start point.
   *
   * \details The supplied value will be clamped to the range [0, 32].
   *
   * \param length the number of characters to edit from the start point.
   *
   * \since 4.0.0
   */
  void set_length(const i32 length) noexcept
  {
    m_event.length = detail::clamp(length, 0, 32);
  }

  /**
   * \brief Returns the window ID associated with the event.
   *
   * \return the window ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto window_id() const noexcept -> u32
  {
    return m_event.windowID;
  }

  /**
   * \brief Returns the text that will be used, as a null-terminated string in
   * UTF-8 encoding.
   *
   * \return the text that will be used.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto text() const noexcept -> std::string_view
  {
    return std::string_view{static_cast<str>(m_event.text)};
  }

  /**
   * \brief Returns the location to begin editing from.
   *
   * \return the location to begin editing from.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto start() const noexcept -> i32
  {
    return m_event.start;
  }

  /**
   * \brief Returns the number of characters to edit from the start point.
   *
   * \details The returned value will always be in the range [0, 32].
   *
   * \return the number of characters to edit from the start point.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto length() const noexcept -> i32
  {
    return m_event.length;
  }

 private:
  void check_length() noexcept
  {
    m_event.length = detail::clamp(m_event.length, 0, 32);
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_TextEditingEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.edit = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_TEXT_EDITING_EVENT_HEADER

// #include "text_input_event.hpp"
#ifndef CENTURION_TEXT_INPUT_EVENT_HEADER
#define CENTURION_TEXT_INPUT_EVENT_HEADER

#include <SDL.h>

#include <string_view>  // string_view

// #include "../core/integers.hpp"

// #include "../core/str.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class text_input_event
 *
 * \brief Provides information about keyboard text input events.
 *
 * \see `SDL_TextInputEvent`
 *
 * \since 4.0.0
 */
class text_input_event final : public common_event<SDL_TextInputEvent>
{
 public:
  /**
   * \brief Creates a text input event.
   *
   * \since 4.0.0
   */
  text_input_event() noexcept : common_event{event_type::text_input}
  {}

  /**
   * \brief Creates an event that is based on the supplied SDL event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit text_input_event(const SDL_TextInputEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the window ID associated with the event.
   *
   * \param id the window ID associated with the event.
   *
   * \since 4.0.0
   */
  void set_window_id(const u32 id) noexcept
  {
    m_event.windowID = id;
  }

  /**
   * \brief Returns the window ID associated with the event.
   *
   * \return the window ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto window_id() const noexcept -> u32
  {
    return m_event.windowID;
  }

  /**
   * Returns the text that will be used, as a null-terminated string in UTF-8
   * encoding.
   *
   * \return the text that will be used.
   * \since 4.0.0
   */
  [[nodiscard]] auto text_utf8() const noexcept -> std::string_view
  {
    return std::string_view{static_cast<str>(m_event.text)};
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_TextInputEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.text = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_TEXT_INPUT_EVENT_HEADER

// #include "touch_finger_event.hpp"
#ifndef CENTURION_TOUCH_FINGER_EVENT_HEADER
#define CENTURION_TOUCH_FINGER_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../detail/clamp.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class touch_finger_event
 *
 * \brief Represents an event related to touch screen actions.
 *
 * \see `SDL_TouchFingerEvent`
 *
 * \since 4.0.0
 */
class touch_finger_event final : public common_event<SDL_TouchFingerEvent>
{
 public:
  /**
   * \brief Creates a touch finger event of type `touch_down`.
   *
   * \since 4.0.0
   */
  touch_finger_event() noexcept : common_event{event_type::touch_down}
  {}

  /**
   * \brief Creates a touch finger event that is based on the supplied SDL
   * ouch finger event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit touch_finger_event(const SDL_TouchFingerEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the ID of the associated touch device.
   *
   * \param id the ID of the associated touch device.
   *
   * \since 4.0.0
   */
  void set_touch_id(const SDL_TouchID id) noexcept
  {
    m_event.touchId = id;
  }

  /**
   * \brief Sets the finger ID associated with the event.
   *
   * \param id the finger ID associated with the event.
   *
   * \since 4.0.0
   */
  void set_finger_id(const SDL_FingerID id) noexcept
  {
    m_event.fingerId = id;
  }

#if SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Sets the window ID of the window under the finger.
   *
   * \param id the window ID of the window under the finger.
   *
   * \since 4.0.0
   */
  void set_window_id(const u32 id) noexcept
  {
    m_event.windowID = id;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Sets the normalized x-coordinate of the location of the event.
   *
   * \details The supplied value will be clamped to the range [0, 1].
   *
   * \param x the normalized x-coordinate of the location of the event,
   * clamped to the range [0, 1].
   *
   * \since 4.0.0
   */
  void set_x(const float x) noexcept
  {
    m_event.x = detail::clamp(x, 0.0f, 1.0f);
  }

  /**
   * \brief Sets the normalized y-coordinate of the location of the event.
   *
   * \details The supplied value will be clamped to the range [0, 1].
   *
   * \param y the normalized y-coordinate of the location of the event,
   * clamped to the range [0, 1].
   *
   * \since 4.0.0
   */
  void set_y(const float y) noexcept
  {
    m_event.y = detail::clamp(y, 0.0f, 1.0f);
  }

  /**
   * \brief Sets the normalized distance moved along the x-axis.
   *
   * \details The supplied value will be clamped to the range [-1, 1].
   *
   * \param dx the normalized distance moved along the x-axis, clamped to the
   * range [-1, 1].
   *
   * \since 4.0.0
   */
  void set_dx(const float dx) noexcept
  {
    m_event.dx = detail::clamp(dx, -1.0f, 1.0f);
  }

  /**
   * \brief Sets the normalized distance moved along the y-axis.
   *
   * \details The supplied value will be clamped to the range [-1, 1].
   *
   * \param dy the normalized distance moved along the y-axis, clamped to the
   * range [-1, 1].
   *
   * \since 4.0.0
   */
  void set_dy(const float dy) noexcept
  {
    m_event.dy = detail::clamp(dy, -1.0f, 1.0f);
  }

  /**
   * \brief Sets the normalized pressure associated with the event.
   *
   * \details The supplied value will be clamped to the range [0, 1].
   *
   * \param pressure the normalized pressure associated with the event, clamped
   * in the range [0, 1].
   *
   * \since 4.0.0
   */
  void set_pressure(const float pressure) noexcept
  {
    m_event.pressure = detail::clamp(pressure, 0.0f, 1.0f);
  }

  /**
   * \brief Returns the touch device ID associated with the event.
   *
   * \return the touch device ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto touch_id() const noexcept -> SDL_TouchID
  {
    return m_event.touchId;
  }

  /**
   * \brief Returns the finger ID associated with the event.
   *
   * \return the finger ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto finger_id() const noexcept -> SDL_FingerID
  {
    return m_event.fingerId;
  }

#if SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Returns the window ID of the window under the finger.
   *
   * \return the window ID of the window under the finger.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto window_id() const noexcept -> u32
  {
    return m_event.windowID;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Returns the normalized x-coordinate of the location of the event.
   *
   * \details The returned value will be in the range [0, 1].
   *
   * \return the normalized x-coordinate of the location of the event, in the
   * range [0, 1].
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto x() const noexcept -> float
  {
    return m_event.x;
  }

  /**
   * \brief Returns the normalized y-coordinate of the location of the event.
   *
   * \details The returned value will be in the range [0, 1].
   *
   * \return the normalized y-coordinate of the location of the event, in the
   * range [0, 1].
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto y() const noexcept -> float
  {
    return m_event.y;
  }

  /**
   * \brief Returns the normalized distance moved along the x-axis.
   *
   * \details The returned value will be in the range [-1, 1].
   *
   * \return the normalized distance moved along the x-axis, in the range
   * [-1, 1].
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto dx() const noexcept -> float
  {
    return m_event.dx;
  }

  /**
   * \brief Returns the normalized distance moved along the y-axis.
   *
   * \details The returned value will be in the range [-1, 1].
   *
   * \return the normalized distance moved along the y-axis, in the range
   * [-1, 1].
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto dy() const noexcept -> float
  {
    return m_event.dy;
  }

  /**
   * \brief Returns the normalized pressure associated with the event.
   *
   * \details The returned value will be in the range [0, 1].
   *
   * \return the normalized pressure associated with the event, in the range
   * [0, 1].
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto pressure() const noexcept -> float
  {
    return m_event.pressure;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_TouchFingerEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.tfinger = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_TOUCH_FINGER_EVENT_HEADER

// #include "user_event.hpp"
#ifndef CENTURION_USER_EVENT_HEADER
#define CENTURION_USER_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class user_event
 *
 * \brief Represents a custom user event.
 *
 * \since 6.3.0
 */
class user_event final : public common_event<SDL_UserEvent>
{
 public:
  /**
   * \brief Creates a user event.
   *
   * \details Note that the event will be created using `event_type::user`, but you can use any
   * event type value in the range [`event_type::user`, SDL_LASTEVENT - 1].
   *
   * \since 6.3.0
   */
  user_event() noexcept : common_event{event_type::user}
  {}

  /**
   * \brief Creates a user event based on an SDL event.
   *
   * \param event the event that will be copied.
   *
   * \since 6.3.0
   */
  explicit user_event(const SDL_UserEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the window ID associated with the event.
   *
   * \param id the ID of the associated window.
   *
   * \since 6.3.0
   */
  void set_window_id(const u32 id) noexcept
  {
    m_event.windowID = id;
  }

  /**
   * \brief Sets the user-defined event code associated with the event.
   *
   * \param code the custom event code.
   *
   * \since 6.3.0
   */
  void set_code(const i32 code) noexcept
  {
    m_event.code = code;
  }

  /**
   * \brief Sets an opaque data pointer to some user data.
   *
   * \param data the user data, can safely be null.
   *
   * \since 6.3.0
   */
  void set_data_1(void* data) noexcept
  {
    m_event.data1 = data;
  }

  /// \copydoc set_data_1()
  void set_data_2(void* data) noexcept
  {
    m_event.data2 = data;
  }

  /**
   * \brief Returns the ID of the window associated with the event.
   *
   * \return the associated window ID.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto window_id() const noexcept -> u32
  {
    return m_event.windowID;
  }

  /**
   * \brief Returns the user-defined event code associated with the event.
   *
   * \return the associated event code.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto code() const noexcept -> i32
  {
    return m_event.code;
  }

  /**
   * \brief Returns a pointer to the first user data slot.
   *
   * \return a pointer to the user data, might be null.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto data_1() noexcept -> void*
  {
    return m_event.data1;
  }

  /// \copydoc data_1()
  [[nodiscard]] auto data_1() const noexcept -> const void*
  {
    return m_event.data1;
  }

  /**
   * \brief Returns a pointer to the second user data slot.
   *
   * \return a pointer to the user data, might be null.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto data_2() noexcept -> void*
  {
    return m_event.data2;
  }

  /// \copydoc data_2()
  [[nodiscard]] auto data_2() const noexcept -> const void*
  {
    return m_event.data2;
  }
};

template <>
inline auto as_sdl_event(const common_event<SDL_UserEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.user = event.get();
  return e;
}

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_USER_EVENT_HEADER

// #include "window_event.hpp"
#ifndef CENTURION_WINDOW_EVENT_HEADER
#define CENTURION_WINDOW_EVENT_HEADER

#include <SDL.h>

// #include "common_event.hpp"

// #include "window_event_id.hpp"
#ifndef CENTURION_WINDOW_EVENT_ID_HEADER
#define CENTURION_WINDOW_EVENT_ID_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \enum window_event_id
 *
 * \brief Represents different flavours of window events.
 *
 * \details Depending on the event ID of a `window_event` instance, the
 * `window_event::data_1()` and `window_event::data_2()` methods have special meanings.
 *
 * | ID             | data_1 | data_2 |
 * | -------------- | ------ | ------ |
 * | `none`         | N/A    | N/A    |
 * | `shown`        | N/A    | N/A    |
 * | `hidden`       | N/A    | N/A    |
 * | `exposed`      | N/A    | N/A    |
 * | `moved`        | X      | Y      |
 * | `resized`      | Width  | Height |
 * | `size_changed` | Width  | Height |
 * | `minimized`    | N/A    | N/A    |
 * | `maximized`    | N/A    | N/A    |
 * | `restored`     | N/A    | N/A    |
 * | `enter`        | N/A    | N/A    |
 * | `leave`        | N/A    | N/A    |
 * | `focus_gained` | N/A    | N/A    |
 * | `focus_lost`   | N/A    | N/A    |
 * | `close`        | N/A    | N/A    |
 * | `take_focus`   | N/A    | N/A    |
 * | `hit_test`     | N/A    | N/A    |
 *
 * \since 4.0.0
 */
enum class window_event_id
{
  none = SDL_WINDOWEVENT_NONE,
  shown = SDL_WINDOWEVENT_SHOWN,
  hidden = SDL_WINDOWEVENT_HIDDEN,
  exposed = SDL_WINDOWEVENT_EXPOSED,
  moved = SDL_WINDOWEVENT_MOVED,
  resized = SDL_WINDOWEVENT_RESIZED,
  size_changed = SDL_WINDOWEVENT_SIZE_CHANGED,
  minimized = SDL_WINDOWEVENT_MINIMIZED,
  maximized = SDL_WINDOWEVENT_MAXIMIZED,
  restored = SDL_WINDOWEVENT_RESTORED,
  enter = SDL_WINDOWEVENT_ENTER,
  leave = SDL_WINDOWEVENT_LEAVE,
  focus_gained = SDL_WINDOWEVENT_FOCUS_GAINED,
  focus_lost = SDL_WINDOWEVENT_FOCUS_LOST,
  close = SDL_WINDOWEVENT_CLOSE,
  take_focus = SDL_WINDOWEVENT_TAKE_FOCUS,
  hit_test = SDL_WINDOWEVENT_HIT_TEST
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied window event ID.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(window_event_id::enter) == "enter"`.
 *
 * \param id the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const window_event_id id) -> std::string_view
{
  switch (id) {
    case window_event_id::none:
      return "none";

    case window_event_id::shown:
      return "shown";

    case window_event_id::hidden:
      return "hidden";

    case window_event_id::exposed:
      return "exposed";

    case window_event_id::moved:
      return "moved";

    case window_event_id::resized:
      return "resized";

    case window_event_id::size_changed:
      return "size_changed";

    case window_event_id::minimized:
      return "minimized";

    case window_event_id::maximized:
      return "maximized";

    case window_event_id::restored:
      return "restored";

    case window_event_id::enter:
      return "enter";

    case window_event_id::leave:
      return "leave";

    case window_event_id::focus_gained:
      return "focus_gained";

    case window_event_id::focus_lost:
      return "focus_lost";

    case window_event_id::close:
      return "close";

    case window_event_id::take_focus:
      return "take_focus";

    case window_event_id::hit_test:
      return "hit_test";

    default:
      throw cen_error{"Did not recognize window event ID!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a window event ID enumerator.
 *
 * \param stream the output stream that will be used.
 * \param id the enumerator that will be printed.
 *
 * \see `to_string(window_event_id)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const window_event_id id) -> std::ostream&
{
  return stream << to_string(id);
}

/// \} End of streaming

/// \name Window event ID comparison operators
/// \{

/**
 * \brief Indicates whether or not two window event ID values are the same.
 *
 * \param lhs the left-hand side window event ID value.
 * \param rhs the right-hand side window event ID value.
 *
 * \return `true` if the window event ID values are the same; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator==(const window_event_id lhs,
                                        const SDL_WindowEventID rhs) noexcept -> bool
{
  return static_cast<SDL_WindowEventID>(lhs) == rhs;
}

/// \copydoc operator==(window_event_id, SDL_WindowEventID)
[[nodiscard]] constexpr auto operator==(const SDL_WindowEventID lhs,
                                        const window_event_id rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two window event ID values aren't the same.
 *
 * \param lhs the left-hand side window event ID value.
 * \param rhs the right-hand side window event ID value.
 *
 * \return `true` if the window event ID values aren't the same; `false`
 * otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator!=(const window_event_id lhs,
                                        const SDL_WindowEventID rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(window_event_id, SDL_WindowEventID)
[[nodiscard]] constexpr auto operator!=(const SDL_WindowEventID lhs,
                                        const window_event_id rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of window event ID comparison operators

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_WINDOW_EVENT_ID_HEADER


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class window_event
 *
 * \brief Represents an event that is associated with an action related to a
 * window.
 *
 * \see `SDL_WindowEvent`
 *
 * \since 4.0.0
 */
class window_event final : public common_event<SDL_WindowEvent>
{
 public:
  /**
   * \brief Creates a window event.
   *
   * \since 4.0.0
   */
  window_event() noexcept : common_event{event_type::window}
  {}

  /**
   * \brief Creates a window event based on the supplied SDL window event.
   *
   * \param event the SDL window event that will be copied.
   *
   * \since 4.0.0
   */
  explicit window_event(const SDL_WindowEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Returns the event ID of this window event.
   *
   * \details There are many different kinds of window events, use this function to check
   * what kind of action that triggered this event.
   *
   * \return the event ID of this window event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto event_id() const noexcept -> window_event_id
  {
    return static_cast<window_event_id>(m_event.event);
  }

  /**
   * \brief Returns the value of the first data value.
   *
   * \details The meaning of this value is dependent on the window event ID of this window
   * event.
   *
   * For instance, if the event ID is `window_event_id::size_changed`, then data1 and
   * data2 represent the new width and height of the window respectively. See the
   * `window_event_id` documentation for more details about whether the value returned
   * from this function is meaningful in regard to the window event ID.
   *
   * \return the value of the first data value.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto data_1() const noexcept -> i32
  {
    return m_event.data1;
  }

  /**
   * \brief Returns the value of the second data value.
   *
   * \details The meaning of this value is dependent on the window event ID of this window
   * event.
   *
   * For instance, if the event ID is `window_event_id::size_changed`, then data1 and
   * data2 represent the new width and height of the window respectively. See the
   * `window_event_id` documentation for more details about whether the value returned
   * from this function is meaningful in regard to the window event ID.
   *
   * \return the value of the second data value.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto data_2() const noexcept -> i32
  {
    return m_event.data2;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_WindowEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.window = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_WINDOW_EVENT_HEADER


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class event
 *
 * \brief Serves as the main interface for dealing with events.
 *
 * \see `SDL_Event`
 *
 * \since 4.0.0
 */
class event final
{
 public:
  /**
   * \brief Creates an empty event.
   *
   * \since 4.0.0
   */
  event() noexcept = default;

  /**
   * \brief Creates an event based on the supplied event.
   *
   * \param event the event that will be copied.
   *
   * \since 4.0.0
   */
  explicit event(const SDL_Event& event) noexcept : m_event{event}
  {
    update_data(static_cast<event_type>(event.type));
  }

  template <typename T>
  explicit event(const common_event<T>& event) noexcept : m_event{as_sdl_event(event)}
  {
    update_data(event.type());
  }

  /**
   * \brief Updates the event loop, gathering events from the input devices.
   *
   * \note You might not have to call this function by yourself.
   *
   * \see `SDL_PumpEvents`
   *
   * \since 3.1.0
   */
  static void update() noexcept
  {
    SDL_PumpEvents();
  }

  /**
   * \brief Pushes an event onto the event queue.
   *
   * \param event the event that will be added to the event queue.
   *
   * \since 3.1.0
   */
  static void push(event& event) noexcept
  {
    auto& sdlEvent = event.m_event;
    SDL_PushEvent(&sdlEvent);
  }

  /**
   * \brief Pushes an event onto the event queue.
   *
   * \tparam T the SDL event type.
   *
   * \param event the event that will be pushed onto the event queue.
   *
   * \return `success` if the event was successfully added; `failure` otherwise.
   *
   * \since 5.1.0
   */
  template <typename T>
  static auto push(const common_event<T>& event) noexcept -> result
  {
    auto sdlEvent = as_sdl_event(event);
    return SDL_PushEvent(&sdlEvent) >= 0;
  }

  /**
   * \brief Flushes all current events from the event queue.
   *
   * \see `SDL_FlushEvents`
   *
   * \since 3.1.0
   */
  static void flush() noexcept
  {
    SDL_FlushEvents(SDL_FIRSTEVENT, SDL_LASTEVENT);
  }

  /**
   * Flushes all of the current events from the event queue, including pending
   * events.
   *
   * \since 3.1.0
   */
  static void flush_all() noexcept
  {
    SDL_PumpEvents();
    SDL_FlushEvents(SDL_FIRSTEVENT, SDL_LASTEVENT);
  }

  /**
   * \brief Polls the next available event, if there is one.
   *
   * \details This is meant to be called inside a while-loop.
   *
   * \return `true` if there are any pending events; `false` otherwise.
   *
   * \since 3.1.0
   */
  auto poll() noexcept -> bool
  {
    const bool result = SDL_PollEvent(&m_event);

    if (result) {
      update_data(static_cast<event_type>(m_event.type));
    }
    else {
      m_data.emplace<std::monostate>();
    }

    return result;
  }

  /**
   * \brief Returns the type of the event.
   *
   * \return the type of the event; `std::nullopt` if there is no internal
   * event.
   *
   * \since 3.1.0
   */
  [[nodiscard]] auto type() const noexcept -> std::optional<event_type>
  {
    if (is_empty()) {
      return std::nullopt;
    }
    else {
      return static_cast<event_type>(m_event.type);
    }
  }

  /**
   * \brief Returns the current amount of events in the event queue.
   *
   * \return the current number of events in the event queue; `std::nullopt`
   * if something goes wrong.
   *
   * \since 5.3.0
   */
  [[nodiscard]] static auto queue_count() noexcept -> std::optional<int>
  {
    const auto num = SDL_PeepEvents(nullptr, 0, SDL_PEEKEVENT, SDL_FIRSTEVENT, SDL_LASTEVENT);
    if (num != -1) {
      return num;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the number of events of a particular type that are in the
   * event queue.
   *
   * \param type the type of event to count.
   *
   * \return the current number of events of the specified type that are in
   * the event queue; `std::nullopt` if something goes wrong.
   *
   * \since 5.3.0
   */
  [[nodiscard]] static auto queue_count(const event_type type) noexcept -> std::optional<int>
  {
    const auto id = to_underlying(type);
    const auto num = SDL_PeepEvents(nullptr, 0, SDL_PEEKEVENT, id, id);
    if (num != -1) {
      return num;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Indicates whether or not any events of the specified type is in the
   * event queue.
   *
   * \param type the event type to look for in the event queue.
   *
   * \return `true` if there are events of the specified type in the event
   * queue; `false` otherwise.
   *
   * \since 5.3.0
   */
  [[nodiscard]] static auto in_queue(const event_type type) noexcept -> bool
  {
    return queue_count(type) > 0;
  }

  /**
   * \brief Indicates whether or not the event is of a particular type.
   *
   * \details This function is useful for checking the event type before
   * calling `get<T>`, to avoid exceptions being thrown.
   *
   * \tparam T the event type that will be checked, e.g. `window_event`.
   *
   * \return `true` if the event is of the specified type; `false` otherwise.
   *
   * \see `get`
   * \see `try_get`
   *
   * \since 5.0.0
   */
  template <typename T>
  [[nodiscard]] auto is() const noexcept -> bool
  {
    return std::holds_alternative<T>(m_data);
  }

  /**
   * \brief Attempts to return the internal event instance.
   *
   * \details If you're certain about the internal type, then you could use this
   * function to simply extract the internal event.
   *
   * \note This functions throws if the internal event isn't of the specified
   * type! You might want to make sure that the internal type is `T` with the
   * `is()` function before calling this function, or use `try_get()`.
   *
   * \tparam T the event type to obtain.
   *
   * \return a reference to the internal event type.
   *
   * \throws bad_variant_access if the internal event type isn't `T`.
   *
   * \see `is`
   * \see `try_get`
   *
   * \since 5.0.0
   */
  template <typename T>
  [[nodiscard]] auto get() -> T&
  {
    return std::get<T>(m_data);
  }

  /**
   * \copydoc get()
   */
  template <typename T>
  [[nodiscard]] auto get() const -> const T&
  {
    return std::get<T>(m_data);
  }

  /**
   * \brief Attempts to return the internal event instance.
   *
   * \details This function returns a null pointer if the internal event
   * doesn't match the specified type.
   *
   * \tparam T the event type to obtain.
   *
   * \return a pointer to the internal event type, might be null.
   *
   * \see `is`
   * \see `get`
   *
   * \since 5.0.0
   */
  template <typename T>
  [[nodiscard]] auto try_get() noexcept -> T*
  {
    return std::get_if<T>(&m_data);
  }

  /**
   * \copybrief try_get
   *
   * \details This function returns a null pointer if the internal event
   * doesn't match the specified type.
   *
   * \tparam T the event type to obtain.
   *
   * \return a pointer to the internal event type, might be null.
   *
   * \see `is`
   * \see `get`
   *
   * \since 5.0.0
   */
  template <typename T>
  [[nodiscard]] auto try_get() const noexcept -> const T*
  {
    return std::get_if<T>(&m_data);
  }

  /**
   * \brief Returns a pointer to the internal event representation.
   *
   * \return a pointer to the internal event instance.
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto data() const noexcept -> const SDL_Event*
  {
    return &m_event;
  }

  /**
   * \brief Indicates whether or not there is an internal event stored in the
   * instance.
   *
   * \return `true` if there is no internal event; `false` otherwise.
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto is_empty() const noexcept -> bool
  {
    return is<std::monostate>();
  }

 private:
  /* Behold, the beast! */
  using data_type = std::variant<std::monostate,
                                 audio_device_event,
                                 controller_axis_event,
                                 controller_button_event,
                                 controller_device_event,
                                 dollar_gesture_event,
                                 drop_event,
                                 joy_axis_event,
                                 joy_ball_event,
                                 joy_button_event,
                                 joy_device_event,
                                 joy_hat_event,
                                 keyboard_event,
                                 mouse_button_event,
                                 mouse_motion_event,
                                 mouse_wheel_event,
                                 multi_gesture_event,
                                 quit_event,
                                 text_editing_event,
                                 text_input_event,
                                 touch_finger_event,
                                 sensor_event,
                                 user_event,

#if SDL_VERSION_ATLEAST(2, 0, 14)
                                 display_event,
                                 controller_touchpad_event,
                                 controller_sensor_event,
#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

                                 window_event>;

  SDL_Event m_event{};
  data_type m_data{};

  void update_data(const event_type type) noexcept
  {
    switch (type) {
      case event_type::quit:
        m_data.emplace<quit_event>(m_event.quit);
        break;

      case event_type::app_terminating:
      case event_type::app_low_memory:
      case event_type::app_will_enter_background:
      case event_type::app_did_enter_background:
      case event_type::app_will_enter_foreground:
      case event_type::app_did_enter_foreground:
        break;

#if SDL_VERSION_ATLEAST(2, 0, 14)
      case event_type::locale_changed:
        break;

      case event_type::display:
        m_data.emplace<display_event>(m_event.display);
        break;
#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

      case event_type::window:
        m_data.emplace<window_event>(m_event.window);
        break;

      case event_type::system:
        break;

      case event_type::key_down:
      case event_type::key_up:
        m_data.emplace<keyboard_event>(m_event.key);
        break;

      case event_type::text_editing:
        m_data.emplace<text_editing_event>(m_event.edit);
        break;

      case event_type::text_input:
        m_data.emplace<text_input_event>(m_event.text);
        break;

      case event_type::keymap_changed:
        break;

      case event_type::mouse_motion:
        m_data.emplace<mouse_motion_event>(m_event.motion);
        break;

      case event_type::mouse_button_down:
      case event_type::mouse_button_up:
        m_data.emplace<mouse_button_event>(m_event.button);
        break;

      case event_type::mouse_wheel:
        m_data.emplace<mouse_wheel_event>(m_event.wheel);
        break;

      case event_type::joystick_axis_motion:
        m_data.emplace<joy_axis_event>(m_event.jaxis);
        break;

      case event_type::joystick_ball_motion:
        m_data.emplace<joy_ball_event>(m_event.jball);
        break;

      case event_type::joystick_hat_motion:
        m_data.emplace<joy_hat_event>(m_event.jhat);
        break;

      case event_type::joystick_button_down:
      case event_type::joystick_button_up:
        m_data.emplace<joy_button_event>(m_event.jbutton);
        break;

      case event_type::joystick_device_added:
      case event_type::joystick_device_removed:
        m_data.emplace<joy_device_event>(m_event.jdevice);
        break;

      case event_type::controller_axis_motion:
        m_data.emplace<controller_axis_event>(m_event.caxis);
        break;

      case event_type::controller_button_down:
      case event_type::controller_button_up:
        m_data.emplace<controller_button_event>(m_event.cbutton);
        break;

      case event_type::controller_device_added:
      case event_type::controller_device_removed:
      case event_type::controller_device_remapped:
        m_data.emplace<controller_device_event>(m_event.cdevice);
        break;

#if SDL_VERSION_ATLEAST(2, 0, 14)
      case event_type::controller_touchpad_down:
      case event_type::controller_touchpad_up:
      case event_type::controller_touchpad_motion:
        m_data.emplace<controller_touchpad_event>(m_event.ctouchpad);
        break;

      case event_type::controller_sensor_update:
        m_data.emplace<controller_sensor_event>(m_event.csensor);
        break;
#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

      case event_type::touch_down:
      case event_type::touch_up:
      case event_type::touch_motion:
        m_data.emplace<touch_finger_event>(m_event.tfinger);
        break;

      case event_type::dollar_gesture:
      case event_type::dollar_record:
        m_data.emplace<dollar_gesture_event>(m_event.dgesture);
        break;

      case event_type::multi_gesture:
        m_data.emplace<multi_gesture_event>(m_event.mgesture);
        break;

      case event_type::clipboard_update:
        break;

      case event_type::drop_file:
      case event_type::drop_text:
      case event_type::drop_begin:
      case event_type::drop_complete:
        m_data.emplace<drop_event>(m_event.drop);
        break;

      case event_type::audio_device_added:
      case event_type::audio_device_removed:
        m_data.emplace<audio_device_event>(m_event.adevice);
        break;

      case event_type::sensor_update:
        m_data.emplace<sensor_event>(m_event.sensor);
        break;

      case event_type::render_targets_reset:
      case event_type::render_device_reset:
        break;

      case event_type::user:
        m_data.emplace<user_event>(m_event.user);
        break;

      default:
        m_data.emplace<std::monostate>();
        break;
    }
  }
};

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_EVENT_HEADER
// #include "centurion/events/event_dispatcher.hpp"
#ifndef CENTURION_EVENT_DISPATCHER_HEADER
#define CENTURION_EVENT_DISPATCHER_HEADER

#include <array>        // array
#include <functional>   // function, bind
#include <ostream>      // ostream
#include <string>       // string, to_string
#include <tuple>        // tuple
#include <type_traits>  // is_same_v, is_invocable_v, is_reference_v, ...

// #include "../core/integers.hpp"

// #include "../detail/tuple_type_index.hpp"
#ifndef CENTURION_DETAIL_TUPLE_TYPE_INDEX_HEADER
#define CENTURION_DETAIL_TUPLE_TYPE_INDEX_HEADER

#include <tuple>        // tuple
#include <type_traits>  // is_same_v
#include <utility>      // index_sequence, index_sequence_for

// #include "../core/integers.hpp"


/// \cond FALSE
namespace cen::detail {

template <typename Target, typename Tuple>
class tuple_type_index;

template <typename Target, typename... T>
class tuple_type_index<Target, std::tuple<T...>>
{
  template <usize... Index>
  constexpr static auto find(std::index_sequence<Index...>) -> int
  {
    return -1 + ((std::is_same_v<Target, T> ? Index + 1 : 0) + ...);
  }

 public:
  inline constexpr static auto value = find(std::index_sequence_for<T...>{});
};

template <typename Target, typename... T>
inline constexpr int tuple_type_index_v = tuple_type_index<Target, T...>::value;

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_TUPLE_TYPE_INDEX_HEADER

// #include "event.hpp"
#ifndef CENTURION_EVENT_HEADER
#define CENTURION_EVENT_HEADER

#include <SDL.h>

#include <optional>  // optional
#include <utility>   // move
#include <variant>   // variant, holds_alternative, monostate, get, get_if

// #include "../core/result.hpp"

// #include "../core/to_underlying.hpp"

// #include "audio_device_event.hpp"

// #include "common_event.hpp"

// #include "controller_axis_event.hpp"

// #include "controller_button_event.hpp"

// #include "controller_device_event.hpp"

// #include "controller_sensor_event.hpp"

// #include "controller_touchpad_event.hpp"

// #include "display_event.hpp"

// #include "dollar_gesture_event.hpp"

// #include "drop_event.hpp"

// #include "event_type.hpp"

// #include "joy_axis_event.hpp"

// #include "joy_ball_event.hpp"

// #include "joy_button_event.hpp"

// #include "joy_device_event.hpp"

// #include "joy_hat_event.hpp"

// #include "keyboard_event.hpp"

// #include "mouse_button_event.hpp"

// #include "mouse_motion_event.hpp"

// #include "mouse_wheel_event.hpp"

// #include "multi_gesture_event.hpp"

// #include "quit_event.hpp"

// #include "sensor_event.hpp"

// #include "text_editing_event.hpp"

// #include "text_input_event.hpp"

// #include "touch_finger_event.hpp"

// #include "user_event.hpp"

// #include "window_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class event
 *
 * \brief Serves as the main interface for dealing with events.
 *
 * \see `SDL_Event`
 *
 * \since 4.0.0
 */
class event final
{
 public:
  /**
   * \brief Creates an empty event.
   *
   * \since 4.0.0
   */
  event() noexcept = default;

  /**
   * \brief Creates an event based on the supplied event.
   *
   * \param event the event that will be copied.
   *
   * \since 4.0.0
   */
  explicit event(const SDL_Event& event) noexcept : m_event{event}
  {
    update_data(static_cast<event_type>(event.type));
  }

  template <typename T>
  explicit event(const common_event<T>& event) noexcept : m_event{as_sdl_event(event)}
  {
    update_data(event.type());
  }

  /**
   * \brief Updates the event loop, gathering events from the input devices.
   *
   * \note You might not have to call this function by yourself.
   *
   * \see `SDL_PumpEvents`
   *
   * \since 3.1.0
   */
  static void update() noexcept
  {
    SDL_PumpEvents();
  }

  /**
   * \brief Pushes an event onto the event queue.
   *
   * \param event the event that will be added to the event queue.
   *
   * \since 3.1.0
   */
  static void push(event& event) noexcept
  {
    auto& sdlEvent = event.m_event;
    SDL_PushEvent(&sdlEvent);
  }

  /**
   * \brief Pushes an event onto the event queue.
   *
   * \tparam T the SDL event type.
   *
   * \param event the event that will be pushed onto the event queue.
   *
   * \return `success` if the event was successfully added; `failure` otherwise.
   *
   * \since 5.1.0
   */
  template <typename T>
  static auto push(const common_event<T>& event) noexcept -> result
  {
    auto sdlEvent = as_sdl_event(event);
    return SDL_PushEvent(&sdlEvent) >= 0;
  }

  /**
   * \brief Flushes all current events from the event queue.
   *
   * \see `SDL_FlushEvents`
   *
   * \since 3.1.0
   */
  static void flush() noexcept
  {
    SDL_FlushEvents(SDL_FIRSTEVENT, SDL_LASTEVENT);
  }

  /**
   * Flushes all of the current events from the event queue, including pending
   * events.
   *
   * \since 3.1.0
   */
  static void flush_all() noexcept
  {
    SDL_PumpEvents();
    SDL_FlushEvents(SDL_FIRSTEVENT, SDL_LASTEVENT);
  }

  /**
   * \brief Polls the next available event, if there is one.
   *
   * \details This is meant to be called inside a while-loop.
   *
   * \return `true` if there are any pending events; `false` otherwise.
   *
   * \since 3.1.0
   */
  auto poll() noexcept -> bool
  {
    const bool result = SDL_PollEvent(&m_event);

    if (result) {
      update_data(static_cast<event_type>(m_event.type));
    }
    else {
      m_data.emplace<std::monostate>();
    }

    return result;
  }

  /**
   * \brief Returns the type of the event.
   *
   * \return the type of the event; `std::nullopt` if there is no internal
   * event.
   *
   * \since 3.1.0
   */
  [[nodiscard]] auto type() const noexcept -> std::optional<event_type>
  {
    if (is_empty()) {
      return std::nullopt;
    }
    else {
      return static_cast<event_type>(m_event.type);
    }
  }

  /**
   * \brief Returns the current amount of events in the event queue.
   *
   * \return the current number of events in the event queue; `std::nullopt`
   * if something goes wrong.
   *
   * \since 5.3.0
   */
  [[nodiscard]] static auto queue_count() noexcept -> std::optional<int>
  {
    const auto num = SDL_PeepEvents(nullptr, 0, SDL_PEEKEVENT, SDL_FIRSTEVENT, SDL_LASTEVENT);
    if (num != -1) {
      return num;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the number of events of a particular type that are in the
   * event queue.
   *
   * \param type the type of event to count.
   *
   * \return the current number of events of the specified type that are in
   * the event queue; `std::nullopt` if something goes wrong.
   *
   * \since 5.3.0
   */
  [[nodiscard]] static auto queue_count(const event_type type) noexcept -> std::optional<int>
  {
    const auto id = to_underlying(type);
    const auto num = SDL_PeepEvents(nullptr, 0, SDL_PEEKEVENT, id, id);
    if (num != -1) {
      return num;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Indicates whether or not any events of the specified type is in the
   * event queue.
   *
   * \param type the event type to look for in the event queue.
   *
   * \return `true` if there are events of the specified type in the event
   * queue; `false` otherwise.
   *
   * \since 5.3.0
   */
  [[nodiscard]] static auto in_queue(const event_type type) noexcept -> bool
  {
    return queue_count(type) > 0;
  }

  /**
   * \brief Indicates whether or not the event is of a particular type.
   *
   * \details This function is useful for checking the event type before
   * calling `get<T>`, to avoid exceptions being thrown.
   *
   * \tparam T the event type that will be checked, e.g. `window_event`.
   *
   * \return `true` if the event is of the specified type; `false` otherwise.
   *
   * \see `get`
   * \see `try_get`
   *
   * \since 5.0.0
   */
  template <typename T>
  [[nodiscard]] auto is() const noexcept -> bool
  {
    return std::holds_alternative<T>(m_data);
  }

  /**
   * \brief Attempts to return the internal event instance.
   *
   * \details If you're certain about the internal type, then you could use this
   * function to simply extract the internal event.
   *
   * \note This functions throws if the internal event isn't of the specified
   * type! You might want to make sure that the internal type is `T` with the
   * `is()` function before calling this function, or use `try_get()`.
   *
   * \tparam T the event type to obtain.
   *
   * \return a reference to the internal event type.
   *
   * \throws bad_variant_access if the internal event type isn't `T`.
   *
   * \see `is`
   * \see `try_get`
   *
   * \since 5.0.0
   */
  template <typename T>
  [[nodiscard]] auto get() -> T&
  {
    return std::get<T>(m_data);
  }

  /**
   * \copydoc get()
   */
  template <typename T>
  [[nodiscard]] auto get() const -> const T&
  {
    return std::get<T>(m_data);
  }

  /**
   * \brief Attempts to return the internal event instance.
   *
   * \details This function returns a null pointer if the internal event
   * doesn't match the specified type.
   *
   * \tparam T the event type to obtain.
   *
   * \return a pointer to the internal event type, might be null.
   *
   * \see `is`
   * \see `get`
   *
   * \since 5.0.0
   */
  template <typename T>
  [[nodiscard]] auto try_get() noexcept -> T*
  {
    return std::get_if<T>(&m_data);
  }

  /**
   * \copybrief try_get
   *
   * \details This function returns a null pointer if the internal event
   * doesn't match the specified type.
   *
   * \tparam T the event type to obtain.
   *
   * \return a pointer to the internal event type, might be null.
   *
   * \see `is`
   * \see `get`
   *
   * \since 5.0.0
   */
  template <typename T>
  [[nodiscard]] auto try_get() const noexcept -> const T*
  {
    return std::get_if<T>(&m_data);
  }

  /**
   * \brief Returns a pointer to the internal event representation.
   *
   * \return a pointer to the internal event instance.
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto data() const noexcept -> const SDL_Event*
  {
    return &m_event;
  }

  /**
   * \brief Indicates whether or not there is an internal event stored in the
   * instance.
   *
   * \return `true` if there is no internal event; `false` otherwise.
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto is_empty() const noexcept -> bool
  {
    return is<std::monostate>();
  }

 private:
  /* Behold, the beast! */
  using data_type = std::variant<std::monostate,
                                 audio_device_event,
                                 controller_axis_event,
                                 controller_button_event,
                                 controller_device_event,
                                 dollar_gesture_event,
                                 drop_event,
                                 joy_axis_event,
                                 joy_ball_event,
                                 joy_button_event,
                                 joy_device_event,
                                 joy_hat_event,
                                 keyboard_event,
                                 mouse_button_event,
                                 mouse_motion_event,
                                 mouse_wheel_event,
                                 multi_gesture_event,
                                 quit_event,
                                 text_editing_event,
                                 text_input_event,
                                 touch_finger_event,
                                 sensor_event,
                                 user_event,

#if SDL_VERSION_ATLEAST(2, 0, 14)
                                 display_event,
                                 controller_touchpad_event,
                                 controller_sensor_event,
#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

                                 window_event>;

  SDL_Event m_event{};
  data_type m_data{};

  void update_data(const event_type type) noexcept
  {
    switch (type) {
      case event_type::quit:
        m_data.emplace<quit_event>(m_event.quit);
        break;

      case event_type::app_terminating:
      case event_type::app_low_memory:
      case event_type::app_will_enter_background:
      case event_type::app_did_enter_background:
      case event_type::app_will_enter_foreground:
      case event_type::app_did_enter_foreground:
        break;

#if SDL_VERSION_ATLEAST(2, 0, 14)
      case event_type::locale_changed:
        break;

      case event_type::display:
        m_data.emplace<display_event>(m_event.display);
        break;
#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

      case event_type::window:
        m_data.emplace<window_event>(m_event.window);
        break;

      case event_type::system:
        break;

      case event_type::key_down:
      case event_type::key_up:
        m_data.emplace<keyboard_event>(m_event.key);
        break;

      case event_type::text_editing:
        m_data.emplace<text_editing_event>(m_event.edit);
        break;

      case event_type::text_input:
        m_data.emplace<text_input_event>(m_event.text);
        break;

      case event_type::keymap_changed:
        break;

      case event_type::mouse_motion:
        m_data.emplace<mouse_motion_event>(m_event.motion);
        break;

      case event_type::mouse_button_down:
      case event_type::mouse_button_up:
        m_data.emplace<mouse_button_event>(m_event.button);
        break;

      case event_type::mouse_wheel:
        m_data.emplace<mouse_wheel_event>(m_event.wheel);
        break;

      case event_type::joystick_axis_motion:
        m_data.emplace<joy_axis_event>(m_event.jaxis);
        break;

      case event_type::joystick_ball_motion:
        m_data.emplace<joy_ball_event>(m_event.jball);
        break;

      case event_type::joystick_hat_motion:
        m_data.emplace<joy_hat_event>(m_event.jhat);
        break;

      case event_type::joystick_button_down:
      case event_type::joystick_button_up:
        m_data.emplace<joy_button_event>(m_event.jbutton);
        break;

      case event_type::joystick_device_added:
      case event_type::joystick_device_removed:
        m_data.emplace<joy_device_event>(m_event.jdevice);
        break;

      case event_type::controller_axis_motion:
        m_data.emplace<controller_axis_event>(m_event.caxis);
        break;

      case event_type::controller_button_down:
      case event_type::controller_button_up:
        m_data.emplace<controller_button_event>(m_event.cbutton);
        break;

      case event_type::controller_device_added:
      case event_type::controller_device_removed:
      case event_type::controller_device_remapped:
        m_data.emplace<controller_device_event>(m_event.cdevice);
        break;

#if SDL_VERSION_ATLEAST(2, 0, 14)
      case event_type::controller_touchpad_down:
      case event_type::controller_touchpad_up:
      case event_type::controller_touchpad_motion:
        m_data.emplace<controller_touchpad_event>(m_event.ctouchpad);
        break;

      case event_type::controller_sensor_update:
        m_data.emplace<controller_sensor_event>(m_event.csensor);
        break;
#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

      case event_type::touch_down:
      case event_type::touch_up:
      case event_type::touch_motion:
        m_data.emplace<touch_finger_event>(m_event.tfinger);
        break;

      case event_type::dollar_gesture:
      case event_type::dollar_record:
        m_data.emplace<dollar_gesture_event>(m_event.dgesture);
        break;

      case event_type::multi_gesture:
        m_data.emplace<multi_gesture_event>(m_event.mgesture);
        break;

      case event_type::clipboard_update:
        break;

      case event_type::drop_file:
      case event_type::drop_text:
      case event_type::drop_begin:
      case event_type::drop_complete:
        m_data.emplace<drop_event>(m_event.drop);
        break;

      case event_type::audio_device_added:
      case event_type::audio_device_removed:
        m_data.emplace<audio_device_event>(m_event.adevice);
        break;

      case event_type::sensor_update:
        m_data.emplace<sensor_event>(m_event.sensor);
        break;

      case event_type::render_targets_reset:
      case event_type::render_device_reset:
        break;

      case event_type::user:
        m_data.emplace<user_event>(m_event.user);
        break;

      default:
        m_data.emplace<std::monostate>();
        break;
    }
  }
};

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_EVENT_HEADER

namespace cen {

/// \addtogroup event
/// \{

/**
 * \brief Manages a subscription to an event.
 *
 * \note This class is used by `event_dispatcher` and isn't really meant to be
 * used by itself.
 *
 * \tparam E the event type, e.g. `window_event`.
 *
 * \see `event_dispatcher`
 *
 * \since 5.1.0
 */
template <typename E>
class event_sink final
{
 public:
  using event_type = std::decay_t<E>;              ///< Associated event type.
  using signature_type = void(const event_type&);  ///< Signature of handler.
  using function_type = std::function<signature_type>;

  /**
   * \brief Resets the event sink, removing any associated handler.
   *
   * \since 5.1.0
   */
  void reset() noexcept
  {
    m_function = nullptr;
  }

  /**
   * \brief Connects to a function object.
   *
   * \note This function will overwrite any previously set handler.
   *
   * \tparam T the type of the function object.
   *
   * \param callable the callable that will be invoked when an event is
   * received.
   *
   * \since 5.1.0
   */
  template <typename T>
  void to(T&& callable)
  {
    static_assert(std::is_invocable_v<T, const event_type&>,
                  "Callable must be invocable with subscribed event!");

    m_function = function_type{callable};
  }

  /**
   * \brief Connects to a member function.
   *
   * \note The event sink does *not* take ownership of the supplied pointer.
   *
   * \note This function will overwrite any previously set handler.
   *
   * \tparam memberFunction a pointer to a member function.
   * \tparam Self the type of the object that owns the function.
   *
   * \param self a pointer to the object that will handle the event.
   *
   * \since 5.1.0
   */
  template <auto memberFunc, typename Self>
  void to(Self* self)
  {
    static_assert(std::is_member_function_pointer_v<decltype(memberFunc)>,
                  "\"memberFunc\" must be member function pointer!");
    static_assert(std::is_invocable_v<decltype(memberFunc), Self*, const event_type&>,
                  "Member function must be invocable with subscribed event!");

    to(std::bind(memberFunc, self, std::placeholders::_1));
  }

  /**
   * \brief Connects to a free function.
   *
   * \note This function will overwrite any previously set handler.
   *
   * \tparam function a function pointer.
   *
   * \since 5.1.0
   */
  template <auto function>
  void to()
  {
    to(function);
  }

  /**
   * \brief Returns the function associated with the sink.
   *
   * \return the function associated with the sink, might be invalid.
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto function() -> function_type&
  {
    return m_function;
  }

  [[nodiscard]] auto function() const -> const function_type&
  {
    return m_function;
  }

 private:
  function_type m_function;
};

/**
 * \brief An event dispatcher wrapper around a `cen::event` instance.
 *
 * \details This class is an attempt to simplify handling events in
 * applications, usually you'd check for all of the events that you'd be
 * interested in using `cen::event::try_get()` in a long `if-else if` statement.
 * By using this class, it's possible to automatically generate equivalent
 * checks by specifying the events that you want to subscribe to, and
 * subsequently connect lambdas, free functions or member functions to handle
 * the subscribed events. This can often lead to cleaner looking code, since the
 * manual checks will be replaced by a single call to
 * `event_dispatcher::poll()`.
 *
 * \details The runtime overhead of using this class compared to typical manual
 * event dispatching is minimal. However, the function objects for the
 * subscribed events are stored internally, so they can take up a bit of space.
 * It might be beneficial to allocate instances of this class on the heap,
 * depending on the amount of subscribed events.
 *
 * \details The signature of all event handlers should be `void(const Event&)`,
 * where `Event` is the subscribed event type.
 *
 * \note It is advisable to always typedef the signature of this class with
 * the events that you want to handle, since the class name quickly grows in
 * size.
 *
 * \tparam E the list of events to "subscribe" to. Events that are not present
 * in this list are ignored.
 *
 * \since 5.1.0
 *
 * \see `cen::event`
 */
template <typename... E>
class event_dispatcher final
{
  static_assert((!std::is_const_v<E> && ...), "Can't use \"const\" on template parameter!");

  static_assert((!std::is_volatile_v<E> && ...),
                "Can't use \"volatile\" on template parameter!");

  static_assert((!std::is_reference_v<E> && ...),
                "Reference types can't be used as template parameters!");

  static_assert((!std::is_pointer_v<E> && ...),
                "Pointer types can't be used as template parameters!");

  /**
   * \brief Returns the index of an event type in the function tuple.
   *
   * \tparam Event the event type.
   *
   * \return the index of the event type.
   *
   * \since 5.1.0
   */
  template <typename Event>
  [[nodiscard]] constexpr static auto index_of()
  {
    using sink_t = event_sink<std::decay_t<Event>>;

    constexpr auto index = detail::tuple_type_index_v<sink_t, sink_tuple>;
    static_assert(index != -1);

    return index;
  }

  template <typename Event>
  [[nodiscard]] auto get_sink() -> event_sink<Event>&
  {
    constexpr auto index = index_of<Event>();
    return std::get<index>(m_sinks);
  }

  template <typename Event>
  [[nodiscard]] auto get_sink() const -> const event_sink<Event>&
  {
    constexpr auto index = index_of<Event>();
    return std::get<index>(m_sinks);
  }

  /**
   * \brief Checks for the specified event type in the event handler.
   *
   * \tparam Event the event to look for.
   *
   * \return `true` if there was a match; `false` otherwise.
   *
   * \since 5.1.0
   */
  template <typename Event>
  auto check_for() -> bool
  {
    if (const auto* event = m_event.template try_get<Event>()) {
      if (auto& function = get_sink<Event>().function()) {
        function(*event);
      }

      return true;
    }
    else {
      return false;
    }
  }

 public:
  using size_type = usize;

  /**
   * \brief Polls all events, checking for subscribed events.
   *
   * \details This function corresponds to the usual inner event `while`-loop
   * used to manage events. You should call this function once for every
   * iteration in your game loop.
   *
   * \since 5.1.0
   */
  void poll()
  {
    while (m_event.poll()) {
      (check_for<E>() || ...);
    }
  }

  /**
   * \brief Returns the event sink associated with the specified event.
   *
   * \tparam Event the subscribed event to obtain the event sink for. This
   * function will not accept an event type that isn't one of the subscribed
   * events (i.e. on of the class template arguments).
   *
   * \return the associated event sink.
   *
   * \since 5.1.0
   */
  template <typename Event>
  auto bind() -> event_sink<Event>&
  {
    static_assert((std::is_same_v<std::decay_t<Event>, E> || ...),
                  "Can't connect unsubscribed event! Make sure that the "
                  "event is listed as a class template parameter.");
    return get_sink<Event>();
  }

  /**
   * \brief Removes all set handlers from all of the subscribed events.
   *
   * \since 5.1.0
   */
  void reset() noexcept
  {
    (bind<E>().reset(), ...);
  }

  /**
   * \brief Returns the amount of set event handlers.
   *
   * \return the amount of set event handlers.
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto active_count() const -> size_type
  {
    return (0u + ... + (get_sink<E>().function() ? 1u : 0u));
  }

  /**
   * \brief Returns the number of subscribed events.
   *
   * \note The returned value is the same as the number of template parameters
   * to the class.
   *
   * \return the amount of subscribed events.
   *
   * \since 5.1.0
   */
  [[nodiscard]] constexpr static auto size() noexcept -> size_type
  {
    return sizeof...(E);
  }

 private:
  using sink_tuple = std::tuple<event_sink<E>...>;

  cen::event m_event;
  sink_tuple m_sinks;
};

/// \name String conversions
/// \{

template <typename... E>
[[nodiscard]] inline auto to_string(const event_dispatcher<E...>& dispatcher) -> std::string
{
  return "event_dispatcher{size: " + std::to_string(dispatcher.size()) +
         ", #active: " + std::to_string(dispatcher.active_count()) + "}";
}

/// \} End of string conversions

/// \name Streaming
/// \{

template <typename... E>
inline auto operator<<(std::ostream& stream, const event_dispatcher<E...>& dispatcher)
    -> std::ostream&
{
  stream << to_string(dispatcher);
  return stream;
}

/// \} End of streaming

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_EVENT_DISPATCHER_HEADER
// #include "centurion/events/event_type.hpp"
#ifndef CENTURION_EVENT_TYPE_HEADER
#define CENTURION_EVENT_TYPE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \enum event_type
 *
 * \brief Represents the different event types.
 *
 * \see `SDL_EventType`
 *
 * \since 3.1.0
 */
enum class event_type : u32
{
  quit = SDL_QUIT,

  app_terminating = SDL_APP_TERMINATING,
  app_low_memory = SDL_APP_LOWMEMORY,
  app_will_enter_background = SDL_APP_WILLENTERBACKGROUND,
  app_did_enter_background = SDL_APP_DIDENTERBACKGROUND,
  app_will_enter_foreground = SDL_APP_WILLENTERFOREGROUND,
  app_did_enter_foreground = SDL_APP_DIDENTERFOREGROUND,

#if SDL_VERSION_ATLEAST(2, 0, 14)
  locale_changed = SDL_LOCALECHANGED,
#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  display = SDL_DISPLAYEVENT,

  window = SDL_WINDOWEVENT,
  system = SDL_SYSWMEVENT,

  key_down = SDL_KEYDOWN,
  key_up = SDL_KEYUP,
  text_editing = SDL_TEXTEDITING,
  text_input = SDL_TEXTINPUT,
  keymap_changed = SDL_KEYMAPCHANGED,

  mouse_motion = SDL_MOUSEMOTION,
  mouse_button_down = SDL_MOUSEBUTTONDOWN,
  mouse_button_up = SDL_MOUSEBUTTONUP,
  mouse_wheel = SDL_MOUSEWHEEL,

  joystick_axis_motion = SDL_JOYAXISMOTION,
  joystick_ball_motion = SDL_JOYBALLMOTION,
  joystick_hat_motion = SDL_JOYHATMOTION,
  joystick_button_down = SDL_JOYBUTTONDOWN,
  joystick_button_up = SDL_JOYBUTTONUP,
  joystick_device_added = SDL_JOYDEVICEADDED,
  joystick_device_removed = SDL_JOYDEVICEREMOVED,

  controller_axis_motion = SDL_CONTROLLERAXISMOTION,
  controller_button_down = SDL_CONTROLLERBUTTONDOWN,
  controller_button_up = SDL_CONTROLLERBUTTONUP,
  controller_device_added = SDL_CONTROLLERDEVICEADDED,
  controller_device_removed = SDL_CONTROLLERDEVICEREMOVED,
  controller_device_remapped = SDL_CONTROLLERDEVICEREMAPPED,

#if SDL_VERSION_ATLEAST(2, 0, 14)
  controller_touchpad_down = SDL_CONTROLLERTOUCHPADDOWN,
  controller_touchpad_up = SDL_CONTROLLERTOUCHPADUP,
  controller_touchpad_motion = SDL_CONTROLLERTOUCHPADMOTION,
  controller_sensor_update = SDL_CONTROLLERSENSORUPDATE,
#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  touch_down = SDL_FINGERDOWN,
  touch_up = SDL_FINGERUP,
  touch_motion = SDL_FINGERMOTION,

  dollar_gesture = SDL_DOLLARGESTURE,
  dollar_record = SDL_DOLLARRECORD,
  multi_gesture = SDL_MULTIGESTURE,

  clipboard_update = SDL_CLIPBOARDUPDATE,

  drop_file = SDL_DROPFILE,
  drop_text = SDL_DROPTEXT,
  drop_begin = SDL_DROPBEGIN,
  drop_complete = SDL_DROPCOMPLETE,

  audio_device_added = SDL_AUDIODEVICEADDED,
  audio_device_removed = SDL_AUDIODEVICEREMOVED,

  sensor_update = SDL_SENSORUPDATE,

  render_targets_reset = SDL_RENDER_TARGETS_RESET,
  render_device_reset = SDL_RENDER_DEVICE_RESET,

  user = SDL_USEREVENT
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied event type.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(event_type::mouse_motion) == "mouse_motion"`.
 *
 * \param type the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const event_type type) -> std::string_view
{
  switch (type) {
    case event_type::quit:
      return "quit";

    case event_type::app_terminating:
      return "app_terminating";

    case event_type::app_low_memory:
      return "app_low_memory";

    case event_type::app_will_enter_background:
      return "app_will_enter_background";

    case event_type::app_did_enter_background:
      return "app_did_enter_background";

    case event_type::app_will_enter_foreground:
      return "app_will_enter_foreground";

    case event_type::app_did_enter_foreground:
      return "app_did_enter_foreground";

#if SDL_VERSION_ATLEAST(2, 0, 14)
    case event_type::locale_changed:
      return "locale_changed";
#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

    case event_type::display:
      return "display";

    case event_type::window:
      return "window";

    case event_type::system:
      return "system";

    case event_type::key_down:
      return "key_down";

    case event_type::key_up:
      return "key_up";

    case event_type::text_editing:
      return "text_editing";

    case event_type::text_input:
      return "text_input";

    case event_type::keymap_changed:
      return "keymap_changed";

    case event_type::mouse_motion:
      return "mouse_motion";

    case event_type::mouse_button_down:
      return "mouse_button_down";

    case event_type::mouse_button_up:
      return "mouse_button_up";

    case event_type::mouse_wheel:
      return "mouse_wheel";

    case event_type::joystick_axis_motion:
      return "joystick_axis_motion";

    case event_type::joystick_ball_motion:
      return "joystick_ball_motion";

    case event_type::joystick_hat_motion:
      return "joystick_hat_motion";

    case event_type::joystick_button_down:
      return "joystick_button_down";

    case event_type::joystick_button_up:
      return "joystick_button_up";

    case event_type::joystick_device_added:
      return "joystick_device_added";

    case event_type::joystick_device_removed:
      return "joystick_device_removed";

    case event_type::controller_axis_motion:
      return "controller_axis_motion";

    case event_type::controller_button_down:
      return "controller_button_down";

    case event_type::controller_button_up:
      return "controller_button_up";

    case event_type::controller_device_added:
      return "controller_device_added";

    case event_type::controller_device_removed:
      return "controller_device_removed";

    case event_type::controller_device_remapped:
      return "controller_device_remapped";

#if SDL_VERSION_ATLEAST(2, 0, 14)
    case event_type::controller_touchpad_down:
      return "controller_touchpad_down";

    case event_type::controller_touchpad_up:
      return "controller_touchpad_up";

    case event_type::controller_touchpad_motion:
      return "controller_touchpad_motion";

    case event_type::controller_sensor_update:
      return "controller_sensor_update";
#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

    case event_type::touch_down:
      return "touch_down";

    case event_type::touch_up:
      return "touch_up";

    case event_type::touch_motion:
      return "touch_motion";

    case event_type::dollar_gesture:
      return "dollar_gesture";

    case event_type::dollar_record:
      return "dollar_record";

    case event_type::multi_gesture:
      return "multi_gesture";

    case event_type::clipboard_update:
      return "clipboard_update";

    case event_type::drop_file:
      return "drop_file";

    case event_type::drop_text:
      return "drop_text";

    case event_type::drop_begin:
      return "drop_begin";

    case event_type::drop_complete:
      return "drop_complete";

    case event_type::audio_device_added:
      return "audio_device_added";

    case event_type::audio_device_removed:
      return "audio_device_removed";

    case event_type::sensor_update:
      return "sensor_update";

    case event_type::render_targets_reset:
      return "render_targets_reset";

    case event_type::render_device_reset:
      return "render_device_reset";

    case event_type::user:
      return "user";

    default:
      throw cen_error{"Did not recognize event type!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of an event type enumerator.
 *
 * \param stream the output stream that will be used.
 * \param type the enumerator that will be printed.
 *
 * \see `to_string(event_type)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const event_type type) -> std::ostream&
{
  return stream << to_string(type);
}

/// \} End of streaming

/// \name Event type comparison operators
/// \{

/**
 * \brief Indicates whether or not two event type values are the same.
 *
 * \param lhs the left-hand side event type value
 * \param rhs the right-hand side event type value
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 3.1.0
 */
[[nodiscard]] constexpr auto operator==(const event_type lhs, const SDL_EventType rhs) noexcept
    -> bool
{
  return static_cast<SDL_EventType>(lhs) == rhs;
}

/// \copydoc operator==(const event_type, const SDL_EventType)
[[nodiscard]] constexpr auto operator==(const SDL_EventType lhs, const event_type rhs) noexcept
    -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two event type values aren't the same.
 *
 * \param lhs the left-hand side event type value
 * \param rhs the right-hand side event type value
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 3.1.0
 */
[[nodiscard]] constexpr auto operator!=(const event_type lhs, const SDL_EventType rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const event_type, const SDL_EventType)
[[nodiscard]] constexpr auto operator!=(const SDL_EventType lhs, const event_type rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \} End of event type comparison operators

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_EVENT_TYPE_HEADER
// #include "centurion/events/joy_axis_event.hpp"
#ifndef CENTURION_JOY_AXIS_EVENT_HEADER
#define CENTURION_JOY_AXIS_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class joy_axis_event
 *
 * \brief Represents an event that occurs whenever a user moves an axis on a
 * joystick.
 *
 * \see `SDL_JoyAxisEvent`
 *
 * \since 4.0.0
 */
class joy_axis_event final : public common_event<SDL_JoyAxisEvent>
{
 public:
  /**
   * \brief Creates a joy axis event.
   *
   * \since 4.0.0
   */
  joy_axis_event() noexcept : common_event{event_type::joystick_axis_motion}
  {}

  /**
   * \brief Creates a joy axis event based on the supplied SDL joy axis event.
   *
   * \param event the SDL joy axis event that will be copied.
   *
   * \since 4.0.0
   */
  explicit joy_axis_event(const SDL_JoyAxisEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the joystick instance ID associated with the event.
   *
   * \param which the joystick instance ID associated with the event.
   *
   * \since 4.0.0
   */
  void set_which(const SDL_JoystickID which) noexcept
  {
    m_event.which = which;
  }

  /**
   * \brief Sets the joystick axis index associated with the event.
   *
   * \param axis the joystick axis index associated with the event.
   *
   * \since 4.0.0
   */
  void set_axis(const u8 axis) noexcept
  {
    m_event.axis = axis;
  }

  /**
   * \brief Sets the joystick axis value associated with the event.
   *
   * \param value the joystick axis value associated with the event.
   *
   * \since 4.0.0
   */
  void set_value(const i16 value) noexcept
  {
    m_event.value = value;
  }

  /**
   * \brief Returns the joystick instance ID associated with the event.
   *
   * \return the joystick instance ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto which() const noexcept -> SDL_JoystickID
  {
    return m_event.which;
  }

  /**
   * \brief Returns the joystick axis index associated with the event.
   *
   * \return the joystick axis index associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto axis() const noexcept -> u8
  {
    return m_event.axis;
  }

  /**
   * \brief Returns the joystick axis value associated with the event.
   *
   * \return the joystick axis value associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto value() const noexcept -> i16
  {
    return m_event.value;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_JoyAxisEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.jaxis = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_JOY_AXIS_EVENT_HEADER

// #include "centurion/events/joy_ball_event.hpp"
#ifndef CENTURION_JOY_BALL_EVENT_HEADER
#define CENTURION_JOY_BALL_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class joy_ball_event
 *
 * \brief Represents the event that is triggered when a user moves a
 * trackball on a joystick.
 *
 * \see `SDL_JoyBallEvent`
 *
 * \since 4.0.0
 */
class joy_ball_event final : public common_event<SDL_JoyBallEvent>
{
 public:
  /**
   * \brief Creates a joy ball event.
   *
   * \since 4.0.0
   */
  joy_ball_event() noexcept : common_event{event_type::joystick_ball_motion}
  {}

  /**
   * \brief Creates a joy ball event based on the supplied SDL joy ball event.
   *
   * \param event the SDL joy ball event that will be copied.
   *
   * \since 4.0.0
   */
  explicit joy_ball_event(const SDL_JoyBallEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the joystick instance ID associated with the event.
   *
   * \param which the joystick instance ID.
   *
   * \since 4.0.0
   */
  void set_which(const SDL_JoystickID which) noexcept
  {
    m_event.which = which;
  }

  /**
   * \brief Sets the joystick trackball index associated with the event.
   *
   * \param ball the joystick trackball index.
   *
   * \since 4.0.0
   */
  void set_ball(const u8 ball) noexcept
  {
    m_event.ball = ball;
  }

  /**
   * \brief Sets the relative motion along the x-axis associated with the event.
   *
   * \param dx the relative motion along the x-axis.
   *
   * \since 4.0.0
   */
  void set_dx(const i16 dx) noexcept
  {
    m_event.xrel = dx;
  }

  /**
   * \brief Sets the relative motion along the y-axis associated with the event.
   *
   * \param dy the relative motion along the y-axis.
   *
   * \since 4.0.0
   */
  void set_dy(const i16 dy) noexcept
  {
    m_event.yrel = dy;
  }

  /**
   * \brief Returns the joystick instance ID associated with the event.
   *
   * \return the joystick instance ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto which() const noexcept -> SDL_JoystickID
  {
    return m_event.which;
  }

  /**
   * \brief Returns the joystick trackball index associated with the event.
   *
   * \return the joystick trackball index associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto ball() const noexcept -> u8
  {
    return m_event.ball;
  }

  /**
   * \brief Returns the relative motion along the x-axis.
   *
   * \note Trackballs only return relative motion, i.e this is the change in
   * position of the ball along the x-axis since it was last updated.
   *
   * \return the relative motion along the x-axis.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto dx() const noexcept -> i16
  {
    return m_event.xrel;
  }

  /**
   * \brief Returns the relative motion along the y-axis.
   *
   * \note Trackballs only return relative motion, i.e this is the change in
   * position of the ball along the y-axis since it was last updated.
   *
   * \return the relative motion along the y-axis.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto dy() const noexcept -> i16
  {
    return m_event.yrel;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_JoyBallEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.jball = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_JOY_BALL_EVENT_HEADER

// #include "centurion/events/joy_button_event.hpp"
#ifndef CENTURION_JOY_BUTTON_EVENT_HEADER
#define CENTURION_JOY_BUTTON_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../core/to_underlying.hpp"

// #include "../input/button_state.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class joy_button_event
 *
 * \brief Represents an event associated with the press or release of a
 * joystick button.
 *
 * \see `SDL_JoyButtonEvent`
 *
 * \since 4.0.0
 */
class joy_button_event final : public common_event<SDL_JoyButtonEvent>
{
 public:
  /**
   * \brief Creates a joystick button event of type `joystick_button_down`.
   *
   * \since 4.0.0
   */
  joy_button_event() noexcept : common_event{event_type::joystick_button_down}
  {}

  /**
   * \brief Creates a joy_button_event based on the supplied event.
   *
   * \param event the event that will be copied.
   *
   * \since 4.0.0
   */
  explicit joy_button_event(const SDL_JoyButtonEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the joystick instance ID associated with the event.
   *
   * \param which the joystick instance ID associated with the event.
   *
   * \since 4.0.0
   */
  void set_which(const SDL_JoystickID which) noexcept
  {
    m_event.which = which;
  }

  /**
   * \brief Sets the button index associated with the event.
   *
   * \param button the button index associated with the event.
   *
   * \since 4.0.0
   */
  void set_button(const u8 button) noexcept
  {
    m_event.button = button;
  }

  /**
   * \brief Sets the button state that is associated with the button that
   * triggered the event.
   *
   * \param state the button state that is associated with the button that
   * triggered the event.
   *
   * \since 4.0.0
   */
  void set_state(const button_state state) noexcept
  {
    m_event.state = to_underlying(state);
  }

  /**
   * \brief Returns the joystick instance ID associated with the event.
   *
   * \return the joystick instance ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto which() const noexcept -> SDL_JoystickID
  {
    return m_event.which;
  }

  /**
   * \brief Returns the index of the button that changed.
   *
   * \return the index of the button that changed.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto button() const noexcept -> u8
  {
    return m_event.button;
  }

  /**
   * \brief Returns the state of the button associated with the event.
   *
   * \return the state of the button associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto state() const noexcept -> button_state
  {
    return static_cast<button_state>(m_event.state);
  }

  /**
   * \brief Indicates whether or not the associated button is pressed.
   *
   * \return `true` if the associated button is pressed; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto pressed() const noexcept -> bool
  {
    return state() == button_state::pressed;
  }

  /**
   * \brief Indicates whether or not the associated button is released.
   *
   * \return `true` if the associated button is released; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto released() const noexcept -> bool
  {
    return state() == button_state::released;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_JoyButtonEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.jbutton = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_JOY_BUTTON_EVENT_HEADER

// #include "centurion/events/joy_device_event.hpp"
#ifndef CENTURION_JOY_DEVICE_EVENT_HEADER
#define CENTURION_JOY_DEVICE_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class joy_device_event
 *
 * \brief Represents an event triggered by adding or removing a joystick device.
 *
 * \see `SDL_JoyDeviceEvent`
 *
 * \since 4.0.0
 */
class joy_device_event final : public common_event<SDL_JoyDeviceEvent>
{
 public:
  /**
   * \brief Creates a joystick device event of type `joystick_device_added`.
   *
   * \since 4.0.0
   */
  joy_device_event() noexcept : common_event{event_type::joystick_device_added}
  {}

  /**
   * \brief Creates a joy_device_event that is based on the supplied SDL event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit joy_device_event(const SDL_JoyDeviceEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the joystick device index or instance ID, depending on the type
   * of the event.
   *
   * \param which the joystick device index or instance ID.
   *
   * \since 4.0.0
   */
  void set_which(const i32 which) noexcept
  {
    m_event.which = which;
  }

  /**
   * \brief Returns the joystick device index or instance ID.
   *
   * \details The returned value is the joystick device index if the type is
   * `JoystickDeviceAdded`, or the joystick instance ID if the type is
   * `JoystickDeviceRemoved`.
   *
   * \return the joystick device index or instance ID.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto which() const noexcept -> i32
  {
    return m_event.which;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_JoyDeviceEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.jdevice = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_JOY_DEVICE_EVENT_HEADER

// #include "centurion/events/joy_hat_event.hpp"
#ifndef CENTURION_JOY_HAT_EVENT_HEADER
#define CENTURION_JOY_HAT_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../core/to_underlying.hpp"

// #include "common_event.hpp"

// #include "joy_hat_position.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class joy_hat_event
 *
 * \brief Represents an event that is triggered whenever a user moves a hat
 * on a joystick.
 *
 * \see `SDL_JoyHatEvent`
 *
 * \since 4.0.0
 */
class joy_hat_event final : public common_event<SDL_JoyHatEvent>
{
 public:
  /**
   * \brief Creates a joy hat event.
   *
   * \since 4.0.0
   */
  joy_hat_event() noexcept : common_event{event_type::joystick_hat_motion}
  {}

  /**
   * \brief Creates a joy hat event based on the supplied SDL event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit joy_hat_event(const SDL_JoyHatEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the hat index associated with the event.
   *
   * \param hat the hat index.
   *
   * \since 4.0.0
   */
  void set_hat(const u8 hat) noexcept
  {
    m_event.hat = hat;
  }

  /**
   * \brief Sets the joystick hat position associated with the event.
   *
   * \param value the joystick hat position associated with the event.
   *
   * \since 4.0.0
   */
  void set_position(const joy_hat_position value) noexcept
  {
    m_event.value = to_underlying(value);
  }

  /**
   * \brief Returns the index of the hat that changed.
   *
   * \return the index of the hat that changed.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto hat() const noexcept -> u8
  {
    return m_event.hat;
  }

  /**
   * \brief Returns the position of the associated joystick hat.
   *
   * \return the position of the associated joystick hat.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto position() const noexcept -> joy_hat_position
  {
    return static_cast<joy_hat_position>(m_event.value);
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_JoyHatEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.jhat = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_JOY_HAT_EVENT_HEADER

// #include "centurion/events/keyboard_event.hpp"
#ifndef CENTURION_KEYBOARD_EVENT_HEADER
#define CENTURION_KEYBOARD_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../core/to_underlying.hpp"

// #include "../input/button_state.hpp"

// #include "../input/key_code.hpp"

// #include "../input/key_modifier.hpp"

// #include "../input/scan_code.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class keyboard_event
 *
 * \brief Represents an event associated with some sort of key action, such
 * as the release or pressing of a key.
 *
 * \see `SDL_KeyboardEvent`
 *
 * \since 4.0.0
 */
class keyboard_event final : public common_event<SDL_KeyboardEvent>
{
 public:
  /**
   * \brief Creates a keyboard event of type `key_down`.
   *
   * \since 4.0.0
   */
  keyboard_event() noexcept : common_event{event_type::key_down}
  {}

  /**
   * \brief Creates a keyboard event based on the supplied SDL event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit keyboard_event(const SDL_KeyboardEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the scan code that is associated with the event.
   *
   * \param code the scan code that will be associated with the event.
   *
   * \since 5.0.0
   */
  void set_scan_code(const scan_code& code) noexcept
  {
    m_event.keysym.scancode = code.get();
  }

  /**
   * \brief Sets the key code that is associated with the event.
   *
   * \param code the key code that will be associated with the event.
   *
   * \since 5.0.0
   */
  void set_key_code(const key_code& code) noexcept
  {
    m_event.keysym.sym = code.get();
  }

  /**
   * \brief Sets the button state associated with the event.
   *
   * \param state the button state that will be associated with the event
   *
   * \since 5.0.0
   */
  void set_button_state(const button_state state) noexcept
  {
    m_event.state = to_underlying(state);
  }

  /**
   * \brief Sets the status of key modifiers.
   *
   * \param modifiers the modifiers that will be affected.
   * \param active `true` if the modifiers should be active; `false` otherwise.
   *
   * \since 4.0.0
   */
  void set_modifier(const key_mod modifiers, const bool active) noexcept
  {
    if (active) {
      m_event.keysym.mod |= to_underlying(modifiers);
    }
    else {
      m_event.keysym.mod &= ~to_underlying(modifiers);
    }
  }

  /**
   * \brief Sets the flag that indicates whether or not the key associated with
   * this key event was repeatedly triggered.
   *
   * \param repeated `true` if the key was repeatedly triggered; `false`
   * otherwise.
   *
   * \since 4.0.0
   */
  void set_repeated(const bool repeated) noexcept
  {
    m_event.repeat = repeated;
  }

  /**
   * \brief Sets the window ID that is associated with this key event.
   *
   * \param id the window ID that should be associated with the key event.
   *
   * \since 4.0.0
   */
  void set_window_id(const u32 id) noexcept
  {
    m_event.windowID = id;
  }

  /**
   * \brief Indicates whether or not the event is associated with the
   * specified scan code.
   *
   * \param code the scan code that will be checked.
   *
   * \return `true` if the supplied scan code is associated with the event;
   * `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto is_active(const scan_code& code) const noexcept -> bool
  {
    return m_event.keysym.scancode == code.get();
  }

  /**
   * \brief Indicates whether or not the event is associated with the
   * specified key code.
   *
   * \param code the key code that will be checked.
   *
   * \return `true` if the supplied key code is associated with the event;
   * `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto is_active(const key_code& code) const noexcept -> bool
  {
    return static_cast<SDL_KeyCode>(m_event.keysym.sym) == code.get();
  }

  /**
   * \brief Indicates whether or not the specified modifiers are active.
   *
   * \note Multiple key modifiers can be active at the same time.
   *
   * \param modifiers the modifiers to check for.
   *
   * \return `true` if any of the specified modifiers are active; `false` otherwise.
   *
   * \see `is_only_active(key_mod)`
   * \see `is_only_any_of_active(key_mod)`
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto is_active(const key_mod modifiers) const noexcept -> bool
  {
    return detail::is_active(modifiers, m_event.keysym.mod);
  }

  /**
   * \brief Indicates whether or not the specified modifiers are solely active.
   *
   * \details This function differs from `is_active(key_mod)` in that this function
   * will return `false` if modifiers other than those specified are active. For example,
   * if the `shift` and `alt` modifiers are being pressed, then
   * `is_only_active(cen::key_mod::shift)` would evaluate to `false`.
   *
   * \param modifiers the modifiers to check for.
   *
   * \return `true` if *only* the specified modifiers are active; false otherwise.
   *
   * \see `is_active(key_mod)`
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto is_only_active(const key_mod modifiers) const noexcept -> bool
  {
    return detail::is_only_active(modifiers, m_event.keysym.mod);
  }

  /**
   * \brief Indicates whether or not only any of the specified modifiers are active.
   *
   * \details This function is very similar to `is_only_active()`, but differs in that not
   * all of the specified modifiers need to be active for this function to return `true`.
   * For example, if you supply `shift` to this function, and only the left shift key is
   * being pressed, then `is_only_any_of_active(cen::key_mod::shift)` would evaluate
   * to `true`. However, if some other modifiers were also being pressed other than the
   * left shift key, the same function call would instead evaluate to `false`.
   *
   * \param modifiers the modifiers to check for.
   *
   * \return `true` if *any* of the specified modifiers are active, but no other
   * modifiers; false otherwise.
   *
   * \see `is_only_active(key_mod)`
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto is_only_any_of_active(const key_mod modifiers) const noexcept -> bool
  {
    return detail::is_only_any_of_active(modifiers, m_event.keysym.mod);
  }

  /**
   * \brief Indicates whether or not the key associated with this key event has
   * been repeatedly triggered.
   *
   * \return `true` if the key associated with the event was repeated; false
   * otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto repeated() const noexcept -> bool
  {
    return m_event.repeat;
  }

  /**
   * \brief Returns the button state of the key associated with the event.
   *
   * \return the button state of the key associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto state() const noexcept -> button_state
  {
    return static_cast<button_state>(m_event.state);
  }

  /**
   * \brief Indicates whether or not the event is associated with the release
   * of a key.
   *
   * \note This function is equivalent to `state() ==  button_state::released`.
   *
   * \return `true` if the event is a key released event; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto released() const noexcept -> bool
  {
    return state() == button_state::released;
  }

  /**
   * \brief Indicates whether or not the event is associated with the press
   * of a key.
   *
   * \note This function is equivalent to `state() ==  button_state::pressed`.
   *
   * \return `true` if the event is a key pressed event; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto pressed() const noexcept -> bool
  {
    return state() == button_state::pressed;
  }

  /**
   * \brief Returns the scan code that is associated with the event.
   *
   * \return the scan code that is associated with the event.
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto scan() const noexcept -> scan_code
  {
    return m_event.keysym.scancode;
  }

  /**
   * \brief Equivalent to `scan()`.
   * \since 5.0.0
   */
  [[nodiscard]] auto get_scan_code() const noexcept -> scan_code
  {
    return scan();
  }

  /**
   * \brief Returns the key code that is associated with the event.
   *
   * \return the key code that is associated with the event.
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto key() const noexcept -> key_code
  {
    return static_cast<SDL_KeyCode>(m_event.keysym.sym);
  }

  /**
   * \brief Equivalent to `key()`.
   * \since 5.0.0
   */
  [[nodiscard]] auto get_key_code() const noexcept -> key_code
  {
    return key();
  }

  /**
   * \brief Returns the ID of the window associated with the event.
   *
   * \return the ID of the window associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto window_id() const noexcept -> u32
  {
    return m_event.windowID;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_KeyboardEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.key = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_KEYBOARD_EVENT_HEADER

// #include "centurion/events/mouse_button_event.hpp"
#ifndef CENTURION_MOUSE_BUTTON_EVENT_HEADER
#define CENTURION_MOUSE_BUTTON_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../core/to_underlying.hpp"

// #include "../input/button_state.hpp"

// #include "../input/mouse_button.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class mouse_button_event
 *
 * \brief Represents an event triggered by mouse button presses or releases.
 *
 * \see `SDL_MouseButtonEvent`
 *
 * \since 4.0.0
 */
class mouse_button_event final : public common_event<SDL_MouseButtonEvent>
{
 public:
  /**
   * \brief Creates a mouse button event of type `mouse_button_down`.
   *
   * \since 4.0.0
   */
  mouse_button_event() noexcept : common_event{event_type::mouse_button_down}
  {}

  /**
   * \brief Creates a mouse_button_event that is based on the supplied SDL
   * event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit mouse_button_event(const SDL_MouseButtonEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the window ID associated with the event.
   *
   * \param id the window ID associated with the event.
   *
   * \since 4.0.0
   */
  void set_window_id(const u32 id) noexcept
  {
    m_event.windowID = id;
  }

  /**
   * \brief Sets the mouse instance ID.
   *
   * \param which the mouse instance ID.
   *
   * \since 4.0.0
   */
  void set_which(const u32 which) noexcept
  {
    m_event.which = which;
  }

  /**
   * \brief Sets the mouse button associated with the event.
   *
   * \param button the mouse button associated with the event.
   *
   * \since 4.0.0
   */
  void set_button(const mouse_button button) noexcept
  {
    m_event.button = to_underlying(button);
  }

  /**
   * \brief Sets the button state associated with the event.
   *
   * \param state the button state associated with the event.
   *
   * \since 4.0.0
   */
  void set_state(const button_state state) noexcept
  {
    m_event.state = to_underlying(state);
  }

  /**
   * \brief Sets the amount of clicks associated with the event.
   *
   * \param clicks the amount of clicks associated with the event.
   *
   * \since 4.0.0
   */
  void set_clicks(const u8 clicks) noexcept
  {
    m_event.clicks = clicks;
  }

  /**
   * \brief Sets the x-coordinate of the mouse relative to the window.
   *
   * \param x the x-coordinate of the mouse relative to the window.
   *
   * \since 4.0.0
   */
  void set_x(const i32 x) noexcept
  {
    m_event.x = x;
  }

  /**
   * \brief Sets the y-coordinate of the mouse relative to the window.
   *
   * \param y the y-coordinate of the mouse relative to the window.
   *
   * \since 4.0.0
   */
  void set_y(const i32 y) noexcept
  {
    m_event.y = y;
  }

  /**
   * \brief Returns the ID of the window associated with the event.
   *
   * \return the ID of the window associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto window_id() const noexcept -> u32
  {
    return m_event.windowID;
  }

  /**
   * \brief Returns the mouse instance ID, or SDL_TOUCH_MOUSEID if the event was
   * triggered by a touch input device.
   *
   * \return the mouse instance ID, or SDL_TOUCH_MOUSEID.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto which() const noexcept -> u32
  {
    return m_event.which;
  }

  /**
   * \brief Returns the mouse button associated with the event.
   *
   * \return the mouse button associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto button() const noexcept -> mouse_button
  {
    return static_cast<mouse_button>(m_event.button);
  }

  /**
   * \brief Returns the state of the mouse button associated with the event.
   *
   * \return the state of the mouse button associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto state() const noexcept -> button_state
  {
    return static_cast<button_state>(m_event.state);
  }

  /**
   * \brief Indicates whether or not the associated button is pressed.
   *
   * \return `true` if the associated button is pressed; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto pressed() const noexcept -> bool
  {
    return state() == button_state::pressed;
  }

  /**
   * \brief Indicates whether or not the associated button is released.
   *
   * \return `true` if the associated button is released; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto released() const noexcept -> bool
  {
    return state() == button_state::released;
  }

  /**
   * \brief Returns the number of mouse clicks associated with the event.
   *
   * \return the number of mouse clicks associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto clicks() const noexcept -> u8
  {
    return m_event.clicks;
  }

  /**
   * \brief Returns the x-coordinate of the mouse relative to the window.
   *
   * \return the x-coordinate of the mouse relative to the window.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto x() const noexcept -> i32
  {
    return m_event.x;
  }

  /**
   * \brief Returns the y-coordinate of the mouse relative to the window.
   *
   * \return the y-coordinate of the mouse relative to the window.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto y() const noexcept -> i32
  {
    return m_event.y;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_MouseButtonEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.button = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_MOUSE_BUTTON_EVENT_HEADER

// #include "centurion/events/mouse_motion_event.hpp"
#ifndef CENTURION_MOUSE_MOTION_EVENT_HEADER
#define CENTURION_MOUSE_MOTION_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../core/to_underlying.hpp"

// #include "../input/mouse_button.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class mouse_motion_event
 *
 * \brief Represents events that are triggered by the movement of the mouse.
 *
 * \see `SDL_MouseMotionEvent`
 *
 * \since 4.0.0
 */
class mouse_motion_event final : public common_event<SDL_MouseMotionEvent>
{
 public:
  /**
   * \brief Creates a mouse motion event.
   *
   * \since 4.0.0
   */
  mouse_motion_event() noexcept : common_event{event_type::mouse_motion}
  {}

  /**
   * \brief Creates an event based on an SDL event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit mouse_motion_event(const SDL_MouseMotionEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the window ID associated with the event.
   *
   * \param id the window ID associated with the event.
   *
   * \since 4.0.0
   */
  void set_window_id(const u32 id) noexcept
  {
    m_event.windowID = id;
  }

  /**
   * \brief Sets the mouse instance ID.
   *
   * \param which the mouse instance ID.
   *
   * \since 4.0.0
   */
  void set_which(const u32 which) noexcept
  {
    m_event.which = which;
  }

  /**
   * \brief Sets the mouse button state associated with the event.
   *
   * \details The state could be any of `SDL_BUTTON_LMASK`, `SDL_BUTTON_MMASK`,
   * `SDL_BUTTON_RMASK`, `SDL_BUTTON_X1MASK` and `SDL_BUTTON_X2MASK` OR'd
   * together.
   *
   * \param state the mouse button state associated with the event.
   *
   * \since 4.0.0
   */
  void set_state(const u32 state) noexcept
  {
    m_event.state = state;
  }

  /**
   * \brief Sets the x-coordinate of the mouse relative to the mouse that is
   * associated with the event.
   *
   * \param x the x-coordinate of the mouse.
   *
   * \since 4.0.0
   */
  void set_x(const i32 x) noexcept
  {
    m_event.x = x;
  }

  /**
   * \brief Sets the y-coordinate of the mouse relative to the mouse that is
   * associated with the event.
   *
   * \param y the y-coordinate of the mouse.
   *
   * \since 4.0.0
   */
  void set_y(const i32 y) noexcept
  {
    m_event.y = y;
  }

  /**
   * \brief Sets the value of the relative motion of the mouse along the x-axis.
   *
   * \param dx the value of the relative motion of the mouse along the x-axis.
   *
   * \since 4.0.0
   */
  void set_dx(const i32 dx) noexcept
  {
    m_event.xrel = dx;
  }

  /**
   * \brief Sets the value of the relative motion of the mouse along the y-axis.
   *
   * \param dy the value of the relative motion of the mouse along the y-axis.
   *
   * \since 4.0.0
   */
  void set_dy(const i32 dy) noexcept
  {
    m_event.yrel = dy;
  }

  /**
   * \brief Returns the window ID associated with the event.
   *
   * \return the window ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto window_id() const noexcept -> u32
  {
    return m_event.windowID;
  }

  /**
   * \brief Returns the mouse instance ID, or `SDL_TOUCH_MOUSEID`.
   *
   * \details The returned value might be `SDL_TOUCH_MOUSEID` for events that
   * were generated by a touch input device.
   *
   * \return the mouse instance ID, or `SDL_TOUCH_MOUSEID`.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto which() const noexcept -> u32
  {
    return m_event.which;
  }

  /**
   * \brief Returns a bitmask for the current mouse button state.
   *
   * \remark If you want to check if a specific mouse button is pressed or released, a
   * better alternative would be to use the `pressed()` function.
   *
   * \return a bitmask for the current mouse button state.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto state() const noexcept -> u32
  {
    return m_event.state;
  }

  /**
   * \brief Indicates whether or not a mouse button is pressed.
   *
   * \param button the mouse button that will be checked.
   *
   * \return `true` if the specified mouse button is pressed; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto pressed(const mouse_button button) const noexcept -> bool
  {
    return m_event.state & SDL_BUTTON(to_underlying(button));
  }

  /**
   * \brief Returns the x-coordinate of the mouse relative to the window.
   *
   * \return the x-coordinate of the mouse relative to the window.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto x() const noexcept -> i32
  {
    return m_event.x;
  }

  /**
   * \brief Returns the y-coordinate of the mouse relative to the window.
   *
   * \return the y-coordinate of the mouse relative to the window.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto y() const noexcept -> i32
  {
    return m_event.y;
  }

  /**
   * \brief Returns the relative motion of the mouse along the x-axis.
   *
   * \return the relative motion of the mouse along the x-axis.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto dx() const noexcept -> i32
  {
    return m_event.xrel;
  }

  /**
   * \brief Returns the relative motion of the mouse along the y-axis.
   *
   * \return the relative motion of the mouse along the y-axis.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto dy() const noexcept -> i32
  {
    return m_event.yrel;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_MouseMotionEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.motion = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_MOUSE_MOTION_EVENT_HEADER

// #include "centurion/events/mouse_wheel_direction.hpp"
#ifndef CENTURION_MOUSE_WHEEL_DIRECTION_HEADER
#define CENTURION_MOUSE_WHEEL_DIRECTION_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \enum mouse_wheel_direction
 *
 * \brief Represents mouse wheel directions.
 *
 * \see `SDL_MouseWheelDirection`
 * \see `mouse_wheel_direction_count()`
 *
 * \since 4.0.0
 */
enum class mouse_wheel_direction : u32
{
  normal = SDL_MOUSEWHEEL_NORMAL,   ///< The scroll direction is normal
  flipped = SDL_MOUSEWHEEL_FLIPPED  ///< The scroll direction is flipped natural
};

/**
 * \brief Returns the number of enumerators for the `mouse_wheel_direction` enum.
 *
 * \return the number of enumerators.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto mouse_wheel_direction_count() noexcept -> int
{
  return 2;
}

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied mouse wheel direction.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(mouse_wheel_direction::normal) == "normal"`.
 *
 * \param dir the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const mouse_wheel_direction dir) -> std::string_view
{
  switch (dir) {
    case mouse_wheel_direction::normal:
      return "normal";

    case mouse_wheel_direction::flipped:
      return "flipped";

    default:
      throw cen_error{"Did not recognize mouse wheel direction!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of an mouse wheel direction enumerator.
 *
 * \param stream the output stream that will be used.
 * \param dir the enumerator that will be printed.
 *
 * \see `to_string(mouse_wheel_direction)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const mouse_wheel_direction dir) -> std::ostream&
{
  return stream << to_string(dir);
}

/// \} End of streaming

/// \name Mouse wheel direction comparison operators
/// \{

/**
 * \brief Indicates whether or not two mouse wheel direction values are equal.
 *
 * \param lhs the left-hand side mouse wheel direction value.
 * \param rhs the right-hand side mouse wheel direction value.
 *
 * \return `true` if the two values are equal; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator==(const mouse_wheel_direction lhs,
                                        const SDL_MouseWheelDirection rhs) noexcept -> bool
{
  return lhs == static_cast<mouse_wheel_direction>(rhs);
}

/// \copydoc operator==(mouse_wheel_direction, SDL_MouseWheelDirection)
[[nodiscard]] constexpr auto operator==(const SDL_MouseWheelDirection lhs,
                                        const mouse_wheel_direction rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two mouse wheel direction values aren't
 * equal.
 *
 * \param lhs the left-hand side mouse wheel direction value.
 * \param rhs the right-hand side mouse wheel direction value.
 *
 * \return `true` if the two values aren't equal; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator!=(const mouse_wheel_direction lhs,
                                        const SDL_MouseWheelDirection rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(mouse_wheel_direction, SDL_MouseWheelDirection)
[[nodiscard]] constexpr auto operator!=(const SDL_MouseWheelDirection lhs,
                                        const mouse_wheel_direction rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of mouse wheel direction comparison operators

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_MOUSE_WHEEL_DIRECTION_HEADER

// #include "centurion/events/mouse_wheel_event.hpp"
#ifndef CENTURION_MOUSE_WHEEL_EVENT_HEADER
#define CENTURION_MOUSE_WHEEL_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../core/to_underlying.hpp"

// #include "common_event.hpp"

// #include "mouse_wheel_direction.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class mouse_wheel_event
 *
 * \brief Represents events triggered when a user moves the mouse wheel.
 *
 * \see `SDL_MouseWheelEvent`
 *
 * \since 4.0.0
 */
class mouse_wheel_event final : public common_event<SDL_MouseWheelEvent>
{
 public:
  /**
   * \brief Creates a mouse wheel event.
   *
   * \since 4.0.0
   */
  mouse_wheel_event() noexcept : common_event{event_type::mouse_wheel}
  {}

  /**
   * \brief Creates an event based on the supplied SDL event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit mouse_wheel_event(const SDL_MouseWheelEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the window ID associated with the event.
   *
   * \param id the window ID associated with the event.
   *
   * \since 4.0.0
   */
  void set_window_id(const u32 id) noexcept
  {
    m_event.windowID = id;
  }

  /**
   * \brief Sets the mouse instance ID.
   *
   * \param which the mouse instance ID.
   *
   * \since 4.0.0
   */
  void set_which(const u32 which) noexcept
  {
    m_event.which = which;
  }

  /**
   * \brief Sets the horizontally scrolled distance.
   *
   * \details A positive value indicates that the user scrolled to the right
   * and a negative value indicates that the user scrolled to the left.
   *
   * \param xScroll the horizontally scrolled distance.
   *
   * \since 4.0.0
   */
  void set_x_scroll(const i32 xScroll) noexcept
  {
    m_event.x = xScroll;
  }

  /**
   * \brief Sets the vertically scrolled distance.
   *
   * \details A positive value indicates that the user scrolled to the right
   * and a negative value indicates that the user scrolled to the left.
   *
   * \param yScroll the vertically scrolled distance.
   *
   * \since 4.0.0
   */
  void set_y_scroll(const i32 yScroll) noexcept
  {
    m_event.y = yScroll;
  }

  /**
   * \brief Sets the mouse wheel direction mode associated with the event.
   *
   * \param direction the mouse wheel direction mode associated with the event.
   *
   * \since 4.0.0
   */
  void set_direction(const mouse_wheel_direction direction) noexcept
  {
    m_event.direction = to_underlying(direction);
  }

  /**
   * \brief Returns the ID of the window associated with the event.
   *
   * \return the ID of the window associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto window_id() const noexcept -> u32
  {
    return m_event.windowID;
  }

  /**
   * \brief Returns the mouse instance ID, or `SDL_TOUCH_MOUSEID` if the event
   * was triggered by a touch input device.
   *
   * \return the mouse instance ID, or `SDL_TOUCH_MOUSEID`.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto which() const noexcept -> u32
  {
    return m_event.which;
  }

  /**
   * \brief Returns the horizontally scrolled distance
   *
   * \details A positive value indicates that the user scrolled to the right
   * and a negative value indicates that the user scrolled to the left.
   *
   * \return the horizontally scrolled distance.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto x_scroll() const noexcept -> i32
  {
    return m_event.x;
  }

  /**
   * \brief Returns the vertically scrolled distance.
   *
   * \details A positive value indicates that the user scrolled to the right
   * and a negative value indicates that the user scrolled to the left.
   *
   * \return the vertically scrolled distance.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto y_scroll() const noexcept -> i32
  {
    return m_event.y;
  }

  /**
   * \brief Returns the mouse wheel direction mode associated with the event.
   *
   * \return the mouse wheel direction mode associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto direction() const noexcept -> mouse_wheel_direction
  {
    return static_cast<mouse_wheel_direction>(m_event.direction);
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_MouseWheelEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.wheel = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_MOUSE_WHEEL_EVENT_HEADER

// #include "centurion/events/multi_gesture_event.hpp"
#ifndef CENTURION_MULTI_GESTURE_EVENT_HEADER
#define CENTURION_MULTI_GESTURE_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class multi_gesture_event
 *
 * \brief Provides information about events related to touch events triggered
 * by multiple fingers.
 *
 * \see `SDL_MultiGestureEvent`
 *
 * \since 4.0.0
 */
class multi_gesture_event final : public common_event<SDL_MultiGestureEvent>
{
 public:
  /**
   * \brief Creates a multi-gesture event.
   *
   * \since 4.0.0
   */
  multi_gesture_event() noexcept : common_event{event_type::multi_gesture}
  {}

  /**
   * \brief Creates an event that is based on the supplied SDL event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit multi_gesture_event(const SDL_MultiGestureEvent& event) noexcept
      : common_event{event}
  {}

  /**
   * \brief Sets the touch device ID associated with the event.
   *
   * \param id the touch device ID associated with the event.
   *
   * \since 4.0.0
   */
  void set_touch_id(const SDL_TouchID id) noexcept
  {
    m_event.touchId = id;
  }

  /**
   * \brief Sets the amount that the fingers rotated during the gesture
   * associated with the event.
   *
   * \param dTheta the amount that the fingers rotated.
   *
   * \since 4.0.0
   */
  void set_delta_theta(const float dTheta) noexcept
  {
    m_event.dTheta = dTheta;
  }

  /**
   * \brief Sets the amount that the fingers pinched during the gesture
   * associated with the event.
   *
   * \param dDistance the amount that the fingers pinched.
   *
   * \since 4.0.0
   */
  void set_delta_distance(const float dDistance) noexcept
  {
    m_event.dDist = dDistance;
  }

  /**
   * \brief Sets the x-coordinate of the normalized center of the gesture
   * associated with the event.
   *
   * \param centerX the x-coordinate of the normalized center of the gesture
   * associated with the event.
   *
   * \since 4.0.0
   */
  void set_center_x(const float centerX) noexcept
  {
    m_event.x = centerX;
  }

  /**
   * \brief Sets the y-coordinate of the normalized center of the gesture
   * associated with the event.
   *
   * \param centerY the y-coordinate of the normalized center of the gesture
   * associated with the event.
   *
   * \since 4.0.0
   */
  void set_center_y(const float centerY) noexcept
  {
    m_event.y = centerY;
  }

  /**
   * \brief Sets the number of fingers that was used in the gesture associated
   * with the event.
   *
   * \param count the number of fingers that were use.
   *
   * \since 6.1.0
   */
  void set_finger_count(const u16 count) noexcept
  {
    m_event.numFingers = count;
  }

  /**
   * \brief Returns the touch device ID associated with the event.
   *
   * \return the touch device ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto touch_id() const noexcept -> SDL_TouchID
  {
    return m_event.touchId;
  }

  /**
   * \brief Returns the amount that the fingers rotated during the gesture
   * associated with the event.
   *
   * \return the amount that the fingers rotated.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto delta_theta() const noexcept -> float
  {
    return m_event.dTheta;
  }

  /**
   * \brief Returns the amount that the fingers pinched during the gesture
   * associated with the event.
   *
   * \return the amount that the fingers pinched.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto delta_distance() const noexcept -> float
  {
    return m_event.dDist;
  }

  /**
   * \brief Returns the x-coordinate of the normalized center of gesture
   * associated with the event.
   *
   * \return the x-coordinate of the normalized center of gesture associated
   * with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto center_x() const noexcept -> float
  {
    return m_event.x;
  }

  /**
   * \brief Returns the y-coordinate of the normalized center of gesture
   * associated with the event.
   *
   * \return the y-coordinate of the normalized center of gesture associated
   * with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto center_y() const noexcept -> float
  {
    return m_event.y;
  }

  /**
   * \brief Returns the amount of fingers used in the gesture associated with the event.
   *
   * \return the amount of fingers used in the gesture.
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto finger_count() const noexcept -> u16
  {
    return m_event.numFingers;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_MultiGestureEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.mgesture = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_MULTI_GESTURE_EVENT_HEADER

// #include "centurion/events/quit_event.hpp"
#ifndef CENTURION_QUIT_EVENT_HEADER
#define CENTURION_QUIT_EVENT_HEADER

#include <SDL.h>

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class quit_event
 *
 * \brief Represents the event of the user wanting to close the application,
 * usually by pressing the "X"-button on the window frame.
 *
 * \see `SDL_QuitEvent`
 *
 * \since 4.0.0
 */
class quit_event final : public common_event<SDL_QuitEvent>
{
 public:
  /**
   * \brief Creates a quit event.
   *
   * \since 4.0.0
   */
  quit_event() noexcept : common_event{event_type::quit}
  {}

  /**
   * \brief Creates a quit event based on the supplied SDL event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit quit_event(const SDL_QuitEvent& event) noexcept : common_event{event}
  {}
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_QuitEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.quit = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_QUIT_EVENT_HEADER

// #include "centurion/events/sensor_event.hpp"
#ifndef CENTURION_SENSOR_EVENT_HEADER
#define CENTURION_SENSOR_EVENT_HEADER

#include <SDL.h>

#include <array>  // array

// #include "../core/integers.hpp"

// #include "../detail/array_utils.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class sensor_event
 *
 * \brief Represents events related to updates of sensors.
 *
 * \since 6.3.0
 */
class sensor_event final : public common_event<SDL_SensorEvent>
{
 public:
  using data_type = std::array<float, 6>;

  /**
   * \brief Creates a sensor event.
   *
   * \since 6.3.0
   */
  sensor_event() noexcept : common_event{event_type::sensor_update}
  {}

  /**
   * \brief Creates a sensor event based on an SDL event.
   *
   * \param event the event that will be copied.
   *
   * \since 6.3.0
   */
  explicit sensor_event(const SDL_SensorEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the sensor instance ID associated with the event.
   *
   * \param id the sensor instance ID.
   *
   * \since 6.3.0
   */
  void set_which(const i32 id) noexcept
  {
    m_event.which = id;
  }

  /**
   * \brief Sets the sensor values associated with the event.
   *
   * \param values the sensor values.
   *
   * \since 6.3.0
   */
  void set_data(const data_type& values)
  {
    detail::assign(values, m_event.data);
  }

  /**
   * \brief Returns the instance ID of the associated sensor.
   *
   * \return the associated sensor instance ID.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto which() const noexcept -> i32
  {
    return m_event.which;
  }

  /**
   * \brief Returns up to 6 values from the sensor.
   *
   * \return values from the sensor.
   *
   * \see `basic_sensor::data()`
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto data() const -> data_type
  {
    return detail::to_array(m_event.data);
  }
};

template <>
inline auto as_sdl_event(const common_event<SDL_SensorEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.sensor = event.get();
  return e;
}

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_SENSOR_EVENT_HEADER

// #include "centurion/events/text_editing_event.hpp"
#ifndef CENTURION_TEXT_EDITING_EVENT_HEADER
#define CENTURION_TEXT_EDITING_EVENT_HEADER

#include <SDL.h>

#include <string_view>  // string_view

// #include "../core/integers.hpp"

// #include "../core/str.hpp"

// #include "../detail/clamp.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class text_editing_event
 *
 * \brief Represents an event triggered by keyboard text editing.
 *
 * \note This class doesn't provide a setter for the text, since it's
 * impossible to assign a value to a variable of type `char[32]` in C++.
 *
 * \see `SDL_TextEditingEvent`
 *
 * \since 4.0.0
 */
class text_editing_event final : public common_event<SDL_TextEditingEvent>
{
 public:
  /**
   * \brief Creates a text editing event.
   *
   * \since 4.0.0
   */
  text_editing_event() noexcept : common_event{event_type::text_editing}
  {
    check_length();
  }

  /**
   * \brief Creates an event that is based on the supplied SDL event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit text_editing_event(const SDL_TextEditingEvent& event) noexcept : common_event{event}
  {
    check_length();
  }

  /**
   * \brief Sets the window ID associated with the event.
   *
   * \param id the window ID associated with the event.
   *
   * \since 4.0.0
   */
  void set_window_id(const u32 id) noexcept
  {
    m_event.windowID = id;
  }

  /**
   * \brief Sets the location to begin editing from.
   *
   * \param start the location to begin editing from.
   *
   * \since 4.0.0
   */
  void set_start(const i32 start) noexcept
  {
    m_event.start = start;
  }

  /**
   * \brief Sets the number of characters to edit from the start point.
   *
   * \details The supplied value will be clamped to the range [0, 32].
   *
   * \param length the number of characters to edit from the start point.
   *
   * \since 4.0.0
   */
  void set_length(const i32 length) noexcept
  {
    m_event.length = detail::clamp(length, 0, 32);
  }

  /**
   * \brief Returns the window ID associated with the event.
   *
   * \return the window ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto window_id() const noexcept -> u32
  {
    return m_event.windowID;
  }

  /**
   * \brief Returns the text that will be used, as a null-terminated string in
   * UTF-8 encoding.
   *
   * \return the text that will be used.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto text() const noexcept -> std::string_view
  {
    return std::string_view{static_cast<str>(m_event.text)};
  }

  /**
   * \brief Returns the location to begin editing from.
   *
   * \return the location to begin editing from.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto start() const noexcept -> i32
  {
    return m_event.start;
  }

  /**
   * \brief Returns the number of characters to edit from the start point.
   *
   * \details The returned value will always be in the range [0, 32].
   *
   * \return the number of characters to edit from the start point.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto length() const noexcept -> i32
  {
    return m_event.length;
  }

 private:
  void check_length() noexcept
  {
    m_event.length = detail::clamp(m_event.length, 0, 32);
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_TextEditingEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.edit = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_TEXT_EDITING_EVENT_HEADER

// #include "centurion/events/text_input_event.hpp"
#ifndef CENTURION_TEXT_INPUT_EVENT_HEADER
#define CENTURION_TEXT_INPUT_EVENT_HEADER

#include <SDL.h>

#include <string_view>  // string_view

// #include "../core/integers.hpp"

// #include "../core/str.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class text_input_event
 *
 * \brief Provides information about keyboard text input events.
 *
 * \see `SDL_TextInputEvent`
 *
 * \since 4.0.0
 */
class text_input_event final : public common_event<SDL_TextInputEvent>
{
 public:
  /**
   * \brief Creates a text input event.
   *
   * \since 4.0.0
   */
  text_input_event() noexcept : common_event{event_type::text_input}
  {}

  /**
   * \brief Creates an event that is based on the supplied SDL event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit text_input_event(const SDL_TextInputEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the window ID associated with the event.
   *
   * \param id the window ID associated with the event.
   *
   * \since 4.0.0
   */
  void set_window_id(const u32 id) noexcept
  {
    m_event.windowID = id;
  }

  /**
   * \brief Returns the window ID associated with the event.
   *
   * \return the window ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto window_id() const noexcept -> u32
  {
    return m_event.windowID;
  }

  /**
   * Returns the text that will be used, as a null-terminated string in UTF-8
   * encoding.
   *
   * \return the text that will be used.
   * \since 4.0.0
   */
  [[nodiscard]] auto text_utf8() const noexcept -> std::string_view
  {
    return std::string_view{static_cast<str>(m_event.text)};
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_TextInputEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.text = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_TEXT_INPUT_EVENT_HEADER

// #include "centurion/events/touch_finger_event.hpp"
#ifndef CENTURION_TOUCH_FINGER_EVENT_HEADER
#define CENTURION_TOUCH_FINGER_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../detail/clamp.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class touch_finger_event
 *
 * \brief Represents an event related to touch screen actions.
 *
 * \see `SDL_TouchFingerEvent`
 *
 * \since 4.0.0
 */
class touch_finger_event final : public common_event<SDL_TouchFingerEvent>
{
 public:
  /**
   * \brief Creates a touch finger event of type `touch_down`.
   *
   * \since 4.0.0
   */
  touch_finger_event() noexcept : common_event{event_type::touch_down}
  {}

  /**
   * \brief Creates a touch finger event that is based on the supplied SDL
   * ouch finger event.
   *
   * \param event the SDL event that will be copied.
   *
   * \since 4.0.0
   */
  explicit touch_finger_event(const SDL_TouchFingerEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the ID of the associated touch device.
   *
   * \param id the ID of the associated touch device.
   *
   * \since 4.0.0
   */
  void set_touch_id(const SDL_TouchID id) noexcept
  {
    m_event.touchId = id;
  }

  /**
   * \brief Sets the finger ID associated with the event.
   *
   * \param id the finger ID associated with the event.
   *
   * \since 4.0.0
   */
  void set_finger_id(const SDL_FingerID id) noexcept
  {
    m_event.fingerId = id;
  }

#if SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Sets the window ID of the window under the finger.
   *
   * \param id the window ID of the window under the finger.
   *
   * \since 4.0.0
   */
  void set_window_id(const u32 id) noexcept
  {
    m_event.windowID = id;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Sets the normalized x-coordinate of the location of the event.
   *
   * \details The supplied value will be clamped to the range [0, 1].
   *
   * \param x the normalized x-coordinate of the location of the event,
   * clamped to the range [0, 1].
   *
   * \since 4.0.0
   */
  void set_x(const float x) noexcept
  {
    m_event.x = detail::clamp(x, 0.0f, 1.0f);
  }

  /**
   * \brief Sets the normalized y-coordinate of the location of the event.
   *
   * \details The supplied value will be clamped to the range [0, 1].
   *
   * \param y the normalized y-coordinate of the location of the event,
   * clamped to the range [0, 1].
   *
   * \since 4.0.0
   */
  void set_y(const float y) noexcept
  {
    m_event.y = detail::clamp(y, 0.0f, 1.0f);
  }

  /**
   * \brief Sets the normalized distance moved along the x-axis.
   *
   * \details The supplied value will be clamped to the range [-1, 1].
   *
   * \param dx the normalized distance moved along the x-axis, clamped to the
   * range [-1, 1].
   *
   * \since 4.0.0
   */
  void set_dx(const float dx) noexcept
  {
    m_event.dx = detail::clamp(dx, -1.0f, 1.0f);
  }

  /**
   * \brief Sets the normalized distance moved along the y-axis.
   *
   * \details The supplied value will be clamped to the range [-1, 1].
   *
   * \param dy the normalized distance moved along the y-axis, clamped to the
   * range [-1, 1].
   *
   * \since 4.0.0
   */
  void set_dy(const float dy) noexcept
  {
    m_event.dy = detail::clamp(dy, -1.0f, 1.0f);
  }

  /**
   * \brief Sets the normalized pressure associated with the event.
   *
   * \details The supplied value will be clamped to the range [0, 1].
   *
   * \param pressure the normalized pressure associated with the event, clamped
   * in the range [0, 1].
   *
   * \since 4.0.0
   */
  void set_pressure(const float pressure) noexcept
  {
    m_event.pressure = detail::clamp(pressure, 0.0f, 1.0f);
  }

  /**
   * \brief Returns the touch device ID associated with the event.
   *
   * \return the touch device ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto touch_id() const noexcept -> SDL_TouchID
  {
    return m_event.touchId;
  }

  /**
   * \brief Returns the finger ID associated with the event.
   *
   * \return the finger ID associated with the event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto finger_id() const noexcept -> SDL_FingerID
  {
    return m_event.fingerId;
  }

#if SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Returns the window ID of the window under the finger.
   *
   * \return the window ID of the window under the finger.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto window_id() const noexcept -> u32
  {
    return m_event.windowID;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Returns the normalized x-coordinate of the location of the event.
   *
   * \details The returned value will be in the range [0, 1].
   *
   * \return the normalized x-coordinate of the location of the event, in the
   * range [0, 1].
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto x() const noexcept -> float
  {
    return m_event.x;
  }

  /**
   * \brief Returns the normalized y-coordinate of the location of the event.
   *
   * \details The returned value will be in the range [0, 1].
   *
   * \return the normalized y-coordinate of the location of the event, in the
   * range [0, 1].
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto y() const noexcept -> float
  {
    return m_event.y;
  }

  /**
   * \brief Returns the normalized distance moved along the x-axis.
   *
   * \details The returned value will be in the range [-1, 1].
   *
   * \return the normalized distance moved along the x-axis, in the range
   * [-1, 1].
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto dx() const noexcept -> float
  {
    return m_event.dx;
  }

  /**
   * \brief Returns the normalized distance moved along the y-axis.
   *
   * \details The returned value will be in the range [-1, 1].
   *
   * \return the normalized distance moved along the y-axis, in the range
   * [-1, 1].
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto dy() const noexcept -> float
  {
    return m_event.dy;
  }

  /**
   * \brief Returns the normalized pressure associated with the event.
   *
   * \details The returned value will be in the range [0, 1].
   *
   * \return the normalized pressure associated with the event, in the range
   * [0, 1].
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto pressure() const noexcept -> float
  {
    return m_event.pressure;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_TouchFingerEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.tfinger = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_TOUCH_FINGER_EVENT_HEADER

// #include "centurion/events/user_event.hpp"
#ifndef CENTURION_USER_EVENT_HEADER
#define CENTURION_USER_EVENT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "common_event.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class user_event
 *
 * \brief Represents a custom user event.
 *
 * \since 6.3.0
 */
class user_event final : public common_event<SDL_UserEvent>
{
 public:
  /**
   * \brief Creates a user event.
   *
   * \details Note that the event will be created using `event_type::user`, but you can use any
   * event type value in the range [`event_type::user`, SDL_LASTEVENT - 1].
   *
   * \since 6.3.0
   */
  user_event() noexcept : common_event{event_type::user}
  {}

  /**
   * \brief Creates a user event based on an SDL event.
   *
   * \param event the event that will be copied.
   *
   * \since 6.3.0
   */
  explicit user_event(const SDL_UserEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Sets the window ID associated with the event.
   *
   * \param id the ID of the associated window.
   *
   * \since 6.3.0
   */
  void set_window_id(const u32 id) noexcept
  {
    m_event.windowID = id;
  }

  /**
   * \brief Sets the user-defined event code associated with the event.
   *
   * \param code the custom event code.
   *
   * \since 6.3.0
   */
  void set_code(const i32 code) noexcept
  {
    m_event.code = code;
  }

  /**
   * \brief Sets an opaque data pointer to some user data.
   *
   * \param data the user data, can safely be null.
   *
   * \since 6.3.0
   */
  void set_data_1(void* data) noexcept
  {
    m_event.data1 = data;
  }

  /// \copydoc set_data_1()
  void set_data_2(void* data) noexcept
  {
    m_event.data2 = data;
  }

  /**
   * \brief Returns the ID of the window associated with the event.
   *
   * \return the associated window ID.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto window_id() const noexcept -> u32
  {
    return m_event.windowID;
  }

  /**
   * \brief Returns the user-defined event code associated with the event.
   *
   * \return the associated event code.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto code() const noexcept -> i32
  {
    return m_event.code;
  }

  /**
   * \brief Returns a pointer to the first user data slot.
   *
   * \return a pointer to the user data, might be null.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto data_1() noexcept -> void*
  {
    return m_event.data1;
  }

  /// \copydoc data_1()
  [[nodiscard]] auto data_1() const noexcept -> const void*
  {
    return m_event.data1;
  }

  /**
   * \brief Returns a pointer to the second user data slot.
   *
   * \return a pointer to the user data, might be null.
   *
   * \since 6.3.0
   */
  [[nodiscard]] auto data_2() noexcept -> void*
  {
    return m_event.data2;
  }

  /// \copydoc data_2()
  [[nodiscard]] auto data_2() const noexcept -> const void*
  {
    return m_event.data2;
  }
};

template <>
inline auto as_sdl_event(const common_event<SDL_UserEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.user = event.get();
  return e;
}

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_USER_EVENT_HEADER

// #include "centurion/events/window_event.hpp"
#ifndef CENTURION_WINDOW_EVENT_HEADER
#define CENTURION_WINDOW_EVENT_HEADER

#include <SDL.h>

// #include "common_event.hpp"

// #include "window_event_id.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \class window_event
 *
 * \brief Represents an event that is associated with an action related to a
 * window.
 *
 * \see `SDL_WindowEvent`
 *
 * \since 4.0.0
 */
class window_event final : public common_event<SDL_WindowEvent>
{
 public:
  /**
   * \brief Creates a window event.
   *
   * \since 4.0.0
   */
  window_event() noexcept : common_event{event_type::window}
  {}

  /**
   * \brief Creates a window event based on the supplied SDL window event.
   *
   * \param event the SDL window event that will be copied.
   *
   * \since 4.0.0
   */
  explicit window_event(const SDL_WindowEvent& event) noexcept : common_event{event}
  {}

  /**
   * \brief Returns the event ID of this window event.
   *
   * \details There are many different kinds of window events, use this function to check
   * what kind of action that triggered this event.
   *
   * \return the event ID of this window event.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto event_id() const noexcept -> window_event_id
  {
    return static_cast<window_event_id>(m_event.event);
  }

  /**
   * \brief Returns the value of the first data value.
   *
   * \details The meaning of this value is dependent on the window event ID of this window
   * event.
   *
   * For instance, if the event ID is `window_event_id::size_changed`, then data1 and
   * data2 represent the new width and height of the window respectively. See the
   * `window_event_id` documentation for more details about whether the value returned
   * from this function is meaningful in regard to the window event ID.
   *
   * \return the value of the first data value.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto data_1() const noexcept -> i32
  {
    return m_event.data1;
  }

  /**
   * \brief Returns the value of the second data value.
   *
   * \details The meaning of this value is dependent on the window event ID of this window
   * event.
   *
   * For instance, if the event ID is `window_event_id::size_changed`, then data1 and
   * data2 represent the new width and height of the window respectively. See the
   * `window_event_id` documentation for more details about whether the value returned
   * from this function is meaningful in regard to the window event ID.
   *
   * \return the value of the second data value.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto data_2() const noexcept -> i32
  {
    return m_event.data2;
  }
};

/// \name SDL event conversions
/// \{

template <>
inline auto as_sdl_event(const common_event<SDL_WindowEvent>& event) -> SDL_Event
{
  SDL_Event e;
  e.window = event.get();
  return e;
}

/// \} End of SDL event conversions

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_WINDOW_EVENT_HEADER

// #include "centurion/events/window_event_id.hpp"
#ifndef CENTURION_WINDOW_EVENT_ID_HEADER
#define CENTURION_WINDOW_EVENT_ID_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup event
/// \{

/**
 * \enum window_event_id
 *
 * \brief Represents different flavours of window events.
 *
 * \details Depending on the event ID of a `window_event` instance, the
 * `window_event::data_1()` and `window_event::data_2()` methods have special meanings.
 *
 * | ID             | data_1 | data_2 |
 * | -------------- | ------ | ------ |
 * | `none`         | N/A    | N/A    |
 * | `shown`        | N/A    | N/A    |
 * | `hidden`       | N/A    | N/A    |
 * | `exposed`      | N/A    | N/A    |
 * | `moved`        | X      | Y      |
 * | `resized`      | Width  | Height |
 * | `size_changed` | Width  | Height |
 * | `minimized`    | N/A    | N/A    |
 * | `maximized`    | N/A    | N/A    |
 * | `restored`     | N/A    | N/A    |
 * | `enter`        | N/A    | N/A    |
 * | `leave`        | N/A    | N/A    |
 * | `focus_gained` | N/A    | N/A    |
 * | `focus_lost`   | N/A    | N/A    |
 * | `close`        | N/A    | N/A    |
 * | `take_focus`   | N/A    | N/A    |
 * | `hit_test`     | N/A    | N/A    |
 *
 * \since 4.0.0
 */
enum class window_event_id
{
  none = SDL_WINDOWEVENT_NONE,
  shown = SDL_WINDOWEVENT_SHOWN,
  hidden = SDL_WINDOWEVENT_HIDDEN,
  exposed = SDL_WINDOWEVENT_EXPOSED,
  moved = SDL_WINDOWEVENT_MOVED,
  resized = SDL_WINDOWEVENT_RESIZED,
  size_changed = SDL_WINDOWEVENT_SIZE_CHANGED,
  minimized = SDL_WINDOWEVENT_MINIMIZED,
  maximized = SDL_WINDOWEVENT_MAXIMIZED,
  restored = SDL_WINDOWEVENT_RESTORED,
  enter = SDL_WINDOWEVENT_ENTER,
  leave = SDL_WINDOWEVENT_LEAVE,
  focus_gained = SDL_WINDOWEVENT_FOCUS_GAINED,
  focus_lost = SDL_WINDOWEVENT_FOCUS_LOST,
  close = SDL_WINDOWEVENT_CLOSE,
  take_focus = SDL_WINDOWEVENT_TAKE_FOCUS,
  hit_test = SDL_WINDOWEVENT_HIT_TEST
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied window event ID.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(window_event_id::enter) == "enter"`.
 *
 * \param id the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const window_event_id id) -> std::string_view
{
  switch (id) {
    case window_event_id::none:
      return "none";

    case window_event_id::shown:
      return "shown";

    case window_event_id::hidden:
      return "hidden";

    case window_event_id::exposed:
      return "exposed";

    case window_event_id::moved:
      return "moved";

    case window_event_id::resized:
      return "resized";

    case window_event_id::size_changed:
      return "size_changed";

    case window_event_id::minimized:
      return "minimized";

    case window_event_id::maximized:
      return "maximized";

    case window_event_id::restored:
      return "restored";

    case window_event_id::enter:
      return "enter";

    case window_event_id::leave:
      return "leave";

    case window_event_id::focus_gained:
      return "focus_gained";

    case window_event_id::focus_lost:
      return "focus_lost";

    case window_event_id::close:
      return "close";

    case window_event_id::take_focus:
      return "take_focus";

    case window_event_id::hit_test:
      return "hit_test";

    default:
      throw cen_error{"Did not recognize window event ID!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a window event ID enumerator.
 *
 * \param stream the output stream that will be used.
 * \param id the enumerator that will be printed.
 *
 * \see `to_string(window_event_id)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const window_event_id id) -> std::ostream&
{
  return stream << to_string(id);
}

/// \} End of streaming

/// \name Window event ID comparison operators
/// \{

/**
 * \brief Indicates whether or not two window event ID values are the same.
 *
 * \param lhs the left-hand side window event ID value.
 * \param rhs the right-hand side window event ID value.
 *
 * \return `true` if the window event ID values are the same; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator==(const window_event_id lhs,
                                        const SDL_WindowEventID rhs) noexcept -> bool
{
  return static_cast<SDL_WindowEventID>(lhs) == rhs;
}

/// \copydoc operator==(window_event_id, SDL_WindowEventID)
[[nodiscard]] constexpr auto operator==(const SDL_WindowEventID lhs,
                                        const window_event_id rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two window event ID values aren't the same.
 *
 * \param lhs the left-hand side window event ID value.
 * \param rhs the right-hand side window event ID value.
 *
 * \return `true` if the window event ID values aren't the same; `false`
 * otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator!=(const window_event_id lhs,
                                        const SDL_WindowEventID rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(window_event_id, SDL_WindowEventID)
[[nodiscard]] constexpr auto operator!=(const SDL_WindowEventID lhs,
                                        const window_event_id rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of window event ID comparison operators

/// \} End of group event

}  // namespace cen

#endif  // CENTURION_WINDOW_EVENT_ID_HEADER

// #include "centurion/filesystem/base_path.hpp"
#ifndef CENTURION_BASE_PATH_HEADER
#define CENTURION_BASE_PATH_HEADER

#include <SDL.h>

// #include "../core/sdl_string.hpp"
#ifndef CENTURION_SDL_STRING_HEADER
#define CENTURION_SDL_STRING_HEADER

#include <SDL.h>

#include <memory>  // unique_ptr
#include <string>  // string

// #include "../detail/sdl_deleter.hpp"
#ifndef CENTURION_DETAIL_SDL_DELETER_HEADER
#define CENTURION_DETAIL_SDL_DELETER_HEADER

#include <SDL.h>

/// \cond FALSE
namespace cen::detail {

template <typename T>
struct sdl_deleter final
{
  void operator()(T* ptr) noexcept
  {
    SDL_free(ptr);
  }
};

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_SDL_DELETER_HEADER

// #include "owner.hpp"
#ifndef CENTURION_OWNER_HEADER
#define CENTURION_OWNER_HEADER

// #include "sfinae.hpp"
#ifndef CENTURION_SFINAE_HEADER
#define CENTURION_SFINAE_HEADER

#include <type_traits>  // enable_if_t, is_same_v, is_integral_v, is_floating_point_v, ...

namespace cen {

/// \addtogroup core
/// \{

// clang-format off

/// Enables a template if the type is either integral of floating-point, but not a boolean.
template <typename T>
using enable_if_number_t = std::enable_if_t<!std::is_same_v<T, bool> &&
                                            (std::is_integral_v<T> ||
                                             std::is_floating_point_v<T>), int>;

// clang-format on

/// Enables a template if the type is a pointer.
template <typename T>
using enable_if_pointer_v = std::enable_if_t<std::is_pointer_v<T>, int>;

/// Enables a template if T is convertible to any of the specified types.
template <typename T, typename... Args>
using enable_if_convertible_t = std::enable_if_t<(std::is_convertible_v<T, Args> || ...), int>;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_SFINAE_HEADER


namespace cen {

/**
 * \typedef owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote ownership of raw pointers directly in code.
 *
 * \details If a function takes an `owner<T*>` as a parameter, then the function will
 * claim ownership of that pointer. Subsequently, if a function returns an `owner<T*>`,
 * then ownership is transferred to the caller.
 */
template <typename T, enable_if_pointer_v<T> = 0>
using owner = T;

/**
 * \typedef maybe_owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote conditional ownership of raw pointers directly in code.
 *
 * \details This is primarily used in constructors of owner/handle classes, where the
 * owner version will claim ownership of the pointer, whilst the handle does not.
 *
 * \since 6.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using maybe_owner = T;

}  // namespace cen

#endif  // CENTURION_OWNER_HEADER
// #include "str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class sdl_string
 *
 * \brief Represents an SDL string.
 *
 * \details Certain SDL APIs return `char*` strings that need to be freed using
 * `SDL_free`, this class serves as a small wrapper around such strings. Use the `copy()`
 * member function to convert the string into a corresponding `std::string`.
 *
 * \note Instances of `sdl_string` might manage null strings. Use the overloaded `operator
 * bool()` in order to determine whether or not any associated string is null.
 *
 * \since 5.0.0
 */
class sdl_string final
{
 public:
  /**
   * \brief Creates a string.
   *
   * \param str the string that will be claimed, can be null.
   *
   * \since 5.0.0
   */
  explicit sdl_string(owner<char*> str) noexcept : m_str{str}
  {}

  /**
   * \brief Returns the internal string, which might be null.
   *
   * \return the internal string; `nullptr` if there is none.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get() const noexcept -> str
  {
    return m_str.get();
  }

  /**
   * \brief Returns a copy of the internal string.
   *
   * \details This function returns the empty string if the internal string is a null
   * pointer.
   *
   * \return a copy of the internal string.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto copy() const -> std::string
  {
    if (m_str) {
      return std::string{get()};
    }
    else {
      return std::string{};
    }
  }

  /**
   * \brief Indicates whether or not the internal string is non-null.
   *
   * \return `true` if the internal string is non-null; `false` otherwise.
   *
   * \since 5.0.0
   */
  explicit operator bool() const noexcept
  {
    return m_str.operator bool();
  }

 private:
  std::unique_ptr<char, detail::sdl_deleter<char>> m_str;
};

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_SDL_STRING_HEADER


namespace cen {

/// \addtogroup filesystem
/// \{

/**
 * \brief Returns the "base" path associated with the application.
 *
 * \details The returned string represents the path to the directory from which
 * application was run from, and will end with a path separator (e.g. "\\" or "/").
 *
 * \note This might be an expensive operation, so it's recommended to only call this
 * function once and cache the returned path.
 *
 * \return the base path of the application; a null string is returned if the path cannot
 * be obtained.
 *
 * \since 5.2.0
 */
[[nodiscard]] inline auto base_path() -> sdl_string
{
  return sdl_string{SDL_GetBasePath()};
}

/// \} End of group filesystem

}  // namespace cen

#endif  // CENTURION_BASE_PATH_HEADER

// #include "centurion/filesystem/file.hpp"
#ifndef CENTURION_FILE_HEADER
#define CENTURION_FILE_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#include <cassert>   // assert
#include <cstddef>   // size_t
#include <memory>    // unique_ptr
#include <optional>  // optional
#include <string>    // string

// #include "../core/integers.hpp"
#ifndef CENTURION_INTEGERS_HEADER
#define CENTURION_INTEGERS_HEADER

#include <SDL.h>

#include <cstddef>  // size_t

namespace cen {

/// \addtogroup core
/// \{

/// \name Integer aliases
/// \{

using usize = std::size_t;

/// Alias for an unsigned integer.
using uint = unsigned int;

/// Alias for the type used for integer literal operators.
using ulonglong = unsigned long long;

/// Alias for a 64-bit unsigned integer.
using u64 = Uint64;

/// Alias for a 32-bit unsigned integer.
using u32 = Uint32;

/// Alias for a 16-bit unsigned integer.
using u16 = Uint16;

/// Alias for an 8-bit unsigned integer.
using u8 = Uint8;

/// Alias for a 64-bit signed integer.
using i64 = Sint64;

/// Alias for a 32-bit signed integer.
using i32 = Sint32;

/// Alias for a 16-bit signed integer.
using i16 = Sint16;

/// Alias for an 8-bit signed integer.
using i8 = Sint8;

/// \} End of integer aliases

// clang-format off

/**
 * \brief Obtains the size of a container as an `int`.
 *
 * \tparam T a "container" that provides a `size()` member function.
 *
 * \param container the container to query the size of.
 *
 * \return the size of the container as an `int` value.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto isize(const T& container) noexcept(noexcept(container.size()))
    -> int
{
  return static_cast<int>(container.size());
}

// clang-format on

namespace literals {

/**
 * \brief Creates an 8-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u8(const ulonglong value) noexcept -> u8
{
  return static_cast<u8>(value);
}

/**
 * \brief Creates a 16-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u16(const ulonglong value) noexcept -> u16
{
  return static_cast<u16>(value);
}

/**
 * \brief Creates a 32-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u32(const ulonglong value) noexcept -> u32
{
  return static_cast<u32>(value);
}

/**
 * \brief Creates a 64-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u64(const ulonglong value) noexcept -> u64
{
  return static_cast<u64>(value);
}

/**
 * \brief Creates an 8-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i8(const ulonglong value) noexcept -> i8
{
  return static_cast<i8>(value);
}

/**
 * \brief Creates a 16-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i16(const ulonglong value) noexcept -> i16
{
  return static_cast<i16>(value);
}

/**
 * \brief Creates a 32-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i32(const ulonglong value) noexcept -> i32
{
  return static_cast<i32>(value);
}

/**
 * \brief Creates a 64-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i64(const ulonglong value) noexcept -> i64
{
  return static_cast<i64>(value);
}

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_INTEGERS_HEADER

// #include "../core/not_null.hpp"
#ifndef CENTURION_NOT_NULL_HEADER
#define CENTURION_NOT_NULL_HEADER

// #include "sfinae.hpp"


namespace cen {

/**
 * \typedef not_null
 *
 * \ingroup core
 *
 * \brief Tag used to indicate that a pointer cannot be null.
 *
 * \note This alias is equivalent to `T`, it is a no-op.
 *
 * \since 5.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using not_null = T;

}  // namespace cen

#endif  // CENTURION_NOT_NULL_HEADER

// #include "../core/result.hpp"
#ifndef CENTURION_RESULT_HEADER
#define CENTURION_RESULT_HEADER

#include <ostream>  // ostream
#include <string>   // string

namespace cen {

/// \addtogroup core
/// \{

/**
 * \class result
 *
 * \brief A simple indicator for the result of different operations.
 *
 * \details The idea behind this class is to make results of various operations
 * unambiguous. Quite an amount of functions in the library may fail, and earlier versions
 * of Centurion would usually return a `bool` in those cases, where `true` and `false`
 * would indicate success and failure, respectively. This class is a development of that
 * practice. For instance, this class is contextually convertible to `bool`, where a
 * successful result is still converted to `true`, and vice versa. However, this class
 * also enables explicit checks against `success` and `failure` constants, which makes
 * code very easy to read and unambiguous.
 * \code{cpp}
 *   cen::window window;
 *
 *   if (window.set_opacity(0.4f))
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::success)
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::failure)
 *   {
 *     // Failure!
 *   }
 * \endcode
 *
 * \see `success`
 * \see `failure`
 *
 * \since 6.0.0
 */
class result final
{
 public:
  /**
   * \brief Creates a result.
   *
   * \param success `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  constexpr result(const bool success) noexcept  // NOLINT implicit
      : m_success{success}
  {}

  /// \name Comparison operators
  /// \{

  /**
   * \brief Indicates whether or not two results have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results are equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator==(const result other) const noexcept -> bool
  {
    return m_success == other.m_success;
  }

  /**
   * \brief Indicates whether or not two results don't have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results aren't equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator!=(const result other) const noexcept -> bool
  {
    return !(*this == other);
  }

  /// \} End of comparison operators

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not the result is successful.
   *
   * \return `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr explicit operator bool() const noexcept
  {
    return m_success;
  }

  /// \} End of conversions

 private:
  bool m_success{};
};

/// Represents a successful result.
/// \since 6.0.0
inline constexpr result success{true};

/// Represents a failure of some kind.
/// \since 6.0.0
inline constexpr result failure{false};

/// \name String conversions
/// \{

/**
 * \brief Returns a string that represents a result value.
 *
 * \note The returned string is in a slightly different format compared to other Centurion
 * components.
 *
 * \param result the value that will be converted.
 *
 * \return `"success"` for a successful result; `"failure"` otherwise.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto to_string(const result result) -> std::string
{
  return result ? "success" : "failure";
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a result value using a stream.
 *
 * \param stream the stream that will be used.
 * \param result the result value that will be printed.
 *
 * \return the used stream.
 *
 * \since 6.0.0
 */
inline auto operator<<(std::ostream& stream, const result result) -> std::ostream&
{
  return stream << to_string(result);
}

/// \} End of streaming

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_RESULT_HEADER

// #include "../core/str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER

// #include "../core/to_underlying.hpp"
#ifndef CENTURION_TO_UNDERLYING_HEADER
#define CENTURION_TO_UNDERLYING_HEADER

#include <type_traits>  // underlying_type_t, enable_if_t, is_enum_v

namespace cen {

/**
 * \brief Converts an enum value to an integral value using the underlying type.
 *
 * \ingroup core
 *
 * \note If you're using C++23, see `std::to_underlying()`.
 *
 * \tparam Enum the enum type.
 *
 * \param value the enum value that will be converted.
 *
 * \return the value of the enum, in the underlying type.
 *
 * \since 6.0.0
 */
template <typename Enum, std::enable_if_t<std::is_enum_v<Enum>, int> = 0>
[[nodiscard]] constexpr auto to_underlying(const Enum value) noexcept
    -> std::underlying_type_t<Enum>
{
  return static_cast<std::underlying_type_t<Enum>>(value);
}

}  // namespace cen

#endif  // CENTURION_TO_UNDERLYING_HEADER

// #include "file_mode.hpp"
#ifndef CENTURION_FILE_MODE_HEADER
#define CENTURION_FILE_MODE_HEADER

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER


namespace cen {

/// \addtogroup filesystem
/// \{

/**
 * \enum file_mode
 *
 * \brief Provides values that represent different file modes.
 *
 * \details This enum provides values that directly correspond to each of the possible SDL
 * file mode strings, such as "r" or "rb".
 *
 * \since 5.3.0
 */
enum class file_mode
{
  read_existing,         ///< "r"
  read_existing_binary,  ///< "rb"

  write,         ///< "w"
  write_binary,  ///< "wb"

  append_or_create,         ///< "a"
  append_or_create_binary,  ///< "ab"

  read_write_existing,         ///< "r+"
  read_write_existing_binary,  ///< "rb+"

  read_write_replace,         ///< "w+"
  read_write_replace_binary,  ///< "wb+"

  read_append,        ///< "a+"
  read_append_binary  ///< "ab+"
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied file mode.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(file_mode::read_append) == "read_append"`.
 *
 * \param mode the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const file_mode mode) -> std::string_view
{
  switch (mode) {
    case file_mode::read_existing:
      return "read_existing";

    case file_mode::read_existing_binary:
      return "read_existing_binary";

    case file_mode::write:
      return "write";

    case file_mode::write_binary:
      return "write_binary";

    case file_mode::append_or_create:
      return "append_or_create";

    case file_mode::append_or_create_binary:
      return "append_or_create_binary";

    case file_mode::read_write_existing:
      return "read_write_existing";

    case file_mode::read_write_existing_binary:
      return "read_write_existing_binary";

    case file_mode::read_write_replace:
      return "read_write_replace";

    case file_mode::read_write_replace_binary:
      return "read_write_replace_binary";

    case file_mode::read_append:
      return "read_append";

    case file_mode::read_append_binary:
      return "read_append_binary";

    default:
      throw cen_error{"Did not recognize file mode!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a file mode enumerator.
 *
 * \param stream the output stream that will be used.
 * \param mode the enumerator that will be printed.
 *
 * \see `to_string(file_mode)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const file_mode mode) -> std::ostream&
{
  return stream << to_string(mode);
}

/// \} End of streaming

/// \} End of group filesystem

}  // namespace cen

#endif  // CENTURION_FILE_MODE_HEADER

// #include "file_type.hpp"
#ifndef CENTURION_FILE_TYPE_HEADER
#define CENTURION_FILE_TYPE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup filesystem
/// \{

/**
 * \enum file_type
 *
 * \brief Provides values that represent different file types.
 *
 * \since 5.3.0
 */
enum class file_type : uint
{
  unknown = SDL_RWOPS_UNKNOWN,     ///< An unknown file type.
  win32 = SDL_RWOPS_WINFILE,       ///< A Win32 file.
  stdio = SDL_RWOPS_STDFILE,       ///< A STDIO file.
  jni = SDL_RWOPS_JNIFILE,         ///< An Android asset file.
  memory = SDL_RWOPS_MEMORY,       ///< A memory stream file.
  memory_ro = SDL_RWOPS_MEMORY_RO  ///< A read-only memory stream file.
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied file type.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(file_type::stdio) == "stdio"`.
 *
 * \param type the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const file_type type) -> std::string_view
{
  switch (type) {
    case file_type::unknown:
      return "unknown";

    case file_type::win32:
      return "win32";

    case file_type::stdio:
      return "stdio";

    case file_type::jni:
      return "jni";

    case file_type::memory:
      return "memory";

    case file_type::memory_ro:
      return "memory_ro";

    default:
      throw cen_error{"Did not recognize file type!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a file type enumerator.
 *
 * \param stream the output stream that will be used.
 * \param type the enumerator that will be printed.
 *
 * \see `to_string(file_type)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const file_type type) -> std::ostream&
{
  return stream << to_string(type);
}

/// \} End of streaming

/// \} End of group filesystem

}  // namespace cen

#endif  // CENTURION_FILE_TYPE_HEADER

// #include "seek_mode.hpp"
#ifndef CENTURION_SEEK_MODE_HEADER
#define CENTURION_SEEK_MODE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup filesystem
/// \{

/**
 * \enum seek_mode
 *
 * \brief Provides values that represent various file seek modes.
 *
 * \since 5.3.0
 */
enum class seek_mode
{
  from_beginning = RW_SEEK_SET,       ///< From the beginning.
  relative_to_current = RW_SEEK_CUR,  ///< Relative to the current read point.
  relative_to_end = RW_SEEK_END       ///< Relative to the end.
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied seek mode.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(seek_mode::from_beginning) == "from_beginning"`.
 *
 * \param mode the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const seek_mode mode) -> std::string_view
{
  switch (mode) {
    case seek_mode::from_beginning:
      return "from_beginning";

    case seek_mode::relative_to_current:
      return "relative_to_current";

    case seek_mode::relative_to_end:
      return "relative_to_end";

    default:
      throw cen_error{"Did not recognize seek mode!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a seek mode enumerator.
 *
 * \param stream the output stream that will be used.
 * \param mode the enumerator that will be printed.
 *
 * \see `to_string(seek_mode)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const seek_mode mode) -> std::ostream&
{
  return stream << to_string(mode);
}

/// \} End of streaming

/// \} End of group filesystem

}  // namespace cen

#endif  // CENTURION_SEEK_MODE_HEADER


namespace cen {

/// \addtogroup filesystem
/// \{

/**
 * \class file
 *
 * \brief Represents a file "context" or handle.
 *
 * \note This class differs slightly from other library classes in that it is owning, but
 * it does *not* throw if the internal pointer can't be created, etc. This is because file
 * operations are error-prone, so we want to avoid throwing a bunch of exceptions, for
 * performance reasons.
 *
 * \since 5.3.0
 */
class file final
{
 public:
  using size_type = std::size_t;

  /// \name Construction
  /// \{

  /**
   * \brief Creates a file handle based on an existing context.
   *
   * \param context the context that will be used.
   *
   * \since 5.3.0
   */
  explicit file(SDL_RWops* context) noexcept : m_context{context}
  {}

  /**
   * \brief Opens the file at the specified file path.
   *
   * \details Be sure to check the validity of the file, after construction.
   * \code{cpp}
   *   cen::file file{"foo", cen::file_mode::read_existing_binary};
   *   if (file) {
   *     // File was opened successfully!
   *   }
   * \endcode
   *
   * \param path the path of the file.
   * \param mode the mode that will be used to open the file.
   *
   * \since 5.3.0
   */
  file(const not_null<str> path, const file_mode mode) noexcept
      : m_context{SDL_RWFromFile(path, to_string(mode))}
  {}

  /// \copydoc file(not_null<str>, file_mode)
  file(const std::string& path, const file_mode mode) noexcept : file{path.c_str(), mode}
  {}

  /// \} End of construction

  /// \name Write API
  /// \{

  /**
   * \brief Writes the supplied data to the file.
   *
   * \tparam T the type of the data.
   *
   * \param data a pointer to the data that will be written to the file.
   * \param count the number of objects that will be written.
   *
   * \return the number of objects that were written to the file.
   *
   * \since 5.3.0
   */
  template <typename T>
  auto write(not_null<const T*> data, const size_type count) noexcept -> size_type
  {
    assert(m_context);
    return SDL_RWwrite(get(), data, sizeof(T), count);
  }

  /**
   * \brief Writes the contents of an array to the file, whose size is known at
   * compile-time.
   *
   * \tparam T the type of the array elements.
   * \tparam size the size of the array.
   *
   * \param data the data that will be written.
   *
   * \return the number of objects that were written.
   *
   * \since 5.3.0
   */
  template <typename T, size_type size>
  auto write(const T (&data)[size]) noexcept -> size_type
  {
    return write(data, size);
  }

  // clang-format off

  /**
   * \brief Writes the contents of a container to the file.
   *
   * \pre `Container` *must* be a collection that stores its data contiguously! The
   * behaviour of this function is undefined otherwise.
   *
   * \tparam Container a contiguous container, e.g. `std::vector` or `std::array`.
   *
   * \param container the container that will be written to the file.
   *
   * \return the number of objects that were written.
   *
   * \since 5.3.0
   */
  template <typename Container>
  auto write(const Container& container) noexcept(noexcept(container.data()) &&
                                                  noexcept(container.size()))
      -> size_type
  {
    return write(container.data(), container.size());
  }

  // clang-format on

  /**
   * \brief Writes an unsigned 8-bit integer to the file.
   *
   * \pre the internal file context must not be null.
   *
   * \param value the value that will be written.
   *
   * \return `success` if the value was written to the file; `failure` otherwise.
   *
   * \since 5.3.0
   */
  auto write_byte(const u8 value) noexcept -> result
  {
    assert(m_context);
    return SDL_WriteU8(m_context.get(), value) == 1;
  }

  /**
   * \brief Writes an unsigned 16-bit integer to the file, as a little endian value.
   *
   * \pre the internal file context must not be null.
   *
   * \param value the value that will be written, in the native endianness.
   *
   * \return `success` if the value was written to the file; `failure` otherwise.
   *
   * \since 5.3.0
   */
  auto write_as_little_endian(const u16 value) noexcept -> result
  {
    assert(m_context);
    return SDL_WriteLE16(m_context.get(), value) == 1;
  }

  /**
   * \brief Writes an unsigned 32-bit integer to the file, as a little endian value.
   *
   * \pre the internal file context must not be null.
   *
   * \param value the value that will be written, in the native endianness.
   *
   * \return `success` if the value was written to the file; `failure` otherwise.
   *
   * \since 5.3.0
   */
  auto write_as_little_endian(const u32 value) noexcept -> result
  {
    assert(m_context);
    return SDL_WriteLE32(m_context.get(), value) == 1;
  }

  /**
   * \brief Writes an unsigned 64-bit integer to the file, as a little endian value.
   *
   * \pre the internal file context must not be null.
   *
   * \param value the value that will be written, in the native endianness.
   *
   * \return `success` if the value was written to the file; `failure` otherwise.
   *
   * \since 5.3.0
   */
  auto write_as_little_endian(const u64 value) noexcept -> result
  {
    assert(m_context);
    return SDL_WriteLE64(m_context.get(), value) == 1;
  }

  /**
   * \brief Writes an unsigned 16-bit integer to the file, as a big endian value.
   *
   * \pre the internal file context must not be null.
   *
   * \param value the value that will be written, in the native endianness.
   *
   * \return `success` if the value was written to the file; `failure` otherwise.
   *
   * \since 5.3.0
   */
  auto write_as_big_endian(const u16 value) noexcept -> result
  {
    assert(m_context);
    return SDL_WriteBE16(m_context.get(), value) == 1;
  }

  /**
   * \brief Writes an unsigned 32-bit integer to the file, as a big endian value.
   *
   * \pre the internal file context must not be null.
   *
   * \param value the value that will be written, in the native endianness.
   *
   * \return `success` if the value was written to the file; `failure` otherwise.
   *
   * \since 5.3.0
   */
  auto write_as_big_endian(const u32 value) noexcept -> result
  {
    assert(m_context);
    return SDL_WriteBE32(m_context.get(), value) == 1;
  }

  /**
   * \brief Writes an unsigned 64-bit integer to the file, as a big endian value.
   *
   * \pre the internal file context must not be null.
   *
   * \param value the value that will be written, in the native endianness.
   *
   * \return `success` if the value was written to the file; `failure` otherwise.
   *
   * \since 5.3.0
   */
  auto write_as_big_endian(const u64 value) noexcept -> result
  {
    assert(m_context);
    return SDL_WriteBE64(m_context.get(), value) == 1;
  }

  /// \} End of write API

  /// \name Read API
  /// \{

  /**
   * \brief Reads data from the file.
   *
   * \pre the internal file context must not be null.
   *
   * \tparam T the type of the data that will be read.
   *
   * \param[out] data the pointer to which the read data will be written to.
   * \param maxCount the maximum number of objects that will be read.
   *
   * \return the number of objects that were read.
   *
   * \since 5.3.0
   */
  template <typename T>
  auto read_to(T* data, const size_type maxCount) noexcept -> size_type
  {
    assert(m_context);
    return SDL_RWread(m_context.get(), data, sizeof(T), maxCount);
  }

  /**
   * \brief Reads data from the file to an array whose size is known at compile-time. This
   * function uses the size of the supplied array to determine the amount of elements to
   * read.
   *
   * \pre the internal file context must not be null.
   *
   * \tparam T the type of the data that will be read.
   * \tparam size the size of the array.
   *
   * \param[out] data the pointer to which the read data will be written to.
   *
   * \return the number of objects that were read.
   *
   * \since 5.3.0
   */
  template <typename T, size_type size>
  auto read_to(T (&data)[size]) noexcept -> size_type
  {
    return read_to(data, size);
  }

  // clang-format off

  /**
   * \brief Reads data from the file to a container. This function uses the size of the
   * supplied container to determine the amount of elements to read.
   *
   * \pre the internal file context must not be null.
   * \pre `Container` *must* be a collection that stores its data contiguously! The
   * behaviour of this function is undefined otherwise.
   *
   * \tparam Container the type of the data that will be read, e.g. `std::vector` or
   * `std::array`.
   *
   * \param[out] container the container to which the read data will be written to.
   *
   * \return the number of objects that were read.
   *
   * \since 5.3.0
   */
  template <typename Container>
  auto read_to(Container& container) noexcept(noexcept(container.data()) &&
                                              noexcept(container.size()))
      -> size_type
  {
    return read_to(container.data(), container.size());
  }

  // clang-format on

  // Reads a value of type T, where T must be default-constructible

  /**
   * \brief Reads a single value from the file.
   *
   * \pre the internal file context must not be null.
   *
   * \note `T` must be default-constructible in order to use this function.
   *
   * \tparam T the type of the value, which must be default-constructible.
   *
   * \return the read value.
   *
   * \since 5.3.0
   */
  template <typename T>
  auto read() noexcept(noexcept(T{})) -> T
  {
    T value{};
    read_to(&value, 1);
    return value;
  }

  /**
   * \brief Reads an unsigned 8-bit integer from the file.
   *
   * \pre the internal file context must not be null.
   *
   * \return the read value.
   *
   * \since 5.3.0
   */
  auto read_byte() noexcept -> u8
  {
    assert(m_context);
    return SDL_ReadU8(m_context.get());
  }

  /**
   * \brief Reads an unsigned 16-bit integer from the file, as a little endian value.
   *
   * \pre the internal file context must not be null.
   *
   * \return the read value.
   *
   * \since 5.3.0
   */
  auto read_little_endian_u16() noexcept -> u16
  {
    assert(m_context);
    return SDL_ReadLE16(m_context.get());
  }

  /**
   * \brief Reads an unsigned 32-bit integer from the file, as a little endian value.
   *
   * \pre the internal file context must not be null.
   *
   * \return the read value.
   *
   * \since 5.3.0
   */
  auto read_little_endian_u32() noexcept -> u32
  {
    assert(m_context);
    return SDL_ReadLE32(m_context.get());
  }

  /**
   * \brief Reads an unsigned 64-bit integer from the file, as a little endian value.
   *
   * \pre the internal file context must not be null.
   *
   * \return the read value.
   *
   * \since 5.3.0
   */
  auto read_little_endian_u64() noexcept -> u64
  {
    assert(m_context);
    return SDL_ReadLE64(m_context.get());
  }

  /**
   * \brief Reads an unsigned 16-bit integer from the file, as a big endian value.
   *
   * \pre the internal file context must not be null.
   *
   * \return the read value.
   *
   * \since 5.3.0
   */
  auto read_big_endian_u16() noexcept -> u16
  {
    assert(m_context);
    return SDL_ReadBE16(m_context.get());
  }

  /**
   * \brief Reads an unsigned 32-bit integer from the file, as a big endian value.
   *
   * \pre the internal file context must not be null.
   *
   * \return the read value.
   *
   * \since 5.3.0
   */
  auto read_big_endian_u32() noexcept -> u32
  {
    assert(m_context);
    return SDL_ReadBE32(m_context.get());
  }

  /**
   * \brief Reads an unsigned 64-bit integer from the file, as a big endian value.
   *
   * \pre the internal file context must not be null.
   *
   * \return the read value.
   *
   * \since 5.3.0
   */
  auto read_big_endian_u64() noexcept -> u64
  {
    assert(m_context);
    return SDL_ReadBE64(m_context.get());
  }

  /// \} End of read API

  /// \name File type queries
  /// \{

#ifndef CENTURION_NO_SDL_IMAGE

  /**
   * \brief Indicates whether or not the file represents a PNG image.
   *
   * \return `true` if the file is a PNG image; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_png() const noexcept -> bool
  {
    return IMG_isPNG(m_context.get()) == 1;
  }

  /**
   * \brief Indicates whether or not the file represents an ICO image.
   *
   * \return `true` if the file is an ICO image; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_ico() const noexcept -> bool
  {
    return IMG_isICO(m_context.get()) == 1;
  }

  /**
   * \brief Indicates whether or not the file represents a JPG image.
   *
   * \return `true` if the file is a JPG image; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_jpg() const noexcept -> bool
  {
    return IMG_isJPG(m_context.get()) == 1;
  }

  /**
   * \brief Indicates whether or not the file represents a BMP image.
   *
   * \return `true` if the file is a BMP image; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_bmp() const noexcept -> bool
  {
    return IMG_isBMP(m_context.get()) == 1;
  }

  /**
   * \brief Indicates whether or not the file represents a GIF.
   *
   * \return `true` if the file is a GIF; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_gif() const noexcept -> bool
  {
    return IMG_isGIF(m_context.get()) == 1;
  }

  /**
   * \brief Indicates whether or not the file represents an SVG image.
   *
   * \return `true` if the file is an SVG image; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_svg() const noexcept -> bool
  {
    return IMG_isSVG(m_context.get()) == 1;
  }

  /**
   * \brief Indicates whether or not the file represents a WEBP image.
   *
   * \return `true` if the file is a WEBP image; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_webp() const noexcept -> bool
  {
    return IMG_isWEBP(m_context.get()) == 1;
  }

  /**
   * \brief Indicates whether or not the file represents a TIF image.
   *
   * \return `true` if the file is a TIF image; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_tif() const noexcept -> bool
  {
    return IMG_isTIF(m_context.get()) == 1;
  }

  /**
   * \brief Indicates whether or not the file represents a PNM image.
   *
   * \return `true` if the file is a PNM image; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_pnm() const noexcept -> bool
  {
    return IMG_isPNM(m_context.get()) == 1;
  }

  /**
   * \brief Indicates whether or not the file represents a PCX image.
   *
   * \return `true` if the file is a PCX image; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_pcx() const noexcept -> bool
  {
    return IMG_isPCX(m_context.get()) == 1;
  }

  /**
   * \brief Indicates whether or not the file represents an LBM image.
   *
   * \return `true` if the file is an LBM image; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_lbm() const noexcept -> bool
  {
    return IMG_isLBM(m_context.get()) == 1;
  }

  /**
   * \brief Indicates whether or not the file represents a CUR image.
   *
   * \return `true` if the file is a CUR image; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_cur() const noexcept -> bool
  {
    return IMG_isCUR(m_context.get()) == 1;
  }

  /**
   * \brief Indicates whether or not the file represents an XCF image.
   *
   * \return `true` if the file is an XCF image; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_xcf() const noexcept -> bool
  {
    return IMG_isXCF(m_context.get()) == 1;
  }

  /**
   * \brief Indicates whether or not the file represents an XPM image.
   *
   * \return `true` if the file is an XPM image; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_xpm() const noexcept -> bool
  {
    return IMG_isXPM(m_context.get()) == 1;
  }

  /**
   * \brief Indicates whether or not the file represents an XV image.
   *
   * \return `true` if the file is an XV image; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_xv() const noexcept -> bool
  {
    return IMG_isXV(m_context.get()) == 1;
  }

#endif  // CENTURION_NO_SDL_IMAGE

  /// \} End of file type queries

  /**
   * \brief Seeks to the specified offset, using the specified seek mode.
   *
   * \param offset the offset to seek to.
   * \param mode the seek mode that will be used.
   *
   * \return the resulting offset in the data stream; `std::nullopt` if something went
   * wrong.
   *
   * \since 5.3.0
   */
  [[nodiscard]] auto seek(const i64 offset, const seek_mode mode) noexcept
      -> std::optional<i64>
  {
    assert(m_context);
    const auto result = SDL_RWseek(m_context.get(), offset, to_underlying(mode));
    if (result != -1) {
      return result;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the current offset in the data stream.
   *
   * \return the current offset in the data stream.
   *
   * \since 5.3.0
   */
  [[nodiscard]] auto offset() const noexcept -> i64
  {
    assert(m_context);
    return SDL_RWtell(m_context.get());
  }

  /**
   * \brief Returns the file type associated with the instance.
   *
   * \return the associated file type.
   *
   * \since 5.3.0
   */
  [[nodiscard]] auto type() const noexcept -> file_type
  {
    assert(m_context);
    return static_cast<file_type>(m_context->type);
  }

  /**
   * \brief Returns the size of the file.
   *
   * \return the size of the file; `std::nullopt` if unknown.
   *
   * \since 5.3.0
   */
  [[nodiscard]] auto size() const noexcept -> std::optional<size_type>
  {
    assert(m_context);
    const auto result = SDL_RWsize(m_context.get());
    if (result != -1) {
      return result;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns a pointer to the internal file context.
   *
   * \return a pointer to the internal file context, can be null.
   *
   * \since 5.3.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_RWops*
  {
    return m_context.get();
  }

  /**
   * \brief Indicates whether or not the file holds a non-null pointer.
   *
   * \return `true` if the file holds a non-null pointer; `false` otherwise.
   *
   * \since 5.3.0
   */
  explicit operator bool() const noexcept
  {
    return m_context != nullptr;
  }

 private:
  struct deleter final
  {
    void operator()(SDL_RWops* context) noexcept
    {
      SDL_RWclose(context);
    }
  };
  std::unique_ptr<SDL_RWops, deleter> m_context;

  [[nodiscard]] static auto to_string(const file_mode mode) noexcept -> str
  {
    switch (mode) {
      default:
        assert(false);

      case file_mode::read_existing:
        return "r";

      case file_mode::read_existing_binary:
        return "rb";

      case file_mode::write:
        return "w";

      case file_mode::write_binary:
        return "wb";

      case file_mode::append_or_create:
        return "a";

      case file_mode::append_or_create_binary:
        return "ab";

      case file_mode::read_write_existing:
        return "r+";

      case file_mode::read_write_existing_binary:
        return "rb+";

      case file_mode::read_write_replace:
        return "w+";

      case file_mode::read_write_replace_binary:
        return "wb+";

      case file_mode::read_append:
        return "a+";

      case file_mode::read_append_binary:
        return "ab+";
    }
  }
};

/// \} End of group filesystem

}  // namespace cen

#endif  // CENTURION_FILE_HEADER

// #include "centurion/filesystem/file_mode.hpp"
#ifndef CENTURION_FILE_MODE_HEADER
#define CENTURION_FILE_MODE_HEADER

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup filesystem
/// \{

/**
 * \enum file_mode
 *
 * \brief Provides values that represent different file modes.
 *
 * \details This enum provides values that directly correspond to each of the possible SDL
 * file mode strings, such as "r" or "rb".
 *
 * \since 5.3.0
 */
enum class file_mode
{
  read_existing,         ///< "r"
  read_existing_binary,  ///< "rb"

  write,         ///< "w"
  write_binary,  ///< "wb"

  append_or_create,         ///< "a"
  append_or_create_binary,  ///< "ab"

  read_write_existing,         ///< "r+"
  read_write_existing_binary,  ///< "rb+"

  read_write_replace,         ///< "w+"
  read_write_replace_binary,  ///< "wb+"

  read_append,        ///< "a+"
  read_append_binary  ///< "ab+"
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied file mode.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(file_mode::read_append) == "read_append"`.
 *
 * \param mode the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const file_mode mode) -> std::string_view
{
  switch (mode) {
    case file_mode::read_existing:
      return "read_existing";

    case file_mode::read_existing_binary:
      return "read_existing_binary";

    case file_mode::write:
      return "write";

    case file_mode::write_binary:
      return "write_binary";

    case file_mode::append_or_create:
      return "append_or_create";

    case file_mode::append_or_create_binary:
      return "append_or_create_binary";

    case file_mode::read_write_existing:
      return "read_write_existing";

    case file_mode::read_write_existing_binary:
      return "read_write_existing_binary";

    case file_mode::read_write_replace:
      return "read_write_replace";

    case file_mode::read_write_replace_binary:
      return "read_write_replace_binary";

    case file_mode::read_append:
      return "read_append";

    case file_mode::read_append_binary:
      return "read_append_binary";

    default:
      throw cen_error{"Did not recognize file mode!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a file mode enumerator.
 *
 * \param stream the output stream that will be used.
 * \param mode the enumerator that will be printed.
 *
 * \see `to_string(file_mode)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const file_mode mode) -> std::ostream&
{
  return stream << to_string(mode);
}

/// \} End of streaming

/// \} End of group filesystem

}  // namespace cen

#endif  // CENTURION_FILE_MODE_HEADER

// #include "centurion/filesystem/file_type.hpp"
#ifndef CENTURION_FILE_TYPE_HEADER
#define CENTURION_FILE_TYPE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup filesystem
/// \{

/**
 * \enum file_type
 *
 * \brief Provides values that represent different file types.
 *
 * \since 5.3.0
 */
enum class file_type : uint
{
  unknown = SDL_RWOPS_UNKNOWN,     ///< An unknown file type.
  win32 = SDL_RWOPS_WINFILE,       ///< A Win32 file.
  stdio = SDL_RWOPS_STDFILE,       ///< A STDIO file.
  jni = SDL_RWOPS_JNIFILE,         ///< An Android asset file.
  memory = SDL_RWOPS_MEMORY,       ///< A memory stream file.
  memory_ro = SDL_RWOPS_MEMORY_RO  ///< A read-only memory stream file.
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied file type.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(file_type::stdio) == "stdio"`.
 *
 * \param type the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const file_type type) -> std::string_view
{
  switch (type) {
    case file_type::unknown:
      return "unknown";

    case file_type::win32:
      return "win32";

    case file_type::stdio:
      return "stdio";

    case file_type::jni:
      return "jni";

    case file_type::memory:
      return "memory";

    case file_type::memory_ro:
      return "memory_ro";

    default:
      throw cen_error{"Did not recognize file type!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a file type enumerator.
 *
 * \param stream the output stream that will be used.
 * \param type the enumerator that will be printed.
 *
 * \see `to_string(file_type)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const file_type type) -> std::ostream&
{
  return stream << to_string(type);
}

/// \} End of streaming

/// \} End of group filesystem

}  // namespace cen

#endif  // CENTURION_FILE_TYPE_HEADER

// #include "centurion/filesystem/preferred_path.hpp"
#ifndef CENTURION_PREFERRED_PATH_HEADER
#define CENTURION_PREFERRED_PATH_HEADER

#include <SDL.h>

#include <cassert>  // assert
#include <string>   // string

// #include "../core/not_null.hpp"

// #include "../core/sdl_string.hpp"

// #include "../core/str.hpp"


namespace cen {

/// \addtogroup filesystem
/// \{

/**
 * \brief Returns the preferred path for storing application related files.
 *
 * \details This function returns the path to the directory to which applications are
 * meant to write files such as preferences and save data, etc. This directory will be
 * unique per user and application. The returned path will end with a path separator (e.g.
 * "\\" or "/").
 *
 * \note Only use letters, numbers, and spaces in the supplied names!
 *
 * \param org the name of the organization, cannot be null.
 * \param app the name of the application, cannot be null.
 *
 * \return an absolute path to the preferred path for storing application files; a null
 * string is returned if something goes wrong.
 *
 * \since 5.2.0
 */
[[nodiscard]] inline auto preferred_path(const not_null<str> org, const not_null<str> app)
    -> sdl_string
{
  /* Looking at the SDL source code, it actually seems fine to supply a null
     string for the organization name. However, I haven't been able to find any
     documentation providing this guarantee, so we simply disallow null
     organization names. */
  assert(org);
  assert(app);
  return sdl_string{SDL_GetPrefPath(org, app)};
}

/**
 * \brief Returns the preferred path for storing application related files.
 *
 * \details This function returns the path to the directory to which applications are
 * meant to write files such as preferences and save data, etc. This directory will be
 * unique per user and application. The returned path will end with a path separator (e.g.
 * "\\" or "/").
 *
 * \note Only use letters, numbers, and spaces in the supplied names!
 *
 * \param org the name of the organization.
 * \param app the name of the application.
 *
 * \return an absolute path to the preferred path for storing application files; a null
 * string is returned if something goes wrong.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto preferred_path(const std::string& org, const std::string& app)
    -> sdl_string
{
  return preferred_path(org.c_str(), app.c_str());
}

/// \} End of group filesystem

}  // namespace cen

#endif  // CENTURION_PREFERRED_PATH_HEADER
// #include "centurion/filesystem/seek_mode.hpp"
#ifndef CENTURION_SEEK_MODE_HEADER
#define CENTURION_SEEK_MODE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup filesystem
/// \{

/**
 * \enum seek_mode
 *
 * \brief Provides values that represent various file seek modes.
 *
 * \since 5.3.0
 */
enum class seek_mode
{
  from_beginning = RW_SEEK_SET,       ///< From the beginning.
  relative_to_current = RW_SEEK_CUR,  ///< Relative to the current read point.
  relative_to_end = RW_SEEK_END       ///< Relative to the end.
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied seek mode.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(seek_mode::from_beginning) == "from_beginning"`.
 *
 * \param mode the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const seek_mode mode) -> std::string_view
{
  switch (mode) {
    case seek_mode::from_beginning:
      return "from_beginning";

    case seek_mode::relative_to_current:
      return "relative_to_current";

    case seek_mode::relative_to_end:
      return "relative_to_end";

    default:
      throw cen_error{"Did not recognize seek mode!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a seek mode enumerator.
 *
 * \param stream the output stream that will be used.
 * \param mode the enumerator that will be printed.
 *
 * \see `to_string(seek_mode)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const seek_mode mode) -> std::ostream&
{
  return stream << to_string(mode);
}

/// \} End of streaming

/// \} End of group filesystem

}  // namespace cen

#endif  // CENTURION_SEEK_MODE_HEADER

// #include "centurion/hints/android_hints.hpp"
#ifndef CENTURION_ANDROID_HINTS_HEADER
#define CENTURION_ANDROID_HINTS_HEADER

#include <SDL.h>

// #include "../core/str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER

// #include "../detail/hints_impl.hpp"
#ifndef CENTURION_DETAIL_HINTS_IMPL_HEADER
#define CENTURION_DETAIL_HINTS_IMPL_HEADER

#include <optional>     // optional
#include <string>       // string, stoi, stoul, stof
#include <type_traits>  // enable_if_t, is_same_v, is_convertible_v

// #include "../core/integers.hpp"
#ifndef CENTURION_INTEGERS_HEADER
#define CENTURION_INTEGERS_HEADER

#include <SDL.h>

#include <cstddef>  // size_t

namespace cen {

/// \addtogroup core
/// \{

/// \name Integer aliases
/// \{

using usize = std::size_t;

/// Alias for an unsigned integer.
using uint = unsigned int;

/// Alias for the type used for integer literal operators.
using ulonglong = unsigned long long;

/// Alias for a 64-bit unsigned integer.
using u64 = Uint64;

/// Alias for a 32-bit unsigned integer.
using u32 = Uint32;

/// Alias for a 16-bit unsigned integer.
using u16 = Uint16;

/// Alias for an 8-bit unsigned integer.
using u8 = Uint8;

/// Alias for a 64-bit signed integer.
using i64 = Sint64;

/// Alias for a 32-bit signed integer.
using i32 = Sint32;

/// Alias for a 16-bit signed integer.
using i16 = Sint16;

/// Alias for an 8-bit signed integer.
using i8 = Sint8;

/// \} End of integer aliases

// clang-format off

/**
 * \brief Obtains the size of a container as an `int`.
 *
 * \tparam T a "container" that provides a `size()` member function.
 *
 * \param container the container to query the size of.
 *
 * \return the size of the container as an `int` value.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto isize(const T& container) noexcept(noexcept(container.size()))
    -> int
{
  return static_cast<int>(container.size());
}

// clang-format on

namespace literals {

/**
 * \brief Creates an 8-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u8(const ulonglong value) noexcept -> u8
{
  return static_cast<u8>(value);
}

/**
 * \brief Creates a 16-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u16(const ulonglong value) noexcept -> u16
{
  return static_cast<u16>(value);
}

/**
 * \brief Creates a 32-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u32(const ulonglong value) noexcept -> u32
{
  return static_cast<u32>(value);
}

/**
 * \brief Creates a 64-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u64(const ulonglong value) noexcept -> u64
{
  return static_cast<u64>(value);
}

/**
 * \brief Creates an 8-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i8(const ulonglong value) noexcept -> i8
{
  return static_cast<i8>(value);
}

/**
 * \brief Creates a 16-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i16(const ulonglong value) noexcept -> i16
{
  return static_cast<i16>(value);
}

/**
 * \brief Creates a 32-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i32(const ulonglong value) noexcept -> i32
{
  return static_cast<i32>(value);
}

/**
 * \brief Creates a 64-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i64(const ulonglong value) noexcept -> i64
{
  return static_cast<i64>(value);
}

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_INTEGERS_HEADER

// #include "../core/str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER

// #include "czstring_compare.hpp"
#ifndef CENTURION_DETAIL_CZSTRING_COMPARE_HEADER
#define CENTURION_DETAIL_CZSTRING_COMPARE_HEADER

// #include "../core/str.hpp"

// #include "czstring_eq.hpp"
#ifndef CENTURION_DETAIL_CZSTRING_EQ_HEADER
#define CENTURION_DETAIL_CZSTRING_EQ_HEADER

#include <cstring>  // strcmp

// #include "../core/str.hpp"


/// \cond FALSE
namespace cen::detail {

/**
 * \brief Indicates whether or not two C-style strings are equal.
 *
 * \param lhs the left-hand side string, can safely be null.
 * \param rhs the right-hand side string, can safely be null.
 *
 * \return `true` if the strings are equal; `false` otherwise.
 *
 * \since 4.1.0
 */
[[nodiscard]] inline auto czstring_eq(const str lhs, const str rhs) noexcept -> bool
{
  if (lhs && rhs) {
    return std::strcmp(lhs, rhs) == 0;
  }
  else {
    return false;
  }
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_CZSTRING_EQ_HEADER


/// \cond FALSE
namespace cen::detail {

struct czstring_compare final
{
  auto operator()(const str lhs, const str rhs) const noexcept -> bool
  {
    return detail::czstring_eq(lhs, rhs);
  }
};

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_CZSTRING_COMPARE_HEADER

// #include "czstring_eq.hpp"

// #include "from_string.hpp"
#ifndef CENTURION_DETAIL_FROM_STRING_HEADER
#define CENTURION_DETAIL_FROM_STRING_HEADER

#include <charconv>      // from_chars
#include <optional>      // optional
#include <string>        // string, stof
#include <string_view>   // string_view
#include <system_error>  // errc
#include <type_traits>   // is_floating_point_v

// #include "../compiler/compiler.hpp"
#ifndef CENTURION_COMPILER_HEADER
#define CENTURION_COMPILER_HEADER

#include <SDL.h>

namespace cen {

/// \addtogroup compiler
/// \{

/**
 * \brief Indicates whether or not a "debug" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a debug build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_debug_build() noexcept -> bool
{
#ifndef NDEBUG
  return true;
#else
  return false;
#endif  // NDEBUG
}

/**
 * \brief Indicates whether or not a "release" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a release build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_release_build() noexcept -> bool
{
  return !is_debug_build();
}

/**
 * \brief Indicates whether or not the compiler is MSVC.
 *
 * \return `true` if MSVC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_msvc() noexcept -> bool
{
#ifdef _MSC_VER
  return true;
#else
  return false;
#endif  // _MSC_VER
}

/**
 * \brief Indicates whether or not the compiler is GCC.
 *
 * \return `true` if GCC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_gcc() noexcept -> bool
{
#ifdef __GNUC__
  return true;
#else
  return false;
#endif  // __GNUC__
}

/**
 * \brief Indicates whether or not the compiler is Clang.
 *
 * \return `true` if Clang is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_clang() noexcept -> bool
{
#ifdef __clang__
  return true;
#else
  return false;
#endif  // __clang__
}

/**
 * \brief Indicates whether or not the compiler is Emscripten.
 *
 * \return `true` if Emscripten is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_emscripten() noexcept -> bool
{
#ifdef __EMSCRIPTEN__
  return true;
#else
  return false;
#endif  // __EMSCRIPTEN__
}

/**
 * \brief Indicates whether or not the compiler is Intel C++.
 *
 * \return `true` if Intel C++ is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_intel_cpp() noexcept -> bool
{
#ifdef __INTEL_COMPILER
  return true;
#else
  return false;
#endif  // __INTEL_COMPILER
}

/// \} End of compiler group

}  // namespace cen

#endif  // CENTURION_COMPILER_HEADER


/// \cond FALSE
namespace cen::detail {

template <typename T>
[[nodiscard]] auto from_string(const std::string_view str,
                               const int base = 10) noexcept(on_msvc()) -> std::optional<T>
{
  T value{};

  const auto begin = str.data();
  const auto end = str.data() + str.size();

  const char* mismatch = end;
  std::errc error{};

  if constexpr (std::is_floating_point_v<T>) {
    if constexpr (on_gcc() || on_clang()) {
      try {
        value = std::stof(std::string{str});
      }
      catch (...) {
        return std::nullopt;
      }
    }
    else {
      const auto [ptr, err] = std::from_chars(begin, end, value);
      mismatch = ptr;
      error = err;
    }
  }
  else {
    const auto [ptr, err] = std::from_chars(begin, end, value, base);
    mismatch = ptr;
    error = err;
  }

  if (mismatch == end && error == std::errc{}) {
    return value;
  }
  else {
    return std::nullopt;
  }
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_FROM_STRING_HEADER

// #include "static_bimap.hpp"
#ifndef CENTURION_DETAIL_STATIC_BIMAP_HEADER
#define CENTURION_DETAIL_STATIC_BIMAP_HEADER

#include <algorithm>  // find_if
#include <array>      // array
#include <utility>    // pair

// #include "../core/exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER


/// \cond FALSE
namespace cen::detail {

/**
 * \class static_bimap
 *
 * \brief A bidirectional associative container for when keys and values are known at
 * compile-time.
 *
 * \note This class is only meant to be used in constexpr contexts.
 *
 * \remarks This class was inspired by Jason Turners C++ Weekly video on constexpr maps!
 *
 * \tparam Key the type of the keys, must provide an overloaded `operator==`.
 * \tparam Value the type of the values.
 * \tparam ValueCmp the predicate used to lookup values from keys.
 * \tparam size the amount of key-value pairs.
 *
 * \since 5.0.0
 */
template <typename Key, typename Value, typename ValueCmp, std::size_t Size>
class static_bimap final
{
  using pair_type = std::pair<Key, Value>;
  using storage_type = std::array<pair_type, Size>;

 public:
  storage_type data;

  constexpr auto find(const Key& key) const -> const Value&
  {
    const auto it = std::find_if(data.begin(), data.end(), [&](const pair_type& pair) {
      return pair.first == key;
    });

    if (it != data.end()) {
      return it->second;
    }
    else {
      throw cen_error{"Failed to find element in static map!"};
    }
  }

  constexpr auto key_from(const Value& value) const -> const Key&
  {
    const auto it = std::find_if(data.begin(), data.end(), [&](const pair_type& pair) {
      ValueCmp predicate;
      return predicate(pair.second, value);
    });

    if (it != data.end()) {
      return it->first;
    }
    else {
      throw cen_error{"Failed to find key in static map!"};
    }
  }
};

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_STATIC_BIMAP_HEADER


/// \cond FALSE

namespace cen::detail {

template <typename Hint, typename T>
using enable_if_hint_arg_t = std::enable_if_t<Hint::template valid_arg<T>(), int>;

template <typename Key, usize Size>
using string_map = static_bimap<Key, str, czstring_compare, Size>;

template <typename Derived, typename Arg>
struct crtp_hint
{
  using value_type = Arg;

  template <typename T>
  [[nodiscard]] constexpr static auto valid_arg() noexcept -> bool
  {
    return std::is_same_v<T, value_type>;
  }
};

// A hint class that only accepts booleans
template <typename Hint>
struct bool_hint : crtp_hint<bool_hint<Hint>, bool>
{
  [[nodiscard]] static auto current_value() noexcept -> std::optional<bool>
  {
    return SDL_GetHintBoolean(Hint::name(), SDL_FALSE) == SDL_TRUE;
  }

  [[nodiscard]] static auto from_string(const str str) noexcept -> bool
  {
    return czstring_eq(str, "1") ? true : false;
  }

  [[nodiscard]] static auto to_string(const bool value) -> std::string
  {
    return value ? "1" : "0";
  }
};

// A hint class that only accepts strings
template <typename Hint>
struct string_hint : crtp_hint<string_hint<Hint>, str>
{
  [[nodiscard]] static auto current_value() noexcept -> std::optional<str>
  {
    if (const str value = SDL_GetHint(Hint::name())) {
      return value;
    }
    else {
      return std::nullopt;
    }
  }

  [[nodiscard]] static auto from_string(const str value) noexcept -> str
  {
    return value;
  }

  [[nodiscard]] static auto to_string(const str value) -> std::string
  {
    return value;
  }
};

// A hint class that only accepts integers
template <typename Hint>
struct int_hint : crtp_hint<int_hint<Hint>, int>
{
  [[nodiscard]] static auto current_value() -> std::optional<int>
  {
    if (const str value = SDL_GetHint(Hint::name())) {
      return std::stoi(value);
    }
    else {
      return std::nullopt;
    }
  }

  [[nodiscard]] static auto from_string(const str value) -> int
  {
    return detail::from_string<int>(value).value();
  }

  [[nodiscard]] static auto to_string(const int value) -> std::string
  {
    return std::to_string(value);
  }
};

// A hint class that only accepts unsigned integers
template <typename Hint>
struct uint_hint : crtp_hint<uint_hint<Hint>, uint>
{
  [[nodiscard]] static auto current_value() -> std::optional<uint>
  {
    if (const str value = SDL_GetHint(Hint::name())) {
      return static_cast<uint>(std::stoul(value));
    }
    else {
      return std::nullopt;
    }
  }

  [[nodiscard]] static auto from_string(const str value) -> uint
  {
    return detail::from_string<uint>(value).value();
  }

  [[nodiscard]] static auto to_string(const uint value) -> std::string
  {
    return std::to_string(value);
  }
};

// A hint class that only accepts floats
template <typename Hint>
struct float_hint : crtp_hint<float_hint<Hint>, float>
{
  [[nodiscard]] static auto current_value() -> std::optional<float>
  {
    if (const str value = SDL_GetHint(Hint::name())) {
      return std::stof(value);
    }
    else {
      return std::nullopt;
    }
  }

  [[nodiscard]] static auto from_string(const str value) -> float
  {
    return detail::from_string<float>(value).value();
  }

  [[nodiscard]] static auto to_string(const float value) -> std::string
  {
    return std::to_string(value);
  }
};

}  // namespace cen::detail

/// \endcond

#endif  // CENTURION_DETAIL_HINTS_IMPL_HEADER


namespace cen::hint::android {

/// \addtogroup hints
/// \{

struct block_on_pause final : detail::bool_hint<block_on_pause>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_ANDROID_BLOCK_ON_PAUSE;
  }
};

struct trap_back_button final : detail::bool_hint<trap_back_button>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_ANDROID_TRAP_BACK_BUTTON;
  }
};

struct apk_expansion_main_file_version final
    : detail::int_hint<apk_expansion_main_file_version>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION;
  }
};

struct apk_expansion_patch_file_version final
    : detail::int_hint<apk_expansion_patch_file_version>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION;
  }
};

#if SDL_VERSION_ATLEAST(2, 0, 14)

struct pause_background_audio final : detail::bool_hint<pause_background_audio>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_ANDROID_BLOCK_ON_PAUSE_PAUSEAUDIO;
  }
};

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

/// \} End of group hints

}  // namespace cen::hint::android

#endif  // CENTURION_ANDROID_HINTS_HEADER
// #include "centurion/hints/apple_tv_hints.hpp"
#ifndef CENTURION_APPLE_TV_HINTS_HEADER
#define CENTURION_APPLE_TV_HINTS_HEADER

#include <SDL.h>

// #include "../core/str.hpp"

// #include "../detail/hints_impl.hpp"


namespace cen::hint::appletv {

/// \addtogroup hints
/// \{

struct controller_ui_events final : detail::bool_hint<controller_ui_events>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_APPLE_TV_CONTROLLER_UI_EVENTS;
  }
};

struct remote_allow_rotation final : detail::bool_hint<remote_allow_rotation>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_APPLE_TV_REMOTE_ALLOW_ROTATION;
  }
};

/// \} End of group hints

}  // namespace cen::hint::appletv

#endif  // CENTURION_APPLE_TV_HINTS_HEADER
// #include "centurion/hints/common_hints.hpp"
#ifndef CENTURION_COMMON_HINTS_HEADER
#define CENTURION_COMMON_HINTS_HEADER

#include <SDL.h>

#include <utility>  // make_pair

// #include "../core/str.hpp"

// #include "../detail/hints_impl.hpp"

// #include "enum_hint.hpp"
#ifndef CENTURION_ENUM_HINT_HEADER
#define CENTURION_ENUM_HINT_HEADER

#include <SDL.h>

#include <optional>     // optional
#include <string>       // string
#include <type_traits>  // is_same_v

// #include "../core/str.hpp"


namespace cen::hint {

/// \addtogroup hints
/// \{

struct render_driver;
struct audio_resampling_mode;
struct scale_quality;
struct framebuffer_acceleration;
struct audio_category;
struct wave_riff_chunk_size;
struct wave_truncation;
struct wave_fact_chunk;
struct logical_size_mode;

namespace qtwayland {
struct content_orientation;
}

namespace windows {
struct d3d_compiler;
}

/// \} End of group hints

/// \cond FALSE

template <class Hint>
struct enum_hint_traits;

template <>
struct enum_hint_traits<render_driver> final
{
  enum class value
  {
    direct3d,
    opengl,
    opengles,
    opengles2,
    metal,
    software
  };
};

template <>
struct enum_hint_traits<audio_resampling_mode> final
{
  enum class value
  {
    normal = 0,
    fast = 1,
    medium = 2,
    best = 3
  };
};

template <>
struct enum_hint_traits<scale_quality> final
{
  enum class value
  {
    nearest = 0,
    linear = 1,
    best = 2
  };
};

template <>
struct enum_hint_traits<framebuffer_acceleration> final
{
  enum class value
  {
    off,
    on,
    direct3d,
    opengl,
    opengles,
    opengles2,
    metal,
    software
  };
};

template <>
struct enum_hint_traits<audio_category> final
{
  enum class value
  {
    ambient,
    playback
  };
};

template <>
struct enum_hint_traits<wave_riff_chunk_size> final
{
  enum class value
  {
    force,
    ignore_zero,
    ignore,
    maximum
  };
};

template <>
struct enum_hint_traits<wave_truncation> final
{
  enum class value
  {
    very_strict,
    strict,
    drop_frame,
    drop_block
  };
};

template <>
struct enum_hint_traits<wave_fact_chunk> final
{
  enum class value
  {
    truncate,
    strict,
    ignore_zero,
    ignore
  };
};

template <>
struct enum_hint_traits<logical_size_mode> final
{
  enum class value
  {
    letterbox,
    overscan
  };
};

template <>
struct enum_hint_traits<qtwayland::content_orientation> final
{
  enum class value
  {
    primary,
    portrait,
    landscape,
    inverted_portrait,
    inverted_landscape
  };
};

template <>
struct enum_hint_traits<windows::d3d_compiler> final
{
  enum class value
  {
    v46,
    v43,
    none
  };
};

/// \endcond

/// \addtogroup hints
/// \{

template <class Derived>
class enum_hint
{
 public:
  using value = typename enum_hint_traits<Derived>::value;
  using value_type = value;

  template <typename T>
  [[nodiscard]] constexpr static auto valid_arg() noexcept -> bool
  {
    return std::is_same_v<T, value>;
  }

  [[nodiscard]] static auto current_value() noexcept -> std::optional<value_type>
  {
    if (const str hint = SDL_GetHint(Derived::name())) {
      return Derived::map.key_from(hint);
    }
    else {
      return std::nullopt;
    }
  }

  [[nodiscard]] static auto from_string(const str value) -> value_type
  {
    return Derived::map.key_from(value);
  }

  [[nodiscard]] static auto to_string(const value_type value) -> std::string
  {
    return Derived::map.find(value);
  }
};

/// \} End of group hints

}  // namespace cen::hint

#endif  // CENTURION_ENUM_HINT_HEADER

namespace cen::hint {

/// \addtogroup hints
/// \{

/**
 * \class render_driver
 *
 * \brief Used to specify the render driver that will be used.
 */
struct render_driver final : enum_hint<render_driver>
{
  static inline constexpr detail::string_map<value, 6> map{
      std::make_pair(value::direct3d, "direct3d"),
      std::make_pair(value::opengl, "opengl"),
      std::make_pair(value::opengles, "opengles"),
      std::make_pair(value::opengles2, "opengles2"),
      std::make_pair(value::metal, "metal"),
      std::make_pair(value::software, "software")};

  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_RENDER_DRIVER;
  }
};

struct audio_resampling_mode final : enum_hint<audio_resampling_mode>
{
  static inline constexpr detail::string_map<value, 4> map{
      std::make_pair(value::normal, "default"),
      std::make_pair(value::fast, "fast"),
      std::make_pair(value::medium, "medium"),
      std::make_pair(value::best, "best")};

  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_AUDIO_RESAMPLING_MODE;
  }
};

#if SDL_VERSION_ATLEAST(2, 0, 16)

struct audio_include_monitors final : detail::bool_hint<audio_include_monitors>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_AUDIO_INCLUDE_MONITORS;
  }
};

struct audio_device_stream_role final : detail::string_hint<audio_device_stream_role>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_AUDIO_DEVICE_STREAM_ROLE;
  }
};

#endif  // SDL_VERSION_ATLEAST(2, 0, 16)

struct scale_quality final : enum_hint<scale_quality>
{
  static inline constexpr detail::string_map<value, 3> map{
      std::make_pair(value::nearest, "nearest"),
      std::make_pair(value::linear, "linear"),
      std::make_pair(value::best, "best")};

  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_RENDER_SCALE_QUALITY;
  }
};

struct framebuffer_acceleration final : enum_hint<framebuffer_acceleration>
{
  static inline constexpr detail::string_map<value, 8> map{
      std::make_pair(value::off, "0"),
      std::make_pair(value::on, "1"),
      std::make_pair(value::direct3d, "direct3d"),
      std::make_pair(value::opengl, "opengl"),
      std::make_pair(value::opengles, "opengles"),
      std::make_pair(value::opengles2, "opengles2"),
      std::make_pair(value::metal, "metal"),
      std::make_pair(value::software, "software")};

  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_FRAMEBUFFER_ACCELERATION;
  }
};

struct audio_category final : enum_hint<audio_category>
{
  static inline constexpr detail::string_map<value, 2> map{
      std::make_pair(value::ambient, "ambient"),
      std::make_pair(value::playback, "playback")};

  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_AUDIO_CATEGORY;
  }
};

struct wave_riff_chunk_size final : enum_hint<wave_riff_chunk_size>
{
  static inline constexpr detail::string_map<value, 4> map{
      std::make_pair(value::force, "force"),
      std::make_pair(value::ignore, "ignore"),
      std::make_pair(value::ignore_zero, "ignorezero"),
      std::make_pair(value::maximum, "maximum")};

  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_WAVE_RIFF_CHUNK_SIZE;
  }
};

struct wave_truncation final : enum_hint<wave_truncation>
{
  static inline constexpr detail::string_map<value, 4> map{
      std::make_pair(value::drop_block, "dropblock"),
      std::make_pair(value::drop_frame, "dropframe"),
      std::make_pair(value::strict, "strict"),
      std::make_pair(value::very_strict, "verystrict")};

  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_WAVE_TRUNCATION;
  }
};

struct wave_fact_chunk final : enum_hint<wave_fact_chunk>
{
  static inline constexpr detail::string_map<value, 4> map{
      std::make_pair(value::strict, "strict"),
      std::make_pair(value::ignore_zero, "ignorezero"),
      std::make_pair(value::ignore, "ignore"),
      std::make_pair(value::truncate, "truncate")};

  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_WAVE_FACT_CHUNK;
  }
};

struct logical_size_mode final : enum_hint<logical_size_mode>
{
  static inline constexpr detail::string_map<value, 2> map{
      std::make_pair(value::letterbox, "letterbox"),
      std::make_pair(value::overscan, "overscan")};

  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_RENDER_LOGICAL_SIZE_MODE;
  }
};

struct accelerometer_as_joystick final : detail::bool_hint<accelerometer_as_joystick>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_ACCELEROMETER_AS_JOYSTICK;
  }
};

struct allow_top_most final : detail::bool_hint<allow_top_most>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_ALLOW_TOPMOST;
  }
};

struct bmp_save_legacy_format final : detail::bool_hint<bmp_save_legacy_format>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_BMP_SAVE_LEGACY_FORMAT;
  }
};

struct double_buffer final : detail::bool_hint<double_buffer>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_VIDEO_DOUBLE_BUFFER;
  }
};

struct enable_steam_controllers final : detail::bool_hint<enable_steam_controllers>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_ENABLE_STEAM_CONTROLLERS;
  }
};

struct grab_keyboard final : detail::bool_hint<grab_keyboard>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_GRAB_KEYBOARD;
  }
};

struct idle_timer_disabled final : detail::bool_hint<idle_timer_disabled>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_IDLE_TIMER_DISABLED;
  }
};

struct ime_internal_editing final : detail::bool_hint<ime_internal_editing>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_IME_INTERNAL_EDITING;
  }
};

struct no_signal_handlers final : detail::bool_hint<no_signal_handlers>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_NO_SIGNAL_HANDLERS;
  }
};

struct opengl_es_driver final : detail::bool_hint<opengl_es_driver>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_OPENGL_ES_DRIVER;
  }
};

struct enable_opengl_shaders final : detail::bool_hint<enable_opengl_shaders>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_RENDER_OPENGL_SHADERS;
  }
};

struct vsync final : detail::bool_hint<vsync>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_RENDER_VSYNC;
  }
};

struct allow_screensaver final : detail::bool_hint<allow_screensaver>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_VIDEO_ALLOW_SCREENSAVER;
  }
};

#if SDL_VERSION_ATLEAST(2, 0, 12)

struct video_external_context final : detail::bool_hint<video_external_context>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_VIDEO_EXTERNAL_CONTEXT;
  }
};

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

struct disable_high_dpi final : detail::bool_hint<disable_high_dpi>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_VIDEO_HIGHDPI_DISABLED;
  }
};

struct minimize_on_focus_loss final : detail::bool_hint<minimize_on_focus_loss>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS;
  }
};

struct window_frame_usable_while_cursor_hidden final
    : detail::bool_hint<window_frame_usable_while_cursor_hidden>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN;
  }
};

struct render_batching final : detail::bool_hint<render_batching>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_RENDER_BATCHING;
  }
};

struct return_key_hides_ime final : detail::bool_hint<return_key_hides_ime>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_RETURN_KEY_HIDES_IME;
  }
};

struct touch_mouse_events final : detail::bool_hint<touch_mouse_events>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_TOUCH_MOUSE_EVENTS;
  }
};

struct mouse_touch_events final : detail::bool_hint<mouse_touch_events>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_MOUSE_TOUCH_EVENTS;
  }
};

struct tv_remote_as_joystick final : detail::bool_hint<tv_remote_as_joystick>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_TV_REMOTE_AS_JOYSTICK;
  }
};

#if SDL_VERSION_ATLEAST(2, 0, 12)

struct display_usable_bounds final : detail::string_hint<display_usable_bounds>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_DISPLAY_USABLE_BOUNDS;
  }
};

#endif  // #if SDL_VERSION_ATLEAST(2, 0, 12)

struct orientations final : detail::string_hint<orientations>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_ORIENTATIONS;
  }
};

struct window_share_pixel_format final : detail::string_hint<window_share_pixel_format>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT;
  }
};

struct event_logging final : detail::int_hint<event_logging>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_EVENT_LOGGING;
  }
};

struct thread_stack_size final : detail::uint_hint<thread_stack_size>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_THREAD_STACK_SIZE;
  }
};

struct timer_resolution final : detail::uint_hint<timer_resolution>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_TIMER_RESOLUTION;
  }
};

#if SDL_VERSION_ATLEAST(2, 0, 14)

struct preferred_locales final : detail::string_hint<preferred_locales>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_PREFERRED_LOCALES;
  }
};

struct thread_priority_policy final : detail::string_hint<thread_priority_policy>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    // This hint could be enum-based, but it isn't clear whether or not there
    // may be implementation specific identifiers other than those of the listed
    // pthread identifiers. So, we let this be a string-based hint.
    return SDL_HINT_THREAD_PRIORITY_POLICY;
  }
};

struct treat_time_critical_as_real_time final
    : detail::bool_hint<treat_time_critical_as_real_time>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_THREAD_FORCE_REALTIME_TIME_CRITICAL;
  }
};

struct audio_device_app_name final : detail::string_hint<audio_device_app_name>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_AUDIO_DEVICE_APP_NAME;
  }
};

struct audio_device_stream_name final : detail::string_hint<audio_device_stream_name>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_AUDIO_DEVICE_STREAM_NAME;
  }
};

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

/// \} End of group hints

}  // namespace cen::hint

#endif  // CENTURION_COMMON_HINTS_HEADER
// #include "centurion/hints/controller_hints.hpp"
#ifndef CENTURION_CONTROLLER_HINTS_HEADER
#define CENTURION_CONTROLLER_HINTS_HEADER

#include <SDL.h>

// #include "../core/str.hpp"

// #include "../detail/hints_impl.hpp"


namespace cen::hint::controller {

/// \addtogroup hints
/// \{

#if SDL_VERSION_ATLEAST(2, 0, 12)

struct use_button_labels final : detail::bool_hint<use_button_labels>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_GAMECONTROLLER_USE_BUTTON_LABELS;
  }
};

struct type final : detail::string_hint<type>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_GAMECONTROLLERTYPE;
  }
};

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

struct config final : detail::string_hint<config>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_GAMECONTROLLERCONFIG;
  }
};

struct config_file final : detail::string_hint<config_file>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_GAMECONTROLLERCONFIG_FILE;
  }
};

struct ignore_devices final : detail::string_hint<ignore_devices>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES;
  }
};

struct ignore_devices_except final : detail::string_hint<ignore_devices_except>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT;
  }
};

/// \} End of group hints

}  // namespace cen::hint::controller

#endif  // CENTURION_CONTROLLER_HINTS_HEADER
// #include "centurion/hints/d3d_hints.hpp"
#ifndef CENTURION_D3D_HINTS_HEADER
#define CENTURION_D3D_HINTS_HEADER

#include <SDL.h>

// #include "../core/str.hpp"

// #include "../detail/hints_impl.hpp"


namespace cen::hint::d3d {

/// \addtogroup hints
/// \{

struct v11_debug final : detail::bool_hint<v11_debug>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_RENDER_DIRECT3D11_DEBUG;
  }
};

struct thread_safe final : detail::bool_hint<thread_safe>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_RENDER_DIRECT3D_THREADSAFE;
  }
};

/// \} End of group hints

}  // namespace cen::hint::d3d

#endif  // CENTURION_D3D_HINTS_HEADER
// #include "centurion/hints/emscripten_hints.hpp"
#ifndef CENTURION_EMSCRIPTEN_HINTS_HEADER
#define CENTURION_EMSCRIPTEN_HINTS_HEADER

#include <SDL.h>

// #include "../core/str.hpp"

// #include "../detail/hints_impl.hpp"


namespace cen::hint::emscripten {

/// \addtogroup hints
/// \{

struct keyboard_element final : detail::string_hint<keyboard_element>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT;
  }
};

#if SDL_VERSION_ATLEAST(2, 0, 14)

struct asyncify final : detail::bool_hint<asyncify>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_EMSCRIPTEN_ASYNCIFY;
  }
};

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

/// \} End of group hints

}  // namespace cen::hint::emscripten

#endif  // CENTURION_EMSCRIPTEN_HINTS_HEADER
// #include "centurion/hints/enum_hint.hpp"
#ifndef CENTURION_ENUM_HINT_HEADER
#define CENTURION_ENUM_HINT_HEADER

#include <SDL.h>

#include <optional>     // optional
#include <string>       // string
#include <type_traits>  // is_same_v

// #include "../core/str.hpp"


namespace cen::hint {

/// \addtogroup hints
/// \{

struct render_driver;
struct audio_resampling_mode;
struct scale_quality;
struct framebuffer_acceleration;
struct audio_category;
struct wave_riff_chunk_size;
struct wave_truncation;
struct wave_fact_chunk;
struct logical_size_mode;

namespace qtwayland {
struct content_orientation;
}

namespace windows {
struct d3d_compiler;
}

/// \} End of group hints

/// \cond FALSE

template <class Hint>
struct enum_hint_traits;

template <>
struct enum_hint_traits<render_driver> final
{
  enum class value
  {
    direct3d,
    opengl,
    opengles,
    opengles2,
    metal,
    software
  };
};

template <>
struct enum_hint_traits<audio_resampling_mode> final
{
  enum class value
  {
    normal = 0,
    fast = 1,
    medium = 2,
    best = 3
  };
};

template <>
struct enum_hint_traits<scale_quality> final
{
  enum class value
  {
    nearest = 0,
    linear = 1,
    best = 2
  };
};

template <>
struct enum_hint_traits<framebuffer_acceleration> final
{
  enum class value
  {
    off,
    on,
    direct3d,
    opengl,
    opengles,
    opengles2,
    metal,
    software
  };
};

template <>
struct enum_hint_traits<audio_category> final
{
  enum class value
  {
    ambient,
    playback
  };
};

template <>
struct enum_hint_traits<wave_riff_chunk_size> final
{
  enum class value
  {
    force,
    ignore_zero,
    ignore,
    maximum
  };
};

template <>
struct enum_hint_traits<wave_truncation> final
{
  enum class value
  {
    very_strict,
    strict,
    drop_frame,
    drop_block
  };
};

template <>
struct enum_hint_traits<wave_fact_chunk> final
{
  enum class value
  {
    truncate,
    strict,
    ignore_zero,
    ignore
  };
};

template <>
struct enum_hint_traits<logical_size_mode> final
{
  enum class value
  {
    letterbox,
    overscan
  };
};

template <>
struct enum_hint_traits<qtwayland::content_orientation> final
{
  enum class value
  {
    primary,
    portrait,
    landscape,
    inverted_portrait,
    inverted_landscape
  };
};

template <>
struct enum_hint_traits<windows::d3d_compiler> final
{
  enum class value
  {
    v46,
    v43,
    none
  };
};

/// \endcond

/// \addtogroup hints
/// \{

template <class Derived>
class enum_hint
{
 public:
  using value = typename enum_hint_traits<Derived>::value;
  using value_type = value;

  template <typename T>
  [[nodiscard]] constexpr static auto valid_arg() noexcept -> bool
  {
    return std::is_same_v<T, value>;
  }

  [[nodiscard]] static auto current_value() noexcept -> std::optional<value_type>
  {
    if (const str hint = SDL_GetHint(Derived::name())) {
      return Derived::map.key_from(hint);
    }
    else {
      return std::nullopt;
    }
  }

  [[nodiscard]] static auto from_string(const str value) -> value_type
  {
    return Derived::map.key_from(value);
  }

  [[nodiscard]] static auto to_string(const value_type value) -> std::string
  {
    return Derived::map.find(value);
  }
};

/// \} End of group hints

}  // namespace cen::hint

#endif  // CENTURION_ENUM_HINT_HEADER
// #include "centurion/hints/hint_priority.hpp"
#ifndef CENTURION_HINT_PRIORITY_HEADER
#define CENTURION_HINT_PRIORITY_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER


namespace cen {

/// \addtogroup hints
/// \{

/**
 * \enum hint_priority
 *
 * \brief Provides three different priorities that can be specified when
 * setting the value of a hint.
 *
 * \since 4.1.0
 *
 * \see `SDL_HintPriority`
 */
enum class hint_priority
{
  low = SDL_HINT_DEFAULT,       ///< The lowest possible priority.
  normal = SDL_HINT_NORMAL,     ///< The priority used by default by `set_hint`.
  override = SDL_HINT_OVERRIDE  ///< The highest priority.
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied hint priority.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(hint_priority::low) == "low"`.
 *
 * \param priority the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const hint_priority priority) -> std::string_view
{
  switch (priority) {
    case hint_priority::low:
      return "low";

    case hint_priority::normal:
      return "normal";

    case hint_priority::override:
      return "override";

    default:
      throw cen_error{"Did not recognize hint priority!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a hint priority enumerator.
 *
 * \param stream the output stream that will be used.
 * \param priority the enumerator that will be printed.
 *
 * \see `to_string(hint_priority)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const hint_priority priority) -> std::ostream&
{
  return stream << to_string(priority);
}

/// \} End of streaming

/// \} End of group hints

}  // namespace cen

#endif  // CENTURION_HINT_PRIORITY_HEADER

// #include "centurion/hints/hints.hpp"
#ifndef CENTURION_HINTS_HEADER
#define CENTURION_HINTS_HEADER

#include <SDL.h>

#include <optional>  // optional

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER

// #include "../core/exception.hpp"

// #include "../core/is_stateless_callable.hpp"
#ifndef CENTURION_IS_STATELESS_CALLABLE_HEADER
#define CENTURION_IS_STATELESS_CALLABLE_HEADER

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER


#if CENTURION_HAS_FEATURE_CONCEPTS

#include <concepts>  // default_initializable, invocable

namespace cen {

/// \addtogroup core
/// \{

template <typename T, typename... Args>
concept is_stateless_callable = std::default_initializable<T> && std::invocable<T, Args...>;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_HAS_FEATURE_CONCEPTS
#endif  // CENTURION_IS_STATELESS_CALLABLE_HEADER

// #include "../core/log.hpp"
#ifndef CENTURION_LOG_HEADER
#define CENTURION_LOG_HEADER

#include <SDL.h>

#include <array>        // array
#include <cassert>      // assert
#include <chrono>       // zoned_time, current_zone, system_clock
#include <iostream>     // clog
#include <string>       // string
#include <string_view>  // string_view
#include <utility>      // forward

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format_to_n

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "is_stateless_callable.hpp"
#ifndef CENTURION_IS_STATELESS_CALLABLE_HEADER
#define CENTURION_IS_STATELESS_CALLABLE_HEADER

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_CONCEPTS

#include <concepts>  // default_initializable, invocable

namespace cen {

/// \addtogroup core
/// \{

template <typename T, typename... Args>
concept is_stateless_callable = std::default_initializable<T> && std::invocable<T, Args...>;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_HAS_FEATURE_CONCEPTS
#endif  // CENTURION_IS_STATELESS_CALLABLE_HEADER

// #include "log_category.hpp"
#ifndef CENTURION_LOG_CATEGORY_HEADER
#define CENTURION_LOG_CATEGORY_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER

// #include "sdl_log_category_workaround.hpp"
#ifndef CENTURION_SDL_LOG_CATEGORY_WORKAROUND_HEADER
#define CENTURION_SDL_LOG_CATEGORY_WORKAROUND_HEADER

#include <SDL.h>

// #include "version.hpp"
#ifndef CENTURION_VERSION_HEADER
#define CENTURION_VERSION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <cassert>  // assert

/// \addtogroup core
/// \{

/**
 * \def CENTURION_VERSION_MAJOR
 *
 * \brief Expands into the current major version of the library.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_MAJOR 6

/**
 * \def CENTURION_VERSION_MINOR
 *
 * \brief Expands into the current minor version of the library.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_MINOR 3

/**
 * \def CENTURION_VERSION_PATCH
 *
 * \brief Expands into the current patch version of the library.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_PATCH 0

/**
 * \def CENTURION_SDL_VERSION_IS
 *
 * \brief This macro is meant to be used when conditionally including code for a specific
 * version of SDL. It is useful for applying workarounds.
 *
 * \since 5.3.0
 */
#define CENTURION_SDL_VERSION_IS(x, y, z) \
  ((SDL_MAJOR_VERSION == (x)) && (SDL_MINOR_VERSION == (y)) && (SDL_PATCHLEVEL == (z)))

#ifdef CENTURION___DOXYGEN

#define CENTURION_MAKE_VERSION_NUMBER
#define CENTURION_VERSION_NUMBER
#define CENTURION_VERSION_AT_LEAST

#endif  // CENTURION___DOXYGEN

/**
 * \def CENTURION_MAKE_VERSION_NUMBER
 *
 * \brief Helper macro for creating version numbers from a set of major/minor/patch
 * numbers.
 *
 * \details For example, if the version is 8.4.2, the resulting version number would be
 * 8402.
 *
 * \since 6.0.0
 */
#define CENTURION_MAKE_VERSION_NUMBER(x, y, z) (((x)*1'000) + ((y)*100) + (z))

/**
 * \def CENTURION_VERSION_NUMBER
 *
 * \brief Expands into a version number based on the current Centurion version.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_NUMBER                         \
  CENTURION_MAKE_VERSION_NUMBER(CENTURION_VERSION_MAJOR, \
                                CENTURION_VERSION_MINOR, \
                                CENTURION_VERSION_PATCH)

/**
 * \def CENTURION_VERSION_AT_LEAST
 *
 * \brief This macro is intended to be used for conditional compilation, based on the
 * Centurion version.
 *
 * \details This macro is used in the same way as the `SDL_VERSION_ATLEAST`, where you use
 * it as the condition with `#if` statements.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_AT_LEAST(x, y, z) \
  CENTURION_VERSION_NUMBER >= CENTURION_MAKE_VERSION_NUMBER(x, y, z)

namespace cen {

/// \name Centurion version queries
/// \{

/**
 * \struct version
 *
 * \brief Represents a set of major/minor/patch version numbers.
 *
 * \details The members of this struct are by default initialized to the current Centurion
 * version values.
 *
 * \since 6.0.0
 */
struct version final
{
  int major{CENTURION_VERSION_MAJOR};
  int minor{CENTURION_VERSION_MINOR};
  int patch{CENTURION_VERSION_PATCH};
};

/**
 * \brief Indicates whether or not the current Centurion version is at least equal to the
 * specified version.
 *
 * \param major the major version value.
 * \param minor the minor version value.
 * \param patch the patch version value.
 *
 * \return `true` if the version of Centurion is at least the specified version; `false`
 * otherwise.
 *
 * \see `CENTURION_VERSION_AT_LEAST`
 *
 * \since 6.0.0
 */
[[nodiscard]] constexpr auto version_at_least(const int major,
                                              const int minor,
                                              const int patch) noexcept -> bool
{
  return CENTURION_VERSION_AT_LEAST(major, minor, patch);
}

/// \} End of centurion version queries

/// \name SDL version queries
/// \{

/**
 * \brief Returns the version of SDL2 that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL that the
 * program was compiled against.
 *
 * \return the linked version of SDL2.
 *
 * \since 5.2.0
 */
[[nodiscard]] inline auto sdl_linked_version() noexcept -> SDL_version
{
  SDL_version version{};
  SDL_GetVersion(&version);
  return version;
}

/**
 * \brief Returns the compile-time version of SDL2 that is being used.
 *
 * \return the compile-time version of SDL2 that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_version() noexcept -> SDL_version
{
  return {SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL};
}

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \brief Returns the version of SDL2_image that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL2_image that
 * the program was compiled against.
 *
 * \return the linked version of SDL2_image.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto sdl_image_linked_version() noexcept -> SDL_version
{
  const auto* version = IMG_Linked_Version();
  assert(version);  // Sanity check
  return *version;
}

/**
 * \brief Returns the compile-time version of SDL2_image that is being used.
 *
 * \return the compile-time version of SDL2_image that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_image_version() noexcept -> SDL_version
{
  return {SDL_IMAGE_MAJOR_VERSION, SDL_IMAGE_MINOR_VERSION, SDL_IMAGE_PATCHLEVEL};
}

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \brief Returns the version of SDL2_mixer that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL2_mixer that
 * the program was compiled against.
 *
 * \return the linked version of SDL2_mixer.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto sdl_mixer_linked_version() noexcept -> SDL_version
{
  const auto* version = Mix_Linked_Version();
  assert(version);  // Sanity check
  return *version;
}

/**
 * \brief Returns the compile-time version of SDL2_mixer that is being used.
 *
 * \return the compile-time version of SDL2_mixer that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_mixer_version() noexcept -> SDL_version
{
  return {SDL_MIXER_MAJOR_VERSION, SDL_MIXER_MINOR_VERSION, SDL_MIXER_PATCHLEVEL};
}

#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF

/**
 * \brief Returns the version of SDL2_ttf that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL2_ttf that the
 * program was compiled against.
 *
 * \return the linked version of SDL2_ttf.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto sdl_ttf_linked_version() noexcept -> SDL_version
{
  const auto* version = TTF_Linked_Version();
  assert(version);  // Sanity check
  return *version;
}

/**
 * \brief Returns the compile-time version of SDL2_ttf that is being used.
 *
 * \return the compile-time version of SDL2_ttf that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_ttf_version() noexcept -> SDL_version
{
  return {SDL_TTF_MAJOR_VERSION, SDL_TTF_MINOR_VERSION, SDL_TTF_PATCHLEVEL};
}

#endif  // CENTURION_NO_SDL_TTF

/// \} End of SDL version queries

}  // namespace cen

#if CENTURION_SDL_VERSION_IS(2, 0, 10)

// Workaround for this enum being completely anonymous in SDL 2.0.10. We include
// this here because multiple files (key_code.hpp and scan_code.hpp) depend on
// this definition.
using SDL_KeyCode = decltype(SDLK_UNKNOWN);

#endif  // CENTURION_SDL_VERSION_IS(2, 0, 10)

/// \} End of group core

#endif  // CENTURION_VERSION_HEADER


#if CENTURION_SDL_VERSION_IS(2, 0, 10)

// Workaround for this enum being completely anonymous in SDL 2.0.10
using SDL_LogCategory = decltype(SDL_LOG_CATEGORY_APPLICATION);

#endif  // CENTURION_SDL_VERSION_IS(2, 0, 10)

#endif  // CENTURION_SDL_LOG_CATEGORY_WORKAROUND_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \brief Represents different logging categories.
 *
 * \see `SDL_LogCategory`
 * \see `log_category_count()`
 *
 * \todo Centurion 7: rename `misc` enumerator to `custom`.
 *
 * \since 3.0.0
 */
enum class log_category : int
{
  app = SDL_LOG_CATEGORY_APPLICATION,
  error = SDL_LOG_CATEGORY_ERROR,
  assert = SDL_LOG_CATEGORY_ASSERT,
  system = SDL_LOG_CATEGORY_SYSTEM,
  audio = SDL_LOG_CATEGORY_AUDIO,
  video = SDL_LOG_CATEGORY_VIDEO,
  render = SDL_LOG_CATEGORY_RENDER,
  input = SDL_LOG_CATEGORY_INPUT,
  test = SDL_LOG_CATEGORY_TEST,
  misc = SDL_LOG_CATEGORY_CUSTOM
};

/**
 * \brief Returns the number of enumerators for the `log_category` enum.
 *
 * \return the number of enumerators.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto log_category_count() noexcept -> int
{
  return 10;
}

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied log category.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(log_category::app) == "app"`.
 *
 * \param category the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const log_category category) -> std::string_view
{
  switch (category) {
    case log_category::app:
      return "app";

    case log_category::error:
      return "error";

    case log_category::assert:
      return "assert";

    case log_category::system:
      return "system";

    case log_category::audio:
      return "audio";

    case log_category::video:
      return "video";

    case log_category::render:
      return "render";

    case log_category::input:
      return "input";

    case log_category::test:
      return "test";

    case log_category::misc:
      return "misc";

    default:
      throw cen_error{"Did not recognize log category!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a log category enumerator.
 *
 * \param stream the output stream that will be used.
 * \param priority the enumerator that will be printed.
 *
 * \see `to_string(log_category)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const log_category category) -> std::ostream&
{
  return stream << to_string(category);
}

/// \} End of streaming

/// \name Log category comparison operators
/// \{

/**
 * \brief Indicates whether or not the two log category values are the same.
 *
 * \param lhs the left-hand side log category value.
 * \param rhs the right-hand side log category value.
 *
 * \return `true` if the categories are the same; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator==(const log_category lhs,
                                        const SDL_LogCategory rhs) noexcept -> bool
{
  return static_cast<SDL_LogCategory>(lhs) == rhs;
}

/// \copydoc operator==(const log_category, const SDL_LogCategory)
[[nodiscard]] constexpr auto operator==(const SDL_LogCategory lhs,
                                        const log_category rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the two log category values are the same.
 *
 * \param lhs the left-hand side log category value.
 * \param rhs the right-hand side log category value.
 *
 * \return `true` if the categories are the same; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator!=(const log_category lhs,
                                        const SDL_LogCategory rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const log_category, const SDL_LogCategory)
[[nodiscard]] constexpr auto operator!=(const SDL_LogCategory lhs,
                                        const log_category rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of log category comparison operators

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_LOG_CATEGORY_HEADER

// #include "log_priority.hpp"
#ifndef CENTURION_LOG_PRIORITY_HEADER
#define CENTURION_LOG_PRIORITY_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "exception.hpp"


namespace cen {

/// \addtogroup core
/// \{

/**
 * \enum log_priority
 *
 * \brief Provides values that represent different logging priorities.
 *
 * \see `SDL_LogPriority`
 *
 * \since 3.0.0
 */
enum class log_priority : int
{
  verbose = SDL_LOG_PRIORITY_VERBOSE,
  debug = SDL_LOG_PRIORITY_DEBUG,
  info = SDL_LOG_PRIORITY_INFO,
  warn = SDL_LOG_PRIORITY_WARN,
  error = SDL_LOG_PRIORITY_ERROR,
  critical = SDL_LOG_PRIORITY_CRITICAL,
};

/**
 * \brief Returns the number of available log priorities.
 *
 * \return the number of log priorities.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto log_priority_count() noexcept -> int
{
  return SDL_NUM_LOG_PRIORITIES;
}

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied log priority.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(log_priority::debug) == "debug"`.
 *
 * \param priority the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const log_priority priority) -> std::string_view
{
  switch (priority) {
    case log_priority::verbose:
      return "verbose";

    case log_priority::debug:
      return "debug";

    case log_priority::info:
      return "info";

    case log_priority::warn:
      return "warn";

    case log_priority::error:
      return "error";

    case log_priority::critical:
      return "critical";

    default:
      throw cen_error{"Did not recognize log priority!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a log priority enumerator.
 *
 * \param stream the output stream that will be used.
 * \param priority the enumerator that will be printed.
 *
 * \see `to_string(log_priority)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const log_priority priority) -> std::ostream&
{
  return stream << to_string(priority);
}

/// \} End of streaming

/// \name Log priority comparison operators
/// \{

/**
 * \brief Indicates whether or not the two log priorities values are the same.
 *
 * \param lhs the left-hand side log priority value.
 * \param rhs the right-hand side log priority value.
 *
 * \return `true` if the priorities are the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const log_priority lhs,
                                        const SDL_LogPriority rhs) noexcept -> bool
{
  return static_cast<SDL_LogPriority>(lhs) == rhs;
}

/// \copydoc operator==(const log_priority, const SDL_LogPriority)
[[nodiscard]] constexpr auto operator==(const SDL_LogPriority lhs,
                                        const log_priority rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the two log priorities values aren't the same.
 *
 * \param lhs the left-hand side log priority value.
 * \param rhs the right-hand side log priority value.
 *
 * \return `true` if the priorities aren't the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator!=(const log_priority lhs,
                                        const SDL_LogPriority rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const log_priority, const SDL_LogPriority)
[[nodiscard]] constexpr auto operator!=(const SDL_LogPriority lhs,
                                        const log_priority rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of log priority comparison operators

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_LOG_PRIORITY_HEADER

// #include "not_null.hpp"
#ifndef CENTURION_NOT_NULL_HEADER
#define CENTURION_NOT_NULL_HEADER

// #include "sfinae.hpp"
#ifndef CENTURION_SFINAE_HEADER
#define CENTURION_SFINAE_HEADER

#include <type_traits>  // enable_if_t, is_same_v, is_integral_v, is_floating_point_v, ...

namespace cen {

/// \addtogroup core
/// \{

// clang-format off

/// Enables a template if the type is either integral of floating-point, but not a boolean.
template <typename T>
using enable_if_number_t = std::enable_if_t<!std::is_same_v<T, bool> &&
                                            (std::is_integral_v<T> ||
                                             std::is_floating_point_v<T>), int>;

// clang-format on

/// Enables a template if the type is a pointer.
template <typename T>
using enable_if_pointer_v = std::enable_if_t<std::is_pointer_v<T>, int>;

/// Enables a template if T is convertible to any of the specified types.
template <typename T, typename... Args>
using enable_if_convertible_t = std::enable_if_t<(std::is_convertible_v<T, Args> || ...), int>;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_SFINAE_HEADER


namespace cen {

/**
 * \typedef not_null
 *
 * \ingroup core
 *
 * \brief Tag used to indicate that a pointer cannot be null.
 *
 * \note This alias is equivalent to `T`, it is a no-op.
 *
 * \since 5.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using not_null = T;

}  // namespace cen

#endif  // CENTURION_NOT_NULL_HEADER

// #include "str.hpp"

// #include "to_underlying.hpp"
#ifndef CENTURION_TO_UNDERLYING_HEADER
#define CENTURION_TO_UNDERLYING_HEADER

#include <type_traits>  // underlying_type_t, enable_if_t, is_enum_v

namespace cen {

/**
 * \brief Converts an enum value to an integral value using the underlying type.
 *
 * \ingroup core
 *
 * \note If you're using C++23, see `std::to_underlying()`.
 *
 * \tparam Enum the enum type.
 *
 * \param value the enum value that will be converted.
 *
 * \return the value of the enum, in the underlying type.
 *
 * \since 6.0.0
 */
template <typename Enum, std::enable_if_t<std::is_enum_v<Enum>, int> = 0>
[[nodiscard]] constexpr auto to_underlying(const Enum value) noexcept
    -> std::underlying_type_t<Enum>
{
  return static_cast<std::underlying_type_t<Enum>>(value);
}

}  // namespace cen

#endif  // CENTURION_TO_UNDERLYING_HEADER


/// \namespace cen::log
/// \brief Contains easy-to-use logging facilities.
/// \ingroup core
/// \since 3.0.0
namespace cen::log {

/// \addtogroup core
/// \{

/**
 * \brief Logs a message with the specified priority and category.
 *
 * \details This function has no effect if the supplied string is null. Usage of this
 * function is quite bulky, so refer to the other logging methods for casual logging.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param priority the priority that will be used.
 * \param category the category that will be used.
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void msg(const log_priority priority,
         const log_category category,
         const not_null<str> fmt,
         Args&&... args) noexcept
{
  assert(fmt);
  const auto sdlCategory = static_cast<SDL_LogCategory>(category);
  const auto prio = static_cast<SDL_LogPriority>(priority);
  SDL_LogMessage(sdlCategory, prio, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::info` and the specified category.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param category the category that will be used.
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void info(const log_category category, const not_null<str> fmt, Args&&... args) noexcept
{
  log::msg(log_priority::info, category, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::info` and `log_category::app`.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void info(const not_null<str> fmt, Args&&... args) noexcept
{
  log::info(log_category::app, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::warn` and the specified category.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param category the category that will be used.
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void warn(const log_category category, const not_null<str> fmt, Args&&... args) noexcept
{
  log::msg(log_priority::warn, category, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::warn` and `log_category::app`.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void warn(const not_null<str> fmt, Args&&... args) noexcept
{
  log::warn(log_category::app, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::verbose` and the specified category.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param category the category that will be used.
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void verbose(const log_category category, const not_null<str> fmt, Args&&... args) noexcept
{
  log::msg(log_priority::verbose, category, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::verbose` and `log_category::app`.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void verbose(const not_null<str> fmt, Args&&... args) noexcept
{
  log::verbose(log_category::app, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::debug` and the specified category.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param category the category that will be used.
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void debug(const log_category category, const not_null<str> fmt, Args&&... args) noexcept
{
  log::msg(log_priority::debug, category, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::debug` and `log_category::app`.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void debug(const not_null<str> fmt, Args&&... args) noexcept
{
  log::debug(log_category::app, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::critical` and the specified category.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param category the category that will be used.
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void critical(const log_category category, const not_null<str> fmt, Args&&... args) noexcept
{
  log::msg(log_priority::critical, category, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::critical` and `log_category::app`.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void critical(const not_null<str> fmt, Args&&... args) noexcept
{
  log::critical(log_category::app, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with `log_priority::error` and the specified category.
 *
 * \details This function has no effect if the supplied string is null.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param category the category that will be used.
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void error(const log_category category, const str fmt, Args&&... args) noexcept
{
  log::msg(log_priority::error, category, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a message with the `log_priority::error` and `log_category::app`.
 *
 * \tparam Args the types of the arguments that will be used in the formatted string.
 *
 * \param fmt the formatted string that will be logged, cannot be null.
 * \param args the arguments that will be used by the formatted string.
 *
 * \since 4.0.0
 */
template <typename... Args>
void error(const not_null<str> fmt, Args&&... args) noexcept
{
  log::error(log_category::app, fmt, std::forward<Args>(args)...);
}

/**
 * \brief Logs a string.
 *
 * \details This function is meant to be used for casual logging, where you just want to
 * log a string. The message will be logged with `log_priority::info` and
 * `log_category::app`.
 *
 * \param str the string that will be logged.
 *
 * \since 5.0.0
 */
inline void put(const std::string& str) noexcept
{
  log::info("%s", str.c_str());
}

/// \copydoc put()
inline void put(const not_null<str> str) noexcept
{
  log::info("%s", str);
}

/**
 * \brief Resets all of the logging priorities.
 *
 * \since 3.0.0
 */
inline void reset_priorities() noexcept
{
  SDL_LogResetPriorities();
}

/**
 * \brief Sets the priority of all categories.
 *
 * \param priority the priority that will be used.
 *
 * \since 3.0.0
 */
inline void set_priority(const log_priority priority) noexcept
{
  const auto p = static_cast<SDL_LogPriority>(priority);
  SDL_LogSetAllPriority(p);

  // Apparently not set by SDL
  SDL_LogSetPriority(SDL_LOG_CATEGORY_TEST, p);
}

/**
 * \brief Sets the priority of the specified category.
 *
 * \param category the category that will have its priority changed.
 * \param priority the new priority value.
 *
 * \since 3.0.0
 */
inline void set_priority(const log_category category, const log_priority priority) noexcept
{
  SDL_LogSetPriority(to_underlying(category), static_cast<SDL_LogPriority>(priority));
}

/**
 * \brief Returns the priority of the specified category.
 *
 * \param category the category to return the priority of.
 * \return the priority of the specified category.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto get_priority(const log_category category) noexcept -> log_priority
{
  return static_cast<log_priority>(SDL_LogGetPriority(to_underlying(category)));
}

/**
 * \brief Returns the maximum size, i.e the maximum amount of characters that a string can
 * contain and successfully be logged without being truncated.
 *
 * \note Strings longer that this value will be truncated.
 *
 * \return the maximum amount of characters that a loggable string can contain.
 *
 * \see `SDL_MAX_LOG_MESSAGE`
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto max_message_size() noexcept -> int
{
  return SDL_MAX_LOG_MESSAGE;
}

#if CENTURION_HAS_FEATURE_CONCEPTS

/**
 * \brief Sets the logging output function that will be used.
 *
 * \tparam Callable the type of the function object.
 *
 * \param callable the function object that will be used as the new logging output
 * function.
 *
 * \see `use_preset_output_function()`
 *
 * \since 6.2.0
 */
template <is_stateless_callable<log_category, log_priority, str> Callable>
inline void set_output_function([[maybe_unused]] Callable callable) noexcept
{
  const auto wrapper = [](void* /*erased*/,
                          const int category,
                          const SDL_LogPriority priority,
                          const str message) {
    Callable tmp;
    tmp(static_cast<log_category>(category), static_cast<log_priority>(priority), message);
  };

  SDL_LogSetOutputFunction(wrapper, nullptr);
}

/**
 * \brief Sets the logging output function that will be used.
 *
 * \tparam UserData the type of the user data.
 * \tparam Callable the type of the function object.
 *
 * \param callable the function object that will be used as the new logging output
 * function.
 * \param data a pointer to the user data, can safely be null. However, see the other
 * overload of this function if you do not need the user data.
 *
 * \see `use_preset_output_function()`
 *
 * \since 6.2.0
 */
template <typename UserData,
          is_stateless_callable<UserData*, log_category, log_priority, str> Callable>
inline void set_output_function([[maybe_unused]] Callable callable, UserData* data) noexcept
{
  const auto wrapper =
      [](void* erased, const int category, const SDL_LogPriority priority, const str message) {
        Callable tmp;
        tmp(static_cast<UserData*>(erased),
            static_cast<log_category>(category),
            static_cast<log_priority>(priority),
            message);
      };

  SDL_LogSetOutputFunction(wrapper, data);
}

#if CENTURION_HAS_FEATURE_FORMAT && CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES

/**
 * \brief Sets the logging output function to a convenient preset.
 *
 * \details Calling this function will make the logging output be channeled through
 * `std::clog`, and use an output format that includes the current time (taking the
 * current time zone into account) and the log priority associated with each message.
 *
 * \see `set_output_function()`
 *
 * \since 6.2.0
 */
inline void use_preset_output_function() noexcept
{
  using std::chrono::current_zone;
  using std::chrono::system_clock;
  using std::chrono::zoned_time;

  set_output_function([](const log_category, const log_priority priority, const str message) {
    const zoned_time time{current_zone(), system_clock::now()};

    std::array<char, 512> buffer;  // NOLINT
    const auto result = std::format_to_n(buffer.data(),
                                         buffer.size() - 1,
                                         "LOG {:%T} [{}] > {}\n",
                                         time,
                                         to_string(priority),
                                         message);
    *result.out = '\0';

    std::clog << std::string_view{buffer.data(), result.out};
  });
}

#endif  // CENTURION_HAS_FEATURE_FORMAT && CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES

#endif  // CENTURION_HAS_FEATURE_CONCEPTS

/// \} End of group core

}  // namespace cen::log

#endif  // CENTURION_LOG_HEADER

// #include "../core/result.hpp"
#ifndef CENTURION_RESULT_HEADER
#define CENTURION_RESULT_HEADER

#include <ostream>  // ostream
#include <string>   // string

namespace cen {

/// \addtogroup core
/// \{

/**
 * \class result
 *
 * \brief A simple indicator for the result of different operations.
 *
 * \details The idea behind this class is to make results of various operations
 * unambiguous. Quite an amount of functions in the library may fail, and earlier versions
 * of Centurion would usually return a `bool` in those cases, where `true` and `false`
 * would indicate success and failure, respectively. This class is a development of that
 * practice. For instance, this class is contextually convertible to `bool`, where a
 * successful result is still converted to `true`, and vice versa. However, this class
 * also enables explicit checks against `success` and `failure` constants, which makes
 * code very easy to read and unambiguous.
 * \code{cpp}
 *   cen::window window;
 *
 *   if (window.set_opacity(0.4f))
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::success)
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::failure)
 *   {
 *     // Failure!
 *   }
 * \endcode
 *
 * \see `success`
 * \see `failure`
 *
 * \since 6.0.0
 */
class result final
{
 public:
  /**
   * \brief Creates a result.
   *
   * \param success `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  constexpr result(const bool success) noexcept  // NOLINT implicit
      : m_success{success}
  {}

  /// \name Comparison operators
  /// \{

  /**
   * \brief Indicates whether or not two results have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results are equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator==(const result other) const noexcept -> bool
  {
    return m_success == other.m_success;
  }

  /**
   * \brief Indicates whether or not two results don't have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results aren't equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator!=(const result other) const noexcept -> bool
  {
    return !(*this == other);
  }

  /// \} End of comparison operators

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not the result is successful.
   *
   * \return `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr explicit operator bool() const noexcept
  {
    return m_success;
  }

  /// \} End of conversions

 private:
  bool m_success{};
};

/// Represents a successful result.
/// \since 6.0.0
inline constexpr result success{true};

/// Represents a failure of some kind.
/// \since 6.0.0
inline constexpr result failure{false};

/// \name String conversions
/// \{

/**
 * \brief Returns a string that represents a result value.
 *
 * \note The returned string is in a slightly different format compared to other Centurion
 * components.
 *
 * \param result the value that will be converted.
 *
 * \return `"success"` for a successful result; `"failure"` otherwise.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto to_string(const result result) -> std::string
{
  return result ? "success" : "failure";
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a result value using a stream.
 *
 * \param stream the stream that will be used.
 * \param result the result value that will be printed.
 *
 * \return the used stream.
 *
 * \since 6.0.0
 */
inline auto operator<<(std::ostream& stream, const result result) -> std::ostream&
{
  return stream << to_string(result);
}

/// \} End of streaming

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_RESULT_HEADER

// #include "../core/str.hpp"

// #include "../detail/hints_impl.hpp"

// #include "hint_priority.hpp"
#ifndef CENTURION_HINT_PRIORITY_HEADER
#define CENTURION_HINT_PRIORITY_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup hints
/// \{

/**
 * \enum hint_priority
 *
 * \brief Provides three different priorities that can be specified when
 * setting the value of a hint.
 *
 * \since 4.1.0
 *
 * \see `SDL_HintPriority`
 */
enum class hint_priority
{
  low = SDL_HINT_DEFAULT,       ///< The lowest possible priority.
  normal = SDL_HINT_NORMAL,     ///< The priority used by default by `set_hint`.
  override = SDL_HINT_OVERRIDE  ///< The highest priority.
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied hint priority.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(hint_priority::low) == "low"`.
 *
 * \param priority the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const hint_priority priority) -> std::string_view
{
  switch (priority) {
    case hint_priority::low:
      return "low";

    case hint_priority::normal:
      return "normal";

    case hint_priority::override:
      return "override";

    default:
      throw cen_error{"Did not recognize hint priority!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a hint priority enumerator.
 *
 * \param stream the output stream that will be used.
 * \param priority the enumerator that will be printed.
 *
 * \see `to_string(hint_priority)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const hint_priority priority) -> std::ostream&
{
  return stream << to_string(priority);
}

/// \} End of streaming

/// \} End of group hints

}  // namespace cen

#endif  // CENTURION_HINT_PRIORITY_HEADER


namespace cen {

/// \addtogroup hints
/// \{

/**
 * \brief Sets the value of the specified hint.
 *
 * \details This function will only accept values that are related to the
 * specified hint, supplying the wrong kind of value causes a compile-time
 * error. See the related hint class for more details about the associated
 * value type. However, whilst this function is type-safe, it doesn't ensure
 * that *correct* values are specified for the hints.
 *
 * \tparam Hint the type of the hint that will be modified.
 * \tparam priority the priority that will be used, defaults to `normal`.
 * \tparam Value the type of the hint value.
 *
 * \param value the new value that will be set for the specified hint.
 *
 * \return `success` if the hint was successfully set; `failure` otherwise.
 *
 * \since 4.1.0
 */
template <typename Hint,
          hint_priority priority = hint_priority::normal,
          typename Value,
          detail::enable_if_hint_arg_t<Hint, Value> = 0>
auto set_hint(const Value& value) -> result
{
  return SDL_SetHintWithPriority(Hint::name(),
                                 Hint::to_string(value).c_str(),
                                 static_cast<SDL_HintPriority>(priority)) == SDL_TRUE;
}

/**
 * \brief Returns the current value of the specified hint.
 *
 * \note Many hints aren't actually set by default.
 *
 * \tparam Hint the type of the Hint to obtain the value of.
 *
 * \return the current value of the specified hint; `std::nullopt` if there is
 * no value set for the hint.
 *
 * \since 4.1.0
 */
template <typename Hint>
[[nodiscard]] auto get_hint() -> std::optional<typename Hint::value_type>
{
  return Hint::current_value();
}

/**
 * \class hint_callback
 *
 * \brief Represents a handle for dealing with hint callbacks.
 *
 * \details This class provides methods for easily connecting and disconnecting a callback
 * from receiving updates.
 *
 * \tparam Hint the type of the associated hint. Should be one of the hint types defined
 * in the `hints.hpp` header.
 *
 * \tparam UserData the type of the user data.
 *
 * \since 4.1.0
 */
template <typename Hint, typename UserData = void>
class hint_callback final
{
 public:
  /**
   * \brief Creates a hint callback.
   *
   * \param callback the function object that will be called whenever the associated hint
   * is updated. The signature should be `void(void*, str, str, str)`.
   * \param userData a pointer to some user data. Defaults to `nullptr`.
   *
   * \throws cen_error if the supplied function pointer is null.
   *
   * \since 4.1.0
   */
  explicit hint_callback(SDL_HintCallback callback, UserData* userData = nullptr)
      : m_callback{callback}
      , m_userData{userData}
  {
    if (!callback) {
      throw cen_error{"Failed to create hint callback"};
    }
  }

  /**
   * \brief Registers the callback to be invoked whenever the associated hint is updated.
   *
   * \see `SDL_AddHintCallback`
   *
   * \since 4.1.0
   */
  void connect() noexcept
  {
    SDL_AddHintCallback(Hint::name(), m_callback, static_cast<void*>(m_userData));
  }

  /**
   * \brief Unregisters the callback from being updated whenever the associated hint is
   * updated.
   *
   * \see `SDL_DelHintCallback`
   *
   * \since 4.1.0
   */
  void disconnect() noexcept
  {
    SDL_DelHintCallback(Hint::name(), m_callback, static_cast<void*>(m_userData));
  }

  /**
   * \brief Returns a pointer to the function that is invoked when the associated hint is
   * updated.
   *
   * \return a pointer to the function that is invoked when the associated hint is
   * updated.
   *
   * \since 4.1.0
   */
  [[nodiscard]] auto get() noexcept -> SDL_HintCallback
  {
    return m_callback;
  }

  /**
   * \brief Returns a pointer to the user data associated with the callback.
   *
   * \return a pointer to the user data associated with the callback, can be null.
   *
   * \since 4.1.0
   */
  [[nodiscard]] auto user_data() const noexcept -> UserData*
  {
    return m_userData;
  }

 private:
  SDL_HintCallback m_callback;
  UserData* m_userData;
};

/**
 * \brief Adds a callback to observe changes of the value of the specified hint.
 *
 * \details A callback handle object is returned, which can be used to easily disconnect
 * the callback later. This function can be used with any function object that is
 * stateless, such as traditional function pointers and lambdas. The simplest way to add a
 * callback is with a lambda and no explicit user data.
 *
 * \note The callback will be immediately invoked with the current value of the hint.
 *
 * \tparam Hint should one of the many hint types defined in this header. However, all it
 * requires is that the type provides a static function that returns a `str`.
 * \tparam UserData the type of the user data, defaults to void.
 *
 * \param fun the function object that will be invoked when the hint is updated. The
 * signature should be `void(void*, str, str, str)`.
 * \param userData the user data to associate with the callback.
 *
 * \return a handle to the added callback.
 *
 * \see `add_hint_callback_ex()`
 *
 * \since 4.1.0
 */
template <typename Hint, typename UserData = void>
auto add_hint_callback(SDL_HintCallback fun, UserData* userData = nullptr) noexcept
    -> hint_callback<Hint, UserData>
{
  hint_callback<Hint, UserData> hintCallback{fun, userData};
  hintCallback.connect();
  return hintCallback;
}

#if CENTURION_HAS_FEATURE_CONCEPTS

/// \since 6.2.0
template <typename T, typename Hint, typename UserData>
concept is_hint_callback = is_stateless_callable<T,
                                                 UserData*,
                                                 str,
                                                 typename Hint::value_type,
                                                 typename Hint::value_type>;

/**
 * \brief Adds a callback to observe changes of the value of the specified hint.
 *
 * \details This function returns a callback handle object, which can be used to easily
 * disconnect the callback at a later time.
 *
 * \details The signature of the callable should be equivalent to `void(UserData*, str,
 * Hint::value_type, Hint::value_type)`.
 *
 * \note This function can be used with any function object that is stateless, such as
 * traditional function pointers or non-capturing lambdas.
 *
 * \details The following is an example of how usage of this function might look.
 * \code{cpp}
 * auto callable = [](int* data,
 *                    cen::str name,
 *                    cen::hint::render_driver::value_type previous,
 *                    cen::hint::render_driver::value_type current) {
 *   // Do stuff when the value of the hint is updated...
 * };
 *
 * int foo = 42;
 * auto handle = cen::add_hint_callback_ex<render_driver>(callable, &foo);
 * \endcode
 *
 * \tparam Hint the hint type, i.e. one of the types defined in the `cen::hint` namespace.
 * \tparam UserData the type of the optional user data.
 * \tparam Callable the type of the callable.
 *
 * \param fun the function object that will be invoked when the hint is updated.
 * \param data optional user data, can safely be null.
 *
 * \return a callback handle.
 *
 * \see `add_hint_callback()`
 *
 * \since 6.2.0
 */
template <typename Hint, typename UserData = void, is_hint_callback<Hint, UserData> Callable>
auto add_hint_callback_ex([[maybe_unused]] Callable fun, UserData* data = nullptr)
    -> hint_callback<Hint, UserData>
{
  const auto wrapper =
      [](void* erased, const str name, const str oldValue, const str newValue) {
        Callable callable;

        const auto previous = Hint::from_string(oldValue);
        const auto current = Hint::from_string(newValue);

        callable(static_cast<UserData*>(erased), name, previous, current);
      };

  return add_hint_callback<Hint>(wrapper, data);
}

#endif  // CENTURION_HAS_FEATURE_CONCEPTS

/**
 * \brief Clears all stored hints.
 *
 * \see `SDL_ClearHints`
 *
 * \since 4.1.0
 */
inline void clear_hints() noexcept
{
  SDL_ClearHints();
}

/// \} End of group hints

}  // namespace cen

#endif  // CENTURION_HINTS_HEADER

// #include "centurion/hints/joystick_hints.hpp"
#ifndef CENTURION_JOYSTICK_HINTS_HEADER
#define CENTURION_JOYSTICK_HINTS_HEADER

#include <SDL.h>

// #include "../core/str.hpp"

// #include "../detail/hints_impl.hpp"


namespace cen::hint::joystick {

/// \addtogroup hints
/// \{

struct allow_background_events final : detail::bool_hint<allow_background_events>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS;
  }
};

struct use_hidapi final : detail::bool_hint<use_hidapi>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_JOYSTICK_HIDAPI;
  }
};

struct use_hidapi_ps4 final : detail::bool_hint<use_hidapi_ps4>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_JOYSTICK_HIDAPI_PS4;
  }
};

struct use_hidapi_ps4_rumble final : detail::bool_hint<use_hidapi_ps4_rumble>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_JOYSTICK_HIDAPI_PS4_RUMBLE;
  }
};

struct use_hidapi_steam final : detail::bool_hint<use_hidapi_steam>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_JOYSTICK_HIDAPI_STEAM;
  }
};

struct use_hidapi_switch final : detail::bool_hint<use_hidapi_switch>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_JOYSTICK_HIDAPI_SWITCH;
  }
};

struct use_hidapi_xbox final : detail::bool_hint<use_hidapi_xbox>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_JOYSTICK_HIDAPI_XBOX;
  }
};

#if SDL_VERSION_ATLEAST(2, 0, 12)

struct use_hidapi_game_cube final : detail::bool_hint<use_hidapi_game_cube>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_JOYSTICK_HIDAPI_GAMECUBE;
  }
};

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

#if SDL_VERSION_ATLEAST(2, 0, 14)

struct use_hidapi_ps5 final : detail::bool_hint<use_hidapi_ps5>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_JOYSTICK_HIDAPI_PS5;
  }
};

struct use_raw_input final : detail::bool_hint<use_raw_input>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_JOYSTICK_RAWINPUT;
  }
};

#if SDL_VERSION_ATLEAST(2, 0, 16)

struct rawinput_correlate_xinput final : detail::bool_hint<rawinput_correlate_xinput>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_JOYSTICK_RAWINPUT_CORRELATE_XINPUT;
  }
};

#else

struct hidapi_correlate_xinput final : detail::bool_hint<hidapi_correlate_xinput>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_JOYSTICK_HIDAPI_CORRELATE_XINPUT;
  }
};

#endif  // SDL_VERSION_ATLEAST(2,0,16)

struct linux_use_deadzones final : detail::bool_hint<linux_use_deadzones>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_LINUX_JOYSTICK_DEADZONES;
  }
};

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

/// \} End of group hints

}  // namespace cen::hint::joystick

#endif  // CENTURION_JOYSTICK_HINTS_HEADER
// #include "centurion/hints/mac_hints.hpp"
#ifndef CENTURION_MAC_HINTS_HEADER
#define CENTURION_MAC_HINTS_HEADER

#include <SDL.h>

// #include "../core/str.hpp"

// #include "../detail/hints_impl.hpp"


namespace cen::hint::mac {

/// \addtogroup hints
/// \{

struct fullscreen_spaces final : detail::bool_hint<fullscreen_spaces>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES;
  }
};

struct background_app final : detail::bool_hint<background_app>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_MAC_BACKGROUND_APP;
  }
};

struct ctrl_click_emulate_right_click final : detail::bool_hint<ctrl_click_emulate_right_click>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK;
  }
};

/// \} End of group hints

}  // namespace cen::hint::mac

#endif  // CENTURION_MAC_HINTS_HEADER
// #include "centurion/hints/mouse_hints.hpp"
#ifndef CENTURION_MOUSE_HINTS_HEADER
#define CENTURION_MOUSE_HINTS_HEADER

#include <SDL.h>

// #include "../core/str.hpp"

// #include "../detail/hints_impl.hpp"


namespace cen::hint::mouse {

/// \addtogroup hints
/// \{

struct focus_clickthrough final : detail::bool_hint<focus_clickthrough>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH;
  }
};

struct relative_mode_warp final : detail::bool_hint<relative_mode_warp>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_MOUSE_RELATIVE_MODE_WARP;
  }
};

struct double_click_time final : detail::int_hint<double_click_time>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_MOUSE_DOUBLE_CLICK_TIME;
  }
};

struct double_click_radius final : detail::int_hint<double_click_radius>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_MOUSE_DOUBLE_CLICK_RADIUS;
  }
};

struct normal_speed_scale final : detail::float_hint<normal_speed_scale>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_MOUSE_NORMAL_SPEED_SCALE;
  }
};

struct relative_speed_scale final : detail::float_hint<relative_speed_scale>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_MOUSE_RELATIVE_SPEED_SCALE;
  }
};

#if SDL_VERSION_ATLEAST(2, 0, 14)

struct relative_scaling final : detail::bool_hint<relative_scaling>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_MOUSE_RELATIVE_SCALING;
  }
};

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

/// \} End of group hints

}  // namespace cen::hint::mouse

#endif  // CENTURION_MOUSE_HINTS_HEADER
// #include "centurion/hints/qtwayland_hints.hpp"
#ifndef CENTURION_QTWAYLAND_HINTS_HEADER
#define CENTURION_QTWAYLAND_HINTS_HEADER

#include <SDL.h>

#include <utility>  // make_pair

// #include "../core/str.hpp"

// #include "../detail/hints_impl.hpp"

// #include "enum_hint.hpp"


namespace cen::hint::qtwayland {

/// \addtogroup hints
/// \{

struct content_orientation final : enum_hint<content_orientation>
{
  static inline constexpr detail::string_map<value, 5> map{
      std::make_pair(value::primary, "primary"),
      std::make_pair(value::portrait, "portrait"),
      std::make_pair(value::landscape, "landscape"),
      std::make_pair(value::inverted_portrait, "inverted-portrait"),
      std::make_pair(value::inverted_landscape, "inverted-landscape")};

  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_QTWAYLAND_CONTENT_ORIENTATION;
  }
};

struct window_flags final : detail::string_hint<window_flags>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_QTWAYLAND_WINDOW_FLAGS;
  }
};

/// \} End of group hints

}  // namespace cen::hint::qtwayland

#endif  // CENTURION_QTWAYLAND_HINTS_HEADER
// #include "centurion/hints/raspberry_pi_hints.hpp"
#ifndef CENTURION_RASPBERRY_PI_HINTS_HEADER
#define CENTURION_RASPBERRY_PI_HINTS_HEADER

#include <SDL.h>

// #include "../core/str.hpp"

// #include "../detail/hints_impl.hpp"


namespace cen::hint::raspberrypi {

/// \addtogroup hints
/// \{

struct video_layer final : detail::int_hint<video_layer>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_RPI_VIDEO_LAYER;
  }
};

/// \} End of group hints

}  // namespace cen::hint::raspberrypi

#endif  // CENTURION_RASPBERRY_PI_HINTS_HEADER

// #include "centurion/hints/windows_hints.hpp"
#ifndef CENTURION_WINDOWS_HINTS_HEADER
#define CENTURION_WINDOWS_HINTS_HEADER

#include <utility>  // make_pair

// #include "../detail/hints_impl.hpp"

// #include "enum_hint.hpp"


namespace cen::hint::windows {

/// \addtogroup hints
/// \{

struct d3d_compiler final : enum_hint<d3d_compiler>
{
  static inline constexpr detail::string_map<value, 3> map{
      std::make_pair(value::v46, "d3dcompiler_46.dll"),
      std::make_pair(value::v43, "d3dcompiler_43.dll"),
      std::make_pair(value::none, "none")};

  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_VIDEO_WIN_D3DCOMPILER;
  }
};

struct no_thread_naming final : detail::bool_hint<no_thread_naming>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_WINDOWS_DISABLE_THREAD_NAMING;
  }
};

struct enable_message_loop final : detail::bool_hint<enable_message_loop>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP;
  }
};

struct no_close_on_alt_f4 final : detail::bool_hint<no_close_on_alt_f4>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_WINDOWS_NO_CLOSE_ON_ALT_F4;
  }
};

struct int_resource_icon final : detail::string_hint<int_resource_icon>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_WINDOWS_INTRESOURCE_ICON;
  }
};

struct int_resource_icon_small final : detail::string_hint<int_resource_icon_small>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_WINDOWS_INTRESOURCE_ICON_SMALL;
  }
};

/// \} End of group hints

}  // namespace cen::hint::windows

#endif  // CENTURION_WINDOWS_HINTS_HEADER

// #include "centurion/hints/winrt_hints.hpp"
#ifndef CENTURION_WINRT_HINTS_HEADER
#define CENTURION_WINRT_HINTS_HEADER

#include <SDL.h>

// #include "../core/str.hpp"

// #include "../detail/hints_impl.hpp"


namespace cen::hint::winrt {

/// \addtogroup hints
/// \{

struct privacy_policy_label final : detail::string_hint<privacy_policy_label>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_WINRT_PRIVACY_POLICY_LABEL;
  }
};

struct privacy_policy_url final : detail::string_hint<privacy_policy_url>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_WINRT_PRIVACY_POLICY_URL;
  }
};

struct handle_back_button final : detail::bool_hint<handle_back_button>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_WINRT_HANDLE_BACK_BUTTON;
  }
};

/// \} End of group hints

}  // namespace cen::hint::winrt

#endif  // CENTURION_WINRT_HINTS_HEADER
// #include "centurion/hints/x11_hints.hpp"
#ifndef CENTURION_X11_HINTS_HEADER
#define CENTURION_X11_HINTS_HEADER

#include <SDL.h>

// #include "../core/str.hpp"

// #include "../detail/hints_impl.hpp"


namespace cen::hint::x11 {

/// \addtogroup hints
/// \{

struct net_wm_ping final : detail::bool_hint<net_wm_ping>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_VIDEO_X11_NET_WM_PING;
  }
};

struct net_wm_bypass_compositor final : detail::bool_hint<net_wm_bypass_compositor>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR;
  }
};

struct xinerama final : detail::bool_hint<xinerama>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_VIDEO_X11_XINERAMA;
  }
};

struct xrandr final : detail::bool_hint<xrandr>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_VIDEO_X11_XRANDR;
  }
};

struct xvidmode final : detail::bool_hint<xvidmode>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_VIDEO_X11_XVIDMODE;
  }
};

#if SDL_VERSION_ATLEAST(2, 0, 12)

struct force_egl final : detail::bool_hint<force_egl>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_VIDEO_X11_FORCE_EGL;
  }
};

struct window_visual_id final : detail::string_hint<window_visual_id>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_VIDEO_X11_WINDOW_VISUALID;
  }
};

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

/// \} End of group hints

}  // namespace cen::hint::x11

#endif  // CENTURION_X11_HINTS_HEADER

// #include "centurion/hints/xinput_hints.hpp"
#ifndef CENTURION_XINPUT_HINTS_HEADER
#define CENTURION_XINPUT_HINTS_HEADER

#include <SDL.h>

// #include "../core/str.hpp"

// #include "../detail/hints_impl.hpp"


namespace cen::hint::xinput {

/// \addtogroup hints
/// \{

struct is_enabled final : detail::bool_hint<is_enabled>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_XINPUT_ENABLED;
  }
};

struct use_old_joystick_mapping final : detail::bool_hint<use_old_joystick_mapping>
{
  [[nodiscard]] constexpr static auto name() noexcept -> str
  {
    return SDL_HINT_XINPUT_USE_OLD_JOYSTICK_MAPPING;
  }
};

/// \} End of group hints

}  // namespace cen::hint::xinput

#endif  // CENTURION_XINPUT_HINTS_HEADER
// #include "centurion/input/button_state.hpp"
#ifndef CENTURION_BUTTON_STATE_HEADER
#define CENTURION_BUTTON_STATE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER

// #include "../core/integers.hpp"
#ifndef CENTURION_INTEGERS_HEADER
#define CENTURION_INTEGERS_HEADER

#include <SDL.h>

#include <cstddef>  // size_t

namespace cen {

/// \addtogroup core
/// \{

/// \name Integer aliases
/// \{

using usize = std::size_t;

/// Alias for an unsigned integer.
using uint = unsigned int;

/// Alias for the type used for integer literal operators.
using ulonglong = unsigned long long;

/// Alias for a 64-bit unsigned integer.
using u64 = Uint64;

/// Alias for a 32-bit unsigned integer.
using u32 = Uint32;

/// Alias for a 16-bit unsigned integer.
using u16 = Uint16;

/// Alias for an 8-bit unsigned integer.
using u8 = Uint8;

/// Alias for a 64-bit signed integer.
using i64 = Sint64;

/// Alias for a 32-bit signed integer.
using i32 = Sint32;

/// Alias for a 16-bit signed integer.
using i16 = Sint16;

/// Alias for an 8-bit signed integer.
using i8 = Sint8;

/// \} End of integer aliases

// clang-format off

/**
 * \brief Obtains the size of a container as an `int`.
 *
 * \tparam T a "container" that provides a `size()` member function.
 *
 * \param container the container to query the size of.
 *
 * \return the size of the container as an `int` value.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto isize(const T& container) noexcept(noexcept(container.size()))
    -> int
{
  return static_cast<int>(container.size());
}

// clang-format on

namespace literals {

/**
 * \brief Creates an 8-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u8(const ulonglong value) noexcept -> u8
{
  return static_cast<u8>(value);
}

/**
 * \brief Creates a 16-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u16(const ulonglong value) noexcept -> u16
{
  return static_cast<u16>(value);
}

/**
 * \brief Creates a 32-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u32(const ulonglong value) noexcept -> u32
{
  return static_cast<u32>(value);
}

/**
 * \brief Creates a 64-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u64(const ulonglong value) noexcept -> u64
{
  return static_cast<u64>(value);
}

/**
 * \brief Creates an 8-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i8(const ulonglong value) noexcept -> i8
{
  return static_cast<i8>(value);
}

/**
 * \brief Creates a 16-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i16(const ulonglong value) noexcept -> i16
{
  return static_cast<i16>(value);
}

/**
 * \brief Creates a 32-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i32(const ulonglong value) noexcept -> i32
{
  return static_cast<i32>(value);
}

/**
 * \brief Creates a 64-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i64(const ulonglong value) noexcept -> i64
{
  return static_cast<i64>(value);
}

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_INTEGERS_HEADER


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum button_state
 *
 * \ingroup input
 *
 * \brief Represents the two possible states for a button.
 *
 * \details Corresponds to the `SDL_RELEASED` and `SDL_PRESSED` macros.
 *
 * \since 3.1.0
 */
enum class button_state : u8
{
  released = SDL_RELEASED,  ///< Corresponds to `SDL_RELEASED`.
  pressed = SDL_PRESSED     ///< Corresponds to `SDL_PRESSED`.
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied button state.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(button_state::released) == "released"`.
 *
 * \param state the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const button_state state) -> std::string_view
{
  switch (state) {
    case button_state::released:
      return "released";

    case button_state::pressed:
      return "pressed";

    default:
      throw cen_error{"Did not recognize button state!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a button state enumerator.
 *
 * \param stream the output stream that will be used.
 * \param state the enumerator that will be printed.
 *
 * \see `to_string(button_state)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const button_state state) -> std::ostream&
{
  return stream << to_string(state);
}

/// \} End of streaming

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_BUTTON_STATE_HEADER
// #include "centurion/input/controller.hpp"
#ifndef CENTURION_GAME_CONTROLLER_HEADER
#define CENTURION_GAME_CONTROLLER_HEADER

#include <SDL.h>

#include <array>        // array
#include <cassert>      // assert
#include <optional>     // optional
#include <ostream>      // ostream
#include <string>       // string
#include <string_view>  // string_view

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/not_null.hpp"
#ifndef CENTURION_NOT_NULL_HEADER
#define CENTURION_NOT_NULL_HEADER

// #include "sfinae.hpp"
#ifndef CENTURION_SFINAE_HEADER
#define CENTURION_SFINAE_HEADER

#include <type_traits>  // enable_if_t, is_same_v, is_integral_v, is_floating_point_v, ...

namespace cen {

/// \addtogroup core
/// \{

// clang-format off

/// Enables a template if the type is either integral of floating-point, but not a boolean.
template <typename T>
using enable_if_number_t = std::enable_if_t<!std::is_same_v<T, bool> &&
                                            (std::is_integral_v<T> ||
                                             std::is_floating_point_v<T>), int>;

// clang-format on

/// Enables a template if the type is a pointer.
template <typename T>
using enable_if_pointer_v = std::enable_if_t<std::is_pointer_v<T>, int>;

/// Enables a template if T is convertible to any of the specified types.
template <typename T, typename... Args>
using enable_if_convertible_t = std::enable_if_t<(std::is_convertible_v<T, Args> || ...), int>;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_SFINAE_HEADER


namespace cen {

/**
 * \typedef not_null
 *
 * \ingroup core
 *
 * \brief Tag used to indicate that a pointer cannot be null.
 *
 * \note This alias is equivalent to `T`, it is a no-op.
 *
 * \since 5.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using not_null = T;

}  // namespace cen

#endif  // CENTURION_NOT_NULL_HEADER

// #include "../core/owner.hpp"
#ifndef CENTURION_OWNER_HEADER
#define CENTURION_OWNER_HEADER

// #include "sfinae.hpp"


namespace cen {

/**
 * \typedef owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote ownership of raw pointers directly in code.
 *
 * \details If a function takes an `owner<T*>` as a parameter, then the function will
 * claim ownership of that pointer. Subsequently, if a function returns an `owner<T*>`,
 * then ownership is transferred to the caller.
 */
template <typename T, enable_if_pointer_v<T> = 0>
using owner = T;

/**
 * \typedef maybe_owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote conditional ownership of raw pointers directly in code.
 *
 * \details This is primarily used in constructors of owner/handle classes, where the
 * owner version will claim ownership of the pointer, whilst the handle does not.
 *
 * \since 6.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using maybe_owner = T;

}  // namespace cen

#endif  // CENTURION_OWNER_HEADER
// #include "../core/result.hpp"
#ifndef CENTURION_RESULT_HEADER
#define CENTURION_RESULT_HEADER

#include <ostream>  // ostream
#include <string>   // string

namespace cen {

/// \addtogroup core
/// \{

/**
 * \class result
 *
 * \brief A simple indicator for the result of different operations.
 *
 * \details The idea behind this class is to make results of various operations
 * unambiguous. Quite an amount of functions in the library may fail, and earlier versions
 * of Centurion would usually return a `bool` in those cases, where `true` and `false`
 * would indicate success and failure, respectively. This class is a development of that
 * practice. For instance, this class is contextually convertible to `bool`, where a
 * successful result is still converted to `true`, and vice versa. However, this class
 * also enables explicit checks against `success` and `failure` constants, which makes
 * code very easy to read and unambiguous.
 * \code{cpp}
 *   cen::window window;
 *
 *   if (window.set_opacity(0.4f))
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::success)
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::failure)
 *   {
 *     // Failure!
 *   }
 * \endcode
 *
 * \see `success`
 * \see `failure`
 *
 * \since 6.0.0
 */
class result final
{
 public:
  /**
   * \brief Creates a result.
   *
   * \param success `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  constexpr result(const bool success) noexcept  // NOLINT implicit
      : m_success{success}
  {}

  /// \name Comparison operators
  /// \{

  /**
   * \brief Indicates whether or not two results have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results are equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator==(const result other) const noexcept -> bool
  {
    return m_success == other.m_success;
  }

  /**
   * \brief Indicates whether or not two results don't have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results aren't equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator!=(const result other) const noexcept -> bool
  {
    return !(*this == other);
  }

  /// \} End of comparison operators

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not the result is successful.
   *
   * \return `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr explicit operator bool() const noexcept
  {
    return m_success;
  }

  /// \} End of conversions

 private:
  bool m_success{};
};

/// Represents a successful result.
/// \since 6.0.0
inline constexpr result success{true};

/// Represents a failure of some kind.
/// \since 6.0.0
inline constexpr result failure{false};

/// \name String conversions
/// \{

/**
 * \brief Returns a string that represents a result value.
 *
 * \note The returned string is in a slightly different format compared to other Centurion
 * components.
 *
 * \param result the value that will be converted.
 *
 * \return `"success"` for a successful result; `"failure"` otherwise.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto to_string(const result result) -> std::string
{
  return result ? "success" : "failure";
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a result value using a stream.
 *
 * \param stream the stream that will be used.
 * \param result the result value that will be printed.
 *
 * \return the used stream.
 *
 * \since 6.0.0
 */
inline auto operator<<(std::ostream& stream, const result result) -> std::ostream&
{
  return stream << to_string(result);
}

/// \} End of streaming

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_RESULT_HEADER

// #include "../core/sdl_string.hpp"
#ifndef CENTURION_SDL_STRING_HEADER
#define CENTURION_SDL_STRING_HEADER

#include <SDL.h>

#include <memory>  // unique_ptr
#include <string>  // string

// #include "../detail/sdl_deleter.hpp"
#ifndef CENTURION_DETAIL_SDL_DELETER_HEADER
#define CENTURION_DETAIL_SDL_DELETER_HEADER

#include <SDL.h>

/// \cond FALSE
namespace cen::detail {

template <typename T>
struct sdl_deleter final
{
  void operator()(T* ptr) noexcept
  {
    SDL_free(ptr);
  }
};

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_SDL_DELETER_HEADER

// #include "owner.hpp"
#ifndef CENTURION_OWNER_HEADER
#define CENTURION_OWNER_HEADER

// #include "sfinae.hpp"


namespace cen {

/**
 * \typedef owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote ownership of raw pointers directly in code.
 *
 * \details If a function takes an `owner<T*>` as a parameter, then the function will
 * claim ownership of that pointer. Subsequently, if a function returns an `owner<T*>`,
 * then ownership is transferred to the caller.
 */
template <typename T, enable_if_pointer_v<T> = 0>
using owner = T;

/**
 * \typedef maybe_owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote conditional ownership of raw pointers directly in code.
 *
 * \details This is primarily used in constructors of owner/handle classes, where the
 * owner version will claim ownership of the pointer, whilst the handle does not.
 *
 * \since 6.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using maybe_owner = T;

}  // namespace cen

#endif  // CENTURION_OWNER_HEADER
// #include "str.hpp"


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class sdl_string
 *
 * \brief Represents an SDL string.
 *
 * \details Certain SDL APIs return `char*` strings that need to be freed using
 * `SDL_free`, this class serves as a small wrapper around such strings. Use the `copy()`
 * member function to convert the string into a corresponding `std::string`.
 *
 * \note Instances of `sdl_string` might manage null strings. Use the overloaded `operator
 * bool()` in order to determine whether or not any associated string is null.
 *
 * \since 5.0.0
 */
class sdl_string final
{
 public:
  /**
   * \brief Creates a string.
   *
   * \param str the string that will be claimed, can be null.
   *
   * \since 5.0.0
   */
  explicit sdl_string(owner<char*> str) noexcept : m_str{str}
  {}

  /**
   * \brief Returns the internal string, which might be null.
   *
   * \return the internal string; `nullptr` if there is none.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get() const noexcept -> str
  {
    return m_str.get();
  }

  /**
   * \brief Returns a copy of the internal string.
   *
   * \details This function returns the empty string if the internal string is a null
   * pointer.
   *
   * \return a copy of the internal string.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto copy() const -> std::string
  {
    if (m_str) {
      return std::string{get()};
    }
    else {
      return std::string{};
    }
  }

  /**
   * \brief Indicates whether or not the internal string is non-null.
   *
   * \return `true` if the internal string is non-null; `false` otherwise.
   *
   * \since 5.0.0
   */
  explicit operator bool() const noexcept
  {
    return m_str.operator bool();
  }

 private:
  std::unique_ptr<char, detail::sdl_deleter<char>> m_str;
};

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_SDL_STRING_HEADER

// #include "../core/str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER

// #include "../core/str_or_na.hpp"
#ifndef CENTURION_STR_OR_NA_HEADER
#define CENTURION_STR_OR_NA_HEADER

// #include "not_null.hpp"
#ifndef CENTURION_NOT_NULL_HEADER
#define CENTURION_NOT_NULL_HEADER

// #include "sfinae.hpp"


namespace cen {

/**
 * \typedef not_null
 *
 * \ingroup core
 *
 * \brief Tag used to indicate that a pointer cannot be null.
 *
 * \note This alias is equivalent to `T`, it is a no-op.
 *
 * \since 5.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using not_null = T;

}  // namespace cen

#endif  // CENTURION_NOT_NULL_HEADER

// #include "str.hpp"


namespace cen {

/// \addtogroup core
/// \{

/**
 * \brief Simply returns the string if it isn't null, returning a placeholder otherwise.
 *
 * \note This is mainly used in `to_string()` overloads.
 *
 * \param string the string that will be checked.
 *
 * \return the supplied string if it isn't null; "n/a" otherwise.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto str_or_na(const str string) noexcept -> not_null<str>
{
  return string ? string : "n/a";
}

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_OR_NA_HEADER

// #include "../core/time.hpp"
#ifndef CENTURION_TIME_HEADER
#define CENTURION_TIME_HEADER

#include <chrono>  // duration
#include <ratio>   // milli, micro, nano

// #include "integers.hpp"
#ifndef CENTURION_INTEGERS_HEADER
#define CENTURION_INTEGERS_HEADER

#include <SDL.h>

#include <cstddef>  // size_t

namespace cen {

/// \addtogroup core
/// \{

/// \name Integer aliases
/// \{

using usize = std::size_t;

/// Alias for an unsigned integer.
using uint = unsigned int;

/// Alias for the type used for integer literal operators.
using ulonglong = unsigned long long;

/// Alias for a 64-bit unsigned integer.
using u64 = Uint64;

/// Alias for a 32-bit unsigned integer.
using u32 = Uint32;

/// Alias for a 16-bit unsigned integer.
using u16 = Uint16;

/// Alias for an 8-bit unsigned integer.
using u8 = Uint8;

/// Alias for a 64-bit signed integer.
using i64 = Sint64;

/// Alias for a 32-bit signed integer.
using i32 = Sint32;

/// Alias for a 16-bit signed integer.
using i16 = Sint16;

/// Alias for an 8-bit signed integer.
using i8 = Sint8;

/// \} End of integer aliases

// clang-format off

/**
 * \brief Obtains the size of a container as an `int`.
 *
 * \tparam T a "container" that provides a `size()` member function.
 *
 * \param container the container to query the size of.
 *
 * \return the size of the container as an `int` value.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto isize(const T& container) noexcept(noexcept(container.size()))
    -> int
{
  return static_cast<int>(container.size());
}

// clang-format on

namespace literals {

/**
 * \brief Creates an 8-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u8(const ulonglong value) noexcept -> u8
{
  return static_cast<u8>(value);
}

/**
 * \brief Creates a 16-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u16(const ulonglong value) noexcept -> u16
{
  return static_cast<u16>(value);
}

/**
 * \brief Creates a 32-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u32(const ulonglong value) noexcept -> u32
{
  return static_cast<u32>(value);
}

/**
 * \brief Creates a 64-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u64(const ulonglong value) noexcept -> u64
{
  return static_cast<u64>(value);
}

/**
 * \brief Creates an 8-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i8(const ulonglong value) noexcept -> i8
{
  return static_cast<i8>(value);
}

/**
 * \brief Creates a 16-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i16(const ulonglong value) noexcept -> i16
{
  return static_cast<i16>(value);
}

/**
 * \brief Creates a 32-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i32(const ulonglong value) noexcept -> i32
{
  return static_cast<i32>(value);
}

/**
 * \brief Creates a 64-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i64(const ulonglong value) noexcept -> i64
{
  return static_cast<i64>(value);
}

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_INTEGERS_HEADER


namespace cen {

/// \addtogroup core
/// \{

/// \name Time (std::chrono) aliases
/// \{

/**
 * \typedef seconds
 *
 * \brief Templated alias for durations in seconds.
 */
template <typename T>
using seconds = std::chrono::duration<T>;

/**
 * \typedef milliseconds
 *
 * \brief Templated alias for durations in milliseconds.
 */
template <typename T>
using milliseconds = std::chrono::duration<T, std::milli>;

/**
 * \typedef microseconds
 *
 * \brief Templated alias for durations in microseconds.
 */
template <typename T>
using microseconds = std::chrono::duration<T, std::micro>;

/**
 * \typedef nanoseconds
 *
 * \brief Templated alias for durations in nanoseconds.
 */
template <typename T>
using nanoseconds = std::chrono::duration<T, std::nano>;

/**
 * \typedef minutes
 *
 * \brief Templated alias for durations in minutes.
 */
template <typename T>
using minutes = std::chrono::duration<T, std::ratio<60>>;

/// \} End of time (std::chrono) aliases

namespace literals {

// clang-format off

[[nodiscard]] constexpr auto operator"" _ns(const ulonglong value) noexcept(noexcept(nanoseconds<u32>{}))
    -> nanoseconds<u32>
{
  return nanoseconds<u32>{value};
}

[[nodiscard]] constexpr auto operator"" _us(const ulonglong value) noexcept(noexcept(microseconds<u32>{}))
    -> microseconds<u32>
{
  return microseconds<u32>{value};
}

[[nodiscard]] constexpr auto operator"" _ms(const ulonglong value) noexcept(noexcept(milliseconds<u32>{}))
    -> milliseconds<u32>
{
  return milliseconds<u32>{value};
}

[[nodiscard]] constexpr auto operator"" _s(const ulonglong value) noexcept(noexcept(seconds<u32>{}))
    -> seconds<u32>
{
  return seconds<u32>{value};
}

// clang-format on

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_TIME_HEADER

// #include "../detail/address_of.hpp"
#ifndef CENTURION_DETAIL_ADDRESS_OF_HEADER
#define CENTURION_DETAIL_ADDRESS_OF_HEADER

#include <sstream>  // stringstream
#include <string>   // string

// #include "../compiler/compiler.hpp"
#ifndef CENTURION_COMPILER_HEADER
#define CENTURION_COMPILER_HEADER

#include <SDL.h>

namespace cen {

/// \addtogroup compiler
/// \{

/**
 * \brief Indicates whether or not a "debug" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a debug build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_debug_build() noexcept -> bool
{
#ifndef NDEBUG
  return true;
#else
  return false;
#endif  // NDEBUG
}

/**
 * \brief Indicates whether or not a "release" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a release build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_release_build() noexcept -> bool
{
  return !is_debug_build();
}

/**
 * \brief Indicates whether or not the compiler is MSVC.
 *
 * \return `true` if MSVC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_msvc() noexcept -> bool
{
#ifdef _MSC_VER
  return true;
#else
  return false;
#endif  // _MSC_VER
}

/**
 * \brief Indicates whether or not the compiler is GCC.
 *
 * \return `true` if GCC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_gcc() noexcept -> bool
{
#ifdef __GNUC__
  return true;
#else
  return false;
#endif  // __GNUC__
}

/**
 * \brief Indicates whether or not the compiler is Clang.
 *
 * \return `true` if Clang is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_clang() noexcept -> bool
{
#ifdef __clang__
  return true;
#else
  return false;
#endif  // __clang__
}

/**
 * \brief Indicates whether or not the compiler is Emscripten.
 *
 * \return `true` if Emscripten is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_emscripten() noexcept -> bool
{
#ifdef __EMSCRIPTEN__
  return true;
#else
  return false;
#endif  // __EMSCRIPTEN__
}

/**
 * \brief Indicates whether or not the compiler is Intel C++.
 *
 * \return `true` if Intel C++ is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_intel_cpp() noexcept -> bool
{
#ifdef __INTEL_COMPILER
  return true;
#else
  return false;
#endif  // __INTEL_COMPILER
}

/// \} End of compiler group

}  // namespace cen

#endif  // CENTURION_COMPILER_HEADER


/// \cond FALSE
namespace cen::detail {

/**
 * \brief Returns a string that represents the memory address of the supplied pointer.
 *
 * \details The empty string is returned if the supplied pointer is null.
 *
 * \tparam T the type of the pointer.
 * \param ptr the pointer that will be converted.
 *
 * \return a string that represents the memory address of the supplied pointer.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto address_of(const void* ptr) -> std::string
{
  if (ptr) {
    std::stringstream stream;

    if constexpr (on_msvc()) {
      stream << "0x";  // Only MSVC seems to omit this, add it for consistency
    }

    stream << ptr;
    return stream.str();
  }
  else {
    return std::string{};
  }
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_ADDRESS_OF_HEADER

// #include "../detail/owner_handle_api.hpp"
#ifndef CENTURION_DETAIL_OWNER_HANDLE_API_HEADER
#define CENTURION_DETAIL_OWNER_HANDLE_API_HEADER

#include <cassert>      // assert
#include <memory>       // unique_ptr
#include <type_traits>  // enable_if_t, is_same_v, true_type, false_type

// #include "../core/exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER


/// \cond FALSE
namespace cen::detail {

using owning_type = std::true_type;
using handle_type = std::false_type;

template <typename T>
using is_owner = std::enable_if_t<std::is_same_v<T, owning_type>, int>;

template <typename T>
using is_handle = std::enable_if_t<std::is_same_v<T, handle_type>, int>;

template <typename T>
[[nodiscard]] constexpr auto is_owning() noexcept -> bool
{
  return std::is_same_v<T, owning_type>;
}

template <typename B, typename Type, typename Deleter>
class pointer_manager final
{
  using managed_ptr = std::unique_ptr<Type, Deleter>;
  using raw_ptr = Type*;
  using pointer_type = std::conditional_t<B::value, managed_ptr, raw_ptr>;

 public:
  pointer_manager() noexcept = default;

  explicit pointer_manager(Type* ptr) noexcept : m_ptr{ptr}
  {}

  template <typename BB = B, is_owner<BB> = 0>
  void reset(Type* ptr) noexcept
  {
    m_ptr.reset(ptr);
  }

  auto operator->() noexcept -> Type*
  {
    return get();
  }

  auto operator->() const noexcept -> const Type*
  {
    return get();
  }

  auto operator*() noexcept -> Type&
  {
    assert(m_ptr);
    return *m_ptr;
  }

  auto operator*() const noexcept -> const Type&
  {
    assert(m_ptr);
    return *m_ptr;
  }

  explicit operator bool() const noexcept
  {
    return m_ptr != nullptr;
  }

  /*implicit*/ operator Type*() const noexcept
  {
    return get();
  }

  template <typename BB = B, is_owner<BB> = 0>
  [[nodiscard]] auto release() noexcept -> Type*
  {
    return m_ptr.release();
  }

  [[nodiscard]] auto get() const noexcept -> Type*
  {
    if constexpr (B::value) {
      return m_ptr.get();
    }
    else {
      return m_ptr;
    }
  }

 private:
  pointer_type m_ptr{};
};

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_OWNER_HANDLE_API_HEADER

// #include "../detail/sdl_version_at_least.hpp"
#ifndef CENTURION_DETAIL_SDL_VERSION_AT_LEAST
#define CENTURION_DETAIL_SDL_VERSION_AT_LEAST

#include <SDL.h>

// #include "../core/version.hpp"
#ifndef CENTURION_VERSION_HEADER
#define CENTURION_VERSION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <cassert>  // assert

/// \addtogroup core
/// \{

/**
 * \def CENTURION_VERSION_MAJOR
 *
 * \brief Expands into the current major version of the library.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_MAJOR 6

/**
 * \def CENTURION_VERSION_MINOR
 *
 * \brief Expands into the current minor version of the library.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_MINOR 3

/**
 * \def CENTURION_VERSION_PATCH
 *
 * \brief Expands into the current patch version of the library.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_PATCH 0

/**
 * \def CENTURION_SDL_VERSION_IS
 *
 * \brief This macro is meant to be used when conditionally including code for a specific
 * version of SDL. It is useful for applying workarounds.
 *
 * \since 5.3.0
 */
#define CENTURION_SDL_VERSION_IS(x, y, z) \
  ((SDL_MAJOR_VERSION == (x)) && (SDL_MINOR_VERSION == (y)) && (SDL_PATCHLEVEL == (z)))

#ifdef CENTURION___DOXYGEN

#define CENTURION_MAKE_VERSION_NUMBER
#define CENTURION_VERSION_NUMBER
#define CENTURION_VERSION_AT_LEAST

#endif  // CENTURION___DOXYGEN

/**
 * \def CENTURION_MAKE_VERSION_NUMBER
 *
 * \brief Helper macro for creating version numbers from a set of major/minor/patch
 * numbers.
 *
 * \details For example, if the version is 8.4.2, the resulting version number would be
 * 8402.
 *
 * \since 6.0.0
 */
#define CENTURION_MAKE_VERSION_NUMBER(x, y, z) (((x)*1'000) + ((y)*100) + (z))

/**
 * \def CENTURION_VERSION_NUMBER
 *
 * \brief Expands into a version number based on the current Centurion version.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_NUMBER                         \
  CENTURION_MAKE_VERSION_NUMBER(CENTURION_VERSION_MAJOR, \
                                CENTURION_VERSION_MINOR, \
                                CENTURION_VERSION_PATCH)

/**
 * \def CENTURION_VERSION_AT_LEAST
 *
 * \brief This macro is intended to be used for conditional compilation, based on the
 * Centurion version.
 *
 * \details This macro is used in the same way as the `SDL_VERSION_ATLEAST`, where you use
 * it as the condition with `#if` statements.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_AT_LEAST(x, y, z) \
  CENTURION_VERSION_NUMBER >= CENTURION_MAKE_VERSION_NUMBER(x, y, z)

namespace cen {

/// \name Centurion version queries
/// \{

/**
 * \struct version
 *
 * \brief Represents a set of major/minor/patch version numbers.
 *
 * \details The members of this struct are by default initialized to the current Centurion
 * version values.
 *
 * \since 6.0.0
 */
struct version final
{
  int major{CENTURION_VERSION_MAJOR};
  int minor{CENTURION_VERSION_MINOR};
  int patch{CENTURION_VERSION_PATCH};
};

/**
 * \brief Indicates whether or not the current Centurion version is at least equal to the
 * specified version.
 *
 * \param major the major version value.
 * \param minor the minor version value.
 * \param patch the patch version value.
 *
 * \return `true` if the version of Centurion is at least the specified version; `false`
 * otherwise.
 *
 * \see `CENTURION_VERSION_AT_LEAST`
 *
 * \since 6.0.0
 */
[[nodiscard]] constexpr auto version_at_least(const int major,
                                              const int minor,
                                              const int patch) noexcept -> bool
{
  return CENTURION_VERSION_AT_LEAST(major, minor, patch);
}

/// \} End of centurion version queries

/// \name SDL version queries
/// \{

/**
 * \brief Returns the version of SDL2 that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL that the
 * program was compiled against.
 *
 * \return the linked version of SDL2.
 *
 * \since 5.2.0
 */
[[nodiscard]] inline auto sdl_linked_version() noexcept -> SDL_version
{
  SDL_version version{};
  SDL_GetVersion(&version);
  return version;
}

/**
 * \brief Returns the compile-time version of SDL2 that is being used.
 *
 * \return the compile-time version of SDL2 that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_version() noexcept -> SDL_version
{
  return {SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL};
}

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \brief Returns the version of SDL2_image that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL2_image that
 * the program was compiled against.
 *
 * \return the linked version of SDL2_image.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto sdl_image_linked_version() noexcept -> SDL_version
{
  const auto* version = IMG_Linked_Version();
  assert(version);  // Sanity check
  return *version;
}

/**
 * \brief Returns the compile-time version of SDL2_image that is being used.
 *
 * \return the compile-time version of SDL2_image that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_image_version() noexcept -> SDL_version
{
  return {SDL_IMAGE_MAJOR_VERSION, SDL_IMAGE_MINOR_VERSION, SDL_IMAGE_PATCHLEVEL};
}

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \brief Returns the version of SDL2_mixer that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL2_mixer that
 * the program was compiled against.
 *
 * \return the linked version of SDL2_mixer.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto sdl_mixer_linked_version() noexcept -> SDL_version
{
  const auto* version = Mix_Linked_Version();
  assert(version);  // Sanity check
  return *version;
}

/**
 * \brief Returns the compile-time version of SDL2_mixer that is being used.
 *
 * \return the compile-time version of SDL2_mixer that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_mixer_version() noexcept -> SDL_version
{
  return {SDL_MIXER_MAJOR_VERSION, SDL_MIXER_MINOR_VERSION, SDL_MIXER_PATCHLEVEL};
}

#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF

/**
 * \brief Returns the version of SDL2_ttf that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL2_ttf that the
 * program was compiled against.
 *
 * \return the linked version of SDL2_ttf.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto sdl_ttf_linked_version() noexcept -> SDL_version
{
  const auto* version = TTF_Linked_Version();
  assert(version);  // Sanity check
  return *version;
}

/**
 * \brief Returns the compile-time version of SDL2_ttf that is being used.
 *
 * \return the compile-time version of SDL2_ttf that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_ttf_version() noexcept -> SDL_version
{
  return {SDL_TTF_MAJOR_VERSION, SDL_TTF_MINOR_VERSION, SDL_TTF_PATCHLEVEL};
}

#endif  // CENTURION_NO_SDL_TTF

/// \} End of SDL version queries

}  // namespace cen

#if CENTURION_SDL_VERSION_IS(2, 0, 10)

// Workaround for this enum being completely anonymous in SDL 2.0.10. We include
// this here because multiple files (key_code.hpp and scan_code.hpp) depend on
// this definition.
using SDL_KeyCode = decltype(SDLK_UNKNOWN);

#endif  // CENTURION_SDL_VERSION_IS(2, 0, 10)

/// \} End of group core

#endif  // CENTURION_VERSION_HEADER


/// \cond FALSE
namespace cen::detail {

[[nodiscard]] constexpr auto sdl_version_at_least(const int major,
                                                  const int minor,
                                                  const int patch) noexcept -> bool
{
  return SDL_COMPILEDVERSION >= SDL_VERSIONNUM(major, minor, patch);
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_SDL_VERSION_AT_LEAST

// #include "../video/color.hpp"
#ifndef CENTURION_COLOR_HEADER
#define CENTURION_COLOR_HEADER

#include <SDL.h>

#include <cassert>      // assert
#include <cmath>        // round, abs, fmod, lerp
#include <iomanip>      // setfill, setw
#include <ios>          // uppercase, hex
#include <optional>     // optional
#include <ostream>      // ostream
#include <sstream>      // stringstream
#include <string>       // string, to_string
#include <string_view>  // string_view

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../compiler/compiler.hpp"
#ifndef CENTURION_COMPILER_HEADER
#define CENTURION_COMPILER_HEADER

#include <SDL.h>

namespace cen {

/// \addtogroup compiler
/// \{

/**
 * \brief Indicates whether or not a "debug" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a debug build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_debug_build() noexcept -> bool
{
#ifndef NDEBUG
  return true;
#else
  return false;
#endif  // NDEBUG
}

/**
 * \brief Indicates whether or not a "release" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a release build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_release_build() noexcept -> bool
{
  return !is_debug_build();
}

/**
 * \brief Indicates whether or not the compiler is MSVC.
 *
 * \return `true` if MSVC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_msvc() noexcept -> bool
{
#ifdef _MSC_VER
  return true;
#else
  return false;
#endif  // _MSC_VER
}

/**
 * \brief Indicates whether or not the compiler is GCC.
 *
 * \return `true` if GCC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_gcc() noexcept -> bool
{
#ifdef __GNUC__
  return true;
#else
  return false;
#endif  // __GNUC__
}

/**
 * \brief Indicates whether or not the compiler is Clang.
 *
 * \return `true` if Clang is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_clang() noexcept -> bool
{
#ifdef __clang__
  return true;
#else
  return false;
#endif  // __clang__
}

/**
 * \brief Indicates whether or not the compiler is Emscripten.
 *
 * \return `true` if Emscripten is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_emscripten() noexcept -> bool
{
#ifdef __EMSCRIPTEN__
  return true;
#else
  return false;
#endif  // __EMSCRIPTEN__
}

/**
 * \brief Indicates whether or not the compiler is Intel C++.
 *
 * \return `true` if Intel C++ is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_intel_cpp() noexcept -> bool
{
#ifdef __INTEL_COMPILER
  return true;
#else
  return false;
#endif  // __INTEL_COMPILER
}

/// \} End of compiler group

}  // namespace cen

#endif  // CENTURION_COMPILER_HEADER

// #include "../core/exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER

// #include "../core/integers.hpp"
#ifndef CENTURION_INTEGERS_HEADER
#define CENTURION_INTEGERS_HEADER

#include <SDL.h>

#include <cstddef>  // size_t

namespace cen {

/// \addtogroup core
/// \{

/// \name Integer aliases
/// \{

using usize = std::size_t;

/// Alias for an unsigned integer.
using uint = unsigned int;

/// Alias for the type used for integer literal operators.
using ulonglong = unsigned long long;

/// Alias for a 64-bit unsigned integer.
using u64 = Uint64;

/// Alias for a 32-bit unsigned integer.
using u32 = Uint32;

/// Alias for a 16-bit unsigned integer.
using u16 = Uint16;

/// Alias for an 8-bit unsigned integer.
using u8 = Uint8;

/// Alias for a 64-bit signed integer.
using i64 = Sint64;

/// Alias for a 32-bit signed integer.
using i32 = Sint32;

/// Alias for a 16-bit signed integer.
using i16 = Sint16;

/// Alias for an 8-bit signed integer.
using i8 = Sint8;

/// \} End of integer aliases

// clang-format off

/**
 * \brief Obtains the size of a container as an `int`.
 *
 * \tparam T a "container" that provides a `size()` member function.
 *
 * \param container the container to query the size of.
 *
 * \return the size of the container as an `int` value.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto isize(const T& container) noexcept(noexcept(container.size()))
    -> int
{
  return static_cast<int>(container.size());
}

// clang-format on

namespace literals {

/**
 * \brief Creates an 8-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u8(const ulonglong value) noexcept -> u8
{
  return static_cast<u8>(value);
}

/**
 * \brief Creates a 16-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u16(const ulonglong value) noexcept -> u16
{
  return static_cast<u16>(value);
}

/**
 * \brief Creates a 32-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u32(const ulonglong value) noexcept -> u32
{
  return static_cast<u32>(value);
}

/**
 * \brief Creates a 64-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u64(const ulonglong value) noexcept -> u64
{
  return static_cast<u64>(value);
}

/**
 * \brief Creates an 8-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i8(const ulonglong value) noexcept -> i8
{
  return static_cast<i8>(value);
}

/**
 * \brief Creates a 16-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i16(const ulonglong value) noexcept -> i16
{
  return static_cast<i16>(value);
}

/**
 * \brief Creates a 32-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i32(const ulonglong value) noexcept -> i32
{
  return static_cast<i32>(value);
}

/**
 * \brief Creates a 64-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i64(const ulonglong value) noexcept -> i64
{
  return static_cast<i64>(value);
}

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_INTEGERS_HEADER

// #include "../detail/clamp.hpp"
#ifndef CENTURION_DETAIL_CLAMP_HEADER
#define CENTURION_DETAIL_CLAMP_HEADER

#include <cassert>  // assert

/// \cond FALSE
namespace cen::detail {

// clang-format off

/**
 * \brief Clamps a value to be within the range [min, max].
 *
 * \pre `min` must be less than or equal to `max`.
 *
 * \note The standard library provides `std::clamp`, but it isn't mandated to be
 * `noexcept` (although MSVC does mark it as `noexcept`), which is the reason this
 * function exists.
 *
 * \tparam T the type of the values.
 *
 * \param value the value that will be clamped.
 * \param min the minimum value (inclusive).
 * \param max the maximum value (inclusive).
 *
 * \return the clamped value.
 *
 * \since 5.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto clamp(const T& value,
                                   const T& min,
                                   const T& max)
    noexcept(noexcept(value < min) && noexcept(value > max)) -> T
{
  assert(min <= max);
  if (value < min)
  {
    return min;
  }
  else if (value > max)
  {
    return max;
  }
  else
  {
    return value;
  }
}

// clang-format on

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_CLAMP_HEADER

// #include "../detail/from_string.hpp"
#ifndef CENTURION_DETAIL_FROM_STRING_HEADER
#define CENTURION_DETAIL_FROM_STRING_HEADER

#include <charconv>      // from_chars
#include <optional>      // optional
#include <string>        // string, stof
#include <string_view>   // string_view
#include <system_error>  // errc
#include <type_traits>   // is_floating_point_v

// #include "../compiler/compiler.hpp"
#ifndef CENTURION_COMPILER_HEADER
#define CENTURION_COMPILER_HEADER

#include <SDL.h>

namespace cen {

/// \addtogroup compiler
/// \{

/**
 * \brief Indicates whether or not a "debug" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a debug build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_debug_build() noexcept -> bool
{
#ifndef NDEBUG
  return true;
#else
  return false;
#endif  // NDEBUG
}

/**
 * \brief Indicates whether or not a "release" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a release build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_release_build() noexcept -> bool
{
  return !is_debug_build();
}

/**
 * \brief Indicates whether or not the compiler is MSVC.
 *
 * \return `true` if MSVC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_msvc() noexcept -> bool
{
#ifdef _MSC_VER
  return true;
#else
  return false;
#endif  // _MSC_VER
}

/**
 * \brief Indicates whether or not the compiler is GCC.
 *
 * \return `true` if GCC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_gcc() noexcept -> bool
{
#ifdef __GNUC__
  return true;
#else
  return false;
#endif  // __GNUC__
}

/**
 * \brief Indicates whether or not the compiler is Clang.
 *
 * \return `true` if Clang is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_clang() noexcept -> bool
{
#ifdef __clang__
  return true;
#else
  return false;
#endif  // __clang__
}

/**
 * \brief Indicates whether or not the compiler is Emscripten.
 *
 * \return `true` if Emscripten is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_emscripten() noexcept -> bool
{
#ifdef __EMSCRIPTEN__
  return true;
#else
  return false;
#endif  // __EMSCRIPTEN__
}

/**
 * \brief Indicates whether or not the compiler is Intel C++.
 *
 * \return `true` if Intel C++ is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_intel_cpp() noexcept -> bool
{
#ifdef __INTEL_COMPILER
  return true;
#else
  return false;
#endif  // __INTEL_COMPILER
}

/// \} End of compiler group

}  // namespace cen

#endif  // CENTURION_COMPILER_HEADER


/// \cond FALSE
namespace cen::detail {

template <typename T>
[[nodiscard]] auto from_string(const std::string_view str,
                               const int base = 10) noexcept(on_msvc()) -> std::optional<T>
{
  T value{};

  const auto begin = str.data();
  const auto end = str.data() + str.size();

  const char* mismatch = end;
  std::errc error{};

  if constexpr (std::is_floating_point_v<T>) {
    if constexpr (on_gcc() || on_clang()) {
      try {
        value = std::stof(std::string{str});
      }
      catch (...) {
        return std::nullopt;
      }
    }
    else {
      const auto [ptr, err] = std::from_chars(begin, end, value);
      mismatch = ptr;
      error = err;
    }
  }
  else {
    const auto [ptr, err] = std::from_chars(begin, end, value, base);
    mismatch = ptr;
    error = err;
  }

  if (mismatch == end && error == std::errc{}) {
    return value;
  }
  else {
    return std::nullopt;
  }
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_FROM_STRING_HEADER

// #include "../detail/lerp.hpp"
#ifndef CENTURION_DETAIL_LERP_HEADER
#define CENTURION_DETAIL_LERP_HEADER

#include <cmath>  // lerp

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER


/// \cond FALSE

namespace cen::detail {

[[nodiscard]] constexpr auto lerp(const float a, const float b, const float bias) noexcept
    -> float
{
#if CENTURION_HAS_FEATURE_LERP
  return std::lerp(a, b, bias);
#else
  return (a * (1.0f - bias)) + (b * bias);
#endif  // CENTURION_HAS_FEATURE_LERP
}

}  // namespace cen::detail

/// \endcond

#endif  // CENTURION_DETAIL_LERP_HEADER


namespace cen {

/// \addtogroup video
/// \{

/**
 * \class color
 *
 * \brief An 8-bit accuracy RGBA color.
 *
 * \serializable
 *
 * \details This class is designed to interact with the SDL colors, i.e. `SDL_Color` and
 * `SDL_MessageBoxColor`. For convenience, there are approximately 140 color constants
 * provided in the `colors` namespace,
 *
 * \since 3.0.0
 */
class color final
{
 public:
  /// \name Construction
  /// \{

  /**
   * \brief Creates a color. The created color will be equal to #000000FF.
   *
   * \since 3.0.0
   */
  constexpr color() noexcept = default;

  /**
   * \brief Creates a color.
   *
   * \param red the red component value, in the range [0, 255].
   * \param green the green component value, in the range [0, 255].
   * \param blue the blue component value, in the range [0, 255].
   * \param alpha the alpha component value, in the rage [0, 255]. Defaults to 255.
   *
   * \since 3.0.0
   */
  constexpr color(const u8 red, const u8 green, const u8 blue, const u8 alpha = max()) noexcept
      : m_color{red, green, blue, alpha}
  {}

  /**
   * \brief Creates a color that is a copy of the supplied `SDL_Color`.
   *
   * \param color the `SDL_Color` that will be copied.
   *
   * \since 3.0.0
   */
  constexpr explicit color(const SDL_Color& color) noexcept : m_color{color}
  {}

  /**
   * \brief Creates a color that is a copy of the supplied SDL_MessageBoxColor.
   *
   * \details Message box colors don't have an alpha component so the created color will
   * feature an alpha value of 255.
   *
   * \param color the message box color that will be copied.
   *
   * \since 3.0.0
   */
  constexpr explicit color(const SDL_MessageBoxColor& color) noexcept
      : m_color{color.r, color.g, color.b, max()}
  {}

  /**
   * \brief Creates a color from HSV-encoded values.
   *
   * \note The values will be clamped to be within their respective ranges.
   *
   * \param hue the hue of the color, in the range [0, 360].
   * \param saturation the saturation of the color, in the range [0, 100].
   * \param value the value of the color, in the range [0, 100].
   *
   * \return an RGBA color converted from the HSV values.
   *
   * \since 5.3.0
   */
  [[nodiscard]] static auto from_hsv(float hue, float saturation, float value) -> color
  {
    hue = detail::clamp(hue, 0.0f, 360.0f);
    saturation = detail::clamp(saturation, 0.0f, 100.0f);
    value = detail::clamp(value, 0.0f, 100.0f);

    const auto v = (value / 100.0f);
    const auto chroma = v * (saturation / 100.0f);
    const auto hp = hue / 60.0f;

    const auto x = chroma * (1.0f - std::abs(std::fmod(hp, 2.0f) - 1.0f));

    float red{};
    float green{};
    float blue{};

    if (0 <= hp && hp <= 1) {
      red = chroma;
      green = x;
      blue = 0;
    }
    else if (1 < hp && hp <= 2) {
      red = x;
      green = chroma;
      blue = 0;
    }
    else if (2 < hp && hp <= 3) {
      red = 0;
      green = chroma;
      blue = x;
    }
    else if (3 < hp && hp <= 4) {
      red = 0;
      green = x;
      blue = chroma;
    }
    else if (4 < hp && hp <= 5) {
      red = x;
      green = 0;
      blue = chroma;
    }
    else if (5 < hp && hp <= 6) {
      red = chroma;
      green = 0;
      blue = x;
    }

    const auto m = v - chroma;

    const auto r = static_cast<u8>(std::round((red + m) * 255.0f));
    const auto g = static_cast<u8>(std::round((green + m) * 255.0f));
    const auto b = static_cast<u8>(std::round((blue + m) * 255.0f));

    return color{r, g, b};
  }

  /**
   * \brief Creates a color from HSL-encoded values.
   *
   * \note The values will be clamped to be within their respective ranges.
   *
   * \param hue the hue of the color, in the range [0, 360].
   * \param saturation the saturation of the color, in the range [0, 100].
   * \param lightness the lightness of the color, in the range [0, 100].
   *
   * \return an RGBA color converted from the HSL values.
   *
   * \since 5.3.0
   */
  [[nodiscard]] static auto from_hsl(float hue, float saturation, float lightness) -> color
  {
    hue = detail::clamp(hue, 0.0f, 360.0f);
    saturation = detail::clamp(saturation, 0.0f, 100.0f);
    lightness = detail::clamp(lightness, 0.0f, 100.0f);

    const auto s = saturation / 100.0f;
    const auto l = lightness / 100.0f;

    const auto chroma = (1.0f - std::abs(2.0f * l - 1.0f)) * s;
    const auto hp = hue / 60.0f;

    const auto x = chroma * (1.0f - std::abs(std::fmod(hp, 2.0f) - 1.0f));

    float red{};
    float green{};
    float blue{};

    if (0 <= hp && hp < 1) {
      red = chroma;
      green = x;
      blue = 0;
    }
    else if (1 <= hp && hp < 2) {
      red = x;
      green = chroma;
      blue = 0;
    }
    else if (2 <= hp && hp < 3) {
      red = 0;
      green = chroma;
      blue = x;
    }
    else if (3 <= hp && hp < 4) {
      red = 0;
      green = x;
      blue = chroma;
    }
    else if (4 <= hp && hp < 5) {
      red = x;
      green = 0;
      blue = chroma;
    }
    else if (5 <= hp && hp < 6) {
      red = chroma;
      green = 0;
      blue = x;
    }

    const auto m = l - (chroma / 2.0f);

    const auto r = static_cast<u8>(std::round((red + m) * 255.0f));
    const auto g = static_cast<u8>(std::round((green + m) * 255.0f));
    const auto b = static_cast<u8>(std::round((blue + m) * 255.0f));

    return color{r, g, b};
  }

  /**
   * \brief Creates a color from a hexadecimal RGB color string.
   *
   * \details The supplied string must feature a leading '#' character, and be 7
   * characters long.
   *
   * \param rgb the hexadecimal RGB color string, using the format "#RRGGBB".
   *
   * \return a corresponding color; `std::nullopt` if something goes wrong.
   *
   * \see `from_rgba()`
   * \see `from_argb()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] static auto from_rgb(const std::string_view rgb) -> std::optional<color>
  {
    if (rgb.length() != 7 || rgb.at(0) != '#') {
      return std::nullopt;
    }

    const auto noHash = rgb.substr(1);

    const auto rr = noHash.substr(0, 2);
    const auto gg = noHash.substr(2, 2);
    const auto bb = noHash.substr(4, 2);

    const auto red = detail::from_string<u8>(rr, 16);
    const auto green = detail::from_string<u8>(gg, 16);
    const auto blue = detail::from_string<u8>(bb, 16);

    if (red && green && blue) {
      return cen::color{*red, *green, *blue};
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Creates a color from a hexadecimal RGBA color string.
   *
   * \details The supplied string must feature a leading '#' character, and be 9
   * characters long.
   *
   * \param rgba the hexadecimal RGBA color string, using the format "#RRGGBBAA".
   *
   * \return a corresponding color; `std::nullopt` if something goes wrong.
   *
   * \see `from_rgb()`
   * \see `from_argb()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] static auto from_rgba(const std::string_view rgba) -> std::optional<color>
  {
    if (rgba.length() != 9 || rgba.at(0) != '#') {
      return std::nullopt;
    }

    const auto noHash = rgba.substr(1);

    const auto rr = noHash.substr(0, 2);
    const auto gg = noHash.substr(2, 2);
    const auto bb = noHash.substr(4, 2);
    const auto aa = noHash.substr(6, 2);

    const auto red = detail::from_string<u8>(rr, 16);
    const auto green = detail::from_string<u8>(gg, 16);
    const auto blue = detail::from_string<u8>(bb, 16);
    const auto alpha = detail::from_string<u8>(aa, 16);

    if (red && green && blue && alpha) {
      return cen::color{*red, *green, *blue, *alpha};
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Creates a color from a hexadecimal ARGB color string.
   *
   * \details The supplied string must feature a leading '#' character, and be 9
   * characters long.
   *
   * \param argb the hexadecimal ARGB color string, using the format "#AARRGGBB".
   *
   * \return a corresponding color; `std::nullopt` if something goes wrong.
   *
   * \see `from_rgb()`
   * \see `from_rgba()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] static auto from_argb(const std::string_view argb) -> std::optional<color>
  {
    if (argb.length() != 9 || argb.at(0) != '#') {
      return std::nullopt;
    }

    const auto noHash = argb.substr(1);

    const auto aa = noHash.substr(0, 2);
    const auto rr = noHash.substr(2, 2);
    const auto gg = noHash.substr(4, 2);
    const auto bb = noHash.substr(6, 2);

    const auto alpha = detail::from_string<u8>(aa, 16);
    const auto red = detail::from_string<u8>(rr, 16);
    const auto green = detail::from_string<u8>(gg, 16);
    const auto blue = detail::from_string<u8>(bb, 16);

    if (alpha && red && green && blue) {
      return cen::color{*red, *green, *blue, *alpha};
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Creates a color from normalized color component values.
   *
   * \note The color components will be clamped to the range [0, 1].
   *
   * \param red the red component value, in the range [0, 1].
   * \param green the green component value, in the range [0, 1].
   * \param blue the blue component value, in the range [0, 1].
   * \param alpha the alpha component value, in the range [0, 1].
   *
   * \return a color with the supplied color components.
   *
   * \since 6.1.0
   */
  [[nodiscard]] static auto from_norm(float red,
                                      float green,
                                      float blue,
                                      float alpha = 1.0f) noexcept(on_msvc()) -> color
  {
    red = detail::clamp(red, 0.0f, 1.0f);
    green = detail::clamp(green, 0.0f, 1.0f);
    blue = detail::clamp(blue, 0.0f, 1.0f);
    alpha = detail::clamp(alpha, 0.0f, 1.0f);

    const auto r = static_cast<u8>(std::round(red * 255.0f));
    const auto g = static_cast<u8>(std::round(green * 255.0f));
    const auto b = static_cast<u8>(std::round(blue * 255.0f));
    const auto a = static_cast<u8>(std::round(alpha * 255.0f));

    return color{r, g, b, a};
  }

  /// \} End of construction

  /// \name Setters
  /// \{

  /**
   * \brief Sets the value of the red component.
   *
   * \param red the new value of the red component.
   *
   * \since 3.0.0
   */
  constexpr void set_red(const u8 red) noexcept
  {
    m_color.r = red;
  }

  /**
   * \brief Sets the value of the green component.
   *
   * \param green the new value of the green component.
   *
   * \since 3.0.0
   */
  constexpr void set_green(const u8 green) noexcept
  {
    m_color.g = green;
  }

  /**
   * \brief Sets the value of the blue component.
   *
   * \param blue the new value of the blue component.
   *
   * \since 3.0.0
   */
  constexpr void set_blue(const u8 blue) noexcept
  {
    m_color.b = blue;
  }

  /**
   * \brief Sets the value of the alpha component.
   *
   * \param alpha the new value of the alpha component.
   *
   * \since 3.0.0
   */
  constexpr void set_alpha(const u8 alpha) noexcept
  {
    m_color.a = alpha;
  }

  /// \} End of setters

  /// \name Getters
  /// \{

  /**
   * \brief Returns the value of the red component.
   *
   * \return the value of the red component, in the range [0, 255].
   *
   * \since 3.0.0
   */
  [[nodiscard]] constexpr auto red() const noexcept -> u8
  {
    return m_color.r;
  }

  /**
   * \brief Returns the value of the green component.
   *
   * \return the value of the green component, in the range [0, 255].
   *
   * \since 3.0.0
   */
  [[nodiscard]] constexpr auto green() const noexcept -> u8
  {
    return m_color.g;
  }

  /**
   * \brief Returns the value of the blue component.
   *
   * \return the value of the blue component, in the range [0, 255].
   *
   * \since 3.0.0
   */
  [[nodiscard]] constexpr auto blue() const noexcept -> u8
  {
    return m_color.b;
  }

  /**
   * \brief Returns the value of the alpha component.
   *
   * \return the value of the alpha component, in the range [0, 255].
   *
   * \since 3.0.0
   */
  [[nodiscard]] constexpr auto alpha() const noexcept -> u8
  {
    return m_color.a;
  }

  /**
   * \brief Returns the normalized red component of the color.
   *
   * \return the red component value, in the range [0, 1].
   *
   * \since 6.1.0
   */
  [[nodiscard]] constexpr auto red_norm() const noexcept -> float
  {
    return static_cast<float>(m_color.r) / 255.0f;
  }

  /**
   * \brief Returns the normalized green component of the color.
   *
   * \return the green component value, in the range [0, 1].
   *
   * \since 6.1.0
   */
  [[nodiscard]] constexpr auto green_norm() const noexcept -> float
  {
    return static_cast<float>(m_color.g) / 255.0f;
  }

  /**
   * \brief Returns the normalized blue component of the color.
   *
   * \return the blue component value, in the range [0, 1].
   *
   * \since 6.1.0
   */
  [[nodiscard]] constexpr auto blue_norm() const noexcept -> float
  {
    return static_cast<float>(m_color.b) / 255.0f;
  }

  /**
   * \brief Returns the normalized alpha component of the color.
   *
   * \return the alpha component value, in the range [0, 1].
   *
   * \since 6.1.0
   */
  [[nodiscard]] constexpr auto alpha_norm() const noexcept -> float
  {
    return static_cast<float>(m_color.a) / 255.0f;
  }

  /**
   * \brief Returns a pointer to the internal SDL color.
   *
   * \warning Do not cache the returned pointer!
   *
   * \return a pointer to the internal color instance.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto data() noexcept -> SDL_Color*
  {
    return &m_color;
  }

  /// \copydoc data()
  [[nodiscard]] auto data() const noexcept -> const SDL_Color*
  {
    return &m_color;
  }

  /**
   * \brief Returns the internal color instance.
   *
   * \return a reference to the internal color.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get() const noexcept -> const SDL_Color&
  {
    return m_color;
  }

  /// \} End of getters

  /// \name Color string conversions
  /// \{

  /**
   * \brief Returns a hexadecimal RGB color string that represents the color.
   *
   * \details The returned string is guaranteed to use uppercase hexadecimal digits (A-F).
   *
   * \return a hexadecimal color string representation, on the format "#RRGGBB".
   *
   * \see `as_rgba()`
   * \see `as_argb()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto as_rgb() const -> std::string
  {
    std::stringstream stream;
    stream << std::setfill('0') << std::hex << std::uppercase;

    stream << '#';
    stream << std::setw(2) << +m_color.r;
    stream << std::setw(2) << +m_color.g;
    stream << std::setw(2) << +m_color.b;

    return stream.str();
  }

  /**
   * \brief Returns a hexadecimal RGBA color string that represents the color.
   *
   * \details The returned string is guaranteed to use uppercase hexadecimal digits (A-F).
   *
   * \return a hexadecimal color string representation, on the format "#RRGGBBAA".
   *
   * \see `as_rgb()`
   * \see `as_argb()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto as_rgba() const -> std::string
  {
    std::stringstream stream;
    stream << std::setfill('0') << std::hex << std::uppercase;

    stream << '#';
    stream << std::setw(2) << +m_color.r;
    stream << std::setw(2) << +m_color.g;
    stream << std::setw(2) << +m_color.b;
    stream << std::setw(2) << +m_color.a;

    return stream.str();
  }

  /**
   * \brief Returns a hexadecimal ARGB color string that represents the color.
   *
   * \details The returned string is guaranteed to use uppercase hexadecimal digits (A-F).
   *
   * \return a hexadecimal color string representation, on the format "#AARRGGBB".
   *
   * \see `as_rgb()`
   * \see `as_rgba()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto as_argb() const -> std::string
  {
    std::stringstream stream;
    stream << std::setfill('0') << std::hex << std::uppercase;

    stream << '#';
    stream << std::setw(2) << +m_color.a;
    stream << std::setw(2) << +m_color.r;
    stream << std::setw(2) << +m_color.g;
    stream << std::setw(2) << +m_color.b;

    return stream.str();
  }

  /// \} End of color string conversions

  /// \name Conversions
  /// \{

  /**
   * \brief Converts the the color into an `SDL_Color`.
   *
   * \return an `SDL_Color` that is equivalent to this color.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit constexpr operator SDL_Color() const noexcept
  {
    return {red(), green(), blue(), alpha()};
  }

  /**
   * \brief Converts the the color into an `SDL_MessageBoxColor`.
   *
   * \note Message box colors don't feature an alpha value!
   *
   * \return an `SDL_MessageBoxColor` that is equivalent to this color.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit constexpr operator SDL_MessageBoxColor() const noexcept
  {
    return {red(), green(), blue()};
  }

  /**
   * \brief Converts the color to `SDL_Color*`.
   *
   * \warning The returned pointer is not to be freed or stored away!
   *
   * \return a pointer to the internal color instance.
   *
   * \since 4.0,0
   */
  [[nodiscard]] explicit operator SDL_Color*() noexcept
  {
    return &m_color;
  }

  /**
   * \brief Converts the color to `const SDL_Color*`.
   *
   * \warning The returned pointer is not to be freed or stored away!
   *
   * \return a pointer to the internal color instance.
   *
   * \since 4.0,0
   */
  [[nodiscard]] explicit operator const SDL_Color*() const noexcept
  {
    return &m_color;
  }

  /// \} End of conversions

  /**
   * \brief Serializes the color.
   *
   * \details This function expects that the archive provides an overloaded `operator()`,
   * used for serializing data. This API is based on the Cereal serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the color.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_color.r, m_color.g, m_color.b, m_color.a);
  }

  /**
   * \brief Returns a copy of the color with the specified alpha value.
   *
   * \param alpha the alpha component value that will be used by the new color.
   *
   * \return a color that is identical to the color except for the alpha component.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto with_alpha(const u8 alpha) const noexcept -> color
  {
    return {red(), green(), blue(), alpha};
  }

  /**
   * \brief Returns the maximum possible value of a color component.
   *
   * \return the maximum possible value of a color component.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr static auto max() noexcept -> u8
  {
    return 0xFF;
  }

 private:
  SDL_Color m_color{0, 0, 0, max()};
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of the color.
 *
 * \param color the color that will be converted.
 *
 * \return a textual representation of the color.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto to_string(const color& color) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("color{{r: {}, g: {}, b: {}: a: {}}}",
                     +color.red(),
                     +color.green(),
                     +color.blue(),
                     +color.alpha());
#else
  return "color{r: " + std::to_string(color.red()) + ", g: " + std::to_string(color.green()) +
         ", b: " + std::to_string(color.blue()) + ", a: " + std::to_string(color.alpha()) +
         "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a color.
 *
 * \param stream the stream that will be used.
 * \param color the color that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
inline auto operator<<(std::ostream& stream, const color& color) -> std::ostream&
{
  return stream << to_string(color);
}

/// \} End of streaming

/**
 * \brief Blends two colors according to the specified bias.
 *
 * \pre `bias` should be in the range [0, 1].
 *
 * \details This function applies a linear interpolation for each color component to
 * obtain the blended color. The bias parameter is the "alpha" for the interpolation,
 * which determines how the input colors are blended. For example, a bias of 0 or 1 will
 * simply result in the first or second color being returned, respectively.
 * Subsequently, a bias of 0.5 will blend the two colors evenly.
 *
 * \param a the first color.
 * \param b the second color.
 * \param bias the bias that determines how the colors are blended, in the range [0, 1].
 *
 * \return a color obtained by blending the two supplied colors.
 *
 * \todo Default the bias to 0.5 when the `double` overload has been removed.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto blend(const color& a, const color& b, const float bias) -> color
{
  assert(bias >= 0);
  assert(bias <= 1.0f);

  const auto red = detail::lerp(a.red_norm(), b.red_norm(), bias);
  const auto green = detail::lerp(a.green_norm(), b.green_norm(), bias);
  const auto blue = detail::lerp(a.blue_norm(), b.blue_norm(), bias);
  const auto alpha = detail::lerp(a.alpha_norm(), b.alpha_norm(), bias);

  return color::from_norm(red, green, blue, alpha);
}

/// \copydoc blend()
/// \deprecated Since 6.2.0, use the overload using a `float` bias parameter instead.
[[nodiscard, deprecated]] inline auto blend(const color& a,
                                            const color& b,
                                            const double bias = 0.5) -> color
{
  return blend(a, b, static_cast<float>(bias));
}

/// \name Color comparison operators
/// \{

/**
 * \brief Indicates whether or not the two colors are equal.
 *
 * \param lhs the left-hand side color.
 * \param rhs the right-hand side color.
 *
 * \return `true` if the colors are equal; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const color& lhs, const color& rhs) noexcept -> bool
{
  return (lhs.red() == rhs.red()) && (lhs.green() == rhs.green()) &&
         (lhs.blue() == rhs.blue()) && (lhs.alpha() == rhs.alpha());
}

/// \copydoc operator==(const color&, const color&)
[[nodiscard]] constexpr auto operator==(const color& lhs, const SDL_Color& rhs) noexcept
    -> bool
{
  return (lhs.red() == rhs.r) && (lhs.green() == rhs.g) && (lhs.blue() == rhs.b) &&
         (lhs.alpha() == rhs.a);
}

/// \copydoc operator==(const color&, const color&)
[[nodiscard]] constexpr auto operator==(const SDL_Color& lhs, const color& rhs) noexcept
    -> bool
{
  return rhs == lhs;
}

/**
 * \copybrief operator==(const color&, const color&)
 *
 * \note The alpha components are not taken into account.
 *
 * \param lhs the left-hand side color.
 * \param rhs the right-hand side color.
 *
 * \return `true` if the colors are equal; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const color& lhs,
                                        const SDL_MessageBoxColor& rhs) noexcept -> bool
{
  return (lhs.red() == rhs.r) && (lhs.green() == rhs.g) && (lhs.blue() == rhs.b);
}

/// \copydoc operator==(const color&, const SDL_MessageBoxColor&)
[[nodiscard]] constexpr auto operator==(const SDL_MessageBoxColor& lhs,
                                        const color& rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the two colors aren't equal.
 *
 * \param lhs the left-hand side color.
 * \param rhs the right-hand side color.
 *
 * \return `true` if the colors aren't equal; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator!=(const color& lhs, const color& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const color&, const color&)
[[nodiscard]] constexpr auto operator!=(const color& lhs, const SDL_Color& rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const color&, const color&)
[[nodiscard]] constexpr auto operator!=(const SDL_Color& lhs, const color& rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/**
 * \copybrief operator!=(const color&, const color&)
 *
 * \note The alpha components are not taken into account.
 *
 * \param lhs the left-hand side color.
 * \param rhs the right-hand side color.
 *
 * \return `true` if the colors aren't equal; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator!=(const color& lhs,
                                        const SDL_MessageBoxColor& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const color&, const SDL_MessageBoxColor&)
[[nodiscard]] constexpr auto operator!=(const SDL_MessageBoxColor& lhs,
                                        const color& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of color comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_COLOR_HEADER

// #include "button_state.hpp"
#ifndef CENTURION_BUTTON_STATE_HEADER
#define CENTURION_BUTTON_STATE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum button_state
 *
 * \ingroup input
 *
 * \brief Represents the two possible states for a button.
 *
 * \details Corresponds to the `SDL_RELEASED` and `SDL_PRESSED` macros.
 *
 * \since 3.1.0
 */
enum class button_state : u8
{
  released = SDL_RELEASED,  ///< Corresponds to `SDL_RELEASED`.
  pressed = SDL_PRESSED     ///< Corresponds to `SDL_PRESSED`.
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied button state.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(button_state::released) == "released"`.
 *
 * \param state the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const button_state state) -> std::string_view
{
  switch (state) {
    case button_state::released:
      return "released";

    case button_state::pressed:
      return "pressed";

    default:
      throw cen_error{"Did not recognize button state!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a button state enumerator.
 *
 * \param stream the output stream that will be used.
 * \param state the enumerator that will be printed.
 *
 * \see `to_string(button_state)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const button_state state) -> std::ostream&
{
  return stream << to_string(state);
}

/// \} End of streaming

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_BUTTON_STATE_HEADER
// #include "controller_axis.hpp"
#ifndef CENTURION_CONTROLLER_AXIS_HEADER
#define CENTURION_CONTROLLER_AXIS_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum controller_axis
 *
 * \brief Represents different game controller axes.
 *
 * \see `SDL_GameControllerAxis`
 *
 * \since 4.0.0
 */
enum class controller_axis
{
  invalid = SDL_CONTROLLER_AXIS_INVALID,
  left_x = SDL_CONTROLLER_AXIS_LEFTX,
  left_y = SDL_CONTROLLER_AXIS_LEFTY,
  right_x = SDL_CONTROLLER_AXIS_RIGHTX,
  right_y = SDL_CONTROLLER_AXIS_RIGHTY,
  trigger_left = SDL_CONTROLLER_AXIS_TRIGGERLEFT,
  trigger_right = SDL_CONTROLLER_AXIS_TRIGGERRIGHT,
  max = SDL_CONTROLLER_AXIS_MAX
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied controller axis.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(controller_axis::right_x) == "right_x"`.
 *
 * \param axis the controller axis that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const controller_axis axis) -> std::string_view
{
  switch (axis) {
    case controller_axis::invalid:
      return "invalid";

    case controller_axis::left_x:
      return "left_x";

    case controller_axis::left_y:
      return "left_y";

    case controller_axis::right_x:
      return "right_x";

    case controller_axis::right_y:
      return "right_y";

    case controller_axis::trigger_left:
      return "trigger_left";

    case controller_axis::trigger_right:
      return "trigger_right";

    case controller_axis::max:
      return "max";

    default:
      throw cen_error{"Did not recognize controller axis!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a controller axis enumerator.
 *
 * \param stream the output stream that will be used.
 * \param axis the controller axis that will be printed.
 *
 * \see `to_string(controller_axis)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const controller_axis axis) -> std::ostream&
{
  return stream << to_string(axis);
}

/// \} End of streaming

/// \name Controller axis comparison operators
/// \{

/**
 * \brief Indicates whether or not two game controller axis values are the same.
 *
 * \param lhs the left-hand-side game controller axis value.
 * \param rhs the right-hand-side game controller axis value.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator==(const controller_axis lhs,
                                        const SDL_GameControllerAxis rhs) noexcept -> bool
{
  return static_cast<SDL_GameControllerAxis>(lhs) == rhs;
}

/// \copydoc operator==(controller_axis, SDL_GameControllerAxis)
[[nodiscard]] constexpr auto operator==(const SDL_GameControllerAxis lhs,
                                        const controller_axis rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two game controller axis values aren't the
 * same.
 *
 * \param lhs the left-hand-side game controller axis value.
 * \param rhs the right-hand-side game controller axis value.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator!=(const controller_axis lhs,
                                        const SDL_GameControllerAxis rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(controller_axis, SDL_GameControllerAxis)
[[nodiscard]] constexpr auto operator!=(const SDL_GameControllerAxis lhs,
                                        const controller_axis rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of controller axis comparison operators

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_CONTROLLER_AXIS_HEADER

// #include "controller_bind_type.hpp"
#ifndef CENTURION_CONTROLLER_BIND_TYPE_HEADER
#define CENTURION_CONTROLLER_BIND_TYPE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum controller_bind_type
 *
 * \brief Represents different game controller bind types.
 *
 * \see `SDL_GameControllerBindType`
 *
 * \since 5.0.0
 */
enum class controller_bind_type
{
  none = SDL_CONTROLLER_BINDTYPE_NONE,
  button = SDL_CONTROLLER_BINDTYPE_BUTTON,
  axis = SDL_CONTROLLER_BINDTYPE_AXIS,
  hat = SDL_CONTROLLER_BINDTYPE_HAT
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied controller bind type.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(controller_bind_type::button) == "button"`.
 *
 * \param type the controller bind type that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const controller_bind_type type) -> std::string_view
{
  switch (type) {
    case controller_bind_type::none:
      return "none";

    case controller_bind_type::button:
      return "button";

    case controller_bind_type::axis:
      return "axis";

    case controller_bind_type::hat:
      return "hat";

    default:
      throw cen_error{"Did not recognzie controller bind type!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a controller bind type enumerator.
 *
 * \param stream the output stream that will be used.
 * \param type the controller bind type that will be printed.
 *
 * \see `to_string(controller_bind_type)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const controller_bind_type type) -> std::ostream&
{
  return stream << to_string(type);
}

/// \} End of streaming

/// \name Controller bind type comparison operators
/// \{

/**
 * \brief Indicates whether or not two controller bind type values are the same.
 *
 * \param lhs the left-hand-side controller bind type value.
 * \param rhs the right-hand-side controller bind type value.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator==(const controller_bind_type lhs,
                                        const SDL_GameControllerBindType rhs) noexcept -> bool
{
  return static_cast<SDL_GameControllerBindType>(lhs) == rhs;
}

/// \copydoc operator==(controller_bind_type, SDL_GameControllerBindType)
[[nodiscard]] constexpr auto operator==(const SDL_GameControllerBindType lhs,
                                        const controller_bind_type rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two controller bind type values aren't the
 * same.
 *
 * \param lhs the left-hand-side controller bind type value.
 * \param rhs the right-hand-side controller bind type value.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator!=(const controller_bind_type lhs,
                                        const SDL_GameControllerBindType rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(controller_bind_type, SDL_GameControllerBindType)
[[nodiscard]] constexpr auto operator!=(const SDL_GameControllerBindType lhs,
                                        const controller_bind_type rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of controller bind type comparison operators

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_CONTROLLER_BIND_TYPE_HEADER

// #include "controller_button.hpp"
#ifndef CENTURION_CONTROLLER_BUTTON_HEADER
#define CENTURION_CONTROLLER_BUTTON_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum controller_button
 *
 * \brief Represents different game controller buttons.
 *
 * \see `SDL_GameControllerButton`
 *
 * \since 4.0.0
 */
enum class controller_button
{
  invalid = SDL_CONTROLLER_BUTTON_INVALID,
  a = SDL_CONTROLLER_BUTTON_A,
  b = SDL_CONTROLLER_BUTTON_B,
  x = SDL_CONTROLLER_BUTTON_X,
  y = SDL_CONTROLLER_BUTTON_Y,
  back = SDL_CONTROLLER_BUTTON_BACK,
  guide = SDL_CONTROLLER_BUTTON_GUIDE,
  start = SDL_CONTROLLER_BUTTON_START,
  left_stick = SDL_CONTROLLER_BUTTON_LEFTSTICK,
  right_stick = SDL_CONTROLLER_BUTTON_RIGHTSTICK,
  left_shoulder = SDL_CONTROLLER_BUTTON_LEFTSHOULDER,
  right_shoulder = SDL_CONTROLLER_BUTTON_RIGHTSHOULDER,
  dpad_up = SDL_CONTROLLER_BUTTON_DPAD_UP,
  dpad_down = SDL_CONTROLLER_BUTTON_DPAD_DOWN,
  dpad_left = SDL_CONTROLLER_BUTTON_DPAD_LEFT,
  dpad_right = SDL_CONTROLLER_BUTTON_DPAD_RIGHT,

#if SDL_VERSION_ATLEAST(2, 0, 14)

  // clang-format off
  misc1 = SDL_CONTROLLER_BUTTON_MISC1, ///< Xbox Series X share button, PS5 microphone button, Nintendo Switch Pro capture button
  // clang-format on

  paddle1 = SDL_CONTROLLER_BUTTON_PADDLE1,    ///< Xbox Elite paddle P1
  paddle2 = SDL_CONTROLLER_BUTTON_PADDLE2,    ///< Xbox Elite paddle P3
  paddle3 = SDL_CONTROLLER_BUTTON_PADDLE3,    ///< Xbox Elite paddle P2
  paddle4 = SDL_CONTROLLER_BUTTON_PADDLE4,    ///< Xbox Elite paddle P4
  touchpad = SDL_CONTROLLER_BUTTON_TOUCHPAD,  ///< PS4/PS5 touchpad button

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  max = SDL_CONTROLLER_BUTTON_MAX
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied controller button.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(controller_button::start) == "start"`.
 *
 * \param button the controller button that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const controller_button button) -> std::string_view
{
  switch (button) {
    case controller_button::invalid:
      return "invalid";

    case controller_button::a:
      return "a";

    case controller_button::b:
      return "b";

    case controller_button::x:
      return "x";

    case controller_button::y:
      return "y";

    case controller_button::back:
      return "back";

    case controller_button::guide:
      return "guide";

    case controller_button::start:
      return "start";

    case controller_button::left_stick:
      return "left_stick";

    case controller_button::right_stick:
      return "right_stick";

    case controller_button::left_shoulder:
      return "left_shoulder";

    case controller_button::right_shoulder:
      return "right_shoulder";

    case controller_button::dpad_up:
      return "dpad_up";

    case controller_button::dpad_down:
      return "dpad_down";

    case controller_button::dpad_left:
      return "dpad_left";

    case controller_button::dpad_right:
      return "dpad_right";

#if SDL_VERSION_ATLEAST(2, 0, 14)

    case controller_button::misc1:
      return "misc1";

    case controller_button::paddle1:
      return "paddle1";

    case controller_button::paddle2:
      return "paddle2";

    case controller_button::paddle3:
      return "paddle3";

    case controller_button::paddle4:
      return "paddle4";

    case controller_button::touchpad:
      return "touchpad";

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

    case controller_button::max:
      return "max";

    default:
      throw cen_error{"Did not recognize controller button!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a controller button enumerator.
 *
 * \param stream the output stream that will be used.
 * \param button the controller button that will be printed.
 *
 * \see `to_string(controller_button)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const controller_button button) -> std::ostream&
{
  return stream << to_string(button);
}

/// \} End of streaming

/// \name Controller button comparison operators
/// \{

/**
 * \brief Indicates whether or not two game controller button values are the
 * same.
 *
 * \param lhs the left-hand side game controller button value.
 * \param rhs the right-hand side game controller button value.
 *
 * \return `true` if the game controller button values are the same; `false`
 * otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator==(const controller_button lhs,
                                        const SDL_GameControllerButton rhs) noexcept -> bool
{
  return static_cast<SDL_GameControllerButton>(lhs) == rhs;
}

/// \copydoc operator==(controller_button, SDL_GameControllerButton)
[[nodiscard]] constexpr auto operator==(const SDL_GameControllerButton lhs,
                                        const controller_button rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two game controller button values aren't the
 * same.
 *
 * \param lhs the left-hand side game controller button value.
 * \param rhs the right-hand side game controller button value.
 *
 * \return `true` if the game controller button values aren't the same; `false`
 * otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator!=(const controller_button lhs,
                                        const SDL_GameControllerButton rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(controller_button, SDL_GameControllerButton)
[[nodiscard]] constexpr auto operator!=(const SDL_GameControllerButton lhs,
                                        const controller_button rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of controller button comparison operators

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_CONTROLLER_BUTTON_HEADER

// #include "controller_type.hpp"
#ifndef CENTURION_CONTROLLER_TYPE_HEADER
#define CENTURION_CONTROLLER_TYPE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup input
/// \{

#if SDL_VERSION_ATLEAST(2, 0, 12)

/**
 * \enum controller_type
 *
 * \brief Represents different game controller types.
 *
 * \see `SDL_GameControllerType`
 *
 * \since 5.0.0
 */
enum class controller_type
{
  // clang-format off
  unknown = SDL_CONTROLLER_TYPE_UNKNOWN,   ///< An unknown controller.
  xbox_360 = SDL_CONTROLLER_TYPE_XBOX360,  ///< An Xbox 360 controller.
  xbox_one = SDL_CONTROLLER_TYPE_XBOXONE,  ///< An Xbox One controller.
  ps3 = SDL_CONTROLLER_TYPE_PS3,           ///< A PS3 controller.
  ps4 = SDL_CONTROLLER_TYPE_PS4,           ///< A PS4 controller.

#if SDL_VERSION_ATLEAST(2, 0, 14)

  ps5 = SDL_CONTROLLER_TYPE_PS5,       ///< A PS5 controller.
  virt = SDL_CONTROLLER_TYPE_VIRTUAL,  ///< A virtual controller.

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

#if SDL_VERSION_ATLEAST(2, 0, 16)

  amazon_luna = SDL_CONTROLLER_TYPE_AMAZON_LUNA,     ///< An Amazon Luna controller.
  google_stadia = SDL_CONTROLLER_TYPE_GOOGLE_STADIA, ///< A Google Stadia controller.

#endif // SDL_VERSION_ATLEAST(2, 0, 16)

  nintendo_switch_pro = SDL_CONTROLLER_TYPE_NINTENDO_SWITCH_PRO  ///< A Nintendo Switch Pro controller.
  // clang-format on
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied controller type.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(controller_type::ps4) == "ps4"`.
 *
 * \param type the controller type that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const controller_type type) -> std::string_view
{
  switch (type) {
    case controller_type::unknown:
      return "unknown";

    case controller_type::nintendo_switch_pro:
      return "nintendo_switch_pro";

    case controller_type::xbox_360:
      return "xbox_360";

    case controller_type::xbox_one:
      return "xbox_one";

    case controller_type::ps3:
      return "ps3";

    case controller_type::ps4:
      return "ps4";

#if SDL_VERSION_ATLEAST(2, 0, 14)

    case controller_type::ps5:
      return "ps5";

    case controller_type::virt:
      return "virt";

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

#if SDL_VERSION_ATLEAST(2, 0, 16)

    case controller_type::amazon_luna:
      return "amazon_luna";

    case controller_type::google_stadia:
      return "google_stadia";

#endif  // SDL_VERSION_ATLEAST(2, 0, 16)

    default:
      throw cen_error{"Did not recognize controller type!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a controller type enumerator.
 *
 * \param stream the output stream that will be used.
 * \param type the controller type that will be printed.
 *
 * \see `to_string(controller_type)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const controller_type type) -> std::ostream&
{
  return stream << to_string(type);
}

/// \} End of streaming

/// \name Controller type comparison operators
/// \{

/**
 * \brief Indicates whether or not to controller type values are the same.
 *
 * \param lhs the left-hand side controller type value.
 * \param rhs the right-hand side controller type value.
 *
 * \return `true` if the controller type values are the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator==(const controller_type lhs,
                                        const SDL_GameControllerType rhs) noexcept -> bool
{
  return static_cast<SDL_GameControllerType>(lhs) == rhs;
}

/// \copydoc operator==(controller_type, SDL_GameControllerType)
[[nodiscard]] constexpr auto operator==(const SDL_GameControllerType lhs,
                                        const controller_type rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not to controller type values aren't the same.
 *
 * \param lhs the left-hand side controller type value.
 * \param rhs the right-hand side controller type value.
 *
 * \return `true` if the controller type values aren't the same; `false`
 * otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator!=(const controller_type lhs,
                                        const SDL_GameControllerType rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(controller_type, SDL_GameControllerType)
[[nodiscard]] constexpr auto operator!=(const SDL_GameControllerType lhs,
                                        const controller_type rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of controller type comparison operators

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_CONTROLLER_TYPE_HEADER

// #include "joystick.hpp"
#ifndef CENTURION_JOYSTICK_HEADER
#define CENTURION_JOYSTICK_HEADER

#include <SDL.h>

#include <cassert>   // assert
#include <optional>  // optional
#include <ostream>   // ostream
#include <string>    // string, to_string

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/not_null.hpp"

// #include "../core/owner.hpp"

// #include "../core/result.hpp"

// #include "../core/str.hpp"

// #include "../core/str_or_na.hpp"

// #include "../core/time.hpp"

// #include "../core/to_underlying.hpp"
#ifndef CENTURION_TO_UNDERLYING_HEADER
#define CENTURION_TO_UNDERLYING_HEADER

#include <type_traits>  // underlying_type_t, enable_if_t, is_enum_v

namespace cen {

/**
 * \brief Converts an enum value to an integral value using the underlying type.
 *
 * \ingroup core
 *
 * \note If you're using C++23, see `std::to_underlying()`.
 *
 * \tparam Enum the enum type.
 *
 * \param value the enum value that will be converted.
 *
 * \return the value of the enum, in the underlying type.
 *
 * \since 6.0.0
 */
template <typename Enum, std::enable_if_t<std::is_enum_v<Enum>, int> = 0>
[[nodiscard]] constexpr auto to_underlying(const Enum value) noexcept
    -> std::underlying_type_t<Enum>
{
  return static_cast<std::underlying_type_t<Enum>>(value);
}

}  // namespace cen

#endif  // CENTURION_TO_UNDERLYING_HEADER

// #include "../detail/address_of.hpp"

// #include "../detail/owner_handle_api.hpp"

// #include "../detail/sdl_version_at_least.hpp"

// #include "../video/color.hpp"

// #include "button_state.hpp"

// #include "hat_state.hpp"
#ifndef CENTURION_HAT_STATE_HEADER
#define CENTURION_HAT_STATE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum hat_state
 *
 * \brief Represents the various states of a joystick "hat".
 *
 * \since 4.2.0
 */
enum class hat_state : u8
{
  centered = SDL_HAT_CENTERED,     ///< The hat is centered.
  up = SDL_HAT_UP,                 ///< The hat is directed "north".
  right = SDL_HAT_RIGHT,           ///< The hat is directed "east".
  down = SDL_HAT_DOWN,             ///< The hat is directed "south".
  left = SDL_HAT_LEFT,             ///< The hat is directed "west".
  right_up = SDL_HAT_RIGHTUP,      ///< The hat is directed "north-east".
  right_down = SDL_HAT_RIGHTDOWN,  ///< The hat is directed "south-east".
  left_up = SDL_HAT_LEFTUP,        ///< The hat is directed "north-west".
  left_down = SDL_HAT_LEFTDOWN,    ///< The hat is directed "south-west".
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied hat state.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(hat_state::down) == "down"`.
 *
 * \param state the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const hat_state state) -> std::string_view
{
  switch (state) {
    case hat_state::centered:
      return "centered";

    case hat_state::up:
      return "up";

    case hat_state::right:
      return "right";

    case hat_state::down:
      return "down";

    case hat_state::left:
      return "left";

    case hat_state::right_up:
      return "right_up";

    case hat_state::right_down:
      return "right_down";

    case hat_state::left_up:
      return "left_up";

    case hat_state::left_down:
      return "left_down";

    default:
      throw cen_error{"Did not recognize hat state!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a hat state enumerator.
 *
 * \param stream the output stream that will be used.
 * \param state the enumerator that will be printed.
 *
 * \see `to_string(hat_state)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const hat_state state) -> std::ostream&
{
  return stream << to_string(state);
}

/// \} End of streaming

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_HAT_STATE_HEADER

// #include "joystick_power.hpp"
#ifndef CENTURION_JOYSTICK_POWER_HEADER
#define CENTURION_JOYSTICK_POWER_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum joystick_power
 *
 * \brief Represents different power states of a joystick.
 *
 * \since 4.2.0
 */
enum class joystick_power
{
  unknown = SDL_JOYSTICK_POWER_UNKNOWN,  ///< Unknown power level.
  empty = SDL_JOYSTICK_POWER_EMPTY,      ///< Indicates <= 5% power.
  low = SDL_JOYSTICK_POWER_LOW,          ///< Indicates <= 20% power.
  medium = SDL_JOYSTICK_POWER_MEDIUM,    ///< Indicates <= 70% power.
  full = SDL_JOYSTICK_POWER_FULL,        ///< Indicates <= 100% power.
  wired = SDL_JOYSTICK_POWER_WIRED,      ///< No need to worry about power.
  max = SDL_JOYSTICK_POWER_MAX
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied joystick power.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(joystick_power::medium) == "medium"`.
 *
 * \param power the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const joystick_power power) -> std::string_view
{
  switch (power) {
    case joystick_power::unknown:
      return "unknown";

    case joystick_power::empty:
      return "empty";

    case joystick_power::low:
      return "low";

    case joystick_power::medium:
      return "medium";

    case joystick_power::full:
      return "full";

    case joystick_power::wired:
      return "wired";

    case joystick_power::max:
      return "max";

    default:
      throw cen_error{"Did not recognize joystick power!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a joystick power enumerator.
 *
 * \param stream the output stream that will be used.
 * \param power the enumerator that will be printed.
 *
 * \see `to_string(joystick_power)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const joystick_power power) -> std::ostream&
{
  return stream << to_string(power);
}

/// \} End of streaming

/// \name Joystick power comparison operators
/// \{

/**
 * \brief Indicates whether or not two joystick power values are the same.
 *
 * \param lhs the left-hand side power type.
 * \param rhs the right-hand side power type.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator==(const joystick_power lhs,
                                        const SDL_JoystickPowerLevel rhs) noexcept -> bool
{
  return static_cast<SDL_JoystickPowerLevel>(lhs) == rhs;
}

/**
 * \brief Indicates whether or not two joystick power values are the same.
 *
 * \param lhs the left-hand side power type.
 * \param rhs the right-hand side power type.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator==(const SDL_JoystickPowerLevel lhs,
                                        const joystick_power rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two joystick power values aren't the same.
 *
 * \param lhs the left-hand side power type.
 * \param rhs the right-hand side power type.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator!=(const joystick_power lhs,
                                        const SDL_JoystickPowerLevel rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/**
 * \brief Indicates whether or not two joystick power values aren't the same.
 *
 * \param lhs the left-hand side power type.
 * \param rhs the right-hand side power type.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator!=(const SDL_JoystickPowerLevel lhs,
                                        const joystick_power rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of joystick power comparison operators

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_JOYSTICK_POWER_HEADER

// #include "joystick_type.hpp"
#ifndef CENTURION_JOYSTICK_TYPE_HEADER
#define CENTURION_JOYSTICK_TYPE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum joystick_type
 *
 * \brief Provides values that represent different types of "joysticks".
 *
 * \since 4.2.0
 */
enum class joystick_type
{
  unknown = SDL_JOYSTICK_TYPE_UNKNOWN,
  game_controller = SDL_JOYSTICK_TYPE_GAMECONTROLLER,
  wheel = SDL_JOYSTICK_TYPE_WHEEL,
  arcade_stick = SDL_JOYSTICK_TYPE_ARCADE_STICK,
  flight_stick = SDL_JOYSTICK_TYPE_FLIGHT_STICK,
  dance_pad = SDL_JOYSTICK_TYPE_DANCE_PAD,
  guitar = SDL_JOYSTICK_TYPE_GUITAR,
  drum_kit = SDL_JOYSTICK_TYPE_DRUM_KIT,
  arcade_pad = SDL_JOYSTICK_TYPE_ARCADE_PAD,
  throttle = SDL_JOYSTICK_TYPE_THROTTLE
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied joystick type.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(joystick_type::guitar) == "guitar"`.
 *
 * \param type the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const joystick_type type) -> std::string_view
{
  switch (type) {
    case joystick_type::unknown:
      return "unknown";

    case joystick_type::game_controller:
      return "game_controller";

    case joystick_type::wheel:
      return "wheel";

    case joystick_type::arcade_stick:
      return "arcade_stick";

    case joystick_type::flight_stick:
      return "flight_stick";

    case joystick_type::dance_pad:
      return "dance_pad";

    case joystick_type::guitar:
      return "guitar";

    case joystick_type::drum_kit:
      return "drum_kit";

    case joystick_type::arcade_pad:
      return "arcade_pad";

    case joystick_type::throttle:
      return "throttle";

    default:
      throw cen_error{"Did not recognize joystick type!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a joystick type enumerator.
 *
 * \param stream the output stream that will be used.
 * \param type the enumerator that will be printed.
 *
 * \see `to_string(joystick_type)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const joystick_type type) -> std::ostream&
{
  return stream << to_string(type);
}

/// \} End of streaming

/// \name Joystick type comparison operators
/// \{

/**
 * \brief Indicates whether or not two joystick type values are the same.
 *
 * \param lhs the left-hand side joystick type value.
 * \param rhs the right-hand side joystick type value.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator==(const joystick_type lhs,
                                        const SDL_JoystickType rhs) noexcept -> bool
{
  return static_cast<SDL_JoystickType>(lhs) == rhs;
}

/**
 * \brief Indicates whether or not two joystick type values are the same.
 *
 * \param lhs the left-hand side joystick type value.
 * \param rhs the right-hand side joystick type value.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator==(const SDL_JoystickType lhs,
                                        const joystick_type rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two joystick type values aren't the same.
 *
 * \param lhs the left-hand side joystick type value.
 * \param rhs the right-hand side joystick type value.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator!=(const joystick_type lhs,
                                        const SDL_JoystickType rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/**
 * \brief Indicates whether or not two joystick type values aren't the same.
 *
 * \param lhs the left-hand side joystick type value.
 * \param rhs the right-hand side joystick type value.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator!=(const SDL_JoystickType lhs,
                                        const joystick_type rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of joystick type comparison operators

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_JOYSTICK_TYPE_HEADER


namespace cen {

/// \addtogroup input
/// \{

/**
 * \struct ball_axis_change
 *
 * \brief Represents the difference in a joystick ball axis position.
 *
 * \since 4.2.0
 */
struct ball_axis_change final
{
  int dx;  ///< Difference in x-axis position since last poll.
  int dy;  ///< Difference in y-axis position since last poll.
};

template <typename T>
class basic_joystick;

/**
 * \typedef joystick
 *
 * \brief Represents an owning joystick.
 *
 * \since 5.0.0
 */
using joystick = basic_joystick<detail::owning_type>;

/**
 * \typedef joystick_handle
 *
 * \brief Represents a non-owning joystick.
 *
 * \since 5.0.0
 */
using joystick_handle = basic_joystick<detail::handle_type>;

/**
 * \class basic_joystick
 *
 * \brief Represents a joystick device.
 *
 * \ownerhandle `joystick`/`joystick_handle`
 *
 * \details The game controller API is built on top of the joystick API, which means that
 * the game controller is higher-level and easier to use.
 *
 * \since 4.2.0
 *
 * \see joystick
 * \see joystick_handle
 */
template <typename T>
class basic_joystick final
{
 public:
  /// \name Construction
  /// \{

  // clang-format off

  /**
   * \brief Creates a joystick instance based on an existing SDL joystick.
   *
   * \note The created instance will only claim ownership of the supplied pointer if the
   * class has owning semantics, i.e. if it's a `joystick` instance.
   *
   * \param joystick a pointer to the existing joystick.
   *
   * \throws cen_error if the supplied pointer is null and the joystick is owning.
   */
  explicit basic_joystick(maybe_owner<SDL_Joystick*> joystick) noexcept(!detail::is_owning<T>())
      : m_joystick{joystick}
  {
    if constexpr (detail::is_owning<T>())
    {
      if (!m_joystick)
      {
        throw cen_error{"Cannot create joystick from null pointer!"};
      }
    }
  }

  // clang-format on

  /**
   * \brief Creates an owning joystick based on a joystick device index.
   *
   * \param index the device index of the joystick.
   *
   * \throws sdl_error if the joystick couldn't be opened.
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_joystick(const int index = 0) : m_joystick{SDL_JoystickOpen(index)}
  {
    if (!m_joystick) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates a handle to an owning joystick.
   *
   * \param owner the owning joystick instance.
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit basic_joystick(const joystick& owner) noexcept : m_joystick{owner.get()}
  {}

  /**
   * \brief Returns a handle to the joystick associated with the specified ID.
   *
   * \param id the joystick ID associated with the desired joystick.
   *
   * \return a handle to the joystick associated with the supplied ID, might be empty.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  [[nodiscard]] static auto from_instance_id(const SDL_JoystickID id) noexcept
      -> joystick_handle
  {
    return joystick_handle{SDL_JoystickFromInstanceID(id)};
  }

#if SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Returns a handle to the joystick associated with the specified player index.
   *
   * \param playerIndex the player index of the desired joystick.
   *
   * \return a handle to the associated joystick, which might be empty.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  [[nodiscard]] static auto from_player_index(const int playerIndex) noexcept
      -> joystick_handle
  {
    return joystick_handle{SDL_JoystickFromPlayerIndex(playerIndex)};
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

  /// \} End of construction

  /**
   * \brief Makes the joystick rumble.
   *
   * \details Invoking this function cancels any previous rumble effects. This function
   * has no effect if the joystick doesn't support rumble effects.
   *
   * \param lowFreq the intensity of the low frequency (left) motor.
   * \param highFreq the intensity of the high frequency (right) motor.
   * \param duration the duration of the rumble effect, in milliseconds.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 4.2.0
   */
  auto rumble(const u16 lowFreq,
              const u16 highFreq,
              const milliseconds<u32> duration) noexcept(noexcept(duration.count())) -> result
  {
    return SDL_JoystickRumble(m_joystick, lowFreq, highFreq, duration.count()) == 0;
  }

#if SDL_VERSION_ATLEAST(2, 0, 14)

  // clang-format off

  /**
   * \brief Starts a rumble effect in the joystick's triggers.
   *
   * \details Calls to this function cancels any previously active rumble effect.
   * Furthermore, supplying 0 as intensities will stop the rumble effect.
   *
   * \param left the intensity used by the left rumble motor.
   * \param right the intensity used by the right rumble motor.
   * \param duration the duration of the rumble.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto rumble_triggers(const u16 left,
                       const u16 right,
                       const milliseconds<u32> duration) noexcept(noexcept(duration.count()))
      -> result
  {
    return SDL_JoystickRumbleTriggers(m_joystick,
                                      left,
                                      right,
                                      duration.count()) == 0;
  }

  // clang-format on

  /**
   * \brief Sets the color of the LED light, if the joystick has one.
   *
   * \param color the color that will be used by the LED, note that the alpha component is
   * ignored.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto set_led(const color& color) noexcept -> result
  {
    return SDL_JoystickSetLED(m_joystick, color.red(), color.green(), color.blue()) == 0;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

#if SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Sets the player index to be associated with the joystick.
   *
   * \param index the player index that will be used.
   *
   * \since 4.2.0
   */
  void set_player_index(const int index) noexcept
  {
    SDL_JoystickSetPlayerIndex(m_joystick, index);
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

#if SDL_VERSION_ATLEAST(2, 0, 16)

  /**
   * \brief Sends a packet of joystick specific data.
   *
   * \param data the data that will be sent.
   * \param size the size of the data.
   *
   * \return `success` if the data was sent successfully; `failure` if the joystick
   * or driver doesn't support effect packets.
   *
   * \since 6.2.0
   */
  auto send_effect(const void* data, const int size) -> result
  {
    return SDL_JoystickSendEffect(m_joystick, data, size) == 0;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 16)

  /// \name Virtual joystick API
  /// \{

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Attaches a new virtual joystick.
   *
   * \param type the type of the virtual joystick.
   * \param nAxes the number of axes.
   * \param nButtons the number of buttons.
   * \param nHats the number of joystick hats.
   *
   * \return the device index of the virtual joystick; `std::nullopt` if something went
   * wrong.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto attach_virtual(const joystick_type type,
                                           const int nAxes,
                                           const int nButtons,
                                           const int nHats) noexcept -> std::optional<int>
  {
    const auto index =
        SDL_JoystickAttachVirtual(static_cast<SDL_JoystickType>(type), nAxes, nButtons, nHats);
    if (index != -1) {
      return index;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Detaches a virtual joystick.
   *
   * \param index the device index of the virtual joystick.
   *
   * \return `success` if the joystick was successfully disconnected; `failure` otherwise.
   *
   * \since 5.2.0
   */
  static auto detach_virtual(const int index) noexcept -> result
  {
    return SDL_JoystickDetachVirtual(index) == 0;
  }

  /**
   * \brief Sets the value of a virtual joystick axis.
   *
   * \param axis the axis that will be modified.
   * \param value the new value of the axis.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto set_virtual_axis(const int axis, const i16 value) noexcept -> result
  {
    return SDL_JoystickSetVirtualAxis(m_joystick, axis, value) == 0;
  }

  /**
   * \brief Sets the state of a virtual button.
   *
   * \param button the index of the button that will be set.
   * \param state the new button state.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto set_virtual_button(const int button, const button_state state) noexcept -> result
  {
    return SDL_JoystickSetVirtualButton(m_joystick, button, to_underlying(state)) == 0;
  }

  /**
   * \brief Sets the state of a virtual joystick hat.
   *
   * \param hat the index of the hat that will be changed.
   * \param state the new state of the virtual joystick hat.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto set_virtual_hat(const int hat, const hat_state state) noexcept -> result
  {
    return SDL_JoystickSetVirtualHat(m_joystick, hat, to_underlying(state)) == 0;
  }

  /**
   * \brief Indicates whether or not a joystick is virtual.
   *
   * \param index the device index of the joystick that will be queried.
   *
   * \return `true` if the specified joystick is virtual; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto is_virtual(const int index) noexcept -> bool
  {
    return SDL_JoystickIsVirtual(index) == SDL_TRUE;
  }

#endif  // #if SDL_VERSION_ATLEAST(2, 0, 14)

  /// \} End of virtual joystick API

  /// \name Instance-based queries
  /// \{

  /**
   * \brief Returns the player index of the joystick, if available.
   *
   * \details For XInput controllers this returns the XInput user index.
   *
   * \return the player index associated with the joystick; `std::nullopt` if it can't be
   * obtained
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto player_index() const noexcept -> std::optional<int>
  {
    const auto index = SDL_JoystickGetPlayerIndex(m_joystick);
    if (index != -1) {
      return index;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the type associated with the joystick.
   *
   * \return the type of the joystick.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto type() const noexcept -> joystick_type
  {
    return static_cast<joystick_type>(SDL_JoystickGetType(m_joystick));
  }

  /**
   * \brief Returns the USB vendor ID of the joystick.
   *
   * \return the USB vendor ID associated with the joystick; `std::nullopt` if it isn't
   * available.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto vendor() const noexcept -> std::optional<u16>
  {
    const auto vendor = SDL_JoystickGetVendor(m_joystick);
    if (vendor != 0) {
      return vendor;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the USB product ID of the joystick.
   *
   * \return the USB product ID associated with the joystick; `std::nullopt` if it isn't
   * available.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto product() const noexcept -> std::optional<u16>
  {
    const auto product = SDL_JoystickGetProduct(m_joystick);
    if (product != 0) {
      return product;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the product version of the joystick, if available.
   *
   * \return the product version of the joystick; `std::nullopt` if it isn't available.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto product_version() const noexcept -> std::optional<u16>
  {
    const auto version = SDL_JoystickGetProductVersion(m_joystick);
    if (version != 0) {
      return version;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the GUID associated with the joystick.
   *
   * \note The GUID is implementation-dependent.
   *
   * \return the GUID associated with the joystick.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto guid() noexcept -> SDL_JoystickGUID
  {
    return SDL_JoystickGetGUID(m_joystick);
  }

  /**
   * \brief Returns the name associated with the joystick.
   *
   * \note If no name can be found, this function returns a null string.
   *
   * \return the name of the joystick; a null pointer if no name is found.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto name() const noexcept -> str
  {
    return SDL_JoystickName(m_joystick);
  }

  /**
   * \brief Returns the instance ID associated with the joystick.
   *
   * \return the instance ID associated with the joystick.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto instance_id() const noexcept -> SDL_JoystickID
  {
    return SDL_JoystickInstanceID(m_joystick);
  }

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Returns the serial number associated with the joystick.
   *
   * \return the serial number of the joystick; a null pointer is returned if the serial
   * number isn't available.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto serial() const noexcept -> str
  {
    return SDL_JoystickGetSerial(m_joystick);
  }

  /**
   * \brief Indicates whether or not the joystick features a LED light.
   *
   * \return `true` if the joystick features a LED light; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_led() const noexcept -> bool
  {
    return SDL_JoystickHasLED(m_joystick) == SDL_TRUE;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  /// \} End of instance-based queries

  /// \name Index-based queries
  /// \{

  /**
   * \brief Returns the player index of the joystick associated with the specified device
   * index.
   *
   * \note This function can be called before any joysticks are opened.
   *
   * \param deviceIndex the device index of the joystick that will be queried.
   *
   * \return the player index of the desired joystick; `std::nullopt` if it can't be
   * obtained.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto player_index(const int deviceIndex) noexcept -> std::optional<int>
  {
    const auto index = SDL_JoystickGetDevicePlayerIndex(deviceIndex);
    if (index != -1) {
      return index;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the type of the joystick associated with the specified device index.
   *
   * \param deviceIndex the device index of the joystick that will be queried.
   *
   * \return the type of the specified joystick.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto type(const int deviceIndex) noexcept -> joystick_type
  {
    return static_cast<joystick_type>(SDL_JoystickGetDeviceType(deviceIndex));
  }

  /**
   * \brief Returns the USB vendor ID for the joystick associated with the specified
   * device index.
   *
   * \param deviceIndex the device index of the joystick that will be queried.
   *
   * \return the USB vendor ID of the desired joystick; `std::nullopt` if it can't be
   * obtained.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto vendor(const int deviceIndex) noexcept -> std::optional<u16>
  {
    const auto vendor = SDL_JoystickGetDeviceVendor(deviceIndex);
    if (vendor != 0) {
      return vendor;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the USB product ID for the joystick associated with the specified
   * device index.
   *
   * \param deviceIndex the device index of the joystick that will be queried.
   *
   * \return the USB product ID of the desired joystick; `std::nullopt` if it can't be
   * obtained.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto product(const int deviceIndex) noexcept -> std::optional<u16>
  {
    const auto product = SDL_JoystickGetDeviceProduct(deviceIndex);
    if (product != 0) {
      return product;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the product version for the joystick associated with the specified
   * device index.
   *
   * \param deviceIndex the device index of the joystick that will be queried.
   *
   * \return the product version of the desired joystick; `std::nullopt` if it can't be
   * obtained.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto product_version(const int deviceIndex) noexcept
      -> std::optional<u16>
  {
    const auto version = SDL_JoystickGetDeviceProductVersion(deviceIndex);
    if (version != 0) {
      return version;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the GUID for the joystick associated with the specified device index.
   *
   * \note The GUID is implementation-dependent.
   * \note This function can be called before any joysticks are opened.
   *
   * \param deviceIndex refers to the N'th joystick that is currently recognized by SDL.
   *
   * \return the GUID of the joystick associated with the device index.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto guid(const int deviceIndex) noexcept -> SDL_JoystickGUID
  {
    return SDL_JoystickGetDeviceGUID(deviceIndex);
  }

  /**
   * \brief Returns the associated with the joystick with the specified device index.
   *
   * \param deviceIndex refers to the N'th joystick that is currently recognized by SDL.
   *
   * \return the name associated with the joystick; a null string is returned if no name
   * is found.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto name(const int deviceIndex) noexcept -> str
  {
    return SDL_JoystickNameForIndex(deviceIndex);
  }

  /**
   * \brief Returns the instance ID for the joystick associated with the specified device
   * index.
   *
   * \param deviceIndex the device index of the joystick that will be queried.
   *
   * \return the instance ID of the desired joystick; `std::nullopt` if it can't be
   * obtained.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto instance_id(const int deviceIndex) noexcept
      -> std::optional<SDL_JoystickID>
  {
    const auto id = SDL_JoystickGetDeviceInstanceID(deviceIndex);
    if (id != -1) {
      return id;
    }
    else {
      return std::nullopt;
    }
  }

  /// \} End of index-based queries

  /**
   * \brief Returns the ball axis change since the last poll.
   *
   * \note Trackballs can only return relative motion since the last call, these motion
   * deltas are placed into the `BallAxisChange` struct.
   *
   * \param ball the ball index to check, start at 0.
   *
   * \return a `JoystickBallAxisChange` instance or `std::nullopt` if something goes
   * wrong.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto get_ball_axis_change(const int ball) const noexcept
      -> std::optional<ball_axis_change>
  {
    ball_axis_change change{};
    if (SDL_JoystickGetBall(m_joystick, ball, &change.dx, &change.dy) == 0) {
      return change;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the current position of the specified axis.
   *
   * \details Most modern joysticks let the X-axis be represented by 0 and the Y-axis
   * by 1. To account for jitter, it may be necessary to impose some kind of tolerance on
   * the returned value.
   *
   * \note Some joysticks use axes 2 and 3 for extra buttons.
   *
   * \param axis the ID of the axis to query.
   *
   * \return the position of the specified axis.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto axis_pos(const int axis) const noexcept -> i16
  {
    return SDL_JoystickGetAxis(m_joystick, axis);
  }

  /**
   * \brief Returns the initial state of the specified axis on the joystick.
   *
   * \param axis the axis that will be queried. Starts at 0.
   *
   * \return the initial state of the axis; `std::nullopt` if the axis doesn't have an
   * initial state.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto axis_initial_state(const int axis) const noexcept -> std::optional<i16>
  {
    i16 state{};
    if (SDL_JoystickGetAxisInitialState(m_joystick, axis, &state)) {
      return state;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Indicates whether or not the joystick is attached to the system.
   *
   * \return `true` if the joystick is attached to the system; false otherwise.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto is_attached() const noexcept -> bool
  {
    return SDL_JoystickGetAttached(m_joystick);
  }

  /**
   * \brief Returns the amount of hats on the joystick.
   *
   * \return the amount of hats on the joystick.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto hat_count() const noexcept -> int
  {
    return SDL_JoystickNumHats(m_joystick);
  }

  /**
   * \brief Returns the amount of general axis controls on the joystick.
   *
   * \return the amount of general axis controls on the joystick.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto axis_count() const noexcept -> int
  {
    return SDL_JoystickNumAxes(m_joystick);
  }

  /**
   * \brief Returns the amount of trackballs on the joystick.
   *
   * \return the amount of trackballs on the joystick.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto trackball_count() const noexcept -> int
  {
    return SDL_JoystickNumBalls(m_joystick);
  }

  /**
   * \brief Returns the amount of buttons on the joystick.
   *
   * \return the amount of buttons on the joystick.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto button_count() const noexcept -> int
  {
    return SDL_JoystickNumButtons(m_joystick);
  }

  /**
   * \brief Returns the current power level of the joystick.
   *
   * \return the current power level.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto get_power() const noexcept -> joystick_power
  {
    return static_cast<joystick_power>(SDL_JoystickCurrentPowerLevel(m_joystick));
  }

  /**
   * \brief Returns the button state of the button associated with the index.
   *
   * \param button the button index to get the state from, starting at 0.
   *
   * \return the state of the button.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto get_button_state(const int button) const noexcept -> button_state
  {
    return static_cast<button_state>(SDL_JoystickGetButton(m_joystick, button));
  }

  /**
   * \brief Returns the state of a specific joystick hat.
   *
   * \param hat the index of the hat to query, indices start at 0.
   *
   * \return the current state of the hat.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto get_hat_state(const int hat) const noexcept -> hat_state
  {
    return static_cast<hat_state>(SDL_JoystickGetHat(m_joystick, hat));
  }

  /**
   * \brief Updates the state of all open joysticks.
   *
   * \note This is done automatically by the event loop if any joystick events are
   * enabled.
   *
   * \since 4.2.0
   */
  static void update() noexcept
  {
    SDL_JoystickUpdate();
  }

  /**
   * \brief Locks the access to all joysticks.
   *
   * \details If you are using the joystick API from multiple threads you should use this
   * function to restrict access to the joysticks.
   *
   * \since 4.2.0
   */
  static void lock() noexcept
  {
    SDL_LockJoysticks();
  }

  /**
   * \brief Unlocks the access to all joysticks.
   *
   * \since 4.2.0
   */
  static void unlock() noexcept
  {
    SDL_UnlockJoysticks();
  }

  /**
   * \brief Specifies whether or not joystick event polling is enabled.
   *
   * \details If joystick event polling is disabled, then you must manually call
   * `basic_joystick::update()` in order to update the joystick state.
   *
   * \note It's recommended to leave joystick event polling enabled.
   *
   * \warning Calling this function might cause all events currently in the event queue to
   * be deleted.
   *
   * \param enabled `true` if joystick event polling should be enabled; `false` otherwise.
   *
   * \since 4.2.0
   */
  static void set_polling(const bool enabled) noexcept
  {
    SDL_JoystickEventState(enabled ? SDL_ENABLE : SDL_DISABLE);
  }

  /**
   * \brief Indicates whether or not joystick event polling is enabled.
   *
   * \return `true` if joystick event polling is enabled; `false` otherwise.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto is_polling() noexcept -> bool
  {
    return SDL_JoystickEventState(SDL_QUERY);
  }

  /**
   * \brief Returns the amount of currently available joysticks.
   *
   * \return the current amount of available joysticks; `std::nullopt` if something goes
   * wrong.
   *
   * \since 5.1.0
   */
  [[nodiscard]] static auto count() noexcept -> std::optional<int>
  {
    const auto result = SDL_NumJoysticks();
    if (result >= 0) {
      return result;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns a joystick GUID based on the supplied string.
   *
   * \param str the string used to obtain the GUID, can't be null.
   *
   * \return the obtained GUID.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto guid_from_string(const not_null<str> str) noexcept
      -> SDL_JoystickGUID
  {
    assert(str);
    return SDL_JoystickGetGUIDFromString(str);
  }

  /**
   * \brief Returns a joystick GUID based on the supplied string.
   *
   * \param str the string used to obtain the GUID.
   *
   * \return the obtained GUID.
   *
   * \since 5.3.0
   */
  [[nodiscard]] static auto guid_from_string(const std::string& str) noexcept
      -> SDL_JoystickGUID
  {
    return guid_from_string(str.c_str());
  }

  /**
   * \brief Returns the maximum possible value of an axis control on a joystick.
   *
   * \return the maximum possible value of an axis control.
   *
   * \since 4.2.0
   */
  [[nodiscard]] constexpr static auto axis_max() noexcept -> i16
  {
    return SDL_JOYSTICK_AXIS_MAX;
  }

  /**
   * \brief Returns the minimum possible value of an axis control on a joystick.
   *
   * \return the minimum possible value of an axis control.
   *
   * \since 4.2.0
   */
  [[nodiscard]] constexpr static auto axis_min() noexcept -> i16
  {
    return SDL_JOYSTICK_AXIS_MIN;
  }

  /**
   * \brief Indicates whether or not a handle holds a non-null pointer.
   *
   * \return `true` if the handle holds a non-null pointer; `false` otherwise.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit operator bool() const noexcept
  {
    return m_joystick != nullptr;
  }

  /**
   * \brief Returns a pointer to the associated `SDL_Joystick`.
   *
   * \warning Don't take ownership of the returned pointer!
   *
   * \return a pointer to the associated `SDL_Joystick`.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_Joystick*
  {
    return m_joystick.get();
  }

 private:
  struct deleter final
  {
    void operator()(SDL_Joystick* joystick) noexcept
    {
      if (SDL_JoystickGetAttached(joystick)) {
        SDL_JoystickClose(joystick);
      }
    }
  };
  detail::pointer_manager<T, SDL_Joystick, deleter> m_joystick;
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a joystick.
 *
 * \tparam T the ownership semantics tag for the joystick.
 *
 * \param joystick the joystick that will be converted.
 *
 * \return a string representation of the joystick.
 *
 * \since 6.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_joystick<T>& joystick) -> std::string
{
  str serial{};
  if constexpr (detail::sdl_version_at_least(2, 0, 14)) {
    serial = joystick.serial();
  }

#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("joystick{{data: {}, id: {}, name: {}, serial: {}}}",
                     detail::address_of(joystick.get()),
                     joystick.instance_id(),
                     str_or_na(joystick.name()),
                     str_or_na(joystick.serial()));
#else
  return "joystick{data: " + detail::address_of(joystick.get()) +
         ", id: " + std::to_string(joystick.instance_id()) +
         ", name: " + str_or_na(joystick.name()) + ", serial: " + str_or_na(serial) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a joystick using a stream.
 *
 * \tparam T the ownership semantics tag for the joystick.
 *
 * \param stream the stream that will be used to print the joystick.
 * \param joystick the joystick that will be printed.
 *
 * \return the used stream.
 *
 * \since 6.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_joystick<T>& joystick) -> std::ostream&
{
  return stream << to_string(joystick);
}

/// \} End of streaming

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_JOYSTICK_HEADER
// #include "sensor.hpp"
#ifndef CENTURION_SENSOR_HEADER
#define CENTURION_SENSOR_HEADER

#include <SDL.h>

#include <array>     // array
#include <optional>  // optional
#include <ostream>   // ostream
#include <string>    // string, to_string

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/owner.hpp"

// #include "../core/str.hpp"

// #include "../core/str_or_na.hpp"

// #include "../detail/address_of.hpp"

// #include "../detail/owner_handle_api.hpp"

// #include "sensor_type.hpp"
#ifndef CENTURION_SENSOR_TYPE_HEADER
#define CENTURION_SENSOR_TYPE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum sensor_type
 *
 * \brief Provides values that represent different sensor types.
 *
 * \see SDL_SensorType
 *
 * \since 5.2.0
 */
enum class sensor_type
{
  invalid = SDL_SENSOR_INVALID,      ///< Invalid sensor
  unknown = SDL_SENSOR_UNKNOWN,      ///< Unknown sensor
  accelerometer = SDL_SENSOR_ACCEL,  ///< Accelerometer
  gyroscope = SDL_SENSOR_GYRO        ///< Gyroscope
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied sensor type.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(sensor_type::gyroscope) == "gyroscope"`.
 *
 * \param type the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const sensor_type type) -> std::string_view
{
  switch (type) {
    case sensor_type::invalid:
      return "invalid";

    case sensor_type::unknown:
      return "unknown";

    case sensor_type::accelerometer:
      return "accelerometer";

    case sensor_type::gyroscope:
      return "gyroscope";

    default:
      throw cen_error{"Did not recognize sensor type!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a sensor type enumerator.
 *
 * \param stream the output stream that will be used.
 * \param type the enumerator that will be printed.
 *
 * \see `to_string(sensor_type)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const sensor_type type) -> std::ostream&
{
  return stream << to_string(type);
}

/// \} End of streaming

/// \name Sensor type comparison operators
/// \{

/**
 * \brief Indicates whether or not two sensor types values are equal.
 *
 * \param lhs the left-hand side sensor type.
 * \param rhs the right-hand side sensor type.
 *
 * \return `true` if the two sensor types are equal; `false` otherwise.
 *
 * \since 5.2.0
 */
[[nodiscard]] constexpr auto operator==(const sensor_type lhs,
                                        const SDL_SensorType rhs) noexcept -> bool
{
  return static_cast<SDL_SensorType>(lhs) == rhs;
}

/// \copydoc operator==(const sensor_type, const SDL_SensorType)
[[nodiscard]] constexpr auto operator==(const SDL_SensorType lhs,
                                        const sensor_type rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two sensor types values aren't equal.
 *
 * \param lhs the left-hand side sensor type.
 * \param rhs the right-hand side sensor type.
 *
 * \return `true` if the two sensor types aren't equal; `false` otherwise.
 *
 * \since 5.2.0
 */
[[nodiscard]] constexpr auto operator!=(const sensor_type lhs,
                                        const SDL_SensorType rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const sensor_type, const SDL_SensorType)
[[nodiscard]] constexpr auto operator!=(const SDL_SensorType lhs,
                                        const sensor_type rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of sensor type comparison operators

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_SENSOR_TYPE_HEADER


namespace cen {

/// \addtogroup input
/// \{

/**
 * \typedef sensor_id
 *
 * \brief Used for unique sensor instance identifiers.
 *
 * \since 5.2.0
 */
using sensor_id = SDL_SensorID;

template <typename T>
class basic_sensor;

/**
 * \typedef sensor
 *
 * \brief Represents an owning sensor device.
 *
 * \since 5.2.0
 */
using sensor = basic_sensor<detail::owning_type>;

/**
 * \typedef sensor_handle
 *
 * \brief Represents a non-owning sensor device.
 *
 * \since 5.2.0
 */
using sensor_handle = basic_sensor<detail::handle_type>;

/**
 * \class basic_sensor
 *
 * \brief Represents a sensor device.
 *
 * \ownerhandle `sensor`/`sensor_handle`
 *
 * \see `sensor`
 * \see `sensor_handle`
 *
 * \since 5.2.0
 */
template <typename T>
class basic_sensor final
{
 public:
  /// \name Construction
  /// \{

  /**
   * \brief Creates a sensor instance based on an existing pointer.
   *
   * \note The created instance will claim ownership of the supplied pointer if the class
   * has owning semantics.
   *
   * \param sensor a pointer to the SDL sensor data.
   *
   * \throws cen_error if the supplied pointer is null and the class has owning semantics.
   *
   * \since 5.2.0
   */
  explicit basic_sensor(maybe_owner<SDL_Sensor*> sensor) noexcept(!detail::is_owning<T>())
      : m_sensor{sensor}
  {
    if constexpr (detail::is_owning<T>()) {
      if (!m_sensor) {
        throw cen_error{"Null sensor pointer!"};
      }
    }
  }

  /**
   * \brief Creates an owning sensor instance based on a device index.
   *
   * \param index the device index of the sensor.
   *
   * \throws sdl_error if the sensor cannot be opened.
   *
   * \since 5.2.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_sensor(const int index = 0) : m_sensor{SDL_SensorOpen(index)}
  {
    if (!m_sensor) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates a sensor handle based on an owning sensor.
   *
   * \param owner the associated owning sensor.
   *
   * \since 5.2.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit basic_sensor(const sensor& owner) noexcept : m_sensor{owner.get()}
  {}

  /// \} End of construction

  /**
   * \brief Updates the state of all open sensors.
   *
   * \note This is done automatically by the event loop if sensor events are enabled.
   *
   * \since 5.2.0
   */
  static void update() noexcept
  {
    SDL_SensorUpdate();
  }

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Locks access to the sensors for multi-threading.
   *
   * \note Refer to the SDL documentation for more details regarding this.
   *
   * \see SDL_LockSensors
   *
   * \since 5.2.0
   */
  static void lock() noexcept
  {
    SDL_LockSensors();
  }

  /**
   * \brief Unlocks access to the sensors.
   *
   * \note Refer to the SDL documentation for more details regarding this.
   *
   * \see SDL_UnlockSensors
   *
   * \since 5.2.0
   */
  static void unlock() noexcept
  {
    SDL_UnlockSensors();
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Returns the amount of sensors currently attached to the system.
   *
   * \return the current amount of system sensors.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto count() noexcept -> int
  {
    return SDL_NumSensors();
  }

  /// \name Instance-based queries
  /// \{

  /**
   * \brief Returns the unique identifier associated with the sensor instance.
   *
   * \return a unique instance ID.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto id() const noexcept -> sensor_id
  {
    return SDL_SensorGetInstanceID(m_sensor);
  }

  /**
   * \brief Returns the name associated with the sensor device.
   *
   * \return the name of the sensor device; a null pointer is returned if the name isn't
   * available.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto name() const noexcept -> str
  {
    return SDL_SensorGetName(m_sensor);
  }

  /**
   * \brief Returns the type associated with the sensor device.
   *
   * \return the type of the sensor device.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto type() const noexcept -> sensor_type
  {
    return static_cast<sensor_type>(SDL_SensorGetType(m_sensor));
  }

  /**
   * \brief Returns the non-portable type associated with the sensor.
   *
   * \return a non-portable sensor type value.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto non_portable_type() const noexcept -> int
  {
    return SDL_SensorGetNonPortableType(m_sensor);
  }

  /**
   * \brief Returns the sensor-dependent data.
   *
   * \tparam Size the number of data elements, varies from sensor to sensor.
   *
   * \return the data associated with the sensor; `std::nullopt` if something goes wrong.
   *
   * \since 5.2.0
   */
  template <usize Size>
  [[nodiscard]] auto data() const noexcept -> std::optional<std::array<float, Size>>
  {
    std::array<float, Size> array{};
    if (SDL_SensorGetData(m_sensor, array.data(), isize(array)) != -1) {
      return array;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns a pointer to the associated SDL sensor.
   *
   * \warning Don't take ownership of the returned pointer!
   *
   * \return a pointer to the associated SDL sensor.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_Sensor*
  {
    return m_sensor.get();
  }

  /// \} End of instance-based queries

  /// \name Index-based queries
  /// \{

  /**
   * \brief Returns the unique identifier associated with a sensor instance.
   *
   * \param index the index of the sensor device that will be queried.
   *
   * \return the unique instance ID associated with a sensor; `std::nullopt` if the index
   * is invalid.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto id(const int index) noexcept -> std::optional<sensor_id>
  {
    const auto id = SDL_SensorGetDeviceInstanceID(index);
    if (id != -1) {
      return id;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the name associated with a sensor device.
   *
   * \param index the index of the sensor device that will be queried.
   *
   * \return the name of the sensor device; a null pointer is returned if the name isn't
   * available or if the index was invalid.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto name(const int index) noexcept -> str
  {
    return SDL_SensorGetDeviceName(index);
  }

  /**
   * \brief Returns the type associated with a sensor device.
   *
   * \param index the index of the sensor device that will be queried.
   *
   * \return the type of the sensor device.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto type(const int index) noexcept -> sensor_type
  {
    return static_cast<sensor_type>(SDL_SensorGetDeviceType(index));
  }

  /**
   * \brief Returns the non-portable type associated with a sensor.
   *
   * \param index the index of the sensor device that will be queried.
   *
   * \return a non-portable sensor type value; `std::nullopt` if the index is invalid.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto non_portable_type(const int index) noexcept -> std::optional<int>
  {
    const auto type = SDL_SensorGetDeviceNonPortableType(index);
    if (type != -1) {
      return type;
    }
    else {
      return std::nullopt;
    }
  }

  /// \} End of index-based queries

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not the handle holds a non-null pointer.
   *
   * \return `true` if the handle holds a non-null pointer; `false` otherwise.
   *
   * \since 5.2.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit operator bool() const noexcept
  {
    return m_sensor != nullptr;
  }

  /// \} End of conversions

 private:
  struct deleter final
  {
    void operator()(SDL_Sensor* sensor) noexcept
    {
      SDL_SensorClose(sensor);
    }
  };
  detail::pointer_manager<T, SDL_Sensor, deleter> m_sensor;
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a sensor instance.
 *
 * \param sensor the sensor that will be converted.
 *
 * \return a string that represents a sensor instance.
 *
 * \since 5.2.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_sensor<T>& sensor) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("sensor{{data: {}, id: {}, name: {}}}",
                     detail::address_of(sensor.get()),
                     sensor.id(),
                     str_or_na(sensor.name()));
#else
  return "sensor{data: " + detail::address_of(sensor.get()) +
         ", id: " + std::to_string(sensor.id()) + ", name: " + str_or_na(sensor.name()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a sensor instance using a stream.
 *
 * \param stream the stream that will be used.
 * \param sensor the sensor that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.2.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_sensor<T>& sensor) -> std::ostream&
{
  return stream << to_string(sensor);
}

/// \} End of streaming

/**
 * \brief Returns the standard gravity value.
 *
 * \return the standard gravity value.
 *
 * \since 5.2.0
 */
[[nodiscard]] constexpr auto standard_gravity() noexcept -> float
{
  return SDL_STANDARD_GRAVITY;
}

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_SENSOR_HEADER

// #include "touch.hpp"
#ifndef CENTURION_TOUCH_HEADER
#define CENTURION_TOUCH_HEADER

#include <SDL.h>

#include <optional>  // optional

// #include "../core/integers.hpp"

// #include "button_state.hpp"

// #include "touch_device_type.hpp"
#ifndef CENTURION_TOUCH_DEVICE_TYPE_HEADER
#define CENTURION_TOUCH_DEVICE_TYPE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

namespace touch {

/// \addtogroup input
/// \{

/**
 * \enum device_type
 *
 * \brief Provides values that represent different touch device types.
 *
 * \see `SDL_TouchDeviceType`
 *
 * \todo Centurion 7: Rename to touch_device_type and move out of touch namespace.
 *
 * \since 4.3.0
 */
enum class device_type
{
  // clang-format off
  invalid = SDL_TOUCH_DEVICE_INVALID,                      ///< Invalid touch device.
  direct = SDL_TOUCH_DEVICE_DIRECT,                        ///< Touch screen with window-relative coordinates.
  indirect_absolute = SDL_TOUCH_DEVICE_INDIRECT_ABSOLUTE,  ///< Trackpad with absolute device coordinates.
  indirect_relative = SDL_TOUCH_DEVICE_INDIRECT_RELATIVE   ///< Trackpad with screen cursor-relative coordinates.
  // clang-format on
};

/// \name Touch device comparison operators
/// \{

/**
 * \brief Indicates whether or not two touch device types are the same.
 *
 * \param lhs the left-hand side touch device type.
 * \param rhs the right-hand side touch device type.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator==(const device_type lhs,
                                        const SDL_TouchDeviceType rhs) noexcept -> bool
{
  return static_cast<SDL_TouchDeviceType>(lhs) == rhs;
}

/// \copydoc operator==(device_type, SDL_TouchDeviceType)
[[nodiscard]] constexpr auto operator==(const SDL_TouchDeviceType lhs,
                                        const device_type rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two touch device types aren't the same.
 *
 * \param lhs the left-hand side touch device type.
 * \param rhs the right-hand side touch device type.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator!=(const device_type lhs,
                                        const SDL_TouchDeviceType rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(device_type, SDL_TouchDeviceType)
[[nodiscard]] constexpr auto operator!=(const SDL_TouchDeviceType lhs,
                                        const device_type rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of touch device comparison operators

/// \} End of group input

}  // namespace touch

/// \addtogroup input
/// \{

// Added for consistency with rest of codebase (no classes in nested namespaces)
using touch_device_type = touch::device_type;

[[nodiscard]] constexpr auto to_string(touch_device_type type) -> std::string_view;

namespace touch {

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a touch device type enumerator.
 *
 * \param stream the output stream that will be used.
 * \param type the enumerator that will be printed.
 *
 * \see `to_string(touch_device_type)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const touch_device_type type) -> std::ostream&
{
  return stream << to_string(type);
}

/// \} End of streaming

}  // namespace touch

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied touch device type.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(device_type::direct) == "direct"`.
 *
 * \param type the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const touch_device_type type) -> std::string_view
{
  switch (type) {
    case touch_device_type::invalid:
      return "invalid";

    case touch_device_type::direct:
      return "direct";

    case touch_device_type::indirect_absolute:
      return "indirect_absolute";

    case touch_device_type::indirect_relative:
      return "indirect_relative";

    default:
      throw cen_error{"Did not recognize touch device type!"};
  }
}

/// \} End of string conversions

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_TOUCH_DEVICE_TYPE_HEADER


/**
 * \namespace cen::touch
 *
 * \ingroup input
 *
 * \brief Provides the touch API components and methods.
 *
 * \since 4.3.0
 */
namespace cen::touch {

/// \addtogroup input
/// \{

/**
 * \struct finger_state
 *
 * \brief Represents the state of a finger.
 *
 * \todo Centurion 7: Rename to touch_finger_state and move out of touch namespace.
 *
 * \since 5.2.0
 */
struct finger_state final
{
  button_state state;  ///< Whether or not the finger is pressed or release.
  float x;             ///< The current x-coordinate.
  float y;             ///< The current y-coordinate.
  float pressure;      ///< The current applied pressure.
};

/**
 * \brief Returns the number of registered touch devices.
 *
 * \return the number of registered touch devices.
 *
 * \since 4.3.0
 */
[[nodiscard]] inline auto device_count() noexcept -> int
{
  return SDL_GetNumTouchDevices();
}

/**
 * \brief Returns the touch device ID associated with the specified index.
 *
 * \param index the index of the desired touch device.
 *
 * \return the touch device ID associated with the index; `std::nullopt` if there is no
 * such value.
 *
 * \since 4.3.0
 */
[[nodiscard]] inline auto get_device(const int index) noexcept -> std::optional<SDL_TouchID>
{
  const auto device = SDL_GetTouchDevice(index);
  if (device != 0) {
    return device;
  }
  else {
    return std::nullopt;
  }
}

/**
 * \brief Returns the type of a touch device.
 *
 * \param id the touch device that will be queried.
 *
 * \return the type of the specified touch device.
 *
 * \since 4.3.0
 */
[[nodiscard]] inline auto type_of(const SDL_TouchID id) noexcept -> device_type
{
  return static_cast<device_type>(SDL_GetTouchDeviceType(id));
}

/**
 * \brief Returns the number of active fingers for a given touch device.
 *
 * \param id the touch device that will be queried.
 *
 * \return the amount of active fingers in a touch device.
 *
 * \since 4.3.0
 */
[[nodiscard]] inline auto finger_count(const SDL_TouchID id) noexcept -> int
{
  return SDL_GetNumTouchFingers(id);
}

/**
 * \brief Returns the finger associated with the specified touch ID and index.
 *
 * \param id the touch ID of the finger.
 * \param index the index of the finger object.
 *
 * \return the associated finger; `std::nullopt` if no such instance could be obtained.
 *
 * \since 4.3.0
 */
[[nodiscard]] inline auto get_finger(const SDL_TouchID id, const int index) noexcept
    -> std::optional<SDL_Finger>
{
  if (const auto* finger = SDL_GetTouchFinger(id, index)) {
    return *finger;
  }
  else {
    return std::nullopt;
  }
}

/**
 * \brief Returns the device ID used for mouse events simulated with touch input.
 *
 * \return a device ID.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto touch_mouse_id() noexcept -> u32
{
  return SDL_TOUCH_MOUSEID;
}

/**
 * \brief Returns the touch ID used by touch events simulated with mouse input.
 *
 * \return the touch ID used by touch events simulated with mouse input.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto mouse_touch_id() noexcept -> SDL_TouchID
{
  return SDL_MOUSE_TOUCHID;
}

/// \} End of group input

}  // namespace cen::touch

namespace cen {

/// \addtogroup input
/// \{

// Added for consistency with rest of codebase (no classes in nested namespaces)
using touch_finger_state = touch::finger_state;

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_TOUCH_HEADER

namespace cen {

/// \addtogroup input
/// \{

template <typename T>
class basic_controller;

/**
 * \typedef controller
 *
 * \brief Represents an owning game controller.
 *
 * \since 5.0.0
 */
using controller = basic_controller<detail::owning_type>;

/**
 * \typedef controller_handle
 *
 * \brief Represents a non-owning game controller.
 *
 * \since 5.0.0
 */
using controller_handle = basic_controller<detail::handle_type>;

/**
 * \class basic_controller
 *
 * \brief Represents a game controller, e.g. Xbox or Playstation controllers.
 *
 * \ownerhandle `controller`/`controller_handle`
 *
 * \details You may need to load appropriate game controller mappings before you can begin
 * using the game controller API with certain controllers. This can be accomplished using
 * the `cen::hint::controller::config_file` hint, or the `load_mappings()` and
 * `add_mapping()` functions.
 *
 * \details For a community managed database file of game controller mappings, see
 * `https://github.com/gabomdq/SDL_GameControllerDB` (if the link doesn’t work for some
 * reason, you should be able to find a copy in the Centurion test resources folder).
 *
 * \todo Centurion 7: Move `mapping_result` out of `basic_controller`.
 *
 * \since 5.0.0
 *
 * \see `controller`
 * \see `controller_handle`
 */
template <typename T>
class basic_controller final
{
 public:
  using mapping_index = int;
  using joystick_index = int;
  using player_index = int;

  /**
   * \brief Used to indicate the result of adding controller mappings.
   *
   * \since 5.1.0
   */
  enum class mapping_result
  {
    error,    ///< Something went wrong.
    updated,  ///< Updated a previous mapping.
    added     ///< Successfully added a new mapping.
  };

  /// \name Construction
  /// \{

  // clang-format off

  /**
   * \brief Creates a game controller from an existing SDL game controller.
   *
   * \note Ownership of the supplied pointer is claimed if the joystick has
   * owning semantics.
   *
   * \param controller a pointer to the associated game controller.
   *
   * \since 5.0.0
   */
  explicit basic_controller(maybe_owner<SDL_GameController*> controller) noexcept(!detail::is_owning<T>())
      : m_controller{controller}
  {
    if constexpr (detail::is_owning<T>()) 
    {
      if (!m_controller) 
      {
        throw cen_error{"Cannot create controller from null pointer!"};
      }
    }
  }

  // clang-format on

  /**
   * \brief Creates a handle to an existing controller instance.
   *
   * \param owner the controller that owns the `SDL_GameController` pointer.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit basic_controller(const controller& owner) noexcept : m_controller{owner.get()}
  {}

  /**
   * \brief Attempts to create a game controller.
   *
   * \details The joystick index is the same as the device index passed to the
   * `joystick` constructor. The index passed as an argument refers to the
   * n'th game controller on the system.
   *
   * \note The supplied index is not the value which will identify the
   * controller in controller events. Instead, the joystick's instance id
   * (`SDL_JoystickID`) will be used.
   *
   * \remark This constructor is only available for owning game controllers.
   *
   * \param index the device index, can't be >= than the amount of number of
   * joysticks.
   *
   * \throws sdl_error if the game controller cannot be opened.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_controller(const int index = 0) : m_controller{SDL_GameControllerOpen(index)}
  {
    if (!m_controller) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates a game controller from an existing joystick ID.
   *
   * \remark This function is only available for owning game controllers.
   *
   * \param id the identifier associated with the joystick to base the game
   * controller on.
   *
   * \return a game controller instance.
   *
   * \throws sdl_error if the game controller cannot be created.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto from_joystick(const SDL_JoystickID id) -> basic_controller
  {
    if (auto* ptr = SDL_GameControllerFromInstanceID(id)) {
      return basic_controller{ptr};
    }
    else {
      throw sdl_error{};
    }
  }

#if SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Creates a controller based on a player index.
   *
   * \param index the player index of the game controller.
   *
   * \return a game controller associated with the specified player index.
   *
   * \throws sdl_error if the game controller cannot be created.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto from_index(const player_index index) -> basic_controller
  {
    if (auto* ptr = SDL_GameControllerFromPlayerIndex(index)) {
      return basic_controller{ptr};
    }
    else {
      throw sdl_error{};
    }
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

  /// \} End of construction

  /**
   * \brief Updates the state of all open game controllers.
   *
   * \note This is done automatically if game controller events are enabled.
   *
   * \since 5.0.0
   */
  static void update()
  {
    SDL_GameControllerUpdate();
  }

  /**
   * \brief Indicates whether or not the specified value is usable as a
   * controller index.
   *
   * \param index the index that will be checked.
   *
   * \return `true` if the supplied index is supported; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] static auto is_supported(const joystick_index index) noexcept -> bool
  {
    return SDL_IsGameController(index) == SDL_TRUE;
  }

  /**
   * \brief Sets whether or not game controller event polling is enabled.
   *
   * \details If this property is set to `false`, then you have to call
   * `update` by yourself.
   *
   * \param polling `true` to enable automatic game controller event polling;
   * `false` otherwise.
   *
   * \since 5.0.0
   */
  static void set_polling(const bool polling) noexcept
  {
    SDL_GameControllerEventState(polling ? SDL_ENABLE : SDL_DISABLE);
  }

  /**
   * \brief Indicates whether or not game controller event polling is enabled.
   *
   * \return `true` if game controller event polling is enabled; `false`
   * otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] static auto is_polling() noexcept -> bool
  {
    return SDL_GameControllerEventState(SDL_QUERY);
  }

#if SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Sets the player index associated with the controller.
   *
   * \param index the player index that will be used.
   *
   * \since 5.0.0
   */
  void set_player_index(const player_index index) noexcept
  {
    SDL_GameControllerSetPlayerIndex(m_controller, index);
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

#if SDL_VERSION_ATLEAST(2, 0, 16)

  /**
   * \brief Sends a packet of controller specific data.
   *
   * \param data the data that will be sent.
   * \param size the size of the data.
   *
   * \return `success` if the data was sent successfully; `failure` if the controller
   * or driver doesn't support effect packets.
   *
   * \since 6.2.0
   */
  auto send_effect(const void* data, const int size) -> result
  {
    return SDL_GameControllerSendEffect(m_controller, data, size) == 0;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 16)

  /// \name Button and axis functions
  /// \{

  /**
   * \brief Returns the button associated with the specified string.
   *
   * \param str the string that represents a controller button, e.g "a".
   *
   * \return a game controller button value.
   *
   * \since 5.0.0
   */
  [[nodiscard]] static auto get_button(const not_null<str> str) noexcept -> controller_button
  {
    assert(str);
    return static_cast<controller_button>(SDL_GameControllerGetButtonFromString(str));
  }

  /**
   * \brief Returns the button associated with the specified string.
   *
   * \param str the string that represents a controller button, e.g "a".
   *
   * \return a game controller button value.
   *
   * \since 5.3.0
   */
  [[nodiscard]] static auto get_button(const std::string& str) noexcept -> controller_button
  {
    return get_button(str.c_str());
  }

  /**
   * \brief Returns a string representation of a controller axis.
   *
   * \param axis the controller axis that will be converted.
   *
   * \return a string that represents the axis, might be null.
   *
   * \since 5.0.0
   */
  [[nodiscard]] static auto stringify(const controller_axis axis) noexcept -> str
  {
    return SDL_GameControllerGetStringForAxis(static_cast<SDL_GameControllerAxis>(axis));
  }

  /**
   * \brief Returns a string representation of a controller button.
   *
   * \param button the controller button that will be converted.
   *
   * \return a string that represents the button, might be null.
   *
   * \since 5.0.0
   */
  [[nodiscard]] static auto stringify(const controller_button button) noexcept -> str
  {
    return SDL_GameControllerGetStringForButton(static_cast<SDL_GameControllerButton>(button));
  }

  /**
   * \brief Returns the bindings for a controller axis.
   *
   * \param axis the axis of the bindings.
   *
   * \return the bindings for a controller axis; `std::nullopt` on failure.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get_binding(const controller_axis axis) const
      -> std::optional<SDL_GameControllerButtonBind>
  {
    const auto result =
        SDL_GameControllerGetBindForAxis(m_controller,
                                         static_cast<SDL_GameControllerAxis>(axis));
    if (result.bindType != SDL_CONTROLLER_BINDTYPE_NONE) {
      return result;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the bindings for a controller button.
   *
   * \param button the button of the bindings.
   *
   * \return the bindings for a controller button; `std::nullopt` on failure.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get_binding(const controller_button button) noexcept
      -> std::optional<SDL_GameControllerButtonBind>
  {
    const auto result =
        SDL_GameControllerGetBindForButton(m_controller,
                                           static_cast<SDL_GameControllerButton>(button));
    if (result.bindType != SDL_CONTROLLER_BINDTYPE_NONE) {
      return result;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the state of the specified game controller button.
   *
   * \param button the button that will be checked.
   *
   * \return the current button state of the specified button.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get_state(const controller_button button) const noexcept -> button_state
  {
    const auto state =
        SDL_GameControllerGetButton(m_controller,
                                    static_cast<SDL_GameControllerButton>(button));
    return static_cast<button_state>(state);
  }

  /**
   * \brief Indicates if the specified button is pressed.
   *
   * \param button the button that will be checked.
   *
   * \return `true` if the specified button is pressed; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto is_pressed(const controller_button button) const noexcept -> bool
  {
    return get_state(button) == button_state::pressed;
  }

  /**
   * \brief Indicates if the specified button is released.
   *
   * \param button the button that will be checked.
   *
   * \return `true` if the specified button is released; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto is_released(const controller_button button) const noexcept -> bool
  {
    return get_state(button) == button_state::released;
  }

  /**
   * \brief Returns the axis associated with the specified string.
   *
   * \note You don't need this function unless you are parsing game controller
   * mappings by yourself.
   *
   * \param str the string that represents a game controller axis, e.g "rightx".
   *
   * \return a game controller axis value.
   *
   * \since 5.0.0
   */
  [[nodiscard]] static auto get_axis(const not_null<str> str) noexcept -> controller_axis
  {
    assert(str);
    return static_cast<controller_axis>(SDL_GameControllerGetAxisFromString(str));
  }

  /**
   * \brief Returns the axis associated with the specified string.
   *
   * \note You don't need this function unless you are parsing game controller
   * mappings by yourself.
   *
   * \param str the string that represents a game controller axis, e.g "rightx".
   *
   * \return a game controller axis value.
   *
   * \since 5.3.0
   */
  [[nodiscard]] static auto get_axis(const std::string& str) noexcept -> controller_axis
  {
    return get_axis(str.c_str());
  }

  /**
   * \brief Returns the value of the specified axis.
   *
   * \param axis the controller axis that will be checked.
   *
   * \return the current value of the specified axis.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get_axis(const controller_axis axis) const noexcept -> i16
  {
    return SDL_GameControllerGetAxis(m_controller, static_cast<SDL_GameControllerAxis>(axis));
  }

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Indicates whether or not the controller has the specified axis.
   *
   * \return `true` if the controller has the specified axis; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_axis(const controller_axis axis) const noexcept -> bool
  {
    const auto value = static_cast<SDL_GameControllerAxis>(axis);
    return SDL_GameControllerHasAxis(m_controller, value) == SDL_TRUE;
  }

  /**
   * \brief Indicates whether or not the controller has the specified button.
   *
   * \param button the button that will be checked.
   *
   * \return `true` if the controller features the specified button; `false`
   * otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_button(const controller_button button) const noexcept -> bool
  {
    const auto value = static_cast<SDL_GameControllerButton>(button);
    return SDL_GameControllerHasButton(m_controller, value) == SDL_TRUE;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  /// \} End of button and axis functions

  /// \name Rumble functions
  /// \{

  /**
   * \brief Starts a rumble effect.
   *
   * \details Calls to this function cancels any previously active rumble
   * effect. Furthermore, supplying 0 as intensities will stop the rumble
   * effect.
   *
   * \note This function has no effect if rumbling isn't supported by the
   * controller.
   *
   * \param lo the intensity of the low frequency motor.
   * \param hi the intensity of the high frequency motor.
   * \param duration the duration of the rumble effect.
   *
   * \return `success` if the rumble is successful; `failure` otherwise.
   *
   * \since 5.0.0
   */
  auto rumble(const u16 lo,
              const u16 hi,
              const milliseconds<u32> duration) noexcept(noexcept(duration.count())) -> result
  {
    return SDL_GameControllerRumble(m_controller, lo, hi, duration.count()) == 0;
  }

#if SDL_VERSION_ATLEAST(2, 0, 14)

  // clang-format off

  /**
   * \brief Starts a rumble effect in the controller's triggers.
   *
   * \details Calls to this function cancels any previously active rumble
   * effect. Furthermore, supplying 0 as intensities will stop the rumble
   * effect.
   *
   * \note This function has no effect if rumbling isn't supported by the
   * controller.
   *
   * \param lo the intensity of the low frequency motor.
   * \param hi the intensity of the high frequency motor.
   * \param duration the duration of the rumble effect.
   *
   * \return `success` if the rumble is successful; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto rumble_triggers(const u16 lo,
                       const u16 hi,
                       const milliseconds<u32> duration) noexcept(noexcept(duration.count()))
      -> result
  {
    return SDL_GameControllerRumbleTriggers(m_controller, lo, hi, duration.count()) == 0;
  }

  // clang-format on

#endif  // SDL_VERSION(2, 0, 14)

  /**
   * \brief Stops any currently active rumble effect.
   *
   * \since 5.0.0
   */
  void stop_rumble() noexcept
  {
    rumble(0, 0, milliseconds<u32>::zero());
  }

  /// \} End of rumble functions

  /// \name Queries
  /// \{

  /**
   * \brief Returns the USB product ID of the controller.
   *
   * \return the USB product ID; `std::nullopt` if the product ID isn't
   * available.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto product() const noexcept -> std::optional<u16>
  {
    const auto id = SDL_GameControllerGetProduct(m_controller);
    if (id != 0) {
      return id;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the USB vendor ID of the controller.
   *
   * \return the USB vendor ID; `std::nullopt` if the vendor ID isn't available.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto vendor() const noexcept -> std::optional<u16>
  {
    const auto id = SDL_GameControllerGetVendor(m_controller);
    if (id != 0) {
      return id;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the product version of the controller.
   *
   * \return the product version; `std::nullopt` if the product version isn't
   * available.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto product_version() const noexcept -> std::optional<u16>
  {
    const auto id = SDL_GameControllerGetProductVersion(m_controller);
    if (id != 0) {
      return id;
    }
    else {
      return std::nullopt;
    }
  }

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Returns the serial number associated with the controller.
   *
   * \return the serial number associated with the controller; a null pointer if
   * no serial number is available.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto serial() const noexcept -> str
  {
    return SDL_GameControllerGetSerial(m_controller);
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Returns the player index associated with the controller.
   *
   * \note If this is an XInput controller, the returned value is the user
   * index.
   *
   * \return the player index associated with the controller; `std::nullopt`
   * if the index isn't available.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto index() const noexcept -> std::optional<player_index>
  {
    const auto result = SDL_GameControllerGetPlayerIndex(m_controller);
    if (result != -1) {
      return result;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Indicates whether or not the game controller is currently connected.
   *
   * \return `true` if the game controller is connected; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto is_connected() const noexcept -> bool
  {
    return SDL_GameControllerGetAttached(m_controller) == SDL_TRUE;
  }

  /**
   * \brief Returns the name associated with the game controller.
   *
   * \note This function might return a null pointer if there is no name
   * associated with the game controller.
   *
   * \return the name of the game controller, might be null.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto name() const noexcept -> str
  {
    return SDL_GameControllerName(m_controller);
  }

#if SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Returns the type of the controller.
   *
   * \return the type of the controller.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto type() const noexcept -> controller_type
  {
    return static_cast<controller_type>(SDL_GameControllerGetType(m_controller));
  }

  /**
   * \brief Returns the type of the controller associated with the specified
   * joystick index.
   *
   * \param index the joystick index of the desired game controller.
   *
   * \return the type of the game controller associated with the index.
   *
   * \since 5.0.0
   */
  [[nodiscard]] static auto type(const joystick_index index) noexcept -> controller_type
  {
    return static_cast<controller_type>(SDL_GameControllerTypeForIndex(index));
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Returns a handle to the associated joystick.
   *
   * \return a handle to the associated joystick.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get_joystick() noexcept -> joystick_handle
  {
    return joystick_handle{SDL_GameControllerGetJoystick(m_controller)};
  }

  /**
   * \brief Returns the amount of available game controllers on the system.
   *
   * \return the amount of available game controllers.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto count() noexcept -> int
  {
    const auto joysticks = SDL_NumJoysticks();

    auto amount = 0;
    for (auto i = 0; i < joysticks; ++i) {
      if (is_supported(i)) {
        ++amount;
      }
    }

    return amount;
  }

  /**
   * \brief Returns a pointer to the associated SDL game controller.
   *
   * \warning Don't take ownership of the returned pointer!
   *
   * \return a pointer to the associated SDL game controller.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_GameController*
  {
    return m_controller.get();
  }

  /// \} End of queries

  /// \name Touchpad functions
  /// \{

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Returns the amount of touchpads on the controller.
   *
   * \return the amount of touchpads on the controller.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto touchpad_count() const noexcept -> int
  {
    return SDL_GameControllerGetNumTouchpads(m_controller);
  }

  /**
   * \brief Returns the amount of supported simultaneous fingers for a touchpad.
   *
   * \param touchpad the index associated with the touchpad that will be
   * queried.
   *
   * \return the maximum amount of supported simultaneous fingers for the
   * specified touchpad.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto touchpad_finger_capacity(const int touchpad) const noexcept -> int
  {
    return SDL_GameControllerGetNumTouchpadFingers(m_controller, touchpad);
  }

  /**
   * \brief Returns the state of a finger on a touchpad.
   *
   * \param touchpad the touchpad to query.
   * \param finger the index of the finger that will be queried.
   *
   * \return the current state of a touchpad finger; `std::nullopt` if something
   * goes wrong.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto touchpad_finger_state(const int touchpad, const int finger) const noexcept
      -> std::optional<touch::finger_state>
  {
    touch::finger_state result{};
    u8 state{};

    const auto res = SDL_GameControllerGetTouchpadFinger(m_controller,
                                                         touchpad,
                                                         finger,
                                                         &state,
                                                         &result.x,
                                                         &result.y,
                                                         &result.pressure);
    result.state = static_cast<button_state>(state);

    if (res != -1) {
      return result;
    }
    else {
      return std::nullopt;
    }
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  /// \} End of touchpad functions

  /// \name Sensor functions
  /// \{

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Sets whether or not data reporting is enabled for a sensor.
   *
   * \param type the type of the sensor that will be changed.
   * \param enabled `true` if data reporting should be enabled; `false`
   * otherwise.
   *
   * \return `success` if the sensor was successfully enabled or disabled;
   * `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto set_sensor_enabled(const sensor_type type, const bool enabled) noexcept -> result
  {
    const auto value = static_cast<SDL_SensorType>(type);
    const auto state = enabled ? SDL_TRUE : SDL_FALSE;
    return SDL_GameControllerSetSensorEnabled(m_controller, value, state) == 0;
  }

  /**
   * \brief Indicates whether or not the controller has a sensor.
   *
   * \param type the type of the sensor to look for.
   *
   * \return `true` if the controller has the specified sensor; `false`
   * otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_sensor(const sensor_type type) const noexcept -> bool
  {
    const auto value = static_cast<SDL_SensorType>(type);
    return SDL_GameControllerHasSensor(m_controller, value) == SDL_TRUE;
  }

  /**
   * \brief Indicates whether or not data reporting is enabled for a sensor.
   *
   * \param type the type of the sensor that will be queried.
   *
   * \return `true` if data reporting is enabled for the sensor; `false`
   * otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto is_sensor_enabled(const sensor_type type) const noexcept -> bool
  {
    const auto value = static_cast<SDL_SensorType>(type);
    return SDL_GameControllerIsSensorEnabled(m_controller, value) == SDL_TRUE;
  }

  /**
   * \brief Returns the state of the specified sensor.
   *
   * \tparam Size the amount of data elements.
   *
   * \param type the type of the sensor that will be queried.
   *
   * \return the sensor data; `std::nullopt` if something went wrong.
   *
   * \since 5.2.0
   */
  template <usize Size>
  [[nodiscard]] auto get_sensor_data(const sensor_type type) const noexcept
      -> std::optional<std::array<float, Size>>
  {
    std::array<float, Size> array{};
    if (SDL_GameControllerGetSensorData(m_controller,
                                        static_cast<SDL_SensorType>(type),
                                        array.data(),
                                        isize(array)) != -1)
    {
      return array;
    }
    else {
      return std::nullopt;
    }
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

#if SDL_VERSION_ATLEAST(2, 0, 16)

  /**
   * \brief Returns the data rate of a controller sensor, i.e. the number of supported
   * events per second.
   *
   * \param type the sensor type that will be queried.
   *
   * \return the data rate (may be zero if the data rate isn't available).
   *
   * \since 6.2.0
   */
  [[nodiscard]] auto get_sensor_data_rate(const sensor_type type) const noexcept -> float
  {
    return SDL_GameControllerGetSensorDataRate(m_controller,
                                               static_cast<SDL_SensorType>(type));
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 16)

  /// \} End of sensor functions

  /// \name LED functions
  /// \{

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Sets the color of the associated LED light.
   *
   * \param color the new color of the controller's LED.
   *
   * \return `success` if the color of the LED was set; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto set_led(const color& color) noexcept -> result
  {
    return SDL_GameControllerSetLED(m_controller, color.red(), color.green(), color.blue()) ==
           0;
  }

  /**
   * \brief Indicates whether or not the controller features a LED light.
   *
   * \return `true` if the controller features a LED light; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_led() const noexcept -> bool
  {
    return SDL_GameControllerHasLED(m_controller) == SDL_TRUE;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  /// \} End of LED functions

  /// \name Mapping functions
  /// \{

  /**
   * \brief Adds a game controller mapping.
   *
   * \param mapping the string that encodes the game controller mapping.
   *
   * \return `added` if a new mapping was added; `updated` if a previous mapping
   * was updated; `error` if something went wrong.
   *
   * \since 5.0.0
   */
  static auto add_mapping(const not_null<str> mapping) noexcept -> mapping_result
  {
    assert(mapping);
    const auto result = SDL_GameControllerAddMapping(mapping);
    if (result == 1) {
      return mapping_result::added;
    }
    else if (result == 0) {
      return mapping_result::updated;
    }
    else {
      return mapping_result::error;
    }
  }

  /**
   * \brief Adds a game controller mapping.
   *
   * \param mapping the string that encodes the game controller mapping.
   *
   * \return `added` if a new mapping was added; `updated` if a previous mapping
   * was updated; `error` if something went wrong.
   *
   * \since 5.3.0
   */
  static auto add_mapping(const std::string& mapping) noexcept -> mapping_result
  {
    return add_mapping(mapping.c_str());
  }

  /**
   * \brief Loads a set of game controller mappings from a file.
   *
   * \details A collection of game controller mappings can be found at <a
   * href="https://github.com/gabomdq/SDL_GameControllerDB">here</a>. New
   * mappings for previously known GUIDs will overwrite the previous mappings.
   * Furthermore, mappings for different platforms than the current platform
   * will be ignored.
   *
   * \remarks It's possible to call this function several times to use multiple
   * mapping files.
   *
   * \note The text database is stored entirely in memory during processing.
   *
   * \param file the path of the mapping file.
   *
   * \return the amount of mappings added; `std::nullopt` if something went
   * wrong.
   *
   * \since 5.0.0
   */
  static auto load_mappings(const not_null<str> file) noexcept -> std::optional<int>
  {
    assert(file);
    const auto result = SDL_GameControllerAddMappingsFromFile(file);
    if (result != -1) {
      return result;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Loads a set of game controller mappings from a file.
   *
   * \details A collection of game controller mappings can be found at <a
   * href="https://github.com/gabomdq/SDL_GameControllerDB">here</a>. New mappings for
   * previously known GUIDs will overwrite the previous mappings. Furthermore, mappings
   * for different platforms than the current platform will be ignored.
   *
   * \remarks It's possible to call this function several times to use multiple mapping
   * files.
   *
   * \note The text database is stored entirely in memory during processing.
   *
   * \param file the path of the mapping file.
   *
   * \return the amount of mappings added; `std::nullopt` if something went wrong.
   *
   * \since 5.3.0
   */
  static auto load_mappings(const std::string& file) noexcept -> std::optional<int>
  {
    return load_mappings(file.c_str());
  }

  /**
   * \brief Returns the mapping associated with the controller.
   *
   * \return the mapping string associated with the controller.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto mapping() const noexcept -> sdl_string
  {
    return sdl_string{SDL_GameControllerMapping(m_controller)};
  }

  /**
   * \brief Returns the mapping associated with a game controller.
   *
   * \param index the joystick index of the desired game controller.
   *
   * \return the mapping string associated with a controller.
   *
   * \since 5.0.0
   */
  [[nodiscard]] static auto mapping(const joystick_index index) noexcept -> sdl_string
  {
    return sdl_string{SDL_GameControllerMappingForDeviceIndex(index)};
  }

  /**
   * \brief Returns the mapping string associated with a joystick GUID.
   *
   * \param guid the GUID to obtain the mapping for.
   *
   * \return the mapping string for a GUID:
   *
   * \since 5.0.0
   */
  [[nodiscard]] static auto mapping(const SDL_JoystickGUID guid) noexcept -> sdl_string
  {
    return sdl_string{SDL_GameControllerMappingForGUID(guid)};
  }

  /**
   * \brief Returns the mapping at a specific index.
   *
   * \param index the index of the desired mapping.
   *
   * \return the mapping at the specified index.
   *
   * \since 5.0.0
   */
  [[nodiscard]] static auto mapping_by_index(const mapping_index index) noexcept -> sdl_string
  {
    return sdl_string{SDL_GameControllerMappingForIndex(index)};
  }

  /**
   * \brief Returns the number of installed mappings.
   *
   * \return the amount of installed mappings.
   *
   * \since 5.0.0
   */
  [[nodiscard]] static auto mapping_count() noexcept -> int
  {
    return SDL_GameControllerNumMappings();
  }

  /// \} End of mapping functions

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not the handle contains a non-null pointer.
   *
   * \return `true` if the handle holds a non-null pointer; `false` otherwise.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit operator bool() const noexcept
  {
    return m_controller != nullptr;
  }

  /// \} End of conversions

 private:
  struct deleter final
  {
    void operator()(SDL_GameController* controller) noexcept
    {
      SDL_GameControllerClose(controller);
    }
  };
  detail::pointer_manager<T, SDL_GameController, deleter> m_controller;
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied controller mapping result.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(controller::mapping_result::added) == "added"`.
 *
 * \param result the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] inline auto to_string(const controller::mapping_result result)
    -> std::string_view
{
  switch (result) {
    case controller::mapping_result::error:
      return "error";

    case controller::mapping_result::updated:
      return "updated";

    case controller::mapping_result::added:
      return "added";

    default:
      throw cen_error{"Did not recognize controller mapping result!"};
  }
}

/// \see to_string(controller::mapping_result)
[[nodiscard]] constexpr auto to_string(const controller_handle::mapping_result result)
    -> std::string_view
{
  switch (result) {
    case controller_handle::mapping_result::error:
      return "error";

    case controller_handle::mapping_result::updated:
      return "updated";

    case controller_handle::mapping_result::added:
      return "added";

    default:
      throw cen_error{"Did not recognize controller mapping result!"};
  }
}

/**
 * \brief Returns a textual representation of a game controller.
 *
 * \param controller the game controller that will be converted.
 *
 * \return a string that represents a game controller.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_controller<T>& controller) -> std::string
{
  const auto* name = controller.name();

  str serial{};
  if constexpr (detail::sdl_version_at_least(2, 0, 14)) {
    serial = controller.serial();
  }

#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("controller{{data: {}, name: {}, serial: {}}}",
                     detail::address_of(controller.get()),
                     str_or_na(name),
                     str_or_na(serial));
#else
  return "controller{data: " + detail::address_of(controller.get()) +
         ", name: " + str_or_na(name) + ", serial: " + str_or_na(serial) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a controller mapping result enumerator.
 *
 * \param stream the output stream that will be used.
 * \param result the enumerator that will be printed.
 *
 * \see `to_string(controller::mapping_result)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const controller::mapping_result result)
    -> std::ostream&
{
  return stream << to_string(result);
}

/// \see operator<<(std::ostream&, controller::mapping_result)
inline auto operator<<(std::ostream& stream, const controller_handle::mapping_result result)
    -> std::ostream&
{
  return stream << to_string(result);
}

/**
 * \brief Prints a textual representation of a game controller.
 *
 * \param stream the stream that will be used.
 * \param controller the game controller that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_controller<T>& controller) -> std::ostream&
{
  return stream << to_string(controller);
}

/// \} End of streaming

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_GAME_CONTROLLER_HEADER

// #include "centurion/input/controller_axis.hpp"
#ifndef CENTURION_CONTROLLER_AXIS_HEADER
#define CENTURION_CONTROLLER_AXIS_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum controller_axis
 *
 * \brief Represents different game controller axes.
 *
 * \see `SDL_GameControllerAxis`
 *
 * \since 4.0.0
 */
enum class controller_axis
{
  invalid = SDL_CONTROLLER_AXIS_INVALID,
  left_x = SDL_CONTROLLER_AXIS_LEFTX,
  left_y = SDL_CONTROLLER_AXIS_LEFTY,
  right_x = SDL_CONTROLLER_AXIS_RIGHTX,
  right_y = SDL_CONTROLLER_AXIS_RIGHTY,
  trigger_left = SDL_CONTROLLER_AXIS_TRIGGERLEFT,
  trigger_right = SDL_CONTROLLER_AXIS_TRIGGERRIGHT,
  max = SDL_CONTROLLER_AXIS_MAX
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied controller axis.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(controller_axis::right_x) == "right_x"`.
 *
 * \param axis the controller axis that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const controller_axis axis) -> std::string_view
{
  switch (axis) {
    case controller_axis::invalid:
      return "invalid";

    case controller_axis::left_x:
      return "left_x";

    case controller_axis::left_y:
      return "left_y";

    case controller_axis::right_x:
      return "right_x";

    case controller_axis::right_y:
      return "right_y";

    case controller_axis::trigger_left:
      return "trigger_left";

    case controller_axis::trigger_right:
      return "trigger_right";

    case controller_axis::max:
      return "max";

    default:
      throw cen_error{"Did not recognize controller axis!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a controller axis enumerator.
 *
 * \param stream the output stream that will be used.
 * \param axis the controller axis that will be printed.
 *
 * \see `to_string(controller_axis)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const controller_axis axis) -> std::ostream&
{
  return stream << to_string(axis);
}

/// \} End of streaming

/// \name Controller axis comparison operators
/// \{

/**
 * \brief Indicates whether or not two game controller axis values are the same.
 *
 * \param lhs the left-hand-side game controller axis value.
 * \param rhs the right-hand-side game controller axis value.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator==(const controller_axis lhs,
                                        const SDL_GameControllerAxis rhs) noexcept -> bool
{
  return static_cast<SDL_GameControllerAxis>(lhs) == rhs;
}

/// \copydoc operator==(controller_axis, SDL_GameControllerAxis)
[[nodiscard]] constexpr auto operator==(const SDL_GameControllerAxis lhs,
                                        const controller_axis rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two game controller axis values aren't the
 * same.
 *
 * \param lhs the left-hand-side game controller axis value.
 * \param rhs the right-hand-side game controller axis value.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator!=(const controller_axis lhs,
                                        const SDL_GameControllerAxis rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(controller_axis, SDL_GameControllerAxis)
[[nodiscard]] constexpr auto operator!=(const SDL_GameControllerAxis lhs,
                                        const controller_axis rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of controller axis comparison operators

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_CONTROLLER_AXIS_HEADER

// #include "centurion/input/controller_type.hpp"
#ifndef CENTURION_CONTROLLER_TYPE_HEADER
#define CENTURION_CONTROLLER_TYPE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup input
/// \{

#if SDL_VERSION_ATLEAST(2, 0, 12)

/**
 * \enum controller_type
 *
 * \brief Represents different game controller types.
 *
 * \see `SDL_GameControllerType`
 *
 * \since 5.0.0
 */
enum class controller_type
{
  // clang-format off
  unknown = SDL_CONTROLLER_TYPE_UNKNOWN,   ///< An unknown controller.
  xbox_360 = SDL_CONTROLLER_TYPE_XBOX360,  ///< An Xbox 360 controller.
  xbox_one = SDL_CONTROLLER_TYPE_XBOXONE,  ///< An Xbox One controller.
  ps3 = SDL_CONTROLLER_TYPE_PS3,           ///< A PS3 controller.
  ps4 = SDL_CONTROLLER_TYPE_PS4,           ///< A PS4 controller.

#if SDL_VERSION_ATLEAST(2, 0, 14)

  ps5 = SDL_CONTROLLER_TYPE_PS5,       ///< A PS5 controller.
  virt = SDL_CONTROLLER_TYPE_VIRTUAL,  ///< A virtual controller.

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

#if SDL_VERSION_ATLEAST(2, 0, 16)

  amazon_luna = SDL_CONTROLLER_TYPE_AMAZON_LUNA,     ///< An Amazon Luna controller.
  google_stadia = SDL_CONTROLLER_TYPE_GOOGLE_STADIA, ///< A Google Stadia controller.

#endif // SDL_VERSION_ATLEAST(2, 0, 16)

  nintendo_switch_pro = SDL_CONTROLLER_TYPE_NINTENDO_SWITCH_PRO  ///< A Nintendo Switch Pro controller.
  // clang-format on
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied controller type.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(controller_type::ps4) == "ps4"`.
 *
 * \param type the controller type that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const controller_type type) -> std::string_view
{
  switch (type) {
    case controller_type::unknown:
      return "unknown";

    case controller_type::nintendo_switch_pro:
      return "nintendo_switch_pro";

    case controller_type::xbox_360:
      return "xbox_360";

    case controller_type::xbox_one:
      return "xbox_one";

    case controller_type::ps3:
      return "ps3";

    case controller_type::ps4:
      return "ps4";

#if SDL_VERSION_ATLEAST(2, 0, 14)

    case controller_type::ps5:
      return "ps5";

    case controller_type::virt:
      return "virt";

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

#if SDL_VERSION_ATLEAST(2, 0, 16)

    case controller_type::amazon_luna:
      return "amazon_luna";

    case controller_type::google_stadia:
      return "google_stadia";

#endif  // SDL_VERSION_ATLEAST(2, 0, 16)

    default:
      throw cen_error{"Did not recognize controller type!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a controller type enumerator.
 *
 * \param stream the output stream that will be used.
 * \param type the controller type that will be printed.
 *
 * \see `to_string(controller_type)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const controller_type type) -> std::ostream&
{
  return stream << to_string(type);
}

/// \} End of streaming

/// \name Controller type comparison operators
/// \{

/**
 * \brief Indicates whether or not to controller type values are the same.
 *
 * \param lhs the left-hand side controller type value.
 * \param rhs the right-hand side controller type value.
 *
 * \return `true` if the controller type values are the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator==(const controller_type lhs,
                                        const SDL_GameControllerType rhs) noexcept -> bool
{
  return static_cast<SDL_GameControllerType>(lhs) == rhs;
}

/// \copydoc operator==(controller_type, SDL_GameControllerType)
[[nodiscard]] constexpr auto operator==(const SDL_GameControllerType lhs,
                                        const controller_type rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not to controller type values aren't the same.
 *
 * \param lhs the left-hand side controller type value.
 * \param rhs the right-hand side controller type value.
 *
 * \return `true` if the controller type values aren't the same; `false`
 * otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator!=(const controller_type lhs,
                                        const SDL_GameControllerType rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(controller_type, SDL_GameControllerType)
[[nodiscard]] constexpr auto operator!=(const SDL_GameControllerType lhs,
                                        const controller_type rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of controller type comparison operators

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_CONTROLLER_TYPE_HEADER

// #include "centurion/input/haptic.hpp"
#ifndef CENTURION_HAPTIC_HEADER
#define CENTURION_HAPTIC_HEADER

#include <SDL.h>

#include <cassert>   // assert
#include <optional>  // optional
#include <ostream>   // ostream
#include <string>    // string

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/owner.hpp"

// #include "../core/result.hpp"

// #include "../core/str.hpp"

// #include "../core/str_or_na.hpp"

// #include "../core/time.hpp"

// #include "../core/to_underlying.hpp"

// #include "../detail/address_of.hpp"

// #include "../detail/clamp.hpp"
#ifndef CENTURION_DETAIL_CLAMP_HEADER
#define CENTURION_DETAIL_CLAMP_HEADER

#include <cassert>  // assert

/// \cond FALSE
namespace cen::detail {

// clang-format off

/**
 * \brief Clamps a value to be within the range [min, max].
 *
 * \pre `min` must be less than or equal to `max`.
 *
 * \note The standard library provides `std::clamp`, but it isn't mandated to be
 * `noexcept` (although MSVC does mark it as `noexcept`), which is the reason this
 * function exists.
 *
 * \tparam T the type of the values.
 *
 * \param value the value that will be clamped.
 * \param min the minimum value (inclusive).
 * \param max the maximum value (inclusive).
 *
 * \return the clamped value.
 *
 * \since 5.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto clamp(const T& value,
                                   const T& min,
                                   const T& max)
    noexcept(noexcept(value < min) && noexcept(value > max)) -> T
{
  assert(min <= max);
  if (value < min)
  {
    return min;
  }
  else if (value > max)
  {
    return max;
  }
  else
  {
    return value;
  }
}

// clang-format on

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_CLAMP_HEADER

// #include "../detail/owner_handle_api.hpp"

// #include "../math/vector3.hpp"
#ifndef CENTURION_VECTOR3_HEADER
#define CENTURION_VECTOR3_HEADER

#include <ostream>  // ostream
#include <string>   // string, to_string

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

namespace cen {

/// \addtogroup math
/// \{

/**
 * \struct vector3
 *
 * \brief A simple representation of a 3-dimensional vector.
 *
 * \serializable
 *
 * \tparam T the representation type, e.g. `float` or `double`.
 *
 * \since 5.2.0
 */
template <typename T>
struct vector3 final
{
  using value_type = T;  ///< The type of the vector components.

  value_type x{};  ///< The x-coordinate of the vector.
  value_type y{};  ///< The y-coordinate of the vector.
  value_type z{};  ///< The z-coordinate of the vector.

#if CENTURION_HAS_FEATURE_SPACESHIP

  [[nodiscard]] constexpr auto operator<=>(const vector3&) const noexcept = default;

#endif  // CENTURION_HAS_FEATURE_SPACESHIP

  /**
   * \brief Casts the vector to a vector with another representation type.
   *
   * \tparam U the target vector type.
   *
   * \return the result vector.
   *
   * \since 5.2.0
   */
  template <typename U>
  [[nodiscard]] explicit operator vector3<U>() const noexcept
  {
    using target_value_type = typename vector3<U>::value_type;
    return vector3<U>{static_cast<target_value_type>(x),
                      static_cast<target_value_type>(y),
                      static_cast<target_value_type>(z)};
  }
};

/**
 * \brief Serializes a 3D-vector.
 *
 * \details This function expects that the archive provides an overloaded `operator()`,
 * used for serializing data. This API is based on the Cereal serialization library.
 *
 * \tparam Archive the type of the archive.
 * \tparam T the type of the vector components.
 *
 * \param archive the archive used to serialize the vector.
 * \param vector the vector that will be serialized.
 *
 * \since 5.3.0
 */
template <typename Archive, typename T>
void serialize(Archive& archive, vector3<T>& vector)
{
  archive(vector.x, vector.y, vector.z);
}

/// \name Vector3 comparison operators
/// \{

#if !CENTURION_HAS_FEATURE_SPACESHIP

/**
 * \brief Indicates whether or not two 3D vectors are equal.
 *
 * \tparam T the representation type used by the vectors.
 *
 * \param lhs the left-hand side vector.
 * \param rhs the right-hand side vector.
 *
 * \return `true` if the vectors are equal; `false` otherwise.
 *
 * \since 5.2.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator==(const vector3<T>& lhs, const vector3<T>& rhs) noexcept
    -> bool
{
  return (lhs.x == rhs.x) && (lhs.y == rhs.y) && (lhs.z == rhs.z);
}

/**
 * \brief Indicates whether or not two 3D vectors aren't equal.
 *
 * \tparam T the representation type used by the vectors.
 *
 * \param lhs the left-hand side vector.
 * \param rhs the right-hand side vector.
 *
 * \return `true` if the vectors aren't equal; `false` otherwise.
 *
 * \since 5.2.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator!=(const vector3<T>& lhs, const vector3<T>& rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

#endif  // CENTURION_HAS_FEATURE_SPACESHIP

/// \} End of vector3 comparison operators

/// \name String conversions
/// \{

/**
 * \brief Returns a string that represents a vector.
 *
 * \tparam T the representation type used by the vector.
 *
 * \param vector the vector that will be converted to a string.
 *
 * \return a string that represents the supplied vector.
 *
 * \since 5.2.0
 */
template <typename T>
[[nodiscard]] auto to_string(const vector3<T>& vector) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("vector3{{x: {}, y: {}, z: {}}}", vector.x, vector.y, vector.z);
#else
  return "vector3{x: " + std::to_string(vector.x) + ", y: " + std::to_string(vector.y) +
         ", z: " + std::to_string(vector.z) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a vector.
 *
 * \tparam T the representation type used by the vector.
 *
 * \param stream the stream that will be used.
 * \param vector the vector that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.2.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const vector3<T>& vector) -> std::ostream&
{
  return stream << to_string(vector);
}

/// \} End of streaming

/// \} End of group math

}  // namespace cen

#endif  // CENTURION_VECTOR3_HEADER

// #include "haptic_effect.hpp"
#ifndef CENTURION_HAPTIC_EFFECT_HEADER
#define CENTURION_HAPTIC_EFFECT_HEADER

#include <SDL.h>

#include <type_traits>  // enable_if_t

// #include "../core/integers.hpp"

// #include "../core/time.hpp"

// #include "haptic_direction.hpp"
#ifndef CENTURION_HAPTIC_DIRECTION_HEADER
#define CENTURION_HAPTIC_DIRECTION_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../core/to_underlying.hpp"

// #include "../math/vector3.hpp"

// #include "haptic_direction_type.hpp"
#ifndef CENTURION_HAPTIC_DIRECTION_TYPE_HEADER
#define CENTURION_HAPTIC_DIRECTION_TYPE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum haptic_direction_type
 *
 * \brief Represents the different types of haptic directions.
 *
 * \since 5.2.0
 */
enum class haptic_direction_type : u8
{
  polar = SDL_HAPTIC_POLAR,
  cartesian = SDL_HAPTIC_CARTESIAN,
  spherical = SDL_HAPTIC_SPHERICAL
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied haptic direction type.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(haptic_direction_type::polar) == "polar"`.
 *
 * \param type the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const haptic_direction_type type) -> std::string_view
{
  switch (type) {
    case haptic_direction_type::polar:
      return "polar";

    case haptic_direction_type::cartesian:
      return "cartesian";

    case haptic_direction_type::spherical:
      return "spherical";

    default:
      throw cen_error{"Did not recognize haptic direction type!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a haptic direction type enumerator.
 *
 * \param stream the output stream that will be used.
 * \param type the enumerator that will be printed.
 *
 * \see `to_string(haptic_direction_type)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const haptic_direction_type type) -> std::ostream&
{
  return stream << to_string(type);
}

/// \} End of streaming

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_HAPTIC_DIRECTION_TYPE_HEADER


namespace cen {

/// \addtogroup input
/// \{

/**
 * \class haptic_direction
 *
 * \brief Represents a haptic direction, used by haptic effects.
 *
 * \since 5.2.0
 */
class haptic_direction final
{
 public:
  using direction_type = vector3<i32>;

  /**
   * \brief Creates a haptic direction of the specified type.
   *
   * \param type the type of the direction.
   *
   * \since 5.2.0
   */
  explicit haptic_direction(const haptic_direction_type type) noexcept
  {
    set_type(type);
  }

  /**
   * \brief Creates a haptic direction based on an `SDL_HapticDirection` instance.
   *
   * \param direction the direction that will be copied.
   *
   * \since 5.2.0
   */
  explicit haptic_direction(const SDL_HapticDirection& direction) noexcept
      : m_direction{direction}
  {}

  /**
   * \brief Sets the type of the direction.
   *
   * \param type the new type of the direction.
   *
   * \since 5.2.0
   */
  void set_type(const haptic_direction_type type) noexcept
  {
    m_direction.type = to_underlying(type);
  }

  /**
   * \brief Sets the value of direction.
   *
   * \param direction the new value of the direction.
   *
   * \since 5.2.0
   */
  void set_value(const direction_type& direction) noexcept
  {
    m_direction.dir[0] = direction.x;
    m_direction.dir[1] = direction.y;
    m_direction.dir[2] = direction.z;
  }

  /**
   * \brief Returns the type associated with the direction.
   *
   * \return the current type of the direction.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto type() const noexcept -> haptic_direction_type
  {
    return static_cast<haptic_direction_type>(m_direction.type);
  }

  /**
   * \brief Returns the value of the direction.
   *
   * \return the current value of the direction.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto value() const noexcept -> direction_type
  {
    return {m_direction.dir[0], m_direction.dir[1], m_direction.dir[2]};
  }

  /**
   * \brief Returns the internal representation of the direction.
   *
   * \return the internal representation.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto get() const noexcept -> const SDL_HapticDirection&
  {
    return m_direction;
  }

 private:
  SDL_HapticDirection m_direction{};
};

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_HAPTIC_DIRECTION_HEADER


namespace cen {

/// \addtogroup input
/// \{

/**
 * \brief A constant that can be used to play an effect indefinitely.
 *
 * \since 5.2.0
 */
inline constexpr u32 haptic_infinity = SDL_HAPTIC_INFINITY;

/**
 * \class haptic_effect
 *
 * \brief Represents a haptic effect.
 *
 * \details The following is an illustration of the different stages of a haptic effect,
 * copied from the SDL documentation, albeit with tweaked terms.
 * \verbatim
    Strength
    ^
    |
    |    effect level -->  _________________
    |                     /                 \
    |                    /                   \
    |                   /                     \
    |                  /                       \
    | attack_level --> |                        \
    |                  |                        |  <---  fade_level
    |
    +--------------------------------------------------> Time
                       [--]                 [---]
                       attack_length        fade_length

    [------------------][-----------------------]
    delay               duration
    \endverbatim
 *
 * \tparam Derived the type of the subclass, for CRTP.
 *
 * \since 5.2.0
 */
template <typename Derived>
class haptic_effect
{
  template <typename T>
  using has_direction = std::enable_if_t<T::hasDirection, int>;

  template <typename T>
  using has_envelope = std::enable_if_t<T::hasEnvelope, int>;

  template <typename T>
  using has_trigger = std::enable_if_t<T::hasTrigger, int>;

  template <typename T>
  using has_delay = std::enable_if_t<T::hasDelay, int>;

 public:
  /// \name Direction functions
  /// \{

  /**
   * \brief Sets the haptic direction associated with the effect.
   *
   * \note This function is not available for all haptic effects.
   *
   * \param direction the new direction of the effect.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_direction<D> = 0>
  void set_direction(const haptic_direction& direction) noexcept
  {
    rep().direction = direction.get();
  }

  /**
   * \brief Returns the haptic direction associated with the effect.
   *
   * \return the current direction associated with the effect.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_direction<D> = 0>
  [[nodiscard]] auto direction() const noexcept -> haptic_direction
  {
    return haptic_direction{rep().direction};
  }

  /// \} End of direction functions

  /// \name Replay functions
  /// \{

  /**
   * \brief Sets the effect to be repeated indefinitely when run.
   *
   * \details This function makes the effect repeat forever when run, but the attack and
   * fade are not repeated.
   *
   * \since 5.2.0
   */
  void set_repeat_forever() noexcept
  {
    rep().length = haptic_infinity;
  }

  /**
   * \brief Sets the duration of the effect.
   *
   * \param duration the duration of the effect.
   *
   * \since 5.2.0
   */
  void set_duration(const milliseconds<u32> duration) noexcept(noexcept(duration.count()))
  {
    rep().length = duration.count();
  }

  /**
   * \brief Sets the delay before before the effect is started.
   *
   * \note This function is not available for all haptic effects.
   *
   * \param delay the delay before before the effect is started.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_delay<D> = 0>
  void set_delay(const milliseconds<u16> delay) noexcept(noexcept(delay.count()))
  {
    rep().delay = delay.count();
  }

  /**
   * \brief Returns the duration of the effect.
   *
   * \return the duration of the effect.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto duration() const -> milliseconds<u32>
  {
    return milliseconds<u32>{rep().length};
  }

  /**
   * \brief Returns the delay before before the effect is started.
   *
   * \note This function is not available for all haptic effects.
   *
   * \return the delay before before the effect is started.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_delay<D> = 0>
  [[nodiscard]] auto delay() const -> milliseconds<u16>
  {
    return milliseconds<u16>{rep().delay};
  }

  /// \} End of replay functions

  /// \name Trigger functions
  /// \{

  /**
   * \brief Sets the button that triggers the effect.
   *
   * \note This function is not available for all haptic effects.
   *
   * \param button the button that triggers the effect.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_trigger<D> = 0>
  void set_button(const u16 button) noexcept
  {
    rep().button = button;
  }

  /**
   * \brief Sets the minimum interval in between activations of the effect.
   *
   * \note This function is not available for all haptic effects.
   *
   * \param interval the minimum interval in between activations of the effect.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_trigger<D> = 0>
  void set_interval(const milliseconds<u16> interval) noexcept(noexcept(interval.count()))
  {
    rep().interval = interval.count();
  }

  /**
   * \brief Returns the button that triggers the effect.
   *
   * \note This function is not available for all haptic effects.
   *
   * \return the button that triggers the effect.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_trigger<D> = 0>
  [[nodiscard]] auto button() const noexcept -> u16
  {
    return rep().button;
  }

  /**
   * \brief Returns the minimum interval in between activations of the effect.
   *
   * \note This function is not available for all haptic effects.
   *
   * \return the minimum interval in between activations of the effect.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_trigger<D> = 0>
  [[nodiscard]] auto interval() const -> milliseconds<u16>
  {
    return milliseconds<u16>{rep().interval};
  }

  /// \} End of trigger functions

  /// \name Envelope functions
  /// \{

  /**
   * \brief Sets the level at the *start* of the attack.
   *
   * \note This function is not available for all haptic effects.
   *
   * \param level the level at the start of the attack.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_envelope<D> = 0>
  void set_attack_level(const u16 level) noexcept
  {
    rep().attack_level = level;
  }

  /**
   * \brief Sets the level at the *end* of the fade out.
   *
   * \note This function is not available for all haptic effects.
   *
   * \param level the level at the *end* of the fade out.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_envelope<D> = 0>
  void set_fade_level(const u16 level) noexcept
  {
    rep().fade_level = level;
  }

  // clang-format off

  /**
   * \brief Sets the duration of the attack.
   *
   * \note This function is not available for all haptic effects.
   *
   * \param duration the duration of the attack.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_envelope<D> = 0>
  void set_attack_duration(const milliseconds<u16> duration) noexcept(noexcept(duration.count()))
  {
    rep().attack_length = duration.count();
  }

  /**
   * \brief Sets the duration of the fade out.
   *
   * \note This function is not available for all haptic effects.
   *
   * \param duration the duration of the fade out.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_envelope<D> = 0>
  void set_fade_duration(const milliseconds<u16> duration) noexcept(noexcept(duration.count()))
  {
    rep().fade_length = duration.count();
  }

  // clang-format on

  /**
   * \brief Returns the level at the *start* of the attack.
   *
   * \note This function is not available for all haptic effects.
   *
   * \return the the level at the *start* of the attack.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_envelope<D> = 0>
  [[nodiscard]] auto attack_level() const noexcept -> u16
  {
    return rep().attack_level;
  }

  /**
   * \brief Returns the level at the *end* of the fade.
   *
   * \note This function is not available for all haptic effects.
   *
   * \return the level at the *end* of the fade.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_envelope<D> = 0>
  [[nodiscard]] auto fade_level() const noexcept -> u16
  {
    return rep().fade_level;
  }

  /**
   * \brief Returns the duration of the attack.
   *
   * \note This function is not available for all haptic effects.
   *
   * \return the duration of the attack.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_envelope<D> = 0>
  [[nodiscard]] auto attack_duration() const -> milliseconds<u16>
  {
    return milliseconds<u16>{rep().attack_length};
  }

  /**
   * \brief Returns the duration of the fade out.
   *
   * \note This function is not available for all haptic effects.
   *
   * \return the duration of the fade out.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_envelope<D> = 0>
  [[nodiscard]] auto fade_duration() const -> milliseconds<u16>
  {
    return milliseconds<u16>{rep().fade_length};
  }

  /// \} End of envelope functions

  /**
   * \brief Returns the type associated with the haptic effect.
   *
   * \return the associated effect type.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto type() const noexcept -> u16
  {
    return rep().type;
  }

  /**
   * \brief Returns the internal effect representation.
   *
   * \return the internal effect representation.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto get() noexcept -> SDL_HapticEffect&
  {
    return m_effect;
  }

  /**
   * \copydoc get()
   */
  [[nodiscard]] auto get() const noexcept -> const SDL_HapticEffect&
  {
    return m_effect;
  }

 protected:
  SDL_HapticEffect m_effect{};

 private:
  [[nodiscard]] auto derived() noexcept -> Derived*
  {
    return static_cast<Derived*>(this);
  }

  [[nodiscard]] auto derived() const noexcept -> const Derived*
  {
    return static_cast<const Derived*>(this);
  }

  [[nodiscard]] auto rep() noexcept -> auto&
  {
    return derived()->representation();
  }

  [[nodiscard]] auto rep() const noexcept -> const auto&
  {
    return derived()->representation();
  }
};

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_HAPTIC_EFFECT_HEADER

// #include "haptic_feature.hpp"
#ifndef CENTURION_HAPTIC_FEATURE_HEADER
#define CENTURION_HAPTIC_FEATURE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum haptic_feature
 *
 * \brief Provides values that represent all of the haptic features.
 *
 * \since 5.2.0
 */
enum class haptic_feature : uint
{
  constant = SDL_HAPTIC_CONSTANT,
  sine = SDL_HAPTIC_SINE,
  left_right = SDL_HAPTIC_LEFTRIGHT,
  triangle = SDL_HAPTIC_TRIANGLE,
  sawtooth_up = SDL_HAPTIC_SAWTOOTHUP,
  sawtooth_down = SDL_HAPTIC_SAWTOOTHDOWN,
  ramp = SDL_HAPTIC_RAMP,
  spring = SDL_HAPTIC_SPRING,
  damper = SDL_HAPTIC_DAMPER,
  inertia = SDL_HAPTIC_INERTIA,
  friction = SDL_HAPTIC_FRICTION,
  custom = SDL_HAPTIC_CUSTOM,
  gain = SDL_HAPTIC_GAIN,
  autocenter = SDL_HAPTIC_AUTOCENTER,
  status = SDL_HAPTIC_STATUS,
  pause = SDL_HAPTIC_PAUSE
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied haptic feature.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(haptic_feature::spring) == "spring"`.
 *
 * \param feature the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const haptic_feature feature) -> std::string_view
{
  switch (feature) {
    case haptic_feature::constant:
      return "constant";

    case haptic_feature::sine:
      return "sine";

    case haptic_feature::left_right:
      return "left_right";

    case haptic_feature::triangle:
      return "triangle";

    case haptic_feature::sawtooth_up:
      return "sawtooth_up";

    case haptic_feature::sawtooth_down:
      return "sawtooth_down";

    case haptic_feature::ramp:
      return "ramp";

    case haptic_feature::spring:
      return "spring";

    case haptic_feature::damper:
      return "damper";

    case haptic_feature::inertia:
      return "inertia";

    case haptic_feature::friction:
      return "friction";

    case haptic_feature::custom:
      return "custom";

    case haptic_feature::gain:
      return "gain";

    case haptic_feature::autocenter:
      return "autocenter";

    case haptic_feature::status:
      return "status";

    case haptic_feature::pause:
      return "pause";

    default:
      throw cen_error{"Did not recognize haptic feature!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a haptic feature enumerator.
 *
 * \param stream the output stream that will be used.
 * \param feature the enumerator that will be printed.
 *
 * \see `to_string(haptic_feature)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const haptic_feature feature) -> std::ostream&
{
  return stream << to_string(feature);
}

/// \} End of streaming

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_HAPTIC_FEATURE_HEADER

// #include "joystick.hpp"


namespace cen {

/// \addtogroup input
/// \{

template <typename B>
class basic_haptic;

/**
 * \typedef haptic
 *
 * \brief Represents an owning haptic device.
 *
 * \since 5.2.0
 */
using haptic = basic_haptic<detail::owning_type>;

/**
 * \typedef haptic_handle
 *
 * \brief Represents a non-owning haptic device.
 *
 * \since 5.2.0
 */
using haptic_handle = basic_haptic<detail::handle_type>;

/**
 * \class basic_haptic
 *
 * \brief Represents a haptic (force feedback) device.
 *
 * \ownerhandle `haptic`/`haptic_handle`
 *
 * \see `haptic`
 * \see `haptic_handle`
 *
 * \since 5.2.0
 */
template <typename T>
class basic_haptic final
{
 public:
  using effect_id = int;

  /// \name Construction
  /// \{

  /**
   * \brief Creates a haptic instance based on an existing pointer.
   *
   * \note The created instance will claim ownership of the supplied pointer if the class
   * has owning semantics.
   *
   * \param haptic a pointer to the haptic device data.
   *
   * \throws cen_error if the supplied pointer is null and the class has owning semantics.
   *
   * \since 5.2.0
   */
  explicit basic_haptic(maybe_owner<SDL_Haptic*> haptic) noexcept(!detail::is_owning<T>())
      : m_haptic{haptic}
  {
    if constexpr (detail::is_owning<T>()) {
      if (!m_haptic) {
        throw cen_error{"Null haptic pointer!"};
      }
    }
  }

  /**
   * \brief Creates a haptic device based on a haptic device index.
   *
   * \note This constructor is only available for owning haptic instances.
   *
   * \param index the device index of the desired haptic device.
   *
   * \throws sdl_error if the haptic device couldn't be opened.
   *
   * \since 5.2.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_haptic(const int index = 0) : m_haptic{SDL_HapticOpen(index)}
  {
    if (!m_haptic) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates a handle based on an owning haptic instance.
   *
   * \param owner the associated owning haptic device.
   *
   * \since 5.2.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit basic_haptic(const haptic& owner) noexcept : m_haptic{owner.get()}
  {}

  /**
   * \brief Creates a haptic device based on a joystick.
   *
   * \note This function is only available for owning haptic instances.
   *
   * \param joystick a joystick handle to the associated joystick.
   *
   * \throws sdl_error if the haptic device couldn't be opened.
   *
   * \see `is_joystick_haptic()`
   *
   * \since 5.2.0
   */
  template <typename U, typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto from_joystick(const basic_joystick<U>& joystick) -> basic_haptic
  {
    if (auto* ptr = SDL_HapticOpenFromJoystick(joystick.get())) {
      return basic_haptic{ptr};
    }
    else {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates a haptic device based on the current mouse.
   *
   * \note This function is only available for owning haptic instances.
   *
   * \throws sdl_error if the haptic device couldn't be opened.
   *
   * \see `is_mouse_haptic()`
   *
   * \since 5.2.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto from_mouse() -> basic_haptic
  {
    if (auto* ptr = SDL_HapticOpenFromMouse()) {
      return basic_haptic{ptr};
    }
    else {
      throw sdl_error{};
    }
  }

  /// \} End of construction

  /// \name Rumble effects
  /// \{

  /**
   * \brief Initializes rumble playback for the haptic device.
   *
   * \return `success` if rumble playback was successfully initialized; `failure`
   * otherwise.
   *
   * \since 5.2.0
   */
  auto init_rumble() noexcept -> result
  {
    return SDL_HapticRumbleInit(m_haptic) == 0;
  }

  /**
   * \brief Plays a rumble effect.
   *
   * \note Make sure to call `init_rumble()` before calling this function!
   *
   * \param strength the strength of the rumble effect, clamped to [0, 1].
   * \param duration the duration of the rumble effect.
   *
   * \return `success` if the rumble was successful; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto play_rumble(const float strength,
                   const milliseconds<u32> duration) noexcept(noexcept(duration.count()))
      -> result
  {
    return SDL_HapticRumblePlay(m_haptic,
                                detail::clamp(strength, 0.0f, 1.0f),
                                duration.count()) == 0;
  }

  /**
   * \brief Stops the current rumble effect.
   *
   * \return `success` if the rumble was successfully stopped; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto stop_rumble() noexcept -> result
  {
    return SDL_HapticRumbleStop(m_haptic) == 0;
  }

  /**
   * \brief Indicates whether or not rumble playback is supported.
   *
   * \return `true` if rumble playback is supported; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto is_rumble_supported() const noexcept -> bool
  {
    return SDL_HapticRumbleSupported(m_haptic) == SDL_TRUE;
  }

  /// \} End of rumble effects

  /// \name Effects
  /// \{

  /**
   * \brief Pauses the device.
   *
   * \pre The device must support the `pause` feature.
   * \post You must call `unpause()` before calling `upload()` or `update()`.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto pause() noexcept -> result
  {
    assert(has_feature_pause());
    return SDL_HapticPause(m_haptic) == 0;
  }

  /**
   * \brief Unpauses the device.
   *
   * \pre `pause()` must have been called before this function is invoked.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto unpause() noexcept -> result
  {
    return SDL_HapticUnpause(m_haptic) == 0;
  }

  /**
   * \brief Uploads an effect to the device.
   *
   * \param effect the effect that will be uploaded to the device.
   *
   * \return the ID associated with the uploaded effect; `std::nullopt` if something went
   * wrong.
   *
   * \since 5.2.0
   */
  template <typename D>
  auto upload(const haptic_effect<D>& effect) noexcept -> std::optional<effect_id>
  {
    auto internal = effect.get();
    const auto id = SDL_HapticNewEffect(m_haptic, &internal);
    if (id != -1) {
      return id;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Attempts to update the effect associated with the specified ID.
   *
   * \note It is not possible to change the type of the effect through this function.
   *
   * \note You might experience strange results if you call this function for an
   * effect that is currently playing, but it is possible.
   *
   * \param id the ID associated with the effect that will be updated.
   * \param effect the new properties that will be associated with the effect.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.2.0
   */
  template <typename D>
  auto update(const effect_id id, const haptic_effect<D>& effect) noexcept -> result
  {
    auto internal = effect.get();
    return SDL_HapticUpdateEffect(m_haptic, id, &internal) == 0;
  }

  /**
   * \brief Runs the specified effect.
   *
   * \note If you want to repeat the effect indefinitely without repeating the attack and
   * fade, see `haptic_effect::set_repeat_forever()`.
   *
   * \param id the ID associated with the effect that will be run.
   * \param iterations the number of iterations, can be `haptic_infinity` to repeat the
   * effect forever (including the attack and fade).
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto run(const effect_id id, const u32 iterations = 1) noexcept -> result
  {
    return SDL_HapticRunEffect(m_haptic, id, iterations) == 0;
  }

  /**
   * \brief Stops a currently running effect.
   *
   * \param id the ID associated with the effect that will be stopped.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto stop(const effect_id id) noexcept -> result
  {
    return SDL_HapticStopEffect(m_haptic, id) == 0;
  }

  /**
   * \brief Stops all currently running effects on the device.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto stop_all() noexcept -> result
  {
    return SDL_HapticStopAll(m_haptic) == 0;
  }

  /**
   * \brief Destroys the effect associated with the specified ID.
   *
   * \note This is done automatically when the device is destructed.
   *
   * \details The effect will be destroyed will be stopped if it is running by the time
   * this function is invoked.
   *
   * \param id the ID associated with the effect that will be destroyed.
   *
   * \since 5.2.0
   */
  void destroy(const effect_id id) noexcept
  {
    SDL_HapticDestroyEffect(m_haptic, id);
  }

  /**
   * \brief Sets the gain the is used.
   *
   * \pre The device must support the `gain` feature.
   * \pre `gain` must be greater or equal to zero.
   * \pre `gain` must be less than or equal to zero.
   *
   * \param gain the gain that will be used, in the interval [0, 100].
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto set_gain(const int gain) noexcept -> result
  {
    assert(has_feature_gain());
    assert(gain >= 0);
    assert(gain <= 100);
    return SDL_HapticSetGain(m_haptic, gain) == 0;
  }

  /**
   * \brief Sets the autocenter value that will be used.
   *
   * \pre The device must support the `autocenter` feature.
   * \pre `autocenter` must be greater or equal to zero.
   * \pre `autocenter` must be less than or equal to zero.
   *
   * \param autocenter the value of the autocenter that will be used, in the interval [0,
   * 100]. Autocentering will be disabled if this value is zero.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto set_autocenter(const int autocenter) noexcept -> result
  {
    assert(has_feature_autocenter());
    assert(autocenter >= 0);
    assert(autocenter <= 100);
    return SDL_HapticSetAutocenter(m_haptic, autocenter) == 0;
  }

  /**
   * \brief Indicates whether or not the device can run the specified effect.
   *
   * \param effect the effect that will be checked.
   *
   * \return `true` if the device supports the effect; `false` otherwise.
   *
   * \since 5.2.0
   */
  template <typename D>
  [[nodiscard]] auto is_supported(const haptic_effect<D>& effect) const noexcept -> bool
  {
    auto internal = effect.get();
    return SDL_HapticEffectSupported(m_haptic, &internal) == SDL_TRUE;
  }

  /**
   * \brief Indicates whether or not the specified effect is playing on the device.
   *
   * \pre The device must support the `status` feature.
   *
   * \return `true` on if the effect is playing on the device; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto is_playing(const effect_id id) const noexcept -> bool
  {
    assert(has_feature_status());
    return SDL_HapticGetEffectStatus(m_haptic, id) == 1;
  }

  /// \}

  /// \name Feature checks
  /// \{

  /**
   * \brief Indicates whether or not the device supports the specified feature.
   *
   * \param feature the haptic feature to be checked.
   *
   * \return `true` if the feature is supported; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_feature(const haptic_feature feature) const noexcept -> bool
  {
    return has_feature(to_underlying(feature));
  }

  /**
   * \brief Indicates whether or not the device has the `constant` feature.
   *
   * \note This is a convenience function that calls `has_feature()`.
   *
   * \return `true` if the device has the feature; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_feature_constant() const noexcept -> bool
  {
    return has_feature(haptic_feature::constant);
  }

  /**
   * \brief Indicates whether or not the device has the `sine` feature.
   *
   * \note This is a convenience function that calls `has_feature()`.
   *
   * \return `true` if the device has the feature; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_feature_sine() const noexcept -> bool
  {
    return has_feature(haptic_feature::sine);
  }

  /**
   * \brief Indicates whether or not the device has the `left_right` feature.
   *
   * \note This is a convenience function that calls `has_feature()`.
   *
   * \return `true` if the device has the feature; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_feature_left_right() const noexcept -> bool
  {
    return has_feature(haptic_feature::left_right);
  }

  /**
   * \brief Indicates whether or not the device has the `triangle` feature.
   *
   * \note This is a convenience function that calls `has_feature()`.
   *
   * \return `true` if the device has the feature; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_feature_triangle() const noexcept -> bool
  {
    return has_feature(haptic_feature::triangle);
  }

  /**
   * \brief Indicates whether or not the device has the `sawtooth_up` feature.
   *
   * \note This is a convenience function that calls `has_feature()`.
   *
   * \return `true` if the device has the feature; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_feature_sawtooth_up() const noexcept -> bool
  {
    return has_feature(haptic_feature::sawtooth_up);
  }

  /**
   * \brief Indicates whether or not the device has the `sawtooth_down` feature.
   *
   * \note This is a convenience function that calls `has_feature()`.
   *
   * \return `true` if the device has the feature; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_feature_sawtooth_down() const noexcept -> bool
  {
    return has_feature(haptic_feature::sawtooth_down);
  }

  /**
   * \brief Indicates whether or not the device has the `ramp` feature.
   *
   * \note This is a convenience function that calls `has_feature()`.
   *
   * \return `true` if the device has the feature; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_feature_ramp() const noexcept -> bool
  {
    return has_feature(haptic_feature::ramp);
  }

  /**
   * \brief Indicates whether or not the device has the `spring` feature.
   *
   * \note This is a convenience function that calls `has_feature()`.
   *
   * \return `true` if the device has the feature; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_feature_spring() const noexcept -> bool
  {
    return has_feature(haptic_feature::spring);
  }

  /**
   * \brief Indicates whether or not the device has the `damper` feature.
   *
   * \note This is a convenience function that calls `has_feature()`.
   *
   * \return `true` if the device has the feature; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_feature_damper() const noexcept -> bool
  {
    return has_feature(haptic_feature::damper);
  }

  /**
   * \brief Indicates whether or not the device has the `inertia` feature.
   *
   * \note This is a convenience function that calls `has_feature()`.
   *
   * \return `true` if the device has the feature; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_feature_inertia() const noexcept -> bool
  {
    return has_feature(haptic_feature::inertia);
  }

  /**
   * \brief Indicates whether or not the device has the `friction` feature.
   *
   * \note This is a convenience function that calls `has_feature()`.
   *
   * \return `true` if the device has the feature; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_feature_friction() const noexcept -> bool
  {
    return has_feature(haptic_feature::friction);
  }

  /**
   * \brief Indicates whether or not the device has the `gain` feature.
   *
   * \note This is a convenience function that calls `has_feature()`.
   *
   * \return `true` if the device has the feature; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_feature_gain() const noexcept -> bool
  {
    return has_feature(haptic_feature::gain);
  }

  /**
   * \brief Indicates whether or not the device has the `autocenter` feature.
   *
   * \note This is a convenience function that calls `has_feature()`.
   *
   * \return `true` if the device has the feature; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_feature_autocenter() const noexcept -> bool
  {
    return has_feature(haptic_feature::autocenter);
  }

  /**
   * \brief Indicates whether or not the device has the `status` feature.
   *
   * \note This is a convenience function that calls `has_feature()`.
   *
   * \return `true` if the device has the feature; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_feature_status() const noexcept -> bool
  {
    return has_feature(haptic_feature::status);
  }

  /**
   * \brief Indicates whether or not the device has the `pause` feature.
   *
   * \note This is a convenience function that calls `has_feature()`.
   *
   * \return `true` if the device has the feature; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_feature_pause() const noexcept -> bool
  {
    return has_feature(haptic_feature::pause);
  }

  /**
   * \brief Indicates whether or not the device has the `custom` feature.
   *
   * \note This is a convenience function that calls `has_feature()`.
   *
   * \return `true` if the device has the feature; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_feature_custom() const noexcept -> bool
  {
    return has_feature(haptic_feature::custom);
  }

  /// \} End of feature queries

  /// \name Device information
  /// \{

  /**
   * \brief Returns the index associated with the haptic device.
   *
   * \return the index associated with the haptic device; `std::nullopt` if something goes
   * wrong.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto index() const noexcept -> std::optional<int>
  {
    const auto res = SDL_HapticIndex(m_haptic);
    if (res != -1) {
      return res;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Attempts to return the name associated with the haptic device.
   *
   * \return the name associated with the haptic device; a null pointer is returned if no
   * name was found.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto name() const noexcept -> str
  {
    if (const auto i = index()) {
      return SDL_HapticName(*i);
    }
    else {
      return nullptr;
    }
  }

  /**
   * \brief Returns the maximum amount of effect the device can store.
   *
   * \note This function isn't supported on all platforms and the returned value should be
   * treated as an approximation.
   *
   * \return the maximum number of effects the the haptic device can store; `std::nullopt`
   * if something goes wrong.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto effect_capacity() const noexcept -> std::optional<int>
  {
    const auto capacity = SDL_HapticNumEffects(m_haptic);
    if (capacity != -1) {
      return capacity;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the maximum amount of effects that can be played simultaneously.
   *
   * \note This function isn't supported on all platforms.
   *
   * \return the maximum number of effects that can be playing simultaneously;
   * `std::nullopt` if something goes wrong.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto concurrent_capacity() const noexcept -> std::optional<int>
  {
    const auto capacity = SDL_HapticNumEffectsPlaying(m_haptic);
    if (capacity != -1) {
      return capacity;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the number of axes that the haptic device has.
   *
   * \return the number of axes that the haptic device has.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto axis_count() const noexcept -> int
  {
    return SDL_HapticNumAxes(m_haptic);
  }

  /// \} End of device information

  /**
   * \brief Returns the number of available haptic devices.
   *
   * \return the amount of available haptic devices.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto count() noexcept -> int
  {
    return SDL_NumHaptics();
  }

  /**
   * \brief Indicates whether or not a joystick has haptic capabilities.
   *
   * \param joystick the joystick that will be checked.
   *
   * \return `true` if the joystick has haptic capabilities; `false` otherwise.
   *
   * \since 5.2.0
   */
  template <typename U>
  [[nodiscard]] static auto is_joystick_haptic(const basic_joystick<U>& joystick) noexcept
      -> bool
  {
    return SDL_JoystickIsHaptic(joystick.get()) == SDL_TRUE;
  }

  /**
   * \brief Indicates whether or not the system mouse has haptic capabilities.
   *
   * \return `true` if the mouse has haptic capabilities; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto is_mouse_haptic() noexcept -> bool
  {
    return SDL_MouseIsHaptic();
  }

  /**
   * \brief Indicates whether or not a haptic device at a specified index has
   * been opened.
   *
   * \param index the index of the haptic device that will be queried.
   *
   * \return `true` if the haptic device has been opened; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto is_opened(const int index) noexcept -> bool
  {
    return SDL_HapticOpened(index);
  }

  /**
   * \brief Indicates whether or not the handle holds a non-null pointer.
   *
   * \return `true` if the handle holds a non-null pointer; `false` otherwise.
   *
   * \since 5.2.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit operator bool() const noexcept
  {
    return m_haptic != nullptr;
  }

  /**
   * \brief Returns a pointer to the internal representation.
   *
   * \warning Don't claim ownership of the returned pointer!
   *
   * \return a pointer to the internal representation.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_Haptic*
  {
    return m_haptic.get();
  }

 private:
  struct deleter final
  {
    void operator()(SDL_Haptic* haptic) noexcept
    {
      SDL_HapticClose(haptic);
    }
  };
  detail::pointer_manager<T, SDL_Haptic, deleter> m_haptic;

  /**
   * \brief Indicates whether or not the haptic device supports the specified features.
   *
   * \details The supplied value must be a masked subset of the following flags:
   *
   * \verbatim
       SDL_HAPTIC_CONSTANT
       SDL_HAPTIC_SINE
       SDL_HAPTIC_LEFTRIGHT
       SDL_HAPTIC_LEFTRIGHT
       SDL_HAPTIC_TRIANGLE
       SDL_HAPTIC_SAWTOOTHUP
       SDL_HAPTIC_SAWTOOTHDOWN
       SDL_HAPTIC_RAMP
       SDL_HAPTIC_SPRING
       SDL_HAPTIC_DAMPER
       SDL_HAPTIC_INERTIA
       SDL_HAPTIC_FRICTION
       SDL_HAPTIC_CUSTOM
       SDL_HAPTIC_GAIN
       SDL_HAPTIC_AUTOCENTER
       SDL_HAPTIC_STATUS
       SDL_HAPTIC_PAUSE.
   * \endverbatim
   *
   * \param flag the mask of feature flags.
   *
   * \return `true` if the haptic device supports the features; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_feature(const uint flag) const noexcept -> bool
  {
    return flag & SDL_HapticQuery(m_haptic);
  }
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a haptic device.
 *
 * \param haptic the haptic device that will be converted.
 *
 * \return a string that represents a haptic device.
 *
 * \since 5.2.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_haptic<T>& haptic) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("haptic{{data: {}, name: {}}}",
                     detail::address_of(haptic.get()),
                     str_or_na(haptic.name()));
#else
  return "haptic{data: " + detail::address_of(haptic.get()) +
         ", name: " + str_or_na(haptic.name()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a haptic device using a stream.
 *
 * \param stream the stream that will be used.
 * \param haptic the haptic device that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.2.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_haptic<T>& haptic) -> std::ostream&
{
  return stream << to_string(haptic);
}

/// \} End of streaming

/// \} End of input group

}  // namespace cen

#endif  // CENTURION_HAPTIC_HEADER

// #include "centurion/input/haptic_condition.hpp"
#ifndef CENTURION_HAPTIC_CONDITION_HEADER
#define CENTURION_HAPTIC_CONDITION_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../core/to_underlying.hpp"

// #include "../math/vector3.hpp"

// #include "haptic_effect.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \class haptic_condition
 *
 * \brief Represents an axes-based haptic effect.
 *
 * \note See the SDL documentation for `SDL_HapticCondition` for detailed documentation.
 *
 * \see SDL_HapticCondition
 *
 * \since 5.2.0
 */
class haptic_condition final : public haptic_effect<haptic_condition>
{
 public:
  inline constexpr static bool hasDirection = false;
  inline constexpr static bool hasEnvelope = false;
  inline constexpr static bool hasTrigger = true;
  inline constexpr static bool hasDelay = true;

  /**
   * \enum condition_type
   *
   * \brief Provides values that serve as identifiers for the different kinds of
   * "condition" haptic effects.
   *
   * \since 5.2.0
   */
  enum condition_type : u32
  {
    spring = SDL_HAPTIC_SPRING,     ///< Based on axes position.
    damper = SDL_HAPTIC_DAMPER,     ///< Based on axes velocity.
    inertia = SDL_HAPTIC_INERTIA,   ///< Based on axes acceleration.
    friction = SDL_HAPTIC_FRICTION  ///< Based on axes movement.
  };

  /**
   * \brief Creates a haptic "condition" effect.
   *
   * \param type the type of the effect.
   *
   * \since 5.2.0
   */
  explicit haptic_condition(const condition_type type = spring) noexcept
  {
    m_effect.condition = {};
    set_type(type);
  }

  /**
   * \brief Sets the type of the effect.
   *
   * \param type the type of the effect.
   *
   * \since 5.2.0
   */
  void set_type(const condition_type type) noexcept
  {
    representation().type = static_cast<u16>(to_underlying(type));
  }

  /**
   * \brief Sets the effect level when the joystick is to the "positive" side.
   *
   * \param level the x-, y- and z-axis levels.
   *
   * \since 5.2.0
   */
  void set_joystick_positive_level(const vector3<u16>& level) noexcept
  {
    representation().right_sat[0] = level.x;
    representation().right_sat[1] = level.y;
    representation().right_sat[2] = level.z;
  }

  /**
   * \brief Sets the effect level when the joystick is to the "negative" side.
   *
   * \param level the x-, y- and z-axis levels.
   *
   * \since 5.2.0
   */
  void set_joystick_negative_level(const vector3<u16>& level) noexcept
  {
    representation().left_sat[0] = level.x;
    representation().left_sat[1] = level.y;
    representation().left_sat[2] = level.z;
  }

  /**
   * \brief Sets of quickly the force should increase towards the "positive"
   * side.
   *
   * \param rate the x-, y- and z-axis rates.
   *
   * \since 5.2.0
   */
  void set_force_rate_positive(const vector3<i16>& rate) noexcept
  {
    representation().right_coeff[0] = rate.x;
    representation().right_coeff[1] = rate.y;
    representation().right_coeff[2] = rate.z;
  }

  /**
   * \brief Sets of quickly the force should increase towards the "negative"
   * side.
   *
   * \param rate the x-, y- and z-axis rates.
   *
   * \since 5.2.0
   */
  void set_force_rate_negative(const vector3<i16>& rate) noexcept
  {
    representation().left_coeff[0] = rate.x;
    representation().left_coeff[1] = rate.y;
    representation().left_coeff[2] = rate.z;
  }

  /**
   * \brief Sets the size of the dead zone.
   *
   * \param size the x-, y- and z-axis sizes.
   *
   * \since 5.2.0
   */
  void set_deadband(const vector3<u16>& size) noexcept
  {
    representation().deadband[0] = size.x;
    representation().deadband[1] = size.y;
    representation().deadband[2] = size.z;
  }

  /**
   * \brief Sets the "center", i.e. the position of the dead zone.
   *
   * \param center the position of the dead zone.
   *
   * \since 5.2.0
   */
  void set_center(const vector3<i16>& center) noexcept
  {
    representation().center[0] = center.x;
    representation().center[1] = center.y;
    representation().center[2] = center.z;
  }

  /**
   * \brief Returns the effect level when the joystick is to the "positive"
   * side.
   *
   * \return the positive side effect level.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto joystick_positive_level() const noexcept -> vector3<u16>
  {
    const auto& level = representation().right_sat;
    return {level[0], level[1], level[2]};
  }

  /**
   * \brief Returns the effect level when the joystick is to the "negative"
   * side.
   *
   * \return the negative side effect level.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto joystick_negative_level() const noexcept -> vector3<u16>
  {
    const auto& level = representation().left_sat;
    return {level[0], level[1], level[2]};
  }

  /**
   * \brief Returns how fast the force increases towards to the "positive" side.
   *
   * \return the positive side force increase rate.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto force_rate_positive() const noexcept -> vector3<i16>
  {
    const auto& rate = representation().right_coeff;
    return {rate[0], rate[1], rate[2]};
  }

  /**
   * \brief Returns how fast the force increases towards to the "negative" side.
   *
   * \return the negative side force increase rate.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto force_rate_negative() const noexcept -> vector3<i16>
  {
    const auto& rate = representation().left_coeff;
    return {rate[0], rate[1], rate[2]};
  }

  /**
   * \brief Returns the size of the dead zone.
   *
   * \return the size of the dead zone.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto deadband() const noexcept -> vector3<u16>
  {
    const auto& band = representation().deadband;
    return {band[0], band[1], band[2]};
  }

  /**
   * \brief Returns the position of the dead zone.
   *
   * \return the position of the dead zone.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto center() const noexcept -> vector3<i16>
  {
    const auto& center = representation().center;
    return {center[0], center[1], center[2]};
  }

  /**
   * \brief Returns the internal representation.
   *
   * \return the internal representation.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto representation() noexcept -> SDL_HapticCondition&
  {
    return m_effect.condition;
  }

  /**
   * \copydoc representation();
   */
  [[nodiscard]] auto representation() const noexcept -> const SDL_HapticCondition&
  {
    return m_effect.condition;
  }
};

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_HAPTIC_CONDITION_HEADER

// #include "centurion/input/haptic_constant.hpp"
#ifndef CENTURION_HAPTIC_CONSTANT_HEADER
#define CENTURION_HAPTIC_CONSTANT_HEADER

#include <SDL.h>

// #include "haptic_effect.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \class haptic_constant
 *
 * \brief Represents a haptic effect that applies a constant force in some direction.
 *
 * \note See the SDL documentation for `SDL_HapticConstant` for  more detailed
 * documentation.
 *
 * \see SDL_HapticConstant
 *
 * \since 5.2.0
 */
class haptic_constant final : public haptic_effect<haptic_constant>
{
 public:
  inline constexpr static bool hasDirection = true;
  inline constexpr static bool hasEnvelope = true;
  inline constexpr static bool hasTrigger = true;
  inline constexpr static bool hasDelay = true;

  /**
   * \brief Creates a constant haptic effect.
   *
   * \since 5.2.0
   */
  haptic_constant() noexcept
  {
    m_effect.constant = {};
    representation().type = SDL_HAPTIC_CONSTANT;
  }

  /**
   * \brief Returns the internal representation.
   *
   * \return the internal representation.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto representation() noexcept -> SDL_HapticConstant&
  {
    return m_effect.constant;
  }

  /**
   * \copydoc representation();
   */
  [[nodiscard]] auto representation() const noexcept -> const SDL_HapticConstant&
  {
    return m_effect.constant;
  }
};

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_HAPTIC_CONSTANT_HEADER

// #include "centurion/input/haptic_custom.hpp"
#ifndef CENTURION_HAPTIC_CUSTOM_HEADER
#define CENTURION_HAPTIC_CUSTOM_HEADER

#include <SDL.h>

#include <cassert>  // assert

// #include "../core/integers.hpp"

// #include "../core/time.hpp"

// #include "../detail/max.hpp"
#ifndef CENTURION_DETAIL_MAX_HEADER
#define CENTURION_DETAIL_MAX_HEADER

/// \cond FALSE
namespace cen::detail {

template <typename T>
[[nodiscard]] constexpr auto max(const T& a, const T& b) noexcept(noexcept(a < b)) -> T
{
  return (a < b) ? b : a;
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_MAX_HEADER

// #include "haptic_effect.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \class haptic_custom
 *
 * \brief Represents a custom haptic effect, similar to a periodic effect.
 *
 * \note See the SDL documentation for `SDL_HapticCustom` for detailed documentation.
 *
 * \see SDL_HapticCustom
 *
 * \since 5.2.0
 */
class haptic_custom final : public haptic_effect<haptic_custom>
{
 public:
  inline constexpr static bool hasDirection = true;
  inline constexpr static bool hasEnvelope = true;
  inline constexpr static bool hasTrigger = true;
  inline constexpr static bool hasDelay = true;

  /**
   * \brief Creates a haptic custom effect.
   *
   * \since 5.2.0
   */
  haptic_custom() noexcept
  {
    m_effect.custom = {};
    representation().type = SDL_HAPTIC_CUSTOM;
  }

  /**
   * \brief Sets the number of axes that are used.
   *
   * \pre `count` must be greater than zero.
   *
   * \param count the number of axes that will be used.
   *
   * \since 5.2.0
   */
  void set_axis_count(const u8 count) noexcept
  {
    assert(count > 0);
    representation().channels = detail::max(u8{1}, count);
  }

  // clang-format off

  /**
   * \brief Sets the duration of the sample periods.
   *
   * \param period duration of sample periods.
   *
   * \since 5.2.0
   */
  void set_sample_period(const milliseconds<u16> period) noexcept(noexcept(period.count()))
  {
    representation().period = period.count();
  }

  // clang-format on

  /**
   * \brief Sets the number of samples.
   *
   * \param count the number of samples.
   *
   * \since 5.2.0
   */
  void set_sample_count(const u16 count) noexcept
  {
    representation().samples = count;
  }

  /**
   * \brief Sets the associated custom data.
   *
   * \note The data must be allocated and managed by you.
   *
   * \details The data should consist of `sample_count() * axis_count()` sample items.
   *
   * \param data a pointer to the custom sample data.
   *
   * \since 5.2.0
   */
  void set_data(u16* data) noexcept
  {
    representation().data = data;
  }

  /**
   * \brief Returns the number of axes that are used.
   *
   * \return the number of used axes.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto axis_count() const noexcept -> u8
  {
    return representation().channels;
  }

  /**
   * \brief Returns the duration of samples.
   *
   * \return the duration of samples.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto sample_period() const -> milliseconds<u16>
  {
    return milliseconds<u16>{representation().period};
  }

  /**
   * \brief Returns the number of samples.
   *
   * \return the number of samples.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto sample_count() const noexcept -> u16
  {
    return representation().samples;
  }

  /**
   * \brief Returns a pointer to user-provided data.
   *
   * \return a pointer to custom user-provided data, might be null.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto data() const noexcept -> u16*
  {
    return representation().data;
  }

  /**
   * \brief Returns the internal representation.
   *
   * \return the internal representation.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto representation() noexcept -> SDL_HapticCustom&
  {
    return m_effect.custom;
  }

  /// \copydoc representation()
  [[nodiscard]] auto representation() const noexcept -> const SDL_HapticCustom&
  {
    return m_effect.custom;
  }
};

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_HAPTIC_CUSTOM_HEADER

// #include "centurion/input/haptic_direction.hpp"
#ifndef CENTURION_HAPTIC_DIRECTION_HEADER
#define CENTURION_HAPTIC_DIRECTION_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../core/to_underlying.hpp"

// #include "../math/vector3.hpp"

// #include "haptic_direction_type.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \class haptic_direction
 *
 * \brief Represents a haptic direction, used by haptic effects.
 *
 * \since 5.2.0
 */
class haptic_direction final
{
 public:
  using direction_type = vector3<i32>;

  /**
   * \brief Creates a haptic direction of the specified type.
   *
   * \param type the type of the direction.
   *
   * \since 5.2.0
   */
  explicit haptic_direction(const haptic_direction_type type) noexcept
  {
    set_type(type);
  }

  /**
   * \brief Creates a haptic direction based on an `SDL_HapticDirection` instance.
   *
   * \param direction the direction that will be copied.
   *
   * \since 5.2.0
   */
  explicit haptic_direction(const SDL_HapticDirection& direction) noexcept
      : m_direction{direction}
  {}

  /**
   * \brief Sets the type of the direction.
   *
   * \param type the new type of the direction.
   *
   * \since 5.2.0
   */
  void set_type(const haptic_direction_type type) noexcept
  {
    m_direction.type = to_underlying(type);
  }

  /**
   * \brief Sets the value of direction.
   *
   * \param direction the new value of the direction.
   *
   * \since 5.2.0
   */
  void set_value(const direction_type& direction) noexcept
  {
    m_direction.dir[0] = direction.x;
    m_direction.dir[1] = direction.y;
    m_direction.dir[2] = direction.z;
  }

  /**
   * \brief Returns the type associated with the direction.
   *
   * \return the current type of the direction.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto type() const noexcept -> haptic_direction_type
  {
    return static_cast<haptic_direction_type>(m_direction.type);
  }

  /**
   * \brief Returns the value of the direction.
   *
   * \return the current value of the direction.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto value() const noexcept -> direction_type
  {
    return {m_direction.dir[0], m_direction.dir[1], m_direction.dir[2]};
  }

  /**
   * \brief Returns the internal representation of the direction.
   *
   * \return the internal representation.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto get() const noexcept -> const SDL_HapticDirection&
  {
    return m_direction;
  }

 private:
  SDL_HapticDirection m_direction{};
};

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_HAPTIC_DIRECTION_HEADER

// #include "centurion/input/haptic_direction_type.hpp"
#ifndef CENTURION_HAPTIC_DIRECTION_TYPE_HEADER
#define CENTURION_HAPTIC_DIRECTION_TYPE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum haptic_direction_type
 *
 * \brief Represents the different types of haptic directions.
 *
 * \since 5.2.0
 */
enum class haptic_direction_type : u8
{
  polar = SDL_HAPTIC_POLAR,
  cartesian = SDL_HAPTIC_CARTESIAN,
  spherical = SDL_HAPTIC_SPHERICAL
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied haptic direction type.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(haptic_direction_type::polar) == "polar"`.
 *
 * \param type the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const haptic_direction_type type) -> std::string_view
{
  switch (type) {
    case haptic_direction_type::polar:
      return "polar";

    case haptic_direction_type::cartesian:
      return "cartesian";

    case haptic_direction_type::spherical:
      return "spherical";

    default:
      throw cen_error{"Did not recognize haptic direction type!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a haptic direction type enumerator.
 *
 * \param stream the output stream that will be used.
 * \param type the enumerator that will be printed.
 *
 * \see `to_string(haptic_direction_type)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const haptic_direction_type type) -> std::ostream&
{
  return stream << to_string(type);
}

/// \} End of streaming

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_HAPTIC_DIRECTION_TYPE_HEADER

// #include "centurion/input/haptic_effect.hpp"
#ifndef CENTURION_HAPTIC_EFFECT_HEADER
#define CENTURION_HAPTIC_EFFECT_HEADER

#include <SDL.h>

#include <type_traits>  // enable_if_t

// #include "../core/integers.hpp"

// #include "../core/time.hpp"

// #include "haptic_direction.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \brief A constant that can be used to play an effect indefinitely.
 *
 * \since 5.2.0
 */
inline constexpr u32 haptic_infinity = SDL_HAPTIC_INFINITY;

/**
 * \class haptic_effect
 *
 * \brief Represents a haptic effect.
 *
 * \details The following is an illustration of the different stages of a haptic effect,
 * copied from the SDL documentation, albeit with tweaked terms.
 * \verbatim
    Strength
    ^
    |
    |    effect level -->  _________________
    |                     /                 \
    |                    /                   \
    |                   /                     \
    |                  /                       \
    | attack_level --> |                        \
    |                  |                        |  <---  fade_level
    |
    +--------------------------------------------------> Time
                       [--]                 [---]
                       attack_length        fade_length

    [------------------][-----------------------]
    delay               duration
    \endverbatim
 *
 * \tparam Derived the type of the subclass, for CRTP.
 *
 * \since 5.2.0
 */
template <typename Derived>
class haptic_effect
{
  template <typename T>
  using has_direction = std::enable_if_t<T::hasDirection, int>;

  template <typename T>
  using has_envelope = std::enable_if_t<T::hasEnvelope, int>;

  template <typename T>
  using has_trigger = std::enable_if_t<T::hasTrigger, int>;

  template <typename T>
  using has_delay = std::enable_if_t<T::hasDelay, int>;

 public:
  /// \name Direction functions
  /// \{

  /**
   * \brief Sets the haptic direction associated with the effect.
   *
   * \note This function is not available for all haptic effects.
   *
   * \param direction the new direction of the effect.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_direction<D> = 0>
  void set_direction(const haptic_direction& direction) noexcept
  {
    rep().direction = direction.get();
  }

  /**
   * \brief Returns the haptic direction associated with the effect.
   *
   * \return the current direction associated with the effect.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_direction<D> = 0>
  [[nodiscard]] auto direction() const noexcept -> haptic_direction
  {
    return haptic_direction{rep().direction};
  }

  /// \} End of direction functions

  /// \name Replay functions
  /// \{

  /**
   * \brief Sets the effect to be repeated indefinitely when run.
   *
   * \details This function makes the effect repeat forever when run, but the attack and
   * fade are not repeated.
   *
   * \since 5.2.0
   */
  void set_repeat_forever() noexcept
  {
    rep().length = haptic_infinity;
  }

  /**
   * \brief Sets the duration of the effect.
   *
   * \param duration the duration of the effect.
   *
   * \since 5.2.0
   */
  void set_duration(const milliseconds<u32> duration) noexcept(noexcept(duration.count()))
  {
    rep().length = duration.count();
  }

  /**
   * \brief Sets the delay before before the effect is started.
   *
   * \note This function is not available for all haptic effects.
   *
   * \param delay the delay before before the effect is started.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_delay<D> = 0>
  void set_delay(const milliseconds<u16> delay) noexcept(noexcept(delay.count()))
  {
    rep().delay = delay.count();
  }

  /**
   * \brief Returns the duration of the effect.
   *
   * \return the duration of the effect.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto duration() const -> milliseconds<u32>
  {
    return milliseconds<u32>{rep().length};
  }

  /**
   * \brief Returns the delay before before the effect is started.
   *
   * \note This function is not available for all haptic effects.
   *
   * \return the delay before before the effect is started.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_delay<D> = 0>
  [[nodiscard]] auto delay() const -> milliseconds<u16>
  {
    return milliseconds<u16>{rep().delay};
  }

  /// \} End of replay functions

  /// \name Trigger functions
  /// \{

  /**
   * \brief Sets the button that triggers the effect.
   *
   * \note This function is not available for all haptic effects.
   *
   * \param button the button that triggers the effect.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_trigger<D> = 0>
  void set_button(const u16 button) noexcept
  {
    rep().button = button;
  }

  /**
   * \brief Sets the minimum interval in between activations of the effect.
   *
   * \note This function is not available for all haptic effects.
   *
   * \param interval the minimum interval in between activations of the effect.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_trigger<D> = 0>
  void set_interval(const milliseconds<u16> interval) noexcept(noexcept(interval.count()))
  {
    rep().interval = interval.count();
  }

  /**
   * \brief Returns the button that triggers the effect.
   *
   * \note This function is not available for all haptic effects.
   *
   * \return the button that triggers the effect.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_trigger<D> = 0>
  [[nodiscard]] auto button() const noexcept -> u16
  {
    return rep().button;
  }

  /**
   * \brief Returns the minimum interval in between activations of the effect.
   *
   * \note This function is not available for all haptic effects.
   *
   * \return the minimum interval in between activations of the effect.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_trigger<D> = 0>
  [[nodiscard]] auto interval() const -> milliseconds<u16>
  {
    return milliseconds<u16>{rep().interval};
  }

  /// \} End of trigger functions

  /// \name Envelope functions
  /// \{

  /**
   * \brief Sets the level at the *start* of the attack.
   *
   * \note This function is not available for all haptic effects.
   *
   * \param level the level at the start of the attack.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_envelope<D> = 0>
  void set_attack_level(const u16 level) noexcept
  {
    rep().attack_level = level;
  }

  /**
   * \brief Sets the level at the *end* of the fade out.
   *
   * \note This function is not available for all haptic effects.
   *
   * \param level the level at the *end* of the fade out.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_envelope<D> = 0>
  void set_fade_level(const u16 level) noexcept
  {
    rep().fade_level = level;
  }

  // clang-format off

  /**
   * \brief Sets the duration of the attack.
   *
   * \note This function is not available for all haptic effects.
   *
   * \param duration the duration of the attack.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_envelope<D> = 0>
  void set_attack_duration(const milliseconds<u16> duration) noexcept(noexcept(duration.count()))
  {
    rep().attack_length = duration.count();
  }

  /**
   * \brief Sets the duration of the fade out.
   *
   * \note This function is not available for all haptic effects.
   *
   * \param duration the duration of the fade out.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_envelope<D> = 0>
  void set_fade_duration(const milliseconds<u16> duration) noexcept(noexcept(duration.count()))
  {
    rep().fade_length = duration.count();
  }

  // clang-format on

  /**
   * \brief Returns the level at the *start* of the attack.
   *
   * \note This function is not available for all haptic effects.
   *
   * \return the the level at the *start* of the attack.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_envelope<D> = 0>
  [[nodiscard]] auto attack_level() const noexcept -> u16
  {
    return rep().attack_level;
  }

  /**
   * \brief Returns the level at the *end* of the fade.
   *
   * \note This function is not available for all haptic effects.
   *
   * \return the level at the *end* of the fade.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_envelope<D> = 0>
  [[nodiscard]] auto fade_level() const noexcept -> u16
  {
    return rep().fade_level;
  }

  /**
   * \brief Returns the duration of the attack.
   *
   * \note This function is not available for all haptic effects.
   *
   * \return the duration of the attack.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_envelope<D> = 0>
  [[nodiscard]] auto attack_duration() const -> milliseconds<u16>
  {
    return milliseconds<u16>{rep().attack_length};
  }

  /**
   * \brief Returns the duration of the fade out.
   *
   * \note This function is not available for all haptic effects.
   *
   * \return the duration of the fade out.
   *
   * \since 5.2.0
   */
  template <typename D = Derived, has_envelope<D> = 0>
  [[nodiscard]] auto fade_duration() const -> milliseconds<u16>
  {
    return milliseconds<u16>{rep().fade_length};
  }

  /// \} End of envelope functions

  /**
   * \brief Returns the type associated with the haptic effect.
   *
   * \return the associated effect type.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto type() const noexcept -> u16
  {
    return rep().type;
  }

  /**
   * \brief Returns the internal effect representation.
   *
   * \return the internal effect representation.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto get() noexcept -> SDL_HapticEffect&
  {
    return m_effect;
  }

  /**
   * \copydoc get()
   */
  [[nodiscard]] auto get() const noexcept -> const SDL_HapticEffect&
  {
    return m_effect;
  }

 protected:
  SDL_HapticEffect m_effect{};

 private:
  [[nodiscard]] auto derived() noexcept -> Derived*
  {
    return static_cast<Derived*>(this);
  }

  [[nodiscard]] auto derived() const noexcept -> const Derived*
  {
    return static_cast<const Derived*>(this);
  }

  [[nodiscard]] auto rep() noexcept -> auto&
  {
    return derived()->representation();
  }

  [[nodiscard]] auto rep() const noexcept -> const auto&
  {
    return derived()->representation();
  }
};

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_HAPTIC_EFFECT_HEADER

// #include "centurion/input/haptic_feature.hpp"
#ifndef CENTURION_HAPTIC_FEATURE_HEADER
#define CENTURION_HAPTIC_FEATURE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum haptic_feature
 *
 * \brief Provides values that represent all of the haptic features.
 *
 * \since 5.2.0
 */
enum class haptic_feature : uint
{
  constant = SDL_HAPTIC_CONSTANT,
  sine = SDL_HAPTIC_SINE,
  left_right = SDL_HAPTIC_LEFTRIGHT,
  triangle = SDL_HAPTIC_TRIANGLE,
  sawtooth_up = SDL_HAPTIC_SAWTOOTHUP,
  sawtooth_down = SDL_HAPTIC_SAWTOOTHDOWN,
  ramp = SDL_HAPTIC_RAMP,
  spring = SDL_HAPTIC_SPRING,
  damper = SDL_HAPTIC_DAMPER,
  inertia = SDL_HAPTIC_INERTIA,
  friction = SDL_HAPTIC_FRICTION,
  custom = SDL_HAPTIC_CUSTOM,
  gain = SDL_HAPTIC_GAIN,
  autocenter = SDL_HAPTIC_AUTOCENTER,
  status = SDL_HAPTIC_STATUS,
  pause = SDL_HAPTIC_PAUSE
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied haptic feature.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(haptic_feature::spring) == "spring"`.
 *
 * \param feature the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const haptic_feature feature) -> std::string_view
{
  switch (feature) {
    case haptic_feature::constant:
      return "constant";

    case haptic_feature::sine:
      return "sine";

    case haptic_feature::left_right:
      return "left_right";

    case haptic_feature::triangle:
      return "triangle";

    case haptic_feature::sawtooth_up:
      return "sawtooth_up";

    case haptic_feature::sawtooth_down:
      return "sawtooth_down";

    case haptic_feature::ramp:
      return "ramp";

    case haptic_feature::spring:
      return "spring";

    case haptic_feature::damper:
      return "damper";

    case haptic_feature::inertia:
      return "inertia";

    case haptic_feature::friction:
      return "friction";

    case haptic_feature::custom:
      return "custom";

    case haptic_feature::gain:
      return "gain";

    case haptic_feature::autocenter:
      return "autocenter";

    case haptic_feature::status:
      return "status";

    case haptic_feature::pause:
      return "pause";

    default:
      throw cen_error{"Did not recognize haptic feature!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a haptic feature enumerator.
 *
 * \param stream the output stream that will be used.
 * \param feature the enumerator that will be printed.
 *
 * \see `to_string(haptic_feature)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const haptic_feature feature) -> std::ostream&
{
  return stream << to_string(feature);
}

/// \} End of streaming

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_HAPTIC_FEATURE_HEADER

// #include "centurion/input/haptic_left_right.hpp"
#ifndef CENTURION_HAPTIC_LEFT_RIGHT_HEADER
#define CENTURION_HAPTIC_LEFT_RIGHT_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "haptic_effect.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \class haptic_left_right
 *
 * \brief Represents a haptic effect based on controlling the large and small
 * motors featured in many modern game controllers.
 *
 * \note See the SDL documentation for `SDL_HapticLeftRight` for detailed documentation.
 *
 * \see SDL_HapticLeftRight
 *
 * \since 5.2.0
 */
class haptic_left_right final : public haptic_effect<haptic_left_right>
{
 public:
  inline constexpr static bool hasDirection = false;
  inline constexpr static bool hasEnvelope = false;
  inline constexpr static bool hasTrigger = false;
  inline constexpr static bool hasDelay = false;

  /**
   * \brief Creates a "left/right" haptic effect.
   *
   * \since 5.2.0
   */
  haptic_left_right() noexcept
  {
    m_effect.leftright = {};
    representation().type = SDL_HAPTIC_LEFTRIGHT;
  }

  /**
   * \brief Sets the magnitude of the large (low frequency) controller motor.
   *
   * \param magnitude the magnitude of the large motor.
   *
   * \since 5.2.0
   */
  void set_large_magnitude(const u16 magnitude) noexcept
  {
    representation().large_magnitude = magnitude;
  }

  /**
   * \brief Sets the magnitude of the small (high frequency) controller motor.
   *
   * \param magnitude the magnitude of the small motor.
   *
   * \since 5.2.0
   */
  void set_small_magnitude(const u16 magnitude) noexcept
  {
    representation().small_magnitude = magnitude;
  }

  /**
   * \brief Returns the magnitude of the large (low frequency) controller motor.
   *
   * \return the magnitude of the large motor.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto large_magnitude() const noexcept -> u16
  {
    return representation().large_magnitude;
  }

  /**
   * \brief Returns the magnitude of the small (high frequency) controller
   * motor.
   *
   * \return the magnitude of the small motor.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto small_magnitude() const noexcept -> u16
  {
    return representation().small_magnitude;
  }

  /**
   * \brief Returns the internal representation.
   *
   * \return the internal representation.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto representation() noexcept -> SDL_HapticLeftRight&
  {
    return m_effect.leftright;
  }

  /**
   * \copydoc representation();
   */
  [[nodiscard]] auto representation() const noexcept -> const SDL_HapticLeftRight&
  {
    return m_effect.leftright;
  }
};

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_HAPTIC_LEFT_RIGHT_HEADER

// #include "centurion/input/haptic_periodic.hpp"
#ifndef CENTURION_HAPTIC_PERIODIC_HEADER
#define CENTURION_HAPTIC_PERIODIC_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "../core/time.hpp"

// #include "../core/to_underlying.hpp"

// #include "haptic_effect.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \class haptic_periodic
 *
 * \brief Represents a wave-shaped haptic effect that repeats itself over time.
 *
 * \note See the SDL documentation for `SDL_HapticPeriodic` for detailed documentation.
 *
 * \see SDL_HapticPeriodic
 *
 * \since 5.2.0
 */
class haptic_periodic final : public haptic_effect<haptic_periodic>
{
 public:
  inline constexpr static bool hasDirection = true;
  inline constexpr static bool hasEnvelope = true;
  inline constexpr static bool hasTrigger = true;
  inline constexpr static bool hasDelay = true;

  /**
   * \enum periodic_type
   *
   * \brief Provides values that serve as identifiers for the different kinds of
   * "periodic" haptic effects.
   *
   * \since 5.2.0
   */
  enum periodic_type : u16
  {
    sine = SDL_HAPTIC_SINE,
    left_right = SDL_HAPTIC_LEFTRIGHT,
    triangle = SDL_HAPTIC_TRIANGLE,
    sawtooth_up = SDL_HAPTIC_SAWTOOTHUP,
    sawtooth_down = SDL_HAPTIC_SAWTOOTHDOWN
  };

  /**
   * \brief Creates a periodic haptic effect.
   *
   * \since 5.2.0
   */
  explicit haptic_periodic(const periodic_type type = sine) noexcept
  {
    m_effect.periodic = {};
    set_type(type);
  }

  /**
   * \brief Sets the type of the effect.
   *
   * \param type the periodic effect type.
   *
   * \since 5.2.0
   */
  void set_type(const periodic_type type) noexcept
  {
    representation().type = to_underlying(type);
  }

  /**
   * \brief Sets the period of the wave.
   *
   * \param period the period duration of the wave.
   *
   * \since 5.2.0
   */
  void set_period(const milliseconds<u16> period) noexcept(noexcept(period.count()))
  {
    representation().period = period.count();
  }

  /**
   * \brief Sets the magnitude (peak value) of the wave.
   *
   * \note If the supplied magnitude is negative, that is interpreted as an extra phase
   * shift of 180 degrees.
   *
   * \param magnitude the magnitude of the wave, can be negative.
   *
   * \since 5.2.0
   */
  void set_magnitude(const i16 magnitude) noexcept
  {
    representation().magnitude = magnitude;
  }

  /**
   * \brief Sets the mean value of the wave.
   *
   * \param mean the mean value of the wave.
   *
   * \since 5.2.0
   */
  void set_mean(const i16 mean) noexcept
  {
    representation().offset = mean;
  }

  /**
   * \brief Sets the phase shift.
   *
   * \param shift the positive phase shift, interpreted as hundredths of a degree.
   *
   * \since 5.2.0
   */
  void set_phase_shift(const u16 shift) noexcept
  {
    representation().phase = shift;
  }

  /**
   * \brief Returns the current period of the wave.
   *
   * \return the period of the wave.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto period() const -> milliseconds<u16>
  {
    return milliseconds<u16>{representation().period};
  }

  /**
   * \brief Returns the current magnitude (peak value) of the wave.
   *
   * \return the magnitude of the wave.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto magnitude() const noexcept -> i16
  {
    return representation().magnitude;
  }

  /**
   * \brief Returns the current mean value of the wave.
   *
   * \return the mean value of the wave.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto mean() const noexcept -> i16
  {
    return representation().offset;
  }

  /**
   * \brief Returns the current positive phase shift of the wave.
   *
   * \return the positive phase shift of the wave, in hundredths of a degree.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto phase_shift() const noexcept -> u16
  {
    return representation().phase;
  }

  /**
   * \brief Returns the internal representation.
   *
   * \return the internal representation.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto representation() noexcept -> SDL_HapticPeriodic&
  {
    return m_effect.periodic;
  }

  /// \copydoc representation();
  [[nodiscard]] auto representation() const noexcept -> const SDL_HapticPeriodic&
  {
    return m_effect.periodic;
  }
};

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_HAPTIC_PERIODIC_HEADER

// #include "centurion/input/haptic_ramp.hpp"
#ifndef CENTURION_HAPTIC_RAMP_HEADER
#define CENTURION_HAPTIC_RAMP_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"

// #include "haptic_effect.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \class haptic_ramp
 *
 * \brief Represents a linear or quadratic haptic effect.
 *
 * \note See the SDL documentation for `SDL_HapticRamp` for more detailed documentation.
 *
 * \see SDL_HapticRamp
 *
 * \since 5.2.0
 */
class haptic_ramp final : public haptic_effect<haptic_ramp>
{
 public:
  inline constexpr static bool hasDirection = true;
  inline constexpr static bool hasEnvelope = true;
  inline constexpr static bool hasTrigger = true;
  inline constexpr static bool hasDelay = true;

  /**
   * \brief Creates a haptic ramp effect.
   *
   * \since 5.2.0
   */
  haptic_ramp() noexcept
  {
    m_effect.ramp = {};
    representation().type = SDL_HAPTIC_RAMP;
  }

  /**
   * \brief Sets the initial strength level.
   *
   * \param start the initial strength level.
   *
   * \since 5.2.0
   */
  void set_start_strength(const i16 start) noexcept
  {
    representation().start = start;
  }

  /**
   * \brief Sets the strength level at the end of the effect.
   *
   * \param end the strength level at the end of the effect.
   *
   * \since 5.2.0
   */
  void set_end_strength(const i16 end) noexcept
  {
    representation().end = end;
  }

  /**
   * \brief Returns the initial strength level.
   *
   * \return the initial strength level.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto start_strength() const noexcept -> i16
  {
    return representation().start;
  }

  /**
   * \brief Returns the strength level at the end of the effect.
   *
   * \return the final strength level.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto end_strength() const noexcept -> i16
  {
    return representation().end;
  }

  /**
   * \brief Returns the internal representation.
   *
   * \return the internal representation.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto representation() noexcept -> SDL_HapticRamp&
  {
    return m_effect.ramp;
  }

  /// \copydoc representation();
  [[nodiscard]] auto representation() const noexcept -> const SDL_HapticRamp&
  {
    return m_effect.ramp;
  }
};

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_HAPTIC_RAMP_HEADER

// #include "centurion/input/hat_state.hpp"
#ifndef CENTURION_HAT_STATE_HEADER
#define CENTURION_HAT_STATE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum hat_state
 *
 * \brief Represents the various states of a joystick "hat".
 *
 * \since 4.2.0
 */
enum class hat_state : u8
{
  centered = SDL_HAT_CENTERED,     ///< The hat is centered.
  up = SDL_HAT_UP,                 ///< The hat is directed "north".
  right = SDL_HAT_RIGHT,           ///< The hat is directed "east".
  down = SDL_HAT_DOWN,             ///< The hat is directed "south".
  left = SDL_HAT_LEFT,             ///< The hat is directed "west".
  right_up = SDL_HAT_RIGHTUP,      ///< The hat is directed "north-east".
  right_down = SDL_HAT_RIGHTDOWN,  ///< The hat is directed "south-east".
  left_up = SDL_HAT_LEFTUP,        ///< The hat is directed "north-west".
  left_down = SDL_HAT_LEFTDOWN,    ///< The hat is directed "south-west".
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied hat state.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(hat_state::down) == "down"`.
 *
 * \param state the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const hat_state state) -> std::string_view
{
  switch (state) {
    case hat_state::centered:
      return "centered";

    case hat_state::up:
      return "up";

    case hat_state::right:
      return "right";

    case hat_state::down:
      return "down";

    case hat_state::left:
      return "left";

    case hat_state::right_up:
      return "right_up";

    case hat_state::right_down:
      return "right_down";

    case hat_state::left_up:
      return "left_up";

    case hat_state::left_down:
      return "left_down";

    default:
      throw cen_error{"Did not recognize hat state!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a hat state enumerator.
 *
 * \param stream the output stream that will be used.
 * \param state the enumerator that will be printed.
 *
 * \see `to_string(hat_state)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const hat_state state) -> std::ostream&
{
  return stream << to_string(state);
}

/// \} End of streaming

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_HAT_STATE_HEADER

// #include "centurion/input/joystick.hpp"
#ifndef CENTURION_JOYSTICK_HEADER
#define CENTURION_JOYSTICK_HEADER

#include <SDL.h>

#include <cassert>   // assert
#include <optional>  // optional
#include <ostream>   // ostream
#include <string>    // string, to_string

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/not_null.hpp"

// #include "../core/owner.hpp"

// #include "../core/result.hpp"

// #include "../core/str.hpp"

// #include "../core/str_or_na.hpp"

// #include "../core/time.hpp"

// #include "../core/to_underlying.hpp"

// #include "../detail/address_of.hpp"

// #include "../detail/owner_handle_api.hpp"

// #include "../detail/sdl_version_at_least.hpp"

// #include "../video/color.hpp"

// #include "button_state.hpp"

// #include "hat_state.hpp"

// #include "joystick_power.hpp"

// #include "joystick_type.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \struct ball_axis_change
 *
 * \brief Represents the difference in a joystick ball axis position.
 *
 * \since 4.2.0
 */
struct ball_axis_change final
{
  int dx;  ///< Difference in x-axis position since last poll.
  int dy;  ///< Difference in y-axis position since last poll.
};

template <typename T>
class basic_joystick;

/**
 * \typedef joystick
 *
 * \brief Represents an owning joystick.
 *
 * \since 5.0.0
 */
using joystick = basic_joystick<detail::owning_type>;

/**
 * \typedef joystick_handle
 *
 * \brief Represents a non-owning joystick.
 *
 * \since 5.0.0
 */
using joystick_handle = basic_joystick<detail::handle_type>;

/**
 * \class basic_joystick
 *
 * \brief Represents a joystick device.
 *
 * \ownerhandle `joystick`/`joystick_handle`
 *
 * \details The game controller API is built on top of the joystick API, which means that
 * the game controller is higher-level and easier to use.
 *
 * \since 4.2.0
 *
 * \see joystick
 * \see joystick_handle
 */
template <typename T>
class basic_joystick final
{
 public:
  /// \name Construction
  /// \{

  // clang-format off

  /**
   * \brief Creates a joystick instance based on an existing SDL joystick.
   *
   * \note The created instance will only claim ownership of the supplied pointer if the
   * class has owning semantics, i.e. if it's a `joystick` instance.
   *
   * \param joystick a pointer to the existing joystick.
   *
   * \throws cen_error if the supplied pointer is null and the joystick is owning.
   */
  explicit basic_joystick(maybe_owner<SDL_Joystick*> joystick) noexcept(!detail::is_owning<T>())
      : m_joystick{joystick}
  {
    if constexpr (detail::is_owning<T>())
    {
      if (!m_joystick)
      {
        throw cen_error{"Cannot create joystick from null pointer!"};
      }
    }
  }

  // clang-format on

  /**
   * \brief Creates an owning joystick based on a joystick device index.
   *
   * \param index the device index of the joystick.
   *
   * \throws sdl_error if the joystick couldn't be opened.
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_joystick(const int index = 0) : m_joystick{SDL_JoystickOpen(index)}
  {
    if (!m_joystick) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates a handle to an owning joystick.
   *
   * \param owner the owning joystick instance.
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit basic_joystick(const joystick& owner) noexcept : m_joystick{owner.get()}
  {}

  /**
   * \brief Returns a handle to the joystick associated with the specified ID.
   *
   * \param id the joystick ID associated with the desired joystick.
   *
   * \return a handle to the joystick associated with the supplied ID, might be empty.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  [[nodiscard]] static auto from_instance_id(const SDL_JoystickID id) noexcept
      -> joystick_handle
  {
    return joystick_handle{SDL_JoystickFromInstanceID(id)};
  }

#if SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Returns a handle to the joystick associated with the specified player index.
   *
   * \param playerIndex the player index of the desired joystick.
   *
   * \return a handle to the associated joystick, which might be empty.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  [[nodiscard]] static auto from_player_index(const int playerIndex) noexcept
      -> joystick_handle
  {
    return joystick_handle{SDL_JoystickFromPlayerIndex(playerIndex)};
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

  /// \} End of construction

  /**
   * \brief Makes the joystick rumble.
   *
   * \details Invoking this function cancels any previous rumble effects. This function
   * has no effect if the joystick doesn't support rumble effects.
   *
   * \param lowFreq the intensity of the low frequency (left) motor.
   * \param highFreq the intensity of the high frequency (right) motor.
   * \param duration the duration of the rumble effect, in milliseconds.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 4.2.0
   */
  auto rumble(const u16 lowFreq,
              const u16 highFreq,
              const milliseconds<u32> duration) noexcept(noexcept(duration.count())) -> result
  {
    return SDL_JoystickRumble(m_joystick, lowFreq, highFreq, duration.count()) == 0;
  }

#if SDL_VERSION_ATLEAST(2, 0, 14)

  // clang-format off

  /**
   * \brief Starts a rumble effect in the joystick's triggers.
   *
   * \details Calls to this function cancels any previously active rumble effect.
   * Furthermore, supplying 0 as intensities will stop the rumble effect.
   *
   * \param left the intensity used by the left rumble motor.
   * \param right the intensity used by the right rumble motor.
   * \param duration the duration of the rumble.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto rumble_triggers(const u16 left,
                       const u16 right,
                       const milliseconds<u32> duration) noexcept(noexcept(duration.count()))
      -> result
  {
    return SDL_JoystickRumbleTriggers(m_joystick,
                                      left,
                                      right,
                                      duration.count()) == 0;
  }

  // clang-format on

  /**
   * \brief Sets the color of the LED light, if the joystick has one.
   *
   * \param color the color that will be used by the LED, note that the alpha component is
   * ignored.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto set_led(const color& color) noexcept -> result
  {
    return SDL_JoystickSetLED(m_joystick, color.red(), color.green(), color.blue()) == 0;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

#if SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Sets the player index to be associated with the joystick.
   *
   * \param index the player index that will be used.
   *
   * \since 4.2.0
   */
  void set_player_index(const int index) noexcept
  {
    SDL_JoystickSetPlayerIndex(m_joystick, index);
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

#if SDL_VERSION_ATLEAST(2, 0, 16)

  /**
   * \brief Sends a packet of joystick specific data.
   *
   * \param data the data that will be sent.
   * \param size the size of the data.
   *
   * \return `success` if the data was sent successfully; `failure` if the joystick
   * or driver doesn't support effect packets.
   *
   * \since 6.2.0
   */
  auto send_effect(const void* data, const int size) -> result
  {
    return SDL_JoystickSendEffect(m_joystick, data, size) == 0;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 16)

  /// \name Virtual joystick API
  /// \{

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Attaches a new virtual joystick.
   *
   * \param type the type of the virtual joystick.
   * \param nAxes the number of axes.
   * \param nButtons the number of buttons.
   * \param nHats the number of joystick hats.
   *
   * \return the device index of the virtual joystick; `std::nullopt` if something went
   * wrong.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto attach_virtual(const joystick_type type,
                                           const int nAxes,
                                           const int nButtons,
                                           const int nHats) noexcept -> std::optional<int>
  {
    const auto index =
        SDL_JoystickAttachVirtual(static_cast<SDL_JoystickType>(type), nAxes, nButtons, nHats);
    if (index != -1) {
      return index;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Detaches a virtual joystick.
   *
   * \param index the device index of the virtual joystick.
   *
   * \return `success` if the joystick was successfully disconnected; `failure` otherwise.
   *
   * \since 5.2.0
   */
  static auto detach_virtual(const int index) noexcept -> result
  {
    return SDL_JoystickDetachVirtual(index) == 0;
  }

  /**
   * \brief Sets the value of a virtual joystick axis.
   *
   * \param axis the axis that will be modified.
   * \param value the new value of the axis.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto set_virtual_axis(const int axis, const i16 value) noexcept -> result
  {
    return SDL_JoystickSetVirtualAxis(m_joystick, axis, value) == 0;
  }

  /**
   * \brief Sets the state of a virtual button.
   *
   * \param button the index of the button that will be set.
   * \param state the new button state.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto set_virtual_button(const int button, const button_state state) noexcept -> result
  {
    return SDL_JoystickSetVirtualButton(m_joystick, button, to_underlying(state)) == 0;
  }

  /**
   * \brief Sets the state of a virtual joystick hat.
   *
   * \param hat the index of the hat that will be changed.
   * \param state the new state of the virtual joystick hat.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.2.0
   */
  auto set_virtual_hat(const int hat, const hat_state state) noexcept -> result
  {
    return SDL_JoystickSetVirtualHat(m_joystick, hat, to_underlying(state)) == 0;
  }

  /**
   * \brief Indicates whether or not a joystick is virtual.
   *
   * \param index the device index of the joystick that will be queried.
   *
   * \return `true` if the specified joystick is virtual; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto is_virtual(const int index) noexcept -> bool
  {
    return SDL_JoystickIsVirtual(index) == SDL_TRUE;
  }

#endif  // #if SDL_VERSION_ATLEAST(2, 0, 14)

  /// \} End of virtual joystick API

  /// \name Instance-based queries
  /// \{

  /**
   * \brief Returns the player index of the joystick, if available.
   *
   * \details For XInput controllers this returns the XInput user index.
   *
   * \return the player index associated with the joystick; `std::nullopt` if it can't be
   * obtained
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto player_index() const noexcept -> std::optional<int>
  {
    const auto index = SDL_JoystickGetPlayerIndex(m_joystick);
    if (index != -1) {
      return index;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the type associated with the joystick.
   *
   * \return the type of the joystick.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto type() const noexcept -> joystick_type
  {
    return static_cast<joystick_type>(SDL_JoystickGetType(m_joystick));
  }

  /**
   * \brief Returns the USB vendor ID of the joystick.
   *
   * \return the USB vendor ID associated with the joystick; `std::nullopt` if it isn't
   * available.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto vendor() const noexcept -> std::optional<u16>
  {
    const auto vendor = SDL_JoystickGetVendor(m_joystick);
    if (vendor != 0) {
      return vendor;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the USB product ID of the joystick.
   *
   * \return the USB product ID associated with the joystick; `std::nullopt` if it isn't
   * available.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto product() const noexcept -> std::optional<u16>
  {
    const auto product = SDL_JoystickGetProduct(m_joystick);
    if (product != 0) {
      return product;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the product version of the joystick, if available.
   *
   * \return the product version of the joystick; `std::nullopt` if it isn't available.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto product_version() const noexcept -> std::optional<u16>
  {
    const auto version = SDL_JoystickGetProductVersion(m_joystick);
    if (version != 0) {
      return version;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the GUID associated with the joystick.
   *
   * \note The GUID is implementation-dependent.
   *
   * \return the GUID associated with the joystick.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto guid() noexcept -> SDL_JoystickGUID
  {
    return SDL_JoystickGetGUID(m_joystick);
  }

  /**
   * \brief Returns the name associated with the joystick.
   *
   * \note If no name can be found, this function returns a null string.
   *
   * \return the name of the joystick; a null pointer if no name is found.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto name() const noexcept -> str
  {
    return SDL_JoystickName(m_joystick);
  }

  /**
   * \brief Returns the instance ID associated with the joystick.
   *
   * \return the instance ID associated with the joystick.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto instance_id() const noexcept -> SDL_JoystickID
  {
    return SDL_JoystickInstanceID(m_joystick);
  }

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Returns the serial number associated with the joystick.
   *
   * \return the serial number of the joystick; a null pointer is returned if the serial
   * number isn't available.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto serial() const noexcept -> str
  {
    return SDL_JoystickGetSerial(m_joystick);
  }

  /**
   * \brief Indicates whether or not the joystick features a LED light.
   *
   * \return `true` if the joystick features a LED light; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_led() const noexcept -> bool
  {
    return SDL_JoystickHasLED(m_joystick) == SDL_TRUE;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  /// \} End of instance-based queries

  /// \name Index-based queries
  /// \{

  /**
   * \brief Returns the player index of the joystick associated with the specified device
   * index.
   *
   * \note This function can be called before any joysticks are opened.
   *
   * \param deviceIndex the device index of the joystick that will be queried.
   *
   * \return the player index of the desired joystick; `std::nullopt` if it can't be
   * obtained.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto player_index(const int deviceIndex) noexcept -> std::optional<int>
  {
    const auto index = SDL_JoystickGetDevicePlayerIndex(deviceIndex);
    if (index != -1) {
      return index;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the type of the joystick associated with the specified device index.
   *
   * \param deviceIndex the device index of the joystick that will be queried.
   *
   * \return the type of the specified joystick.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto type(const int deviceIndex) noexcept -> joystick_type
  {
    return static_cast<joystick_type>(SDL_JoystickGetDeviceType(deviceIndex));
  }

  /**
   * \brief Returns the USB vendor ID for the joystick associated with the specified
   * device index.
   *
   * \param deviceIndex the device index of the joystick that will be queried.
   *
   * \return the USB vendor ID of the desired joystick; `std::nullopt` if it can't be
   * obtained.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto vendor(const int deviceIndex) noexcept -> std::optional<u16>
  {
    const auto vendor = SDL_JoystickGetDeviceVendor(deviceIndex);
    if (vendor != 0) {
      return vendor;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the USB product ID for the joystick associated with the specified
   * device index.
   *
   * \param deviceIndex the device index of the joystick that will be queried.
   *
   * \return the USB product ID of the desired joystick; `std::nullopt` if it can't be
   * obtained.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto product(const int deviceIndex) noexcept -> std::optional<u16>
  {
    const auto product = SDL_JoystickGetDeviceProduct(deviceIndex);
    if (product != 0) {
      return product;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the product version for the joystick associated with the specified
   * device index.
   *
   * \param deviceIndex the device index of the joystick that will be queried.
   *
   * \return the product version of the desired joystick; `std::nullopt` if it can't be
   * obtained.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto product_version(const int deviceIndex) noexcept
      -> std::optional<u16>
  {
    const auto version = SDL_JoystickGetDeviceProductVersion(deviceIndex);
    if (version != 0) {
      return version;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the GUID for the joystick associated with the specified device index.
   *
   * \note The GUID is implementation-dependent.
   * \note This function can be called before any joysticks are opened.
   *
   * \param deviceIndex refers to the N'th joystick that is currently recognized by SDL.
   *
   * \return the GUID of the joystick associated with the device index.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto guid(const int deviceIndex) noexcept -> SDL_JoystickGUID
  {
    return SDL_JoystickGetDeviceGUID(deviceIndex);
  }

  /**
   * \brief Returns the associated with the joystick with the specified device index.
   *
   * \param deviceIndex refers to the N'th joystick that is currently recognized by SDL.
   *
   * \return the name associated with the joystick; a null string is returned if no name
   * is found.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto name(const int deviceIndex) noexcept -> str
  {
    return SDL_JoystickNameForIndex(deviceIndex);
  }

  /**
   * \brief Returns the instance ID for the joystick associated with the specified device
   * index.
   *
   * \param deviceIndex the device index of the joystick that will be queried.
   *
   * \return the instance ID of the desired joystick; `std::nullopt` if it can't be
   * obtained.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto instance_id(const int deviceIndex) noexcept
      -> std::optional<SDL_JoystickID>
  {
    const auto id = SDL_JoystickGetDeviceInstanceID(deviceIndex);
    if (id != -1) {
      return id;
    }
    else {
      return std::nullopt;
    }
  }

  /// \} End of index-based queries

  /**
   * \brief Returns the ball axis change since the last poll.
   *
   * \note Trackballs can only return relative motion since the last call, these motion
   * deltas are placed into the `BallAxisChange` struct.
   *
   * \param ball the ball index to check, start at 0.
   *
   * \return a `JoystickBallAxisChange` instance or `std::nullopt` if something goes
   * wrong.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto get_ball_axis_change(const int ball) const noexcept
      -> std::optional<ball_axis_change>
  {
    ball_axis_change change{};
    if (SDL_JoystickGetBall(m_joystick, ball, &change.dx, &change.dy) == 0) {
      return change;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the current position of the specified axis.
   *
   * \details Most modern joysticks let the X-axis be represented by 0 and the Y-axis
   * by 1. To account for jitter, it may be necessary to impose some kind of tolerance on
   * the returned value.
   *
   * \note Some joysticks use axes 2 and 3 for extra buttons.
   *
   * \param axis the ID of the axis to query.
   *
   * \return the position of the specified axis.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto axis_pos(const int axis) const noexcept -> i16
  {
    return SDL_JoystickGetAxis(m_joystick, axis);
  }

  /**
   * \brief Returns the initial state of the specified axis on the joystick.
   *
   * \param axis the axis that will be queried. Starts at 0.
   *
   * \return the initial state of the axis; `std::nullopt` if the axis doesn't have an
   * initial state.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto axis_initial_state(const int axis) const noexcept -> std::optional<i16>
  {
    i16 state{};
    if (SDL_JoystickGetAxisInitialState(m_joystick, axis, &state)) {
      return state;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Indicates whether or not the joystick is attached to the system.
   *
   * \return `true` if the joystick is attached to the system; false otherwise.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto is_attached() const noexcept -> bool
  {
    return SDL_JoystickGetAttached(m_joystick);
  }

  /**
   * \brief Returns the amount of hats on the joystick.
   *
   * \return the amount of hats on the joystick.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto hat_count() const noexcept -> int
  {
    return SDL_JoystickNumHats(m_joystick);
  }

  /**
   * \brief Returns the amount of general axis controls on the joystick.
   *
   * \return the amount of general axis controls on the joystick.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto axis_count() const noexcept -> int
  {
    return SDL_JoystickNumAxes(m_joystick);
  }

  /**
   * \brief Returns the amount of trackballs on the joystick.
   *
   * \return the amount of trackballs on the joystick.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto trackball_count() const noexcept -> int
  {
    return SDL_JoystickNumBalls(m_joystick);
  }

  /**
   * \brief Returns the amount of buttons on the joystick.
   *
   * \return the amount of buttons on the joystick.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto button_count() const noexcept -> int
  {
    return SDL_JoystickNumButtons(m_joystick);
  }

  /**
   * \brief Returns the current power level of the joystick.
   *
   * \return the current power level.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto get_power() const noexcept -> joystick_power
  {
    return static_cast<joystick_power>(SDL_JoystickCurrentPowerLevel(m_joystick));
  }

  /**
   * \brief Returns the button state of the button associated with the index.
   *
   * \param button the button index to get the state from, starting at 0.
   *
   * \return the state of the button.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto get_button_state(const int button) const noexcept -> button_state
  {
    return static_cast<button_state>(SDL_JoystickGetButton(m_joystick, button));
  }

  /**
   * \brief Returns the state of a specific joystick hat.
   *
   * \param hat the index of the hat to query, indices start at 0.
   *
   * \return the current state of the hat.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto get_hat_state(const int hat) const noexcept -> hat_state
  {
    return static_cast<hat_state>(SDL_JoystickGetHat(m_joystick, hat));
  }

  /**
   * \brief Updates the state of all open joysticks.
   *
   * \note This is done automatically by the event loop if any joystick events are
   * enabled.
   *
   * \since 4.2.0
   */
  static void update() noexcept
  {
    SDL_JoystickUpdate();
  }

  /**
   * \brief Locks the access to all joysticks.
   *
   * \details If you are using the joystick API from multiple threads you should use this
   * function to restrict access to the joysticks.
   *
   * \since 4.2.0
   */
  static void lock() noexcept
  {
    SDL_LockJoysticks();
  }

  /**
   * \brief Unlocks the access to all joysticks.
   *
   * \since 4.2.0
   */
  static void unlock() noexcept
  {
    SDL_UnlockJoysticks();
  }

  /**
   * \brief Specifies whether or not joystick event polling is enabled.
   *
   * \details If joystick event polling is disabled, then you must manually call
   * `basic_joystick::update()` in order to update the joystick state.
   *
   * \note It's recommended to leave joystick event polling enabled.
   *
   * \warning Calling this function might cause all events currently in the event queue to
   * be deleted.
   *
   * \param enabled `true` if joystick event polling should be enabled; `false` otherwise.
   *
   * \since 4.2.0
   */
  static void set_polling(const bool enabled) noexcept
  {
    SDL_JoystickEventState(enabled ? SDL_ENABLE : SDL_DISABLE);
  }

  /**
   * \brief Indicates whether or not joystick event polling is enabled.
   *
   * \return `true` if joystick event polling is enabled; `false` otherwise.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto is_polling() noexcept -> bool
  {
    return SDL_JoystickEventState(SDL_QUERY);
  }

  /**
   * \brief Returns the amount of currently available joysticks.
   *
   * \return the current amount of available joysticks; `std::nullopt` if something goes
   * wrong.
   *
   * \since 5.1.0
   */
  [[nodiscard]] static auto count() noexcept -> std::optional<int>
  {
    const auto result = SDL_NumJoysticks();
    if (result >= 0) {
      return result;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns a joystick GUID based on the supplied string.
   *
   * \param str the string used to obtain the GUID, can't be null.
   *
   * \return the obtained GUID.
   *
   * \since 4.2.0
   */
  [[nodiscard]] static auto guid_from_string(const not_null<str> str) noexcept
      -> SDL_JoystickGUID
  {
    assert(str);
    return SDL_JoystickGetGUIDFromString(str);
  }

  /**
   * \brief Returns a joystick GUID based on the supplied string.
   *
   * \param str the string used to obtain the GUID.
   *
   * \return the obtained GUID.
   *
   * \since 5.3.0
   */
  [[nodiscard]] static auto guid_from_string(const std::string& str) noexcept
      -> SDL_JoystickGUID
  {
    return guid_from_string(str.c_str());
  }

  /**
   * \brief Returns the maximum possible value of an axis control on a joystick.
   *
   * \return the maximum possible value of an axis control.
   *
   * \since 4.2.0
   */
  [[nodiscard]] constexpr static auto axis_max() noexcept -> i16
  {
    return SDL_JOYSTICK_AXIS_MAX;
  }

  /**
   * \brief Returns the minimum possible value of an axis control on a joystick.
   *
   * \return the minimum possible value of an axis control.
   *
   * \since 4.2.0
   */
  [[nodiscard]] constexpr static auto axis_min() noexcept -> i16
  {
    return SDL_JOYSTICK_AXIS_MIN;
  }

  /**
   * \brief Indicates whether or not a handle holds a non-null pointer.
   *
   * \return `true` if the handle holds a non-null pointer; `false` otherwise.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit operator bool() const noexcept
  {
    return m_joystick != nullptr;
  }

  /**
   * \brief Returns a pointer to the associated `SDL_Joystick`.
   *
   * \warning Don't take ownership of the returned pointer!
   *
   * \return a pointer to the associated `SDL_Joystick`.
   *
   * \since 4.2.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_Joystick*
  {
    return m_joystick.get();
  }

 private:
  struct deleter final
  {
    void operator()(SDL_Joystick* joystick) noexcept
    {
      if (SDL_JoystickGetAttached(joystick)) {
        SDL_JoystickClose(joystick);
      }
    }
  };
  detail::pointer_manager<T, SDL_Joystick, deleter> m_joystick;
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a joystick.
 *
 * \tparam T the ownership semantics tag for the joystick.
 *
 * \param joystick the joystick that will be converted.
 *
 * \return a string representation of the joystick.
 *
 * \since 6.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_joystick<T>& joystick) -> std::string
{
  str serial{};
  if constexpr (detail::sdl_version_at_least(2, 0, 14)) {
    serial = joystick.serial();
  }

#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("joystick{{data: {}, id: {}, name: {}, serial: {}}}",
                     detail::address_of(joystick.get()),
                     joystick.instance_id(),
                     str_or_na(joystick.name()),
                     str_or_na(joystick.serial()));
#else
  return "joystick{data: " + detail::address_of(joystick.get()) +
         ", id: " + std::to_string(joystick.instance_id()) +
         ", name: " + str_or_na(joystick.name()) + ", serial: " + str_or_na(serial) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a joystick using a stream.
 *
 * \tparam T the ownership semantics tag for the joystick.
 *
 * \param stream the stream that will be used to print the joystick.
 * \param joystick the joystick that will be printed.
 *
 * \return the used stream.
 *
 * \since 6.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_joystick<T>& joystick) -> std::ostream&
{
  return stream << to_string(joystick);
}

/// \} End of streaming

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_JOYSTICK_HEADER
// #include "centurion/input/joystick_power.hpp"
#ifndef CENTURION_JOYSTICK_POWER_HEADER
#define CENTURION_JOYSTICK_POWER_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum joystick_power
 *
 * \brief Represents different power states of a joystick.
 *
 * \since 4.2.0
 */
enum class joystick_power
{
  unknown = SDL_JOYSTICK_POWER_UNKNOWN,  ///< Unknown power level.
  empty = SDL_JOYSTICK_POWER_EMPTY,      ///< Indicates <= 5% power.
  low = SDL_JOYSTICK_POWER_LOW,          ///< Indicates <= 20% power.
  medium = SDL_JOYSTICK_POWER_MEDIUM,    ///< Indicates <= 70% power.
  full = SDL_JOYSTICK_POWER_FULL,        ///< Indicates <= 100% power.
  wired = SDL_JOYSTICK_POWER_WIRED,      ///< No need to worry about power.
  max = SDL_JOYSTICK_POWER_MAX
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied joystick power.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(joystick_power::medium) == "medium"`.
 *
 * \param power the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const joystick_power power) -> std::string_view
{
  switch (power) {
    case joystick_power::unknown:
      return "unknown";

    case joystick_power::empty:
      return "empty";

    case joystick_power::low:
      return "low";

    case joystick_power::medium:
      return "medium";

    case joystick_power::full:
      return "full";

    case joystick_power::wired:
      return "wired";

    case joystick_power::max:
      return "max";

    default:
      throw cen_error{"Did not recognize joystick power!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a joystick power enumerator.
 *
 * \param stream the output stream that will be used.
 * \param power the enumerator that will be printed.
 *
 * \see `to_string(joystick_power)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const joystick_power power) -> std::ostream&
{
  return stream << to_string(power);
}

/// \} End of streaming

/// \name Joystick power comparison operators
/// \{

/**
 * \brief Indicates whether or not two joystick power values are the same.
 *
 * \param lhs the left-hand side power type.
 * \param rhs the right-hand side power type.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator==(const joystick_power lhs,
                                        const SDL_JoystickPowerLevel rhs) noexcept -> bool
{
  return static_cast<SDL_JoystickPowerLevel>(lhs) == rhs;
}

/**
 * \brief Indicates whether or not two joystick power values are the same.
 *
 * \param lhs the left-hand side power type.
 * \param rhs the right-hand side power type.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator==(const SDL_JoystickPowerLevel lhs,
                                        const joystick_power rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two joystick power values aren't the same.
 *
 * \param lhs the left-hand side power type.
 * \param rhs the right-hand side power type.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator!=(const joystick_power lhs,
                                        const SDL_JoystickPowerLevel rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/**
 * \brief Indicates whether or not two joystick power values aren't the same.
 *
 * \param lhs the left-hand side power type.
 * \param rhs the right-hand side power type.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator!=(const SDL_JoystickPowerLevel lhs,
                                        const joystick_power rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of joystick power comparison operators

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_JOYSTICK_POWER_HEADER

// #include "centurion/input/joystick_type.hpp"
#ifndef CENTURION_JOYSTICK_TYPE_HEADER
#define CENTURION_JOYSTICK_TYPE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum joystick_type
 *
 * \brief Provides values that represent different types of "joysticks".
 *
 * \since 4.2.0
 */
enum class joystick_type
{
  unknown = SDL_JOYSTICK_TYPE_UNKNOWN,
  game_controller = SDL_JOYSTICK_TYPE_GAMECONTROLLER,
  wheel = SDL_JOYSTICK_TYPE_WHEEL,
  arcade_stick = SDL_JOYSTICK_TYPE_ARCADE_STICK,
  flight_stick = SDL_JOYSTICK_TYPE_FLIGHT_STICK,
  dance_pad = SDL_JOYSTICK_TYPE_DANCE_PAD,
  guitar = SDL_JOYSTICK_TYPE_GUITAR,
  drum_kit = SDL_JOYSTICK_TYPE_DRUM_KIT,
  arcade_pad = SDL_JOYSTICK_TYPE_ARCADE_PAD,
  throttle = SDL_JOYSTICK_TYPE_THROTTLE
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied joystick type.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(joystick_type::guitar) == "guitar"`.
 *
 * \param type the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const joystick_type type) -> std::string_view
{
  switch (type) {
    case joystick_type::unknown:
      return "unknown";

    case joystick_type::game_controller:
      return "game_controller";

    case joystick_type::wheel:
      return "wheel";

    case joystick_type::arcade_stick:
      return "arcade_stick";

    case joystick_type::flight_stick:
      return "flight_stick";

    case joystick_type::dance_pad:
      return "dance_pad";

    case joystick_type::guitar:
      return "guitar";

    case joystick_type::drum_kit:
      return "drum_kit";

    case joystick_type::arcade_pad:
      return "arcade_pad";

    case joystick_type::throttle:
      return "throttle";

    default:
      throw cen_error{"Did not recognize joystick type!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a joystick type enumerator.
 *
 * \param stream the output stream that will be used.
 * \param type the enumerator that will be printed.
 *
 * \see `to_string(joystick_type)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const joystick_type type) -> std::ostream&
{
  return stream << to_string(type);
}

/// \} End of streaming

/// \name Joystick type comparison operators
/// \{

/**
 * \brief Indicates whether or not two joystick type values are the same.
 *
 * \param lhs the left-hand side joystick type value.
 * \param rhs the right-hand side joystick type value.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator==(const joystick_type lhs,
                                        const SDL_JoystickType rhs) noexcept -> bool
{
  return static_cast<SDL_JoystickType>(lhs) == rhs;
}

/**
 * \brief Indicates whether or not two joystick type values are the same.
 *
 * \param lhs the left-hand side joystick type value.
 * \param rhs the right-hand side joystick type value.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator==(const SDL_JoystickType lhs,
                                        const joystick_type rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two joystick type values aren't the same.
 *
 * \param lhs the left-hand side joystick type value.
 * \param rhs the right-hand side joystick type value.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator!=(const joystick_type lhs,
                                        const SDL_JoystickType rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/**
 * \brief Indicates whether or not two joystick type values aren't the same.
 *
 * \param lhs the left-hand side joystick type value.
 * \param rhs the right-hand side joystick type value.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator!=(const SDL_JoystickType lhs,
                                        const joystick_type rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of joystick type comparison operators

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_JOYSTICK_TYPE_HEADER

// #include "centurion/input/key_code.hpp"
#ifndef CENTURION_KEY_CODE_HEADER
#define CENTURION_KEY_CODE_HEADER

#include <SDL.h>

#include <cassert>  // assert
#include <ostream>  // ostream
#include <string>   // string

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/not_null.hpp"

// #include "../core/str.hpp"

// #include "../core/version.hpp"
#ifndef CENTURION_VERSION_HEADER
#define CENTURION_VERSION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <cassert>  // assert

/// \addtogroup core
/// \{

/**
 * \def CENTURION_VERSION_MAJOR
 *
 * \brief Expands into the current major version of the library.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_MAJOR 6

/**
 * \def CENTURION_VERSION_MINOR
 *
 * \brief Expands into the current minor version of the library.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_MINOR 3

/**
 * \def CENTURION_VERSION_PATCH
 *
 * \brief Expands into the current patch version of the library.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_PATCH 0

/**
 * \def CENTURION_SDL_VERSION_IS
 *
 * \brief This macro is meant to be used when conditionally including code for a specific
 * version of SDL. It is useful for applying workarounds.
 *
 * \since 5.3.0
 */
#define CENTURION_SDL_VERSION_IS(x, y, z) \
  ((SDL_MAJOR_VERSION == (x)) && (SDL_MINOR_VERSION == (y)) && (SDL_PATCHLEVEL == (z)))

#ifdef CENTURION___DOXYGEN

#define CENTURION_MAKE_VERSION_NUMBER
#define CENTURION_VERSION_NUMBER
#define CENTURION_VERSION_AT_LEAST

#endif  // CENTURION___DOXYGEN

/**
 * \def CENTURION_MAKE_VERSION_NUMBER
 *
 * \brief Helper macro for creating version numbers from a set of major/minor/patch
 * numbers.
 *
 * \details For example, if the version is 8.4.2, the resulting version number would be
 * 8402.
 *
 * \since 6.0.0
 */
#define CENTURION_MAKE_VERSION_NUMBER(x, y, z) (((x)*1'000) + ((y)*100) + (z))

/**
 * \def CENTURION_VERSION_NUMBER
 *
 * \brief Expands into a version number based on the current Centurion version.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_NUMBER                         \
  CENTURION_MAKE_VERSION_NUMBER(CENTURION_VERSION_MAJOR, \
                                CENTURION_VERSION_MINOR, \
                                CENTURION_VERSION_PATCH)

/**
 * \def CENTURION_VERSION_AT_LEAST
 *
 * \brief This macro is intended to be used for conditional compilation, based on the
 * Centurion version.
 *
 * \details This macro is used in the same way as the `SDL_VERSION_ATLEAST`, where you use
 * it as the condition with `#if` statements.
 *
 * \since 6.0.0
 */
#define CENTURION_VERSION_AT_LEAST(x, y, z) \
  CENTURION_VERSION_NUMBER >= CENTURION_MAKE_VERSION_NUMBER(x, y, z)

namespace cen {

/// \name Centurion version queries
/// \{

/**
 * \struct version
 *
 * \brief Represents a set of major/minor/patch version numbers.
 *
 * \details The members of this struct are by default initialized to the current Centurion
 * version values.
 *
 * \since 6.0.0
 */
struct version final
{
  int major{CENTURION_VERSION_MAJOR};
  int minor{CENTURION_VERSION_MINOR};
  int patch{CENTURION_VERSION_PATCH};
};

/**
 * \brief Indicates whether or not the current Centurion version is at least equal to the
 * specified version.
 *
 * \param major the major version value.
 * \param minor the minor version value.
 * \param patch the patch version value.
 *
 * \return `true` if the version of Centurion is at least the specified version; `false`
 * otherwise.
 *
 * \see `CENTURION_VERSION_AT_LEAST`
 *
 * \since 6.0.0
 */
[[nodiscard]] constexpr auto version_at_least(const int major,
                                              const int minor,
                                              const int patch) noexcept -> bool
{
  return CENTURION_VERSION_AT_LEAST(major, minor, patch);
}

/// \} End of centurion version queries

/// \name SDL version queries
/// \{

/**
 * \brief Returns the version of SDL2 that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL that the
 * program was compiled against.
 *
 * \return the linked version of SDL2.
 *
 * \since 5.2.0
 */
[[nodiscard]] inline auto sdl_linked_version() noexcept -> SDL_version
{
  SDL_version version{};
  SDL_GetVersion(&version);
  return version;
}

/**
 * \brief Returns the compile-time version of SDL2 that is being used.
 *
 * \return the compile-time version of SDL2 that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_version() noexcept -> SDL_version
{
  return {SDL_MAJOR_VERSION, SDL_MINOR_VERSION, SDL_PATCHLEVEL};
}

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \brief Returns the version of SDL2_image that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL2_image that
 * the program was compiled against.
 *
 * \return the linked version of SDL2_image.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto sdl_image_linked_version() noexcept -> SDL_version
{
  const auto* version = IMG_Linked_Version();
  assert(version);  // Sanity check
  return *version;
}

/**
 * \brief Returns the compile-time version of SDL2_image that is being used.
 *
 * \return the compile-time version of SDL2_image that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_image_version() noexcept -> SDL_version
{
  return {SDL_IMAGE_MAJOR_VERSION, SDL_IMAGE_MINOR_VERSION, SDL_IMAGE_PATCHLEVEL};
}

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \brief Returns the version of SDL2_mixer that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL2_mixer that
 * the program was compiled against.
 *
 * \return the linked version of SDL2_mixer.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto sdl_mixer_linked_version() noexcept -> SDL_version
{
  const auto* version = Mix_Linked_Version();
  assert(version);  // Sanity check
  return *version;
}

/**
 * \brief Returns the compile-time version of SDL2_mixer that is being used.
 *
 * \return the compile-time version of SDL2_mixer that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_mixer_version() noexcept -> SDL_version
{
  return {SDL_MIXER_MAJOR_VERSION, SDL_MIXER_MINOR_VERSION, SDL_MIXER_PATCHLEVEL};
}

#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF

/**
 * \brief Returns the version of SDL2_ttf that is linked against the program.
 *
 * \note The linked version isn't necessarily the same as the version of SDL2_ttf that the
 * program was compiled against.
 *
 * \return the linked version of SDL2_ttf.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto sdl_ttf_linked_version() noexcept -> SDL_version
{
  const auto* version = TTF_Linked_Version();
  assert(version);  // Sanity check
  return *version;
}

/**
 * \brief Returns the compile-time version of SDL2_ttf that is being used.
 *
 * \return the compile-time version of SDL2_ttf that is being used.
 *
 * \since 5.1.0
 */
[[nodiscard]] constexpr auto sdl_ttf_version() noexcept -> SDL_version
{
  return {SDL_TTF_MAJOR_VERSION, SDL_TTF_MINOR_VERSION, SDL_TTF_PATCHLEVEL};
}

#endif  // CENTURION_NO_SDL_TTF

/// \} End of SDL version queries

}  // namespace cen

#if CENTURION_SDL_VERSION_IS(2, 0, 10)

// Workaround for this enum being completely anonymous in SDL 2.0.10. We include
// this here because multiple files (key_code.hpp and scan_code.hpp) depend on
// this definition.
using SDL_KeyCode = decltype(SDLK_UNKNOWN);

#endif  // CENTURION_SDL_VERSION_IS(2, 0, 10)

/// \} End of group core

#endif  // CENTURION_VERSION_HEADER


namespace cen {

/// \addtogroup input
/// \{

/**
 * \class key_code
 *
 * \brief Represents a key code (or virtual key).
 *
 * \serializable
 *
 * \details Key codes are mapped to the current layout of the keyboard and correlate to a
 * `scan_code`. Whilst scan codes identify the *location* of a key press, the
 * corresponding key codes give the key press *meaning* in the context of the current
 * keyboard layout.
 *
 * Keycodes are meant to be layout-dependent. Think of this as "the user pressed the key
 * that is labelled 'Q' on a specific keyboard."
 *
 * For example, if you pressed the key that's two keys to the right of CAPS LOCK on a US
 * QWERTY keyboard, it'll report a scancode of SDL_SCANCODE_S and a keycode of SDLK_S. The
 * same key on a Dvorak keyboard, will report a scancode of SDL_SCANCODE_S and a keycode
 * of SDLK_O.
 *
 * \note Key codes are sometimes referred to as "keysyms" in the SDL documentation.
 *
 * \since 5.0.0
 *
 * \see `scan_code`
 * \see `cen::keycodes`
 */
class key_code final
{
 public:
  /// \name Construction
  /// \{

  /**
   * \brief Creates a `key_code` instance with the `SDLK_UNKNOWN` key code.
   *
   * \since 5.0.0
   */
  constexpr key_code() noexcept = default;

  constexpr key_code(const key_code&) noexcept = default;

  constexpr key_code(key_code&&) noexcept = default;

  /**
   * \brief Creates a `key_code` instance with the specified key code.
   *
   * \param key the key code that will be used.
   *
   * \since 5.0.0
   */
  constexpr /*implicit*/ key_code(const SDL_KeyCode key) noexcept : m_key{key}
  {}

  /**
   * \brief Creates a `key_code` instance based on a scan code.
   *
   * \details The created `key_code` will use the key code obtained
   * by converting the specified scan code.
   *
   * \param scancode the scan code that will be converted and used.
   *
   * \see `SDL_GetKeyFromScancode`
   *
   * \since 5.0.0
   */
  explicit key_code(const SDL_Scancode scancode) noexcept
      : m_key{static_cast<SDL_KeyCode>(SDL_GetKeyFromScancode(scancode))}
  {}

  /**
   * \brief Creates a `key_code` instance based on the specified name.
   *
   * \details If the specified name isn't recognized, `SDLK_UNKNOWN` is used as
   * the key code.
   *
   * \param name the name of the key, mustn't be null.
   *
   * \see `SDL_GetKeyFromName`
   *
   * \since 5.0.0
   */
  explicit key_code(const not_null<str> name) noexcept
      : m_key{static_cast<SDL_KeyCode>(SDL_GetKeyFromName(name))}
  {}

  /**
   * \brief Creates a `key_code` instance based on the specified name.
   *
   * \details If the specified name isn't recognized, `SDLK_UNKNOWN` is used as
   * the key code.
   *
   * \param name the name of the key.
   *
   * \since 5.3.0
   */
  explicit key_code(const std::string& name) noexcept : key_code{name.c_str()}
  {}

  /// \} End of construction

  /// \name Assignment operators
  /// \{

  constexpr auto operator=(const key_code&) noexcept -> key_code& = default;

  constexpr auto operator=(key_code&&) noexcept -> key_code& = default;

  /**
   * \brief Sets the key code used to the specified key code.
   *
   * \param key the key code that will be used.
   *
   * \return the `key_code` instance.
   *
   * \since 5.0.0
   */
  constexpr auto operator=(const SDL_KeyCode key) noexcept -> key_code&
  {
    m_key = key;
    return *this;
  }

  /**
   * \brief Sets the key code used to be the converted version of the
   * supplied scan code.
   *
   * \param scancode the scan code that will be converted and used.
   *
   * \return the `key_code` instance.
   *
   * \since 5.0.0
   */
  auto operator=(const SDL_Scancode scancode) noexcept -> key_code&
  {
    m_key = static_cast<SDL_KeyCode>(SDL_GetKeyFromScancode(scancode));
    return *this;
  }

  /**
   * \brief Sets the key code used to be the one associated with the
   * specified name.
   *
   * \details If the specified name isn't recognized, `SDLK_UNKNOWN` is used as
   * the key code.
   *
   * \param name the name of the key, mustn't be null.
   *
   * \return the `key_code` instance.
   *
   * \since 5.0.0
   */
  auto operator=(const not_null<str> name) noexcept -> key_code&
  {
    assert(name);
    m_key = static_cast<SDL_KeyCode>(SDL_GetKeyFromName(name));
    return *this;
  }

  /**
   * \brief Sets the key code used to be the one associated with the specified name.
   *
   * \details If the specified name isn't recognized, `SDLK_UNKNOWN` is used as the key
   * code.
   *
   * \param name the name of the key.
   *
   * \return the `key_code` instance.
   *
   * \since 5.3.0
   */
  auto operator=(const std::string& name) noexcept -> key_code&
  {
    return this->operator=(name.c_str());  // NOLINT
  }

  /// \} End of assignment operators

  /// \name Queries
  /// \{

  /**
   * \brief Indicates whether or not the stored key code is `SDLK_UNKNOWN`.
   *
   * \return `true` if the internal key code is `SDLK_UNKNOWN`; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto unknown() const noexcept -> bool
  {
    return m_key == SDLK_UNKNOWN;
  }

  /**
   * \brief Returns the name associated with the key code.
   *
   * \return the name associated with the key code.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto name() const -> std::string
  {
    return SDL_GetKeyName(m_key);
  }

  /**
   * \brief Returns the corresponding `SDL_Scancode`.
   *
   * \return the scan code associated with the internal key code.
   *
   * \see `SDL_GetScancodeFromKey`
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto to_scan_code() const noexcept -> SDL_Scancode
  {
    return SDL_GetScancodeFromKey(m_key);
  }

  /**
   * \brief Returns the internal key code.
   *
   * \return the internal key code.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto get() const noexcept -> SDL_KeyCode
  {
    return m_key;
  }

  /// \} End of queries

  /// \name Conversions
  /// \{

  /**
   * \brief Converts to `SDL_KeyCode`.
   *
   * \return the internal key code.
   *
   * \since 5.0.0
   */
  constexpr explicit operator SDL_KeyCode() const noexcept
  {
    return m_key;
  }

  /**
   * \brief Converts to `SDL_Keycode`.
   *
   * \return the internal key code.
   *
   * \note `SDL_Keycode` is just an alias for `i32`.
   *
   * \since 5.0.0
   */
  constexpr explicit operator SDL_Keycode() const noexcept
  {
    return m_key;
  }

  /**
   * \brief Converts to `SDL_Scancode`.
   *
   * \return the scan code associated with the internal key code.
   *
   * \see `to_scan_code()`
   *
   * \since 5.0.0
   */
  explicit operator SDL_Scancode() const noexcept
  {
    return to_scan_code();
  }

  /// \} End of conversions

  /**
   * \brief Serializes the key code.
   *
   * \details This function expects that the archive provides an overloaded `operator()`,
   * used for serializing data. This API is based on the Cereal serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the key code.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_key);
  }

 private:
  SDL_KeyCode m_key{SDLK_UNKNOWN};
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a key code.
 *
 * \param keyCode the key code that will be converted.
 *
 * \return a textual representation of the key code.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto to_string(const key_code& keyCode) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("key_code{{key: {}}}", keyCode.name());
#else
  return "key_code{key: " + keyCode.name() + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a key code using a stream.
 *
 * \param stream the stream that will be used.
 * \param keyCode the key code that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
inline auto operator<<(std::ostream& stream, const key_code& keyCode) -> std::ostream&
{
  return stream << to_string(keyCode);
}

/// \} End of streaming

/// \name Key code comparison operators
/// \{

/**
 * \brief Indicates whether or not two key codes are the same.
 *
 * \param lhs the left-hand side key code.
 * \param rhs the right-hand side key code.
 *
 * \return `true` if the key codes are the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator==(const key_code& lhs, const key_code& rhs) noexcept
    -> bool
{
  return lhs.get() == rhs.get();
}

/**
 * \brief Indicates whether or not two key codes aren't the same.
 *
 * \param lhs the left-hand side key code.
 * \param rhs the right-hand side key code.
 *
 * \return `true` if the key codes aren't the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator!=(const key_code& lhs, const key_code& rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \} End of key code comparison operators

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_KEY_CODE_HEADER
// #include "centurion/input/key_modifier.hpp"
#ifndef CENTURION_KEY_MODIFIER_HEADER
#define CENTURION_KEY_MODIFIER_HEADER

#include <SDL.h>

#include <ostream>  // ostream
#include <sstream>  // stringstream
#include <string>   // string

// #include "../core/integers.hpp"

// #include "../core/str.hpp"

// #include "../core/to_underlying.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum key_modifier
 *
 * \brief Represents different key modifiers.
 *
 * \note This is a flag enum, and provides overloads for the common bitwise operators.
 *
 * \todo Centurion 7: Rename this enum to `key_mod`.
 * \todo Centurion 7: Replace left_{}/right_{} prefixes with l{}/r{}.
 *
 * \see `key_mod`
 * \see `SDL_Keymod`
 * \see `operator~(key_mod)`
 * \see `operator|(key_mod, key_mod)`
 * \see `operator&(key_mod, key_mod)`
 *
 * \since 3.1.0
 */
enum class key_modifier : u16
{
  none = KMOD_NONE,
  left_shift = KMOD_LSHIFT,
  right_shift = KMOD_RSHIFT,
  left_ctrl = KMOD_LCTRL,
  right_ctrl = KMOD_RCTRL,
  left_alt = KMOD_LALT,
  right_alt = KMOD_RALT,
  left_gui = KMOD_LGUI,
  right_gui = KMOD_RGUI,
  shift = KMOD_SHIFT,
  ctrl = KMOD_CTRL,
  alt = KMOD_ALT,
  gui = KMOD_GUI,
  num = KMOD_NUM,
  caps = KMOD_CAPS,
  mode = KMOD_MODE,

  reserved = KMOD_RESERVED
};

/**
 * \typedef key_mod
 *
 * \brief Simple shorthand for `key_modifier`.
 *
 * \note In a future major release, `key_modifier` will likely be renamed to `key_mod`.
 *
 * \since 6.2.0
 */
using key_mod = key_modifier;

/**
 * \brief Sets the current key modifier flags.
 *
 * \param mods the modifier flags that will be used.
 *
 * \see `get_modifiers()`
 *
 * \since 6.2.0
 */
inline void set_modifiers(const key_mod mods) noexcept
{
  SDL_SetModState(static_cast<SDL_Keymod>(mods));
}

/**
 * \brief Returns the current key modifier state.
 *
 * \return the current key modifier flags.
 *
 * \see `set_modifiers()`
 *
 * \since 6.2.0
 */
[[nodiscard]] inline auto get_modifiers() noexcept -> key_mod
{
  return static_cast<key_mod>(SDL_GetModState());
}

/// \name Key modifier bitwise operators
/// \{

/**
 * \brief Returns the bitwise negation of the supplied modifiers.
 *
 * \param mods the modifiers that will be inverted.
 *
 * \return the bitwise negation of the supplied modifiers.
 *
 * \since 6.1.0
 */
[[nodiscard]] constexpr auto operator~(const key_mod mods) noexcept -> key_mod
{
  return static_cast<key_mod>(~to_underlying(mods));
}

/**
 * \brief Combines two groups of modifiers by applying bitwise OR.
 *
 * \param a the first group of modifiers.
 * \param b the second group of modifiers.
 *
 * \return the bitwise combination of the two groups of modifiers.
 *
 * \since 6.1.0
 */
[[nodiscard]] constexpr auto operator|(const key_mod a, const key_mod b) noexcept -> key_mod
{
  return static_cast<key_mod>(to_underlying(a) | to_underlying(b));
}

/**
 * \brief Combines two groups of modifiers by applying bitwise AND.
 *
 * \param a the first group of modifiers.
 * \param b the second group of modifiers.
 *
 * \return the result of applying bitwise AND between the two modifier groups.
 *
 * \since 6.1.0
 */
[[nodiscard]] constexpr auto operator&(const key_mod a, const key_mod b) noexcept -> key_mod
{
  return static_cast<key_mod>(to_underlying(a) & to_underlying(b));
}

/// \} End of key modifier bitwise operators

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied key modifiers.
 *
 * \details This function returns a string of comma separated values (CSV) if the supplied
 * enumerator is a composite of more than one key modifier. For example,
 * `to_string(key_mod::left_shift | key_mod::right_ctrl) == "left_shift,right_ctrl"`. The
 * order of the enumerators in the returned string mirrors the enumerator declaration
 * order.
 *
 * \details The comma is omitted if you supply an enumerator that only represents a single
 * key modifier.
 *
 * \details The empty string is returned if an invalid enumerator is provided.
 *
 * \details Composite enumerators, such as `key_mod::shift`, will be printed as separate
 * enumerators, i.e. `"left_shift,right_shift"` in the case of `key_mod::shift`.
 *
 * \param mods the key modifiers that will be converted.
 *
 * \return a string of comma separated values of key modifier names.
 *
 * \since 6.2.0
 */
[[nodiscard]] inline auto to_string(const key_mod mods) -> std::string
{
  if (mods == key_mod::none) {
    return "none";
  }

  const auto mask = to_underlying(mods);
  std::stringstream stream;

  auto check = [&stream, mask, count = 0](const key_mod mod, const str name) mutable {
    if (mask & to_underlying(mod)) {
      if (count != 0) {
        stream << ',';
      }

      stream << name;
      ++count;
    }
  };

  check(key_mod::left_shift, "left_shift");
  check(key_mod::right_shift, "right_shift");

  check(key_mod::left_ctrl, "left_ctrl");
  check(key_mod::right_ctrl, "right_ctrl");

  check(key_mod::left_alt, "left_alt");
  check(key_mod::right_alt, "right_alt");

  check(key_mod::left_gui, "left_gui");
  check(key_mod::right_gui, "right_gui");

  check(key_mod::num, "num");
  check(key_mod::caps, "caps");
  check(key_mod::mode, "mode");

  return stream.str();
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of the supplied key modifiers.
 *
 * \param stream the output stream that will be used.
 * \param mods the key modifiers that will be printed.
 *
 * \see `to_string(key_mod)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const key_mod mods) -> std::ostream&
{
  return stream << to_string(mods);
}

/// \} End of streaming

/// \} End of group input

/// \cond FALSE

namespace detail {

[[nodiscard]] inline auto is_active(const key_mod modifiers, const u16 currentMask) noexcept
    -> bool
{
  if (modifiers == key_mod::none) {
    return !currentMask;
  }
  else {
    return currentMask & to_underlying(modifiers);
  }
}

[[nodiscard]] inline auto is_only_active(const key_mod modifiers,
                                         const u16 currentMask) noexcept -> bool
{
  if (modifiers == key_mod::none) {
    return !currentMask;
  }

  const auto mask = to_underlying(modifiers);
  const auto hits = currentMask & mask;

  if (hits != mask) {
    return false;  // The specified modifiers were a combo that wasn't fully active
  }
  else {
    const auto others = currentMask & ~hits;
    return hits && !others;
  }
}

[[nodiscard]] inline auto is_only_any_of_active(const key_mod modifiers,
                                                const u16 currentMask) noexcept -> bool
{
  if (modifiers == key_mod::none) {
    return !currentMask;
  }

  const auto mask = to_underlying(modifiers);

  const auto hits = currentMask & mask;
  const auto others = currentMask & ~hits;

  return hits && !others;
}

}  // namespace detail

/// \endcond

}  // namespace cen

#endif  // CENTURION_KEY_MODIFIER_HEADER
// #include "centurion/input/keyboard.hpp"
#ifndef CENTURION_KEYBOARD_HEADER
#define CENTURION_KEYBOARD_HEADER

#include <SDL.h>

#include <algorithm>  // copy
#include <array>      // array
#include <ostream>    // ostream
#include <string>     // string, to_string

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../compiler/compiler.hpp"
#ifndef CENTURION_COMPILER_HEADER
#define CENTURION_COMPILER_HEADER

#include <SDL.h>

namespace cen {

/// \addtogroup compiler
/// \{

/**
 * \brief Indicates whether or not a "debug" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a debug build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_debug_build() noexcept -> bool
{
#ifndef NDEBUG
  return true;
#else
  return false;
#endif  // NDEBUG
}

/**
 * \brief Indicates whether or not a "release" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a release build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_release_build() noexcept -> bool
{
  return !is_debug_build();
}

/**
 * \brief Indicates whether or not the compiler is MSVC.
 *
 * \return `true` if MSVC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_msvc() noexcept -> bool
{
#ifdef _MSC_VER
  return true;
#else
  return false;
#endif  // _MSC_VER
}

/**
 * \brief Indicates whether or not the compiler is GCC.
 *
 * \return `true` if GCC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_gcc() noexcept -> bool
{
#ifdef __GNUC__
  return true;
#else
  return false;
#endif  // __GNUC__
}

/**
 * \brief Indicates whether or not the compiler is Clang.
 *
 * \return `true` if Clang is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_clang() noexcept -> bool
{
#ifdef __clang__
  return true;
#else
  return false;
#endif  // __clang__
}

/**
 * \brief Indicates whether or not the compiler is Emscripten.
 *
 * \return `true` if Emscripten is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_emscripten() noexcept -> bool
{
#ifdef __EMSCRIPTEN__
  return true;
#else
  return false;
#endif  // __EMSCRIPTEN__
}

/**
 * \brief Indicates whether or not the compiler is Intel C++.
 *
 * \return `true` if Intel C++ is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_intel_cpp() noexcept -> bool
{
#ifdef __INTEL_COMPILER
  return true;
#else
  return false;
#endif  // __INTEL_COMPILER
}

/// \} End of compiler group

}  // namespace cen

#endif  // CENTURION_COMPILER_HEADER

// #include "../core/integers.hpp"

// #include "key_code.hpp"
#ifndef CENTURION_KEY_CODE_HEADER
#define CENTURION_KEY_CODE_HEADER

#include <SDL.h>

#include <cassert>  // assert
#include <ostream>  // ostream
#include <string>   // string

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/not_null.hpp"

// #include "../core/str.hpp"

// #include "../core/version.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \class key_code
 *
 * \brief Represents a key code (or virtual key).
 *
 * \serializable
 *
 * \details Key codes are mapped to the current layout of the keyboard and correlate to a
 * `scan_code`. Whilst scan codes identify the *location* of a key press, the
 * corresponding key codes give the key press *meaning* in the context of the current
 * keyboard layout.
 *
 * Keycodes are meant to be layout-dependent. Think of this as "the user pressed the key
 * that is labelled 'Q' on a specific keyboard."
 *
 * For example, if you pressed the key that's two keys to the right of CAPS LOCK on a US
 * QWERTY keyboard, it'll report a scancode of SDL_SCANCODE_S and a keycode of SDLK_S. The
 * same key on a Dvorak keyboard, will report a scancode of SDL_SCANCODE_S and a keycode
 * of SDLK_O.
 *
 * \note Key codes are sometimes referred to as "keysyms" in the SDL documentation.
 *
 * \since 5.0.0
 *
 * \see `scan_code`
 * \see `cen::keycodes`
 */
class key_code final
{
 public:
  /// \name Construction
  /// \{

  /**
   * \brief Creates a `key_code` instance with the `SDLK_UNKNOWN` key code.
   *
   * \since 5.0.0
   */
  constexpr key_code() noexcept = default;

  constexpr key_code(const key_code&) noexcept = default;

  constexpr key_code(key_code&&) noexcept = default;

  /**
   * \brief Creates a `key_code` instance with the specified key code.
   *
   * \param key the key code that will be used.
   *
   * \since 5.0.0
   */
  constexpr /*implicit*/ key_code(const SDL_KeyCode key) noexcept : m_key{key}
  {}

  /**
   * \brief Creates a `key_code` instance based on a scan code.
   *
   * \details The created `key_code` will use the key code obtained
   * by converting the specified scan code.
   *
   * \param scancode the scan code that will be converted and used.
   *
   * \see `SDL_GetKeyFromScancode`
   *
   * \since 5.0.0
   */
  explicit key_code(const SDL_Scancode scancode) noexcept
      : m_key{static_cast<SDL_KeyCode>(SDL_GetKeyFromScancode(scancode))}
  {}

  /**
   * \brief Creates a `key_code` instance based on the specified name.
   *
   * \details If the specified name isn't recognized, `SDLK_UNKNOWN` is used as
   * the key code.
   *
   * \param name the name of the key, mustn't be null.
   *
   * \see `SDL_GetKeyFromName`
   *
   * \since 5.0.0
   */
  explicit key_code(const not_null<str> name) noexcept
      : m_key{static_cast<SDL_KeyCode>(SDL_GetKeyFromName(name))}
  {}

  /**
   * \brief Creates a `key_code` instance based on the specified name.
   *
   * \details If the specified name isn't recognized, `SDLK_UNKNOWN` is used as
   * the key code.
   *
   * \param name the name of the key.
   *
   * \since 5.3.0
   */
  explicit key_code(const std::string& name) noexcept : key_code{name.c_str()}
  {}

  /// \} End of construction

  /// \name Assignment operators
  /// \{

  constexpr auto operator=(const key_code&) noexcept -> key_code& = default;

  constexpr auto operator=(key_code&&) noexcept -> key_code& = default;

  /**
   * \brief Sets the key code used to the specified key code.
   *
   * \param key the key code that will be used.
   *
   * \return the `key_code` instance.
   *
   * \since 5.0.0
   */
  constexpr auto operator=(const SDL_KeyCode key) noexcept -> key_code&
  {
    m_key = key;
    return *this;
  }

  /**
   * \brief Sets the key code used to be the converted version of the
   * supplied scan code.
   *
   * \param scancode the scan code that will be converted and used.
   *
   * \return the `key_code` instance.
   *
   * \since 5.0.0
   */
  auto operator=(const SDL_Scancode scancode) noexcept -> key_code&
  {
    m_key = static_cast<SDL_KeyCode>(SDL_GetKeyFromScancode(scancode));
    return *this;
  }

  /**
   * \brief Sets the key code used to be the one associated with the
   * specified name.
   *
   * \details If the specified name isn't recognized, `SDLK_UNKNOWN` is used as
   * the key code.
   *
   * \param name the name of the key, mustn't be null.
   *
   * \return the `key_code` instance.
   *
   * \since 5.0.0
   */
  auto operator=(const not_null<str> name) noexcept -> key_code&
  {
    assert(name);
    m_key = static_cast<SDL_KeyCode>(SDL_GetKeyFromName(name));
    return *this;
  }

  /**
   * \brief Sets the key code used to be the one associated with the specified name.
   *
   * \details If the specified name isn't recognized, `SDLK_UNKNOWN` is used as the key
   * code.
   *
   * \param name the name of the key.
   *
   * \return the `key_code` instance.
   *
   * \since 5.3.0
   */
  auto operator=(const std::string& name) noexcept -> key_code&
  {
    return this->operator=(name.c_str());  // NOLINT
  }

  /// \} End of assignment operators

  /// \name Queries
  /// \{

  /**
   * \brief Indicates whether or not the stored key code is `SDLK_UNKNOWN`.
   *
   * \return `true` if the internal key code is `SDLK_UNKNOWN`; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto unknown() const noexcept -> bool
  {
    return m_key == SDLK_UNKNOWN;
  }

  /**
   * \brief Returns the name associated with the key code.
   *
   * \return the name associated with the key code.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto name() const -> std::string
  {
    return SDL_GetKeyName(m_key);
  }

  /**
   * \brief Returns the corresponding `SDL_Scancode`.
   *
   * \return the scan code associated with the internal key code.
   *
   * \see `SDL_GetScancodeFromKey`
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto to_scan_code() const noexcept -> SDL_Scancode
  {
    return SDL_GetScancodeFromKey(m_key);
  }

  /**
   * \brief Returns the internal key code.
   *
   * \return the internal key code.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto get() const noexcept -> SDL_KeyCode
  {
    return m_key;
  }

  /// \} End of queries

  /// \name Conversions
  /// \{

  /**
   * \brief Converts to `SDL_KeyCode`.
   *
   * \return the internal key code.
   *
   * \since 5.0.0
   */
  constexpr explicit operator SDL_KeyCode() const noexcept
  {
    return m_key;
  }

  /**
   * \brief Converts to `SDL_Keycode`.
   *
   * \return the internal key code.
   *
   * \note `SDL_Keycode` is just an alias for `i32`.
   *
   * \since 5.0.0
   */
  constexpr explicit operator SDL_Keycode() const noexcept
  {
    return m_key;
  }

  /**
   * \brief Converts to `SDL_Scancode`.
   *
   * \return the scan code associated with the internal key code.
   *
   * \see `to_scan_code()`
   *
   * \since 5.0.0
   */
  explicit operator SDL_Scancode() const noexcept
  {
    return to_scan_code();
  }

  /// \} End of conversions

  /**
   * \brief Serializes the key code.
   *
   * \details This function expects that the archive provides an overloaded `operator()`,
   * used for serializing data. This API is based on the Cereal serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the key code.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_key);
  }

 private:
  SDL_KeyCode m_key{SDLK_UNKNOWN};
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a key code.
 *
 * \param keyCode the key code that will be converted.
 *
 * \return a textual representation of the key code.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto to_string(const key_code& keyCode) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("key_code{{key: {}}}", keyCode.name());
#else
  return "key_code{key: " + keyCode.name() + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a key code using a stream.
 *
 * \param stream the stream that will be used.
 * \param keyCode the key code that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
inline auto operator<<(std::ostream& stream, const key_code& keyCode) -> std::ostream&
{
  return stream << to_string(keyCode);
}

/// \} End of streaming

/// \name Key code comparison operators
/// \{

/**
 * \brief Indicates whether or not two key codes are the same.
 *
 * \param lhs the left-hand side key code.
 * \param rhs the right-hand side key code.
 *
 * \return `true` if the key codes are the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator==(const key_code& lhs, const key_code& rhs) noexcept
    -> bool
{
  return lhs.get() == rhs.get();
}

/**
 * \brief Indicates whether or not two key codes aren't the same.
 *
 * \param lhs the left-hand side key code.
 * \param rhs the right-hand side key code.
 *
 * \return `true` if the key codes aren't the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator!=(const key_code& lhs, const key_code& rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \} End of key code comparison operators

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_KEY_CODE_HEADER
// #include "key_modifier.hpp"
#ifndef CENTURION_KEY_MODIFIER_HEADER
#define CENTURION_KEY_MODIFIER_HEADER

#include <SDL.h>

#include <ostream>  // ostream
#include <sstream>  // stringstream
#include <string>   // string

// #include "../core/integers.hpp"

// #include "../core/str.hpp"

// #include "../core/to_underlying.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum key_modifier
 *
 * \brief Represents different key modifiers.
 *
 * \note This is a flag enum, and provides overloads for the common bitwise operators.
 *
 * \todo Centurion 7: Rename this enum to `key_mod`.
 * \todo Centurion 7: Replace left_{}/right_{} prefixes with l{}/r{}.
 *
 * \see `key_mod`
 * \see `SDL_Keymod`
 * \see `operator~(key_mod)`
 * \see `operator|(key_mod, key_mod)`
 * \see `operator&(key_mod, key_mod)`
 *
 * \since 3.1.0
 */
enum class key_modifier : u16
{
  none = KMOD_NONE,
  left_shift = KMOD_LSHIFT,
  right_shift = KMOD_RSHIFT,
  left_ctrl = KMOD_LCTRL,
  right_ctrl = KMOD_RCTRL,
  left_alt = KMOD_LALT,
  right_alt = KMOD_RALT,
  left_gui = KMOD_LGUI,
  right_gui = KMOD_RGUI,
  shift = KMOD_SHIFT,
  ctrl = KMOD_CTRL,
  alt = KMOD_ALT,
  gui = KMOD_GUI,
  num = KMOD_NUM,
  caps = KMOD_CAPS,
  mode = KMOD_MODE,

  reserved = KMOD_RESERVED
};

/**
 * \typedef key_mod
 *
 * \brief Simple shorthand for `key_modifier`.
 *
 * \note In a future major release, `key_modifier` will likely be renamed to `key_mod`.
 *
 * \since 6.2.0
 */
using key_mod = key_modifier;

/**
 * \brief Sets the current key modifier flags.
 *
 * \param mods the modifier flags that will be used.
 *
 * \see `get_modifiers()`
 *
 * \since 6.2.0
 */
inline void set_modifiers(const key_mod mods) noexcept
{
  SDL_SetModState(static_cast<SDL_Keymod>(mods));
}

/**
 * \brief Returns the current key modifier state.
 *
 * \return the current key modifier flags.
 *
 * \see `set_modifiers()`
 *
 * \since 6.2.0
 */
[[nodiscard]] inline auto get_modifiers() noexcept -> key_mod
{
  return static_cast<key_mod>(SDL_GetModState());
}

/// \name Key modifier bitwise operators
/// \{

/**
 * \brief Returns the bitwise negation of the supplied modifiers.
 *
 * \param mods the modifiers that will be inverted.
 *
 * \return the bitwise negation of the supplied modifiers.
 *
 * \since 6.1.0
 */
[[nodiscard]] constexpr auto operator~(const key_mod mods) noexcept -> key_mod
{
  return static_cast<key_mod>(~to_underlying(mods));
}

/**
 * \brief Combines two groups of modifiers by applying bitwise OR.
 *
 * \param a the first group of modifiers.
 * \param b the second group of modifiers.
 *
 * \return the bitwise combination of the two groups of modifiers.
 *
 * \since 6.1.0
 */
[[nodiscard]] constexpr auto operator|(const key_mod a, const key_mod b) noexcept -> key_mod
{
  return static_cast<key_mod>(to_underlying(a) | to_underlying(b));
}

/**
 * \brief Combines two groups of modifiers by applying bitwise AND.
 *
 * \param a the first group of modifiers.
 * \param b the second group of modifiers.
 *
 * \return the result of applying bitwise AND between the two modifier groups.
 *
 * \since 6.1.0
 */
[[nodiscard]] constexpr auto operator&(const key_mod a, const key_mod b) noexcept -> key_mod
{
  return static_cast<key_mod>(to_underlying(a) & to_underlying(b));
}

/// \} End of key modifier bitwise operators

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied key modifiers.
 *
 * \details This function returns a string of comma separated values (CSV) if the supplied
 * enumerator is a composite of more than one key modifier. For example,
 * `to_string(key_mod::left_shift | key_mod::right_ctrl) == "left_shift,right_ctrl"`. The
 * order of the enumerators in the returned string mirrors the enumerator declaration
 * order.
 *
 * \details The comma is omitted if you supply an enumerator that only represents a single
 * key modifier.
 *
 * \details The empty string is returned if an invalid enumerator is provided.
 *
 * \details Composite enumerators, such as `key_mod::shift`, will be printed as separate
 * enumerators, i.e. `"left_shift,right_shift"` in the case of `key_mod::shift`.
 *
 * \param mods the key modifiers that will be converted.
 *
 * \return a string of comma separated values of key modifier names.
 *
 * \since 6.2.0
 */
[[nodiscard]] inline auto to_string(const key_mod mods) -> std::string
{
  if (mods == key_mod::none) {
    return "none";
  }

  const auto mask = to_underlying(mods);
  std::stringstream stream;

  auto check = [&stream, mask, count = 0](const key_mod mod, const str name) mutable {
    if (mask & to_underlying(mod)) {
      if (count != 0) {
        stream << ',';
      }

      stream << name;
      ++count;
    }
  };

  check(key_mod::left_shift, "left_shift");
  check(key_mod::right_shift, "right_shift");

  check(key_mod::left_ctrl, "left_ctrl");
  check(key_mod::right_ctrl, "right_ctrl");

  check(key_mod::left_alt, "left_alt");
  check(key_mod::right_alt, "right_alt");

  check(key_mod::left_gui, "left_gui");
  check(key_mod::right_gui, "right_gui");

  check(key_mod::num, "num");
  check(key_mod::caps, "caps");
  check(key_mod::mode, "mode");

  return stream.str();
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of the supplied key modifiers.
 *
 * \param stream the output stream that will be used.
 * \param mods the key modifiers that will be printed.
 *
 * \see `to_string(key_mod)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const key_mod mods) -> std::ostream&
{
  return stream << to_string(mods);
}

/// \} End of streaming

/// \} End of group input

/// \cond FALSE

namespace detail {

[[nodiscard]] inline auto is_active(const key_mod modifiers, const u16 currentMask) noexcept
    -> bool
{
  if (modifiers == key_mod::none) {
    return !currentMask;
  }
  else {
    return currentMask & to_underlying(modifiers);
  }
}

[[nodiscard]] inline auto is_only_active(const key_mod modifiers,
                                         const u16 currentMask) noexcept -> bool
{
  if (modifiers == key_mod::none) {
    return !currentMask;
  }

  const auto mask = to_underlying(modifiers);
  const auto hits = currentMask & mask;

  if (hits != mask) {
    return false;  // The specified modifiers were a combo that wasn't fully active
  }
  else {
    const auto others = currentMask & ~hits;
    return hits && !others;
  }
}

[[nodiscard]] inline auto is_only_any_of_active(const key_mod modifiers,
                                                const u16 currentMask) noexcept -> bool
{
  if (modifiers == key_mod::none) {
    return !currentMask;
  }

  const auto mask = to_underlying(modifiers);

  const auto hits = currentMask & mask;
  const auto others = currentMask & ~hits;

  return hits && !others;
}

}  // namespace detail

/// \endcond

}  // namespace cen

#endif  // CENTURION_KEY_MODIFIER_HEADER
// #include "scan_code.hpp"
#ifndef CENTURION_SCAN_CODE_HEADER
#define CENTURION_SCAN_CODE_HEADER

#include <SDL.h>

#include <cassert>  // assert
#include <ostream>  // ostream
#include <string>   // string

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/not_null.hpp"

// #include "../core/str.hpp"

// #include "../core/version.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \class scan_code
 *
 * \brief Represents a scan code.
 *
 * \serializable
 *
 * \details Scan codes represent the physical location of a key on the
 * keyboard. Use the associated key code associated with the location to give
 * the key press meaning.
 *
 * Scan codes are meant to be layout-independent. Think of this as "the user
 * pressed the Q key as it would be on a US QWERTY keyboard" regardless of
 * whether this is actually a European keyboard or a Dvorak keyboard or
 * whatever. *The scancode is always the same key position.*
 *
 * \since 5.0.0
 *
 * \see `key_code`
 * \see `cen::scancodes`
 */
class scan_code final
{
 public:
  /// \name Construction
  /// \{

  /**
   * \brief Creates a `scan_code` instance with the `SDL_SCANCODE_UNKNOWN` scan
   * code.
   *
   * \since 5.0.0
   */
  constexpr scan_code() noexcept = default;

  constexpr scan_code(const scan_code&) noexcept = default;

  constexpr scan_code(scan_code&&) noexcept = default;

  /**
   * \brief Creates a `scan_code` instance with the specified scan code.
   *
   * \param scancode the scan code that will be used.
   *
   * \since 5.0.0
   */
  constexpr /*implicit*/ scan_code(const SDL_Scancode scancode) noexcept : m_code{scancode}
  {}

  /**
   * \brief Creates a `scan_code` instance based on a key code.
   *
   * \details The created `scan_code` will use the scan code obtained
   * by converting the specified key code.
   *
   * \param key the key code that will be converted and used.
   *
   * \since 5.0.0
   */
  explicit scan_code(const SDL_Keycode key) noexcept : m_code{SDL_GetScancodeFromKey(key)}
  {}

  /**
   * \brief Creates a `scan_code` instance based on the specified name.
   *
   * \details If the specified name isn't recognized, `SDL_SCANCODE_UNKNOWN` is
   * used as the scan code.
   *
   * \param name the name of the key, mustn't be null.
   *
   * \see `SDL_GetScancodeFromName`
   *
   * \since 5.0.0
   */
  explicit scan_code(const not_null<str> name) noexcept : m_code{SDL_GetScancodeFromName(name)}
  {}

  /**
   * \brief Creates a `scan_code` instance based on the specified name.
   *
   * \details If the specified name isn't recognized, `SDL_SCANCODE_UNKNOWN` is
   * used as the scan code.
   *
   * \param name the name of the key.
   *
   * \since 5.3.0
   */
  explicit scan_code(const std::string& name) noexcept : scan_code{name.c_str()}
  {}

  /// \} End of construction

  /// \name Assignment operators
  /// \{

  constexpr auto operator=(const scan_code&) noexcept -> scan_code& = default;

  constexpr auto operator=(scan_code&&) noexcept -> scan_code& = default;

  /**
   * \brief Sets the scan code used to the specified scan code.
   *
   * \param code the scan code that will be used.
   *
   * \return the `scan_code` instance.
   *
   * \since 5.0.0
   */
  constexpr auto operator=(const SDL_Scancode code) noexcept -> scan_code&
  {
    m_code = code;
    return *this;
  }

  /**
   * \brief Sets the scan code used to be the converted version of the
   * supplied key code.
   *
   * \param keycode the key code that will be converted and used.
   *
   * \return the `scan_code` instance.
   *
   * \since 5.0.0
   */
  auto operator=(const SDL_Keycode keycode) noexcept -> scan_code&
  {
    m_code = SDL_GetScancodeFromKey(keycode);
    return *this;
  }

  /**
   * \brief Sets the scan code used to be the one associated with the
   * specified name.
   *
   * \details If the specified name isn't recognized, `SDL_SCANCODE_UNKNOWN` is
   * used as the scan code.
   *
   * \param name the name of the key, mustn't be null.
   *
   * \return the `scan_code` instance.
   *
   * \since 5.0.0
   */
  auto operator=(const not_null<str> name) noexcept -> scan_code&
  {
    assert(name);
    m_code = SDL_GetScancodeFromName(name);
    return *this;
  }

  /**
   * \brief Sets the scan code used to be the one associated with the
   * specified name.
   *
   * \details If the specified name isn't recognized, `SDL_SCANCODE_UNKNOWN` is
   * used as the scan code.
   *
   * \param name the name of the key.
   *
   * \return the `scan_code` instance.
   *
   * \since 5.3.0
   */
  auto operator=(const std::string& name) noexcept -> scan_code&
  {
    return operator=(name.c_str());  // NOLINT
  }

  /// \} End of assignment operators

  /// \name Queries
  /// \{

  /**
   * \brief Returns the total amount of scan codes.
   *
   * \return the amount of scan codes.
   *
   * \since 5.1.0
   */
  [[nodiscard]] constexpr static auto count() noexcept -> int
  {
    return SDL_NUM_SCANCODES;
  }

  /**
   * \brief Indicates whether or not the stored scan code is
   * `SDL_SCANCODE_UNKNOWN`.
   *
   * \return `true` if the internal scan code is `SDL_SCANCODE_UNKNOWN`;
   * `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto unknown() const noexcept -> bool
  {
    return m_code == SDL_SCANCODE_UNKNOWN;
  }

  /**
   * \brief Returns the name associated with the scan code.
   *
   * \return the name associated with the scan code.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto name() const -> std::string
  {
    return SDL_GetScancodeName(m_code);
  }

  /**
   * \brief Returns the corresponding `SDL_KeyCode`.
   *
   * \return the key code associated with the internal scan code.
   *
   * \see `SDL_GetKeyFromScancode`
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto to_key_code() const noexcept -> SDL_KeyCode
  {
    return static_cast<SDL_KeyCode>(SDL_GetKeyFromScancode(m_code));
  }

  /**
   * \brief Returns the internal scan code.
   *
   * \return the internal scan code.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto get() const noexcept -> SDL_Scancode
  {
    return m_code;
  }

  /// \} End of queries

  /// \name Conversions
  /// \{

  /**
   * \brief Converts to `SDL_Scancode`.
   *
   * \return the internal scan code.
   *
   * \since 5.0.0
   */
  constexpr explicit operator SDL_Scancode() const noexcept
  {
    return m_code;
  }

  /**
   * \brief Converts to `SDL_KeyCode`.
   *
   * \return the key code associated with the internal scan code.
   *
   * \see `SDL_GetKeyFromScancode`
   *
   * \since 5.0.0
   */
  explicit operator SDL_KeyCode() const noexcept
  {
    return to_key_code();
  }

  /// \} End of conversions

  /**
   * \brief Serializes the scan code.
   *
   * \details This function expects that the archive provides an overloaded
   * `operator()`, used for serializing data. This API is based on the Cereal
   * serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the scan code.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_code);
  }

 private:
  SDL_Scancode m_code{SDL_SCANCODE_UNKNOWN};
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a scan code.
 *
 * \param code the scan code that will be converted.
 *
 * \return a textual representation of the scan code.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto to_string(const scan_code& code) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("scan_code{{key: {}}}", code.name());
#else
  return "scan_code{key: " + code.name() + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a scan code using a stream.
 *
 * \param stream the stream that will be used.
 * \param scanCode the scan code that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
inline auto operator<<(std::ostream& stream, const scan_code& scanCode) -> std::ostream&
{
  return stream << to_string(scanCode);
}

/// \} End of streaming

/// \name Scan code comparison operators
/// \{

/**
 * \brief Indicates whether or not two scan codes are the same.
 *
 * \param lhs the left-hand side scan code.
 * \param rhs the right-hand side scan code.
 *
 * \return `true` if the scan codes are the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator==(const scan_code& lhs, const scan_code& rhs) noexcept
    -> bool
{
  return lhs.get() == rhs.get();
}

/**
 * \brief Indicates whether or not two scan codes aren't the same.
 *
 * \param lhs the left-hand side scan code.
 * \param rhs the right-hand side scan code.
 *
 * \return `true` if the scan codes aren't the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator!=(const scan_code& lhs, const scan_code& rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \} End of scan code comparison operators

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_SCAN_CODE_HEADER

namespace cen {

/// \addtogroup input
/// \{

/**
 * \class keyboard
 *
 * \brief Provides information about the keyboard state.
 *
 * \details Using the keyboard state is an alternative to using events for
 * keyboard input.
 *
 * \see `mouse`
 * \see `has_screen_keyboard()`
 *
 * \since 3.0.0
 */
class keyboard final
{
 public:
  /**
   * \brief Creates a `keyboard` instance.
   *
   * \since 3.0.0
   */
  keyboard() noexcept
  {
    m_states = SDL_GetKeyboardState(&m_nKeys);
  }

  /**
   * \brief Updates the state of the key state object.
   *
   * \note `SDL_PumpEvents` isn't invoked by this function.
   *
   * \since 3.0.0
   */
  void update()
  {
    std::copy(m_states, m_states + m_nKeys, m_previous.begin());
  }

  /**
   * \brief Indicates whether or not the specified key is being pressed.
   *
   * \details This function returns false if the supplied key isn't recognized.
   *
   * \param code the scan code that will be checked.
   *
   * \return `true` if the key is being pressed; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_pressed(const scan_code& code) const noexcept -> bool
  {
    return check_state(code, [this](const SDL_Scancode sc) noexcept { return m_states[sc]; });
  }

  /**
   * \brief Indicates whether or not the specified key is being pressed.
   *
   * \details This function returns false if the supplied key isn't recognized.
   *
   * \note This function is slightly slower that the `scan_code` version.
   *
   * \param code the key code that will be checked.
   *
   * \return `true` if the key is being pressed; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_pressed(const key_code& code) const noexcept -> bool
  {
    return is_pressed(code.to_scan_code());
  }

  /**
   * \brief Indicates whether or not the specified key has been pressed during more than
   * one update of the key state.
   *
   * \details This function returns false if the supplied key isn't recognized.
   *
   * \param code the scan code that will be checked.
   *
   * \return `true` if the key has been held down; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_held(const scan_code& code) const noexcept(on_msvc()) -> bool
  {
    return check_state(code, [this](const SDL_Scancode sc) noexcept(on_msvc()) {
      return m_states[sc] && m_previous[sc];
    });
  }

  /**
   * \brief Indicates whether or not the specified key has been pressed during more than
   * one update of the key state.
   *
   * \details This function returns false if the supplied key isn't recognized.
   *
   * \note This function is slightly slower that the `scan_code` version.
   *
   * \param code the key code that will be checked.
   *
   * \return `true` if the key has been held down; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_held(const key_code& code) const noexcept(on_msvc()) -> bool
  {
    return is_held(code.to_scan_code());
  }

  /**
   * \brief Indicates whether or not a key just became pressed in the last update of the
   * key state.
   *
   * \details This function returns false if the supplied key isn't recognized.
   *
   * \param code the scan code that will be checked.
   *
   * \return `true` if the key has just been pressed; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto just_pressed(const scan_code& code) const noexcept(on_msvc()) -> bool
  {
    return check_state(code, [this](const SDL_Scancode sc) noexcept(on_msvc()) {
      return m_states[sc] && !m_previous[sc];
    });
  }

  /**
   * \brief Indicates whether or not a key just became pressed in the last update of the
   * key state.
   *
   * \details This function returns false if the supplied key isn't recognized.
   *
   * \note This function is slightly slower that the `scan_code` version.
   *
   * \param code the key code that will be checked.
   *
   * \return `true` if the key has just been pressed; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto just_pressed(const key_code& code) const noexcept(on_msvc()) -> bool
  {
    return just_pressed(code.to_scan_code());
  }

  /**
   * \brief Indicates whether or not the specified key was released in the last update of
   * the key state.
   *
   * \details This function returns false if the supplied key isn't recognized.
   *
   * \param code the scan code that will be checked.
   *
   * \return `true` if the key was released; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto just_released(const scan_code& code) const noexcept(on_msvc()) -> bool
  {
    return check_state(code, [this](const SDL_Scancode sc) noexcept(on_msvc()) {
      return !m_states[sc] && m_previous[sc];
    });
  }

  /**
   * \brief Indicates whether or not the specified key was released in the last update of
   * the key state.
   *
   * \details This function returns false if the supplied key isn't recognized.
   *
   * \note This function is slightly slower that the `scan_code` version.
   *
   * \param code the key code that will be checked.
   *
   * \return `true` if the key was released; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto just_released(const key_code& code) const noexcept(on_msvc()) -> bool
  {
    return just_released(code.to_scan_code());
  }

  /**
   * \brief Indicates whether or not any of the specified modifiers are active.
   *
   * \note Multiple key modifiers can be active at the same time.
   *
   * \param modifiers the modifiers that will be checked.
   *
   * \return `true` if any of the modifiers are active; `false` otherwise.
   *
   * \see `is_only_active()`
   * \see `is_only_any_of_active()`
   *
   * \since 4.0.0
   */
  [[nodiscard]] static auto is_active(const key_mod modifiers) noexcept -> bool
  {
    return detail::is_active(modifiers, static_cast<u16>(SDL_GetModState()));
  }

  /**
   * \brief Indicates whether or not the specified modifiers are solely active.
   *
   * \details This function differs from `is_active(key_mod)` in that this function
   * will return `false` if modifiers other than those specified are active. For example,
   * if the `shift` and `alt` modifiers are being pressed, then
   * `is_only_active(cen::key_mod::shift)` would evaluate to `false`.
   *
   * \param modifiers the modifiers to check for.
   *
   * \return `true` if *only* the specified modifiers are active; false otherwise.
   *
   * \see `is_active(key_mod)`
   * \see `is_only_any_of_active()`
   *
   * \since 6.2.0
   */
  [[nodiscard]] static auto is_only_active(const key_mod modifiers) noexcept -> bool
  {
    return detail::is_only_active(modifiers, static_cast<u16>(SDL_GetModState()));
  }

  /**
   * \brief Indicates whether or not only any of the specified modifiers are active.
   *
   * \details This function is very similar to `is_only_active()`, but differs in that not
   * all of the specified modifiers need to be active for this function to return `true`.
   * For example, if you supply `shift` to this function, and only the left shift key is
   * being pressed, then `is_only_any_of_active(cen::key_mod::shift)` would evaluate
   * to `true`. However, if some other modifiers were also being pressed other than the
   * left shift key, the same function call would instead evaluate to `false`.
   *
   * \param modifiers the modifiers to check for.
   *
   * \return `true` if *any* of the specified modifiers are active, but no other
   * modifiers; false otherwise.
   *
   * \see `is_active(key_mod)`
   * \see `is_only_active()`
   *
   * \since 6.2.0
   */
  [[nodiscard]] static auto is_only_any_of_active(const key_mod modifiers) noexcept -> bool
  {
    return detail::is_only_any_of_active(modifiers, static_cast<u16>(SDL_GetModState()));
  }

  /**
   * \brief Returns the total amount of keys.
   *
   * \return the total amount of keys.
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto key_count() const noexcept -> int
  {
    return m_nKeys;
  }

 private:
  const u8* m_states{};
  std::array<u8, cen::scan_code::count()> m_previous{};
  int m_nKeys{};

  template <typename Predicate>
  auto check_state(const cen::scan_code& code, Predicate&& predicate) const
      noexcept(noexcept(predicate(code.get()))) -> bool
  {
    const auto sc = code.get();
    if (sc >= 0 && sc < m_nKeys) {
      return predicate(sc);
    }
    else {
      return false;
    }
  }
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a keyboard.
 *
 * \param keyboard the keyboard instance that will be converted.
 *
 * \return a string that represents the keyboard.
 *
 * \since 6.2.0
 */
[[nodiscard]] inline auto to_string(const keyboard& keyboard) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("keyboard{{#keys: {}}}", keyboard.key_count());
#else
  return "keyboard{#keys: " + std::to_string(keyboard.key_count()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a keyboard.
 *
 * \param stream the output stream that will be used.
 * \param keyboard the keyboard that will be printed.
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const keyboard& keyboard) -> std::ostream&
{
  return stream << to_string(keyboard);
}

/// \} End of streaming

/**
 * \brief Indicates whether or not the platform has screen keyboard support.
 *
 * \return `true` if the current platform has some form of screen keyboard support;
 * `false` otherwise.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto has_screen_keyboard() noexcept -> bool
{
  return SDL_HasScreenKeyboardSupport() == SDL_TRUE;
}

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_KEYBOARD_HEADER

// #include "centurion/input/keycodes.hpp"
#ifndef CENTURION_KEYCODES_HEADER
#define CENTURION_KEYCODES_HEADER

#include <SDL.h>

// #include "key_code.hpp"


namespace cen {

/**
 * \namespace cen::keycodes
 *
 * \brief Provides a collection of `key_code` constants.
 *
 * \details Far from all key codes are provided. Instead, some of the most commonly used
 * key codes are available.
 *
 * \since 5.0.0
 */
namespace keycodes {

/// \addtogroup input
/// \{

/// \name Key code constants
/// \{

/**
 * \brief Represents an unknown key.
 *
 * \since 5.0.0
 */
inline constexpr key_code unknown;

/**
 * \brief Represents the key with the label "A".
 *
 * \since 5.0.0
 */
inline constexpr key_code a{SDLK_a};

/**
 * \brief Represents the key with the label "B".
 *
 * \since 5.0.0
 */
inline constexpr key_code b{SDLK_b};

/**
 * \brief Represents the key with the label "C".
 *
 * \since 5.0.0
 */
inline constexpr key_code c{SDLK_c};

/**
 * \brief Represents the key with the label "D".
 *
 * \since 5.0.0
 */
inline constexpr key_code d{SDLK_d};

/**
 * \brief Represents the key with the label "E".
 *
 * \since 5.0.0
 */
inline constexpr key_code e{SDLK_e};

/**
 * \brief Represents the key with the label "F".
 *
 * \since 5.0.0
 */
inline constexpr key_code f{SDLK_f};

/**
 * \brief Represents the key with the label "G".
 *
 * \since 5.0.0
 */
inline constexpr key_code g{SDLK_g};

/**
 * \brief Represents the key with the label "H".
 *
 * \since 5.0.0
 */
inline constexpr key_code h{SDLK_h};

/**
 * \brief Represents the key with the label "I".
 *
 * \since 5.0.0
 */
inline constexpr key_code i{SDLK_i};

/**
 * \brief Represents the key with the label "J".
 *
 * \since 5.0.0
 */
inline constexpr key_code j{SDLK_j};

/**
 * \brief Represents the key with the label "K".
 *
 * \since 5.0.0
 */
inline constexpr key_code k{SDLK_k};

/**
 * \brief Represents the key with the label "L".
 *
 * \since 5.0.0
 */
inline constexpr key_code l{SDLK_l};

/**
 * \brief Represents the key with the label "M".
 *
 * \since 5.0.0
 */
inline constexpr key_code m{SDLK_m};

/**
 * \brief Represents the key with the label "N".
 *
 * \since 5.0.0
 */
inline constexpr key_code n{SDLK_n};

/**
 * \brief Represents the key with the label "O".
 *
 * \since 5.0.0
 */
inline constexpr key_code o{SDLK_o};

/**
 * \brief Represents the key with the label "P".
 *
 * \since 5.0.0
 */
inline constexpr key_code p{SDLK_p};

/**
 * \brief Represents the key with the label "Q".
 *
 * \since 5.0.0
 */
inline constexpr key_code q{SDLK_q};

/**
 * \brief Represents the key with the label "R".
 *
 * \since 5.0.0
 */
inline constexpr key_code r{SDLK_r};

/**
 * \brief Represents the key with the label "S".
 *
 * \since 5.0.0
 */
inline constexpr key_code s{SDLK_s};

/**
 * \brief Represents the key with the label "T".
 *
 * \since 5.0.0
 */
inline constexpr key_code t{SDLK_t};

/**
 * \brief Represents the key with the label "U".
 *
 * \since 5.0.0
 */
inline constexpr key_code u{SDLK_u};

/**
 * \brief Represents the key with the label "V".
 *
 * \since 5.0.0
 */
inline constexpr key_code v{SDLK_v};

/**
 * \brief Represents the key with the label "W".
 *
 * \since 5.0.0
 */
inline constexpr key_code w{SDLK_w};

/**
 * \brief Represents the key with the label "X".
 *
 * \since 5.0.0
 */
inline constexpr key_code x{SDLK_x};

/**
 * \brief Represents the key with the label "Y".
 *
 * \since 5.0.0
 */
inline constexpr key_code y{SDLK_y};

/**
 * \brief Represents the key with the label "Z".
 *
 * \since 5.0.0
 */
inline constexpr key_code z{SDLK_z};

/**
 * \brief Represents the key with the label "1".
 *
 * \note This is not for a potential "1" key on the key pad.
 *
 * \since 5.0.0
 */
inline constexpr key_code one{SDLK_1};

/**
 * \brief Represents the key with the label "2".
 *
 * \note This is not for a potential "2" key on the key pad.
 *
 * \since 5.0.0
 */
inline constexpr key_code two{SDLK_2};

/**
 * \brief Represents the key with the label "3".
 *
 * \note This is not for a potential "3" key on the key pad.
 *
 * \since 5.0.0
 */
inline constexpr key_code three{SDLK_3};

/**
 * \brief Represents the key with the label "4".
 *
 * \note This is not for a potential "4" key on the key pad.
 *
 * \since 5.0.0
 */
inline constexpr key_code four{SDLK_4};

/**
 * \brief Represents the key with the label "5".
 *
 * \note This is not for a potential "5" key on the key pad.
 *
 * \since 5.0.0
 */
inline constexpr key_code five{SDLK_5};

/**
 * \brief Represents the key with the label "6".
 *
 * \note This is not for a potential "6" key on the key pad.
 *
 * \since 5.0.0
 */
inline constexpr key_code six{SDLK_6};

/**
 * \brief Represents the key with the label "7".
 *
 * \note This is not for a potential "7" key on the key pad.
 *
 * \since 5.0.0
 */
inline constexpr key_code seven{SDLK_7};

/**
 * \brief Represents the key with the label "8".
 *
 * \note This is not for a potential "8" key on the key pad.
 *
 * \since 5.0.0
 */
inline constexpr key_code eight{SDLK_8};

/**
 * \brief Represents the key with the label "9".
 *
 * \note This is not for a potential "9" key on the key pad.
 *
 * \since 5.0.0
 */
inline constexpr key_code nine{SDLK_9};

/**
 * \brief Represents the key with the label "0".
 *
 * \note This is not for a potential "0" key on the key pad.
 *
 * \since 5.0.0
 */
inline constexpr key_code zero{SDLK_0};

/**
 * \brief Represents the function key "F1".
 *
 * \since 5.0.0
 */
inline constexpr key_code f1{SDLK_F1};

/**
 * \brief Represents the function key "F2".
 *
 * \since 5.0.0
 */
inline constexpr key_code f2{SDLK_F2};

/**
 * \brief Represents the function key "F3".
 *
 * \since 5.0.0
 */
inline constexpr key_code f3{SDLK_F3};

/**
 * \brief Represents the function key "F4".
 *
 * \since 5.0.0
 */
inline constexpr key_code f4{SDLK_F4};

/**
 * \brief Represents the function key "F5".
 *
 * \since 5.0.0
 */
inline constexpr key_code f5{SDLK_F5};

/**
 * \brief Represents the function key "F6".
 *
 * \since 5.0.0
 */
inline constexpr key_code f6{SDLK_F6};

/**
 * \brief Represents the function key "F7".
 *
 * \since 5.0.0
 */
inline constexpr key_code f7{SDLK_F7};

/**
 * \brief Represents the function key "F8".
 *
 * \since 5.0.0
 */
inline constexpr key_code f8{SDLK_F8};

/**
 * \brief Represents the function key "F9".
 *
 * \since 5.0.0
 */
inline constexpr key_code f9{SDLK_F9};

/**
 * \brief Represents the function key "F10".
 *
 * \since 5.0.0
 */
inline constexpr key_code f10{SDLK_F10};

/**
 * \brief Represents the function key "F11".
 *
 * \since 5.0.0
 */
inline constexpr key_code f11{SDLK_F11};

/**
 * \brief Represents the function key "F12".
 *
 * \since 5.0.0
 */
inline constexpr key_code f12{SDLK_F12};

/**
 * \brief Represents the left arrow key.
 *
 * \since 5.0.0
 */
inline constexpr key_code left{SDLK_LEFT};

/**
 * \brief Represents the right arrow key.
 *
 * \since 5.0.0
 */
inline constexpr key_code right{SDLK_RIGHT};

/**
 * \brief Represents the up arrow key.
 *
 * \since 5.0.0
 */
inline constexpr key_code up{SDLK_UP};

/**
 * \brief Represents the down arrow key.
 *
 * \since 5.0.0
 */
inline constexpr key_code down{SDLK_DOWN};

/**
 * \brief Represents the "Space" key.
 *
 * \since 5.0.0
 */
inline constexpr key_code space{SDLK_SPACE};

/**
 * \brief Represents the "Enter" key.
 *
 * \note This key is also referred to as the "Return" key.
 *
 * \since 5.0.0
 */
inline constexpr key_code enter{SDLK_RETURN};

/**
 * \brief Represents the "Escape" key.
 *
 * \since 5.0.0
 */
inline constexpr key_code escape{SDLK_ESCAPE};

/**
 * \brief Represents the "Backspace" key.
 *
 * \since 5.0.0
 */
inline constexpr key_code backspace{SDLK_BACKSPACE};

/**
 * \brief Represents the "Tab" key.
 *
 * \since 5.0.0
 */
inline constexpr key_code tab{SDLK_TAB};

/**
 * \brief Represents the "Caps Lock" key.
 *
 * \since 5.0.0
 */
inline constexpr key_code caps_lock{SDLK_CAPSLOCK};

/**
 * \brief Represents the left "Shift" key.
 *
 * \since 5.0.0
 */
inline constexpr key_code left_shift{SDLK_LSHIFT};

/**
 * \brief Represents the right "Shift" key.
 *
 * \since 5.0.0
 */
inline constexpr key_code right_shift{SDLK_RSHIFT};

/**
 * \brief Represents the left "CTRL" key.
 *
 * \since 5.0.0
 */
inline constexpr key_code left_ctrl{SDLK_LCTRL};

/**
 * \brief Represents the right "CTRL" key.
 *
 * \since 5.0.0
 */
inline constexpr key_code right_ctrl{SDLK_RCTRL};

/**
 * \brief Represents the left "Alt" key.
 *
 * \since 5.0.0
 */
inline constexpr key_code left_alt{SDLK_LALT};

/**
 * \brief Represents the right "Alt" key.
 *
 * \since 5.0.0
 */
inline constexpr key_code right_alt{SDLK_RALT};

/**
 * \brief Represents the left "GUI" key.
 *
 * \details On Windows, this is the "Windows key"; for macs it's the "CMD" key, etc.
 *
 * \since 5.0.0
 */
inline constexpr key_code left_gui{SDLK_LGUI};

/**
 * \brief Represents the right "GUI" key.
 *
 * \details On Windows, this is the "Windows" key; for macs it's the "CMD" key, etc.
 *
 * \since 5.0.0
 */
inline constexpr key_code right_gui{SDLK_RGUI};

/// \} End of key code constants

/// \} End of group input

}  // namespace keycodes

}  // namespace cen

#endif  // CENTURION_KEYCODES_HEADER

// #include "centurion/input/mouse.hpp"
#ifndef CENTURION_MOUSE_HEADER
#define CENTURION_MOUSE_HEADER

#include <ostream>  // ostream
#include <string>   // string, to_string

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/integers.hpp"

// #include "../detail/max.hpp"

// #include "../math/area.hpp"
#ifndef CENTURION_AREA_HEADER
#define CENTURION_AREA_HEADER

#include <ostream>      // ostream
#include <string>       // string, to_string
#include <type_traits>  // is_integral_v, is_floating_point_v, is_same_v

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/cast.hpp"
#ifndef CENTURION_CAST_HEADER
#define CENTURION_CAST_HEADER

namespace cen {

/**
 * \brief Casts a value to a value of another type.
 *
 * \ingroup core
 *
 * \details This is the default implementation, which simply attempts to use
 * `static_cast`. The idea is that this function will be specialized for various Centurion
 * and SDL types. This is useful because it isn't always possible to implement conversion
 * operators as members.
 *
 * \tparam To the type of the value that will be converted.
 * \tparam From the type that the value will be casted to.
 *
 * \param from the value that will be converted.
 *
 * \return the result of casting the supplied value to the specified type.
 *
 * \since 5.0.0
 */
template <typename To, typename From>
[[nodiscard]] constexpr auto cast(const From& from) noexcept -> To
{
  return static_cast<To>(from);
}

}  // namespace cen

#endif  // CENTURION_CAST_HEADER


namespace cen {

/// \addtogroup math
/// \{

template <typename T>
struct basic_area;

/**
 * \typedef iarea
 *
 * \brief An alias for `int` areas.
 *
 * \since 4.1.0
 */
using iarea = basic_area<int>;

/**
 * \typedef farea
 *
 * \brief An alias for `float` areas.
 *
 * \since 4.1.0
 */
using farea = basic_area<float>;

/**
 * \typedef darea
 *
 * \brief An alias for `double` areas.
 *
 * \since 4.1.0
 */
using darea = basic_area<double>;

/**
 * \struct basic_area
 *
 * \brief Simply represents an area with a width and height.
 *
 * \serializable
 *
 * \tparam T the type of the components of the area. Must be either an integral or
 * floating-point type. Can't be `bool`.
 *
 * \since 4.0.0
 *
 * \see `iarea`
 * \see `farea`
 * \see `darea`
 */
template <typename T>
struct basic_area final
{
  static_assert(std::is_integral_v<T> || std::is_floating_point_v<T>);
  static_assert(!std::is_same_v<T, bool>);

  using value_type = T;

  T width{0};   ///< The width of the area.
  T height{0};  ///< The height of the area.

#if CENTURION_HAS_FEATURE_SPACESHIP

  [[nodiscard]] constexpr auto operator==(const basic_area&) const noexcept -> bool = default;

#endif  // CENTURION_HAS_FEATURE_SPACESHIP
};

/// \name Area-related functions
/// \{

/**
 * \brief Creates an area instance with automatically deduced precision.
 *
 * \tparam T the deduced type of the width and height values.
 *
 * \param width the width of the area.
 * \param height the height of the area.
 *
 * \return an area instance with the specified width and height.
 *
 * \since 6.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto area(const T width, const T height) noexcept -> basic_area<T>
{
  return {width, height};
}

/**
 * \brief Returns the size (width x height) of an area.
 *
 * \tparam T the representation type.
 *
 * \param area the area instance that will be calculated.
 *
 * \return the size of the area.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto area_of(const basic_area<T> area) noexcept -> T
{
  return area.width * area.height;
}

/// \} End of area-related functions

/**
 * \brief Serializes an area instance.
 *
 * \details This function expects that the archive provides an overloaded `operator()`,
 * used for serializing data. This API is based on the Cereal serialization library.
 *
 * \tparam Archive the type of the archive.
 * \tparam T the type of the area components.
 *
 * \param archive the archive used to serialize the area.
 * \param area the area that will be serialized.
 *
 * \since 5.3.0
 */
template <typename Archive, typename T>
void serialize(Archive& archive, basic_area<T>& area)
{
  archive(area.width, area.height);
}

/// \name Area cast specializations
/// \{

template <>
[[nodiscard]] constexpr auto cast(const iarea& from) noexcept -> darea
{
  return {static_cast<double>(from.width), static_cast<double>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const iarea& from) noexcept -> farea
{
  return {static_cast<float>(from.width), static_cast<float>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const farea& from) noexcept -> darea
{
  return {static_cast<double>(from.width), static_cast<double>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const farea& from) noexcept -> iarea
{
  return {static_cast<int>(from.width), static_cast<int>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const darea& from) noexcept -> farea
{
  return {static_cast<float>(from.width), static_cast<float>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const darea& from) noexcept -> iarea
{
  return {static_cast<int>(from.width), static_cast<int>(from.height)};
}

/// \} End of area cast specializations

/// \name Area comparison operators
/// \{

#if !CENTURION_HAS_FEATURE_SPACESHIP

/**
 * \brief Indicates whether or not two areas are considered to be equal.
 *
 * \param lhs the left-hand side area.
 * \param rhs the right-hand side area.
 *
 * \return `true` if the areas are equal; `false` otherwise.
 *
 * \since 4.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator==(const basic_area<T>& lhs,
                                        const basic_area<T>& rhs) noexcept -> bool
{
  return (lhs.width == rhs.width) && (lhs.height == rhs.height);
}

/**
 * \brief Indicates whether or not two areas aren't considered to be equal.
 *
 * \param lhs the left-hand side area.
 * \param rhs the right-hand side area.
 *
 * \return `true` if the areas aren't equal; `false` otherwise.
 *
 * \since 4.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator!=(const basic_area<T>& lhs,
                                        const basic_area<T>& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

#endif  // CENTURION_HAS_FEATURE_SPACESHIP

/// \} End of area comparison operators

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of an area.
 *
 * \tparam T the type of the area components.
 *
 * \param area the area that will be converted.
 *
 * \return a string that represents the area.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_area<T>& area) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("area{{width: {}, height: {}}}", area.width, area.height);
#else
  return "area{width: " + std::to_string(area.width) +
         ", height: " + std::to_string(area.height) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of an area using a stream.
 *
 * \tparam T the type of the area components.
 *
 * \param stream the stream that will be used.
 * \param area the are that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_area<T>& area) -> std::ostream&
{
  return stream << to_string(area);
}

/// \} End of streaming

/// \} End of group math

}  // namespace cen

#endif  // CENTURION_AREA_HEADER
// #include "../math/point.hpp"
#ifndef CENTURION_POINT_HEADER
#define CENTURION_POINT_HEADER

#include <SDL.h>

#include <cmath>        // sqrt, abs, round
#include <ostream>      // ostream
#include <string>       // string, to_string
#include <type_traits>  // conditional_t, is_integral_v, is_floating_point_v, ...

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/cast.hpp"

// #include "../core/sfinae.hpp"
#ifndef CENTURION_SFINAE_HEADER
#define CENTURION_SFINAE_HEADER

#include <type_traits>  // enable_if_t, is_same_v, is_integral_v, is_floating_point_v, ...

namespace cen {

/// \addtogroup core
/// \{

// clang-format off

/// Enables a template if the type is either integral of floating-point, but not a boolean.
template <typename T>
using enable_if_number_t = std::enable_if_t<!std::is_same_v<T, bool> &&
                                            (std::is_integral_v<T> ||
                                             std::is_floating_point_v<T>), int>;

// clang-format on

/// Enables a template if the type is a pointer.
template <typename T>
using enable_if_pointer_v = std::enable_if_t<std::is_pointer_v<T>, int>;

/// Enables a template if T is convertible to any of the specified types.
template <typename T, typename... Args>
using enable_if_convertible_t = std::enable_if_t<(std::is_convertible_v<T, Args> || ...), int>;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_SFINAE_HEADER


namespace cen {

/// \addtogroup math
/// \{

/**
 * \brief Provides traits used by the `basic_point` class.
 *
 * \tparam T the representation type. Must be convertible to `int` or `float`.
 *
 * \since 5.0.0
 *
 * \see `basic_point`
 * \see `ipoint`
 * \see `fpoint`
 */
template <typename T, enable_if_convertible_t<T, int, float> = 0>
class point_traits final
{
 public:
  /**
   * \var isIntegral
   *
   * \brief Indicates whether or not the point is based on an integral type.
   *
   * \since 5.0.0
   */
  inline constexpr static bool isIntegral = std::is_integral_v<T>;

  /**
   * \var isFloating
   *
   * \brief Indicates whether or not the point is based on a floating-point
   * type.
   *
   * \since 5.0.0
   */
  inline constexpr static bool isFloating = std::is_floating_point_v<T>;

  /**
   * \typedef value_type
   *
   * \brief The actual representation type, i.e. `int` or `float`.
   *
   * \since 5.0.0
   */
  using value_type = std::conditional_t<isIntegral, int, float>;

  /**
   * \typedef point_type
   *
   * \brief The SDL point type, i.e. `SDL_Point` or `SDL_FPoint`.
   *
   * \since 5.0.0
   */
  using point_type = std::conditional_t<isIntegral, SDL_Point, SDL_FPoint>;
};

template <typename T>
class basic_point;

/**
 * \typedef ipoint
 *
 * \brief Alias for an `int`-based point.
 *
 * \details This type corresponds to `SDL_Point`.
 *
 * \since 5.0.0
 */
using ipoint = basic_point<int>;

/**
 * \typedef fpoint
 *
 * \brief Alias for a `float`-based point.
 *
 * \details This type corresponds to `SDL_FPoint`.
 *
 * \since 5.0.0
 */
using fpoint = basic_point<float>;

/**
 * \class basic_point
 *
 * \brief Represents a two-dimensional point.
 *
 * \serializable
 *
 * \details This class is designed as a wrapper for `SDL_Point` and `SDL_FPoint`. The
 * representation is specified by the type parameter.
 *
 * \note This point class will only use `int` or `float` as the actual internal
 * representation.
 *
 * \tparam T the representation type. Must be convertible to `int` or `float`.
 *
 * \since 5.0.0
 *
 * \see `ipoint`
 * \see `fpoint`
 * \see `point()`
 * \see `distance()`
 */
template <typename T>
class basic_point final
{
 public:
  /// \copydoc point_traits::isIntegral
  inline constexpr static bool isIntegral = point_traits<T>::isIntegral;

  /// \copydoc point_traits::isFloating
  inline constexpr static bool isFloating = point_traits<T>::isFloating;

  /// \copydoc point_traits::value_type
  using value_type = typename point_traits<T>::value_type;

  /// \copydoc point_traits::point_type
  using point_type = typename point_traits<T>::point_type;

  /// \name Construction
  /// \{

  /**
   * \brief Creates a zero-initialized point.
   *
   * \since 5.0.0
   */
  constexpr basic_point() noexcept = default;

  /**
   * \brief Creates a point with the specified coordinates.
   *
   * \param x the x-coordinate that will be used.
   * \param y the y-coordinate that will be used.
   *
   * \since 5.0.0
   */
  constexpr basic_point(const value_type x, const value_type y) noexcept
  {
    m_point.x = x;
    m_point.y = y;
  };

  /// \} End of construction

  /// \name Setters
  /// \{

  /**
   * \brief Sets the x-coordinate of the point.
   *
   * \param x the new x-coordinate.
   *
   * \since 5.0.0
   */
  constexpr void set_x(const value_type x) noexcept
  {
    m_point.x = x;
  }

  /**
   * \brief Sets the y-coordinate of the point.
   *
   * \param y the new y-coordinate.
   *
   * \since 5.0.0
   */
  constexpr void set_y(const value_type y) noexcept
  {
    m_point.y = y;
  }

  /// \} End of setters

  /// \name Getters
  /// \{

  /**
   * \brief Returns the x-coordinate of the point.
   *
   * \return the x-coordinate.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto x() const noexcept -> value_type
  {
    return m_point.x;
  }

  /**
   * \brief Returns the y-coordinate of the point.
   *
   * \return the y-coordinate.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto y() const noexcept -> value_type
  {
    return m_point.y;
  }

  /**
   * \brief Returns the internal point representation.
   *
   * \return a reference to the internal representation.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto get() noexcept -> point_type&
  {
    return m_point;
  }

  /// \copydoc get
  [[nodiscard]] constexpr auto get() const noexcept -> const point_type&
  {
    return m_point;
  }

  /**
   * \brief Returns a pointer to the internal point representation.
   *
   * \note Don't cache the returned pointer.
   *
   * \return a pointer to the point representation.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto data() noexcept -> point_type*
  {
    return &m_point;
  }

  /// \copydoc data
  [[nodiscard]] auto data() const noexcept -> const point_type*
  {
    return &m_point;
  }

  /// \} End of getters

  /// \name Conversions
  /// \{

  /**
   * \brief Converts to the internal representation.
   *
   * \return a copy of the internal point.
   *
   * \see `cen::cast`
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr explicit operator point_type() const noexcept
  {
    return m_point;
  }

  /// \copydoc data()
  [[nodiscard]] explicit operator point_type*() noexcept
  {
    return data();
  }

  /// \copydoc data()
  [[nodiscard]] explicit operator const point_type*() const noexcept
  {
    return data();
  }

  /// \} End of conversions

  /**
   * \brief Serializes the point.
   *
   * \details This function expects that the archive provides an overloaded `operator()`,
   * used for serializing data. This API is based on the Cereal serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the point.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_point.x, m_point.y);
  }

 private:
  point_type m_point{0, 0};
};

/// \name Point-related functions
/// \{

/**
 * \brief Creates a point instance with automatically deduced precision.
 *
 * \note The only supported precisions for points are `int` and `float`, so this function
 * will cast the supplied values to the corresponding type. For example, if you supply two
 * doubles to this function, the returned point will use float as the precision.
 *
 * \tparam T the deduced precision type, must be a numerical type other than `bool`.
 *
 * \param x the x-coordinate of the point.
 * \param y the y-coordinate of the point.
 *
 * \return the created point.
 *
 * \since 6.0.0
 */
template <typename T, enable_if_number_t<T> = 0>
[[nodiscard]] constexpr auto point(const T x, const T y) noexcept
    -> basic_point<typename point_traits<T>::value_type>
{
  using value_type = typename point_traits<T>::value_type;
  return basic_point<value_type>{static_cast<value_type>(x), static_cast<value_type>(y)};
}

/**
 * \brief Returns the distance between two points.
 *
 * \tparam T the representation type used by the points.
 *
 * \param from the first point.
 * \param to the second point.
 *
 * \return the distance between the two points.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto distance(const basic_point<T> from, const basic_point<T> to) noexcept ->
    typename point_traits<T>::value_type
{
  if constexpr (basic_point<T>::isIntegral) {
    const auto xDiff = std::pow(from.x() - to.x(), 2);
    const auto yDiff = std::pow(from.y() - to.y(), 2);
    const auto dist = std::sqrt(xDiff + yDiff);
    return static_cast<int>(std::round(dist));
  }
  else {
    return std::sqrt(std::pow(from.x() - to.x(), 2) + std::pow(from.y() - to.y(), 2));
  }
}

/// \} End of point-related functions

/// \name String conversions
/// \{

[[nodiscard]] inline auto to_string(const ipoint point) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("ipoint{{x: {}, y: {}}}", point.x(), point.y());
#else
  return "ipoint{x: " + std::to_string(point.x()) + ", y: " + std::to_string(point.y()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

[[nodiscard]] inline auto to_string(const fpoint point) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("fpoint{{x: {}, y: {}}}", point.x(), point.y());
#else
  return "fpoint{x: " + std::to_string(point.x()) + ", y: " + std::to_string(point.y()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

template <typename T>
auto operator<<(std::ostream& stream, const basic_point<T>& point) -> std::ostream&
{
  return stream << to_string(point);
}

/// \} End of streaming

/// \name Point cast specializations
/// \{

/**
 * \brief Converts an `fpoint` instance to the corresponding `ipoint`.
 *
 * \details This function casts the coordinates of the supplied point to `int`, and uses
 * the obtained values to create an `ipoint` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `ipoint` instance that corresponds to the supplied `fpoint`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const fpoint& from) noexcept -> ipoint
{
  const auto x = static_cast<int>(from.x());
  const auto y = static_cast<int>(from.y());
  return ipoint{x, y};
}

/**
 * \brief Converts an `ipoint` instance to the corresponding `fpoint`.
 *
 * \details This function casts the coordinates of the supplied point to `float`, and uses
 * the obtained values to create an `fpoint` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `fpoint` instance that corresponds to the supplied `ipoint`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const ipoint& from) noexcept -> fpoint
{
  const auto x = static_cast<float>(from.x());
  const auto y = static_cast<float>(from.y());
  return fpoint{x, y};
}

/**
 * \brief Converts an `SDL_FPoint` instance to the corresponding `SDL_Point`.
 *
 * \details This function casts the coordinates of the supplied point to `int`, and uses
 * the obtained values to create an `SDL_Point` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `SDL_Point` instance that corresponds to the supplied `SDL_FPoint`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const SDL_FPoint& from) noexcept -> SDL_Point
{
  const auto x = static_cast<int>(from.x);
  const auto y = static_cast<int>(from.y);
  return SDL_Point{x, y};
}

/**
 * \brief Converts an `SDL_Point` instance to the corresponding `SDL_FPoint`.
 *
 * \details This function casts the coordinates of the supplied point to `float`, and uses
 * the obtained values to create an `SDL_FPoint` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `SDL_FPoint` instance that corresponds to the supplied `SDL_Point`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const SDL_Point& from) noexcept -> SDL_FPoint
{
  const auto x = static_cast<float>(from.x);
  const auto y = static_cast<float>(from.y);
  return SDL_FPoint{x, y};
}

/// \} End of point cast specializations

/// \name Point addition and subtraction operators
/// \{

template <typename T>
[[nodiscard]] constexpr auto operator+(const basic_point<T>& lhs,
                                       const basic_point<T>& rhs) noexcept -> basic_point<T>
{
  return {lhs.x() + rhs.x(), lhs.y() + rhs.y()};
}

template <typename T>
[[nodiscard]] constexpr auto operator-(const basic_point<T>& lhs,
                                       const basic_point<T>& rhs) noexcept -> basic_point<T>
{
  return {lhs.x() - rhs.x(), lhs.y() - rhs.y()};
}

/// \} End of point addition and subtraction operators

/// \name Point comparison operators
/// \{

template <typename T>
[[nodiscard]] constexpr auto operator==(const basic_point<T> lhs,
                                        const basic_point<T> rhs) noexcept -> bool
{
  return (lhs.x() == rhs.x()) && (lhs.y() == rhs.y());
}

template <typename T>
[[nodiscard]] constexpr auto operator!=(const basic_point<T> lhs,
                                        const basic_point<T> rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of point comparison operators

/// \} End of group math

}  // namespace cen

#endif  // CENTURION_POINT_HEADER

namespace cen {

/// \addtogroup input
/// \{

/**
 * \class mouse
 *
 * \brief Provides information about the mouse state, which is an alternative to dealing
 * with mouse events.
 *
 * \since 3.0.0
 *
 * \see `keyboard`
 */
class mouse final
{
 public:
  /**
   * \brief Creates a `mouse` instance.
   *
   * \since 3.0.0
   */
  mouse() noexcept = default;

  /**
   * \brief Updates the mouse state. The window width and height will be adjusted to be at
   * least 1.
   *
   * \param windowWidth the current window width, set to 1 by default.
   * \param windowHeight the current window height, set to 1 by default.
   *
   * \since 3.0.0
   */
  void update(const int windowWidth = 1, const int windowHeight = 1) noexcept
  {
    m_oldX = m_mouseX;
    m_oldY = m_mouseY;
    m_prevLeftPressed = m_leftPressed;
    m_prevRightPressed = m_rightPressed;

    {
      const u32 mask = SDL_GetMouseState(&m_mouseX, &m_mouseY);
      m_leftPressed = mask & SDL_BUTTON(SDL_BUTTON_LEFT);
      m_rightPressed = mask & SDL_BUTTON(SDL_BUTTON_RIGHT);
    }

    {
      const auto xRatio =
          static_cast<float>(m_mouseX) / static_cast<float>(detail::max(windowWidth, 1));
      const auto adjustedX = xRatio * static_cast<float>(m_logicalWidth);

      const auto yRatio =
          static_cast<float>(m_mouseY) / static_cast<float>(detail::max(windowHeight, 1));
      const auto adjustedY = yRatio * static_cast<float>(m_logicalHeight);

      m_mouseX = static_cast<int>(adjustedX);
      m_mouseY = static_cast<int>(adjustedY);
    }
  }

  /**
   * \brief Updates the mouse state.
   *
   * \param size the size of the window.
   *
   * \since 5.3.0
   */
  void update(const iarea size) noexcept
  {
    update(size.width, size.height);
  }

  /**
   * \brief Resets the screen and logical dimensions of the mouse state instance.
   *
   * \since 3.0.0
   */
  void reset() noexcept
  {
    m_logicalWidth = 1;
    m_logicalHeight = 1;
  }

  /**
   * \brief Sets the logical width that will be used to determine the mouse position.
   *
   * \details The supplied value will be adjusted to be at least 1.
   *
   * \param logicalWidth the logical width that will be used to determine the mouse
   * position.
   *
   * \since 3.0.0
   */
  void set_logical_width(const int logicalWidth) noexcept
  {
    m_logicalWidth = detail::max(logicalWidth, 1);
  }

  /**
   * \brief Sets the logical height that will be used to determine the mouse position.
   *
   * \details The supplied value will be adjusted to be at least 1.
   *
   * \param logicalHeight the logical height that will be used to determine the mouse
   * position.
   *
   * \since 3.0.0
   */
  void set_logical_height(const int logicalHeight) noexcept
  {
    m_logicalHeight = detail::max(logicalHeight, 1);
  }

  /**
   * \brief Sets the current logical window size.
   *
   * \param size the logical size that will be used to determine the mouse position.
   *
   * \since 5.3.0
   */
  void set_logical_size(const iarea size) noexcept
  {
    set_logical_width(size.width);
    set_logical_height(size.height);
  }

  /**
   * \brief Indicates whether or not the left mouse button was released.
   *
   * \return `true` if the left mouse button was released; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto was_left_button_released() const noexcept -> bool
  {
    return !m_leftPressed && m_prevLeftPressed;
  }

  /**
   * \brief Indicates whether or not the right mouse button was released.
   *
   * \return `true` if the right mouse button was released; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto was_right_button_released() const noexcept -> bool
  {
    return !m_rightPressed && m_prevRightPressed;
  }

  /**
   * \brief Indicates whether or not the mouse was moved.
   *
   * \return `true` if the mouse was moved; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto was_moved() const noexcept -> bool
  {
    return (m_mouseX != m_oldX) || (m_mouseY != m_oldY);
  }

  /**
   * \brief Returns the x-coordinate of the mouse.
   *
   * \return the x-coordinate of the mouse.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto x() const noexcept -> int
  {
    return m_mouseX;
  }

  /**
   * \brief Returns the y-coordinate of the mouse.
   *
   * \return the y-coordinate of the mouse.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto y() const noexcept -> int
  {
    return m_mouseY;
  }

  /**
   * \brief Returns the position of the mouse.
   *
   * \return the current position of the mouse cursor.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto position() const noexcept -> ipoint
  {
    return {m_mouseX, m_mouseY};
  }

  /**
   * \brief Returns the logical width used by the mouse state instance.
   *
   * \return the logical width used by the mouse state instance, 1 is used by default.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto logical_width() const noexcept -> int
  {
    return m_logicalWidth;
  }

  /**
   * \brief Returns the logical height used by the mouse state instance.
   *
   * \return the logical height used by the mouse state instance, 1 is used by default.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto logical_height() const noexcept -> int
  {
    return m_logicalHeight;
  }

  /**
   * \brief Returns the logical size used by the mouse state instance.
   *
   * \return the logical size used.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto logical_size() const noexcept -> iarea
  {
    return {m_logicalWidth, m_logicalHeight};
  }

  /**
   * \brief Indicates whether or not the left mouse button is currently pressed.
   *
   * \return `true` if the left mouse button is pressed; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_left_button_pressed() const noexcept -> bool
  {
    return m_leftPressed;
  }

  /**
   * \brief Indicates whether or not the right mouse button is currently pressed.
   *
   * \return `true` if the right mouse button is pressed; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_right_button_pressed() const noexcept -> bool
  {
    return m_rightPressed;
  }

 private:
  int m_mouseX{};
  int m_mouseY{};
  int m_oldX{};
  int m_oldY{};
  int m_logicalWidth{1};
  int m_logicalHeight{1};
  bool m_leftPressed{};
  bool m_rightPressed{};
  bool m_prevLeftPressed{};
  bool m_prevRightPressed{};
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a mouse.
 *
 * \param mouse the mouse instance that will be converted.
 *
 * \return a string that represents the mouse.
 *
 * \since 6.2.0
 */
[[nodiscard]] inline auto to_string(const mouse& mouse) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("mouse{{x: {}, y: {}}}", mouse.x(), mouse.y());
#else
  return "mouse{x: " + std::to_string(mouse.x()) + ", y: " + std::to_string(mouse.y()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a mouse.
 *
 * \param stream the output stream that will be used.
 * \param mouse the mouse that will be printed.
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const mouse& mouse) -> std::ostream&
{
  return stream << to_string(mouse);
}

/// \} End of streaming

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_MOUSE_HEADER
// #include "centurion/input/scan_code.hpp"
#ifndef CENTURION_SCAN_CODE_HEADER
#define CENTURION_SCAN_CODE_HEADER

#include <SDL.h>

#include <cassert>  // assert
#include <ostream>  // ostream
#include <string>   // string

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/not_null.hpp"

// #include "../core/str.hpp"

// #include "../core/version.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \class scan_code
 *
 * \brief Represents a scan code.
 *
 * \serializable
 *
 * \details Scan codes represent the physical location of a key on the
 * keyboard. Use the associated key code associated with the location to give
 * the key press meaning.
 *
 * Scan codes are meant to be layout-independent. Think of this as "the user
 * pressed the Q key as it would be on a US QWERTY keyboard" regardless of
 * whether this is actually a European keyboard or a Dvorak keyboard or
 * whatever. *The scancode is always the same key position.*
 *
 * \since 5.0.0
 *
 * \see `key_code`
 * \see `cen::scancodes`
 */
class scan_code final
{
 public:
  /// \name Construction
  /// \{

  /**
   * \brief Creates a `scan_code` instance with the `SDL_SCANCODE_UNKNOWN` scan
   * code.
   *
   * \since 5.0.0
   */
  constexpr scan_code() noexcept = default;

  constexpr scan_code(const scan_code&) noexcept = default;

  constexpr scan_code(scan_code&&) noexcept = default;

  /**
   * \brief Creates a `scan_code` instance with the specified scan code.
   *
   * \param scancode the scan code that will be used.
   *
   * \since 5.0.0
   */
  constexpr /*implicit*/ scan_code(const SDL_Scancode scancode) noexcept : m_code{scancode}
  {}

  /**
   * \brief Creates a `scan_code` instance based on a key code.
   *
   * \details The created `scan_code` will use the scan code obtained
   * by converting the specified key code.
   *
   * \param key the key code that will be converted and used.
   *
   * \since 5.0.0
   */
  explicit scan_code(const SDL_Keycode key) noexcept : m_code{SDL_GetScancodeFromKey(key)}
  {}

  /**
   * \brief Creates a `scan_code` instance based on the specified name.
   *
   * \details If the specified name isn't recognized, `SDL_SCANCODE_UNKNOWN` is
   * used as the scan code.
   *
   * \param name the name of the key, mustn't be null.
   *
   * \see `SDL_GetScancodeFromName`
   *
   * \since 5.0.0
   */
  explicit scan_code(const not_null<str> name) noexcept : m_code{SDL_GetScancodeFromName(name)}
  {}

  /**
   * \brief Creates a `scan_code` instance based on the specified name.
   *
   * \details If the specified name isn't recognized, `SDL_SCANCODE_UNKNOWN` is
   * used as the scan code.
   *
   * \param name the name of the key.
   *
   * \since 5.3.0
   */
  explicit scan_code(const std::string& name) noexcept : scan_code{name.c_str()}
  {}

  /// \} End of construction

  /// \name Assignment operators
  /// \{

  constexpr auto operator=(const scan_code&) noexcept -> scan_code& = default;

  constexpr auto operator=(scan_code&&) noexcept -> scan_code& = default;

  /**
   * \brief Sets the scan code used to the specified scan code.
   *
   * \param code the scan code that will be used.
   *
   * \return the `scan_code` instance.
   *
   * \since 5.0.0
   */
  constexpr auto operator=(const SDL_Scancode code) noexcept -> scan_code&
  {
    m_code = code;
    return *this;
  }

  /**
   * \brief Sets the scan code used to be the converted version of the
   * supplied key code.
   *
   * \param keycode the key code that will be converted and used.
   *
   * \return the `scan_code` instance.
   *
   * \since 5.0.0
   */
  auto operator=(const SDL_Keycode keycode) noexcept -> scan_code&
  {
    m_code = SDL_GetScancodeFromKey(keycode);
    return *this;
  }

  /**
   * \brief Sets the scan code used to be the one associated with the
   * specified name.
   *
   * \details If the specified name isn't recognized, `SDL_SCANCODE_UNKNOWN` is
   * used as the scan code.
   *
   * \param name the name of the key, mustn't be null.
   *
   * \return the `scan_code` instance.
   *
   * \since 5.0.0
   */
  auto operator=(const not_null<str> name) noexcept -> scan_code&
  {
    assert(name);
    m_code = SDL_GetScancodeFromName(name);
    return *this;
  }

  /**
   * \brief Sets the scan code used to be the one associated with the
   * specified name.
   *
   * \details If the specified name isn't recognized, `SDL_SCANCODE_UNKNOWN` is
   * used as the scan code.
   *
   * \param name the name of the key.
   *
   * \return the `scan_code` instance.
   *
   * \since 5.3.0
   */
  auto operator=(const std::string& name) noexcept -> scan_code&
  {
    return operator=(name.c_str());  // NOLINT
  }

  /// \} End of assignment operators

  /// \name Queries
  /// \{

  /**
   * \brief Returns the total amount of scan codes.
   *
   * \return the amount of scan codes.
   *
   * \since 5.1.0
   */
  [[nodiscard]] constexpr static auto count() noexcept -> int
  {
    return SDL_NUM_SCANCODES;
  }

  /**
   * \brief Indicates whether or not the stored scan code is
   * `SDL_SCANCODE_UNKNOWN`.
   *
   * \return `true` if the internal scan code is `SDL_SCANCODE_UNKNOWN`;
   * `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto unknown() const noexcept -> bool
  {
    return m_code == SDL_SCANCODE_UNKNOWN;
  }

  /**
   * \brief Returns the name associated with the scan code.
   *
   * \return the name associated with the scan code.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto name() const -> std::string
  {
    return SDL_GetScancodeName(m_code);
  }

  /**
   * \brief Returns the corresponding `SDL_KeyCode`.
   *
   * \return the key code associated with the internal scan code.
   *
   * \see `SDL_GetKeyFromScancode`
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto to_key_code() const noexcept -> SDL_KeyCode
  {
    return static_cast<SDL_KeyCode>(SDL_GetKeyFromScancode(m_code));
  }

  /**
   * \brief Returns the internal scan code.
   *
   * \return the internal scan code.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto get() const noexcept -> SDL_Scancode
  {
    return m_code;
  }

  /// \} End of queries

  /// \name Conversions
  /// \{

  /**
   * \brief Converts to `SDL_Scancode`.
   *
   * \return the internal scan code.
   *
   * \since 5.0.0
   */
  constexpr explicit operator SDL_Scancode() const noexcept
  {
    return m_code;
  }

  /**
   * \brief Converts to `SDL_KeyCode`.
   *
   * \return the key code associated with the internal scan code.
   *
   * \see `SDL_GetKeyFromScancode`
   *
   * \since 5.0.0
   */
  explicit operator SDL_KeyCode() const noexcept
  {
    return to_key_code();
  }

  /// \} End of conversions

  /**
   * \brief Serializes the scan code.
   *
   * \details This function expects that the archive provides an overloaded
   * `operator()`, used for serializing data. This API is based on the Cereal
   * serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the scan code.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_code);
  }

 private:
  SDL_Scancode m_code{SDL_SCANCODE_UNKNOWN};
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a scan code.
 *
 * \param code the scan code that will be converted.
 *
 * \return a textual representation of the scan code.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto to_string(const scan_code& code) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("scan_code{{key: {}}}", code.name());
#else
  return "scan_code{key: " + code.name() + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a scan code using a stream.
 *
 * \param stream the stream that will be used.
 * \param scanCode the scan code that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
inline auto operator<<(std::ostream& stream, const scan_code& scanCode) -> std::ostream&
{
  return stream << to_string(scanCode);
}

/// \} End of streaming

/// \name Scan code comparison operators
/// \{

/**
 * \brief Indicates whether or not two scan codes are the same.
 *
 * \param lhs the left-hand side scan code.
 * \param rhs the right-hand side scan code.
 *
 * \return `true` if the scan codes are the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator==(const scan_code& lhs, const scan_code& rhs) noexcept
    -> bool
{
  return lhs.get() == rhs.get();
}

/**
 * \brief Indicates whether or not two scan codes aren't the same.
 *
 * \param lhs the left-hand side scan code.
 * \param rhs the right-hand side scan code.
 *
 * \return `true` if the scan codes aren't the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator!=(const scan_code& lhs, const scan_code& rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \} End of scan code comparison operators

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_SCAN_CODE_HEADER
// #include "centurion/input/scancodes.hpp"
#ifndef CENTURION_SCANCODES_HEADER
#define CENTURION_SCANCODES_HEADER

#include <SDL.h>

// #include "scan_code.hpp"


namespace cen {

/**
 * \namespace cen::scancodes
 *
 * \brief Provides a collection of `scan_code` constants.
 *
 * \ingroup input
 *
 * \details Far from all scan codes are provided. Instead, the most commonly used scan
 * codes are available.
 */
namespace scancodes {

/// \addtogroup input
/// \{

/// \name Scan code constants
/// \{

/**
 * \brief Represents an unknown key.
 *
 * \since 5.0.0
 */
inline constexpr scan_code unknown;

/**
 * \brief Represents the key "A".
 *
 * \since 5.0.0
 */
inline constexpr scan_code a{SDL_SCANCODE_A};

/**
 * \brief Represents the key "B".
 *
 * \since 5.0.0
 */
inline constexpr scan_code b{SDL_SCANCODE_B};

/**
 * \brief Represents the key "C".
 *
 * \since 5.0.0
 */
inline constexpr scan_code c{SDL_SCANCODE_C};

/**
 * \brief Represents the key "D".
 *
 * \since 5.0.0
 */
inline constexpr scan_code d{SDL_SCANCODE_D};

/**
 * \brief Represents the key "E".
 *
 * \since 5.0.0
 */
inline constexpr scan_code e{SDL_SCANCODE_E};

/**
 * \brief Represents the key "F".
 *
 * \since 5.0.0
 */
inline constexpr scan_code f{SDL_SCANCODE_F};

/**
 * \brief Represents the key "G".
 *
 * \since 5.0.0
 */
inline constexpr scan_code g{SDL_SCANCODE_G};

/**
 * \brief Represents the key "H".
 *
 * \since 5.0.0
 */
inline constexpr scan_code h{SDL_SCANCODE_H};

/**
 * \brief Represents the key "I".
 *
 * \since 5.0.0
 */
inline constexpr scan_code i{SDL_SCANCODE_I};

/**
 * \brief Represents the key "J".
 *
 * \since 5.0.0
 */
inline constexpr scan_code j{SDL_SCANCODE_J};

/**
 * \brief Represents the key "K".
 *
 * \since 5.0.0
 */
inline constexpr scan_code k{SDL_SCANCODE_K};

/**
 * \brief Represents the key "L".
 *
 * \since 5.0.0
 */
inline constexpr scan_code l{SDL_SCANCODE_L};

/**
 * \brief Represents the key "M".
 *
 * \since 5.0.0
 */
inline constexpr scan_code m{SDL_SCANCODE_M};

/**
 * \brief Represents the key "N".
 *
 * \since 5.0.0
 */
inline constexpr scan_code n{SDL_SCANCODE_N};

/**
 * \brief Represents the key "O".
 *
 * \since 5.0.0
 */
inline constexpr scan_code o{SDL_SCANCODE_O};

/**
 * \brief Represents the key "P".
 *
 * \since 5.0.0
 */
inline constexpr scan_code p{SDL_SCANCODE_P};

/**
 * \brief Represents the key "Q".
 *
 * \since 5.0.0
 */
inline constexpr scan_code q{SDL_SCANCODE_Q};

/**
 * \brief Represents the key "R".
 *
 * \since 5.0.0
 */
inline constexpr scan_code r{SDL_SCANCODE_R};

/**
 * \brief Represents the key "S".
 *
 * \since 5.0.0
 */
inline constexpr scan_code s{SDL_SCANCODE_S};

/**
 * \brief Represents the key "T".
 *
 * \since 5.0.0
 */
inline constexpr scan_code t{SDL_SCANCODE_T};

/**
 * \brief Represents the key "U".
 *
 * \since 5.0.0
 */
inline constexpr scan_code u{SDL_SCANCODE_U};

/**
 * \brief Represents the key "V".
 *
 * \since 5.0.0
 */
inline constexpr scan_code v{SDL_SCANCODE_V};

/**
 * \brief Represents the key "W".
 *
 * \since 5.0.0
 */
inline constexpr scan_code w{SDL_SCANCODE_W};

/**
 * \brief Represents the key "X".
 *
 * \since 5.0.0
 */
inline constexpr scan_code x{SDL_SCANCODE_X};

/**
 * \brief Represents the key "Y".
 *
 * \since 5.0.0
 */
inline constexpr scan_code y{SDL_SCANCODE_Y};

/**
 * \brief Represents the key "Z".
 *
 * \since 5.0.0
 */
inline constexpr scan_code z{SDL_SCANCODE_Z};

/**
 * \brief Represents the key "1".
 *
 * \note This is not for a potential "1" key on the key pad.
 *
 * \since 5.0.0
 */
inline constexpr scan_code one{SDL_SCANCODE_1};

/**
 * \brief Represents the key "2".
 *
 * \note This is not for a potential "2" key on the key pad.
 *
 * \since 5.0.0
 */
inline constexpr scan_code two{SDL_SCANCODE_2};

/**
 * \brief Represents the key "3".
 *
 * \note This is not for a potential "3" key on the key pad.
 *
 * \since 5.0.0
 */
inline constexpr scan_code three{SDL_SCANCODE_3};

/**
 * \brief Represents the key "4".
 *
 * \note This is not for a potential "4" key on the key pad.
 *
 * \since 5.0.0
 */
inline constexpr scan_code four{SDL_SCANCODE_4};

/**
 * \brief Represents the key "5".
 *
 * \note This is not for a potential "5" key on the key pad.
 *
 * \since 5.0.0
 */
inline constexpr scan_code five{SDL_SCANCODE_5};

/**
 * \brief Represents the key "6".
 *
 * \note This is not for a potential "6" key on the key pad.
 *
 * \since 5.0.0
 */
inline constexpr scan_code six{SDL_SCANCODE_6};

/**
 * \brief Represents the key "7".
 *
 * \note This is not for a potential "7" key on the key pad.
 *
 * \since 5.0.0
 */
inline constexpr scan_code seven{SDL_SCANCODE_7};

/**
 * \brief Represents the key "8".
 *
 * \note This is not for a potential "8" key on the key pad.
 *
 * \since 5.0.0
 */
inline constexpr scan_code eight{SDL_SCANCODE_8};

/**
 * \brief Represents the key "9".
 *
 * \note This is not for a potential "9" key on the key pad.
 *
 * \since 5.0.0
 */
inline constexpr scan_code nine{SDL_SCANCODE_9};

/**
 * \brief Represents the key "0".
 *
 * \note This is not for a potential "0" key on the key pad.
 *
 * \since 5.0.0
 */
inline constexpr scan_code zero{SDL_SCANCODE_0};

/**
 * \brief Represents the function key "F1".
 *
 * \since 5.0.0
 */
inline constexpr scan_code f1{SDL_SCANCODE_F1};

/**
 * \brief Represents the function key "F2".
 *
 * \since 5.0.0
 */
inline constexpr scan_code f2{SDL_SCANCODE_F2};

/**
 * \brief Represents the function key "F3".
 *
 * \since 5.0.0
 */
inline constexpr scan_code f3{SDL_SCANCODE_F3};

/**
 * \brief Represents the function key "F4".
 *
 * \since 5.0.0
 */
inline constexpr scan_code f4{SDL_SCANCODE_F4};

/**
 * \brief Represents the function key "F5".
 *
 * \since 5.0.0
 */
inline constexpr scan_code f5{SDL_SCANCODE_F5};

/**
 * \brief Represents the function key "F6".
 *
 * \since 5.0.0
 */
inline constexpr scan_code f6{SDL_SCANCODE_F6};

/**
 * \brief Represents the function key "F7".
 *
 * \since 5.0.0
 */
inline constexpr scan_code f7{SDL_SCANCODE_F7};

/**
 * \brief Represents the function key "F8".
 *
 * \since 5.0.0
 */
inline constexpr scan_code f8{SDL_SCANCODE_F8};

/**
 * \brief Represents the function key "F9".
 *
 * \since 5.0.0
 */
inline constexpr scan_code f9{SDL_SCANCODE_F9};

/**
 * \brief Represents the function key "F10".
 *
 * \since 5.0.0
 */
inline constexpr scan_code f10{SDL_SCANCODE_F10};

/**
 * \brief Represents the function key "F11".
 *
 * \since 5.0.0
 */
inline constexpr scan_code f11{SDL_SCANCODE_F11};

/**
 * \brief Represents the function key "F12".
 *
 * \since 5.0.0
 */
inline constexpr scan_code f12{SDL_SCANCODE_F12};

/**
 * \brief Represents the left arrow key.
 *
 * \since 5.0.0
 */
inline constexpr scan_code left{SDL_SCANCODE_LEFT};

/**
 * \brief Represents the right arrow key.
 *
 * \since 5.0.0
 */
inline constexpr scan_code right{SDL_SCANCODE_RIGHT};

/**
 * \brief Represents the up arrow key.
 *
 * \since 5.0.0
 */
inline constexpr scan_code up{SDL_SCANCODE_UP};

/**
 * \brief Represents the down arrow key.
 *
 * \since 5.0.0
 */
inline constexpr scan_code down{SDL_SCANCODE_DOWN};

/**
 * \brief Represents the "Space" key.
 *
 * \since 5.0.0
 */
inline constexpr scan_code space{SDL_SCANCODE_SPACE};

/**
 * \brief Represents the "Enter" key.
 *
 * \note This key is also referred to as the "Return" key.
 *
 * \since 5.0.0
 */
inline constexpr scan_code enter{SDL_SCANCODE_RETURN};

/**
 * \brief Represents the "Escape" key.
 *
 * \since 5.0.0
 */
inline constexpr scan_code escape{SDL_SCANCODE_ESCAPE};

/**
 * \brief Represents the "Backspace" key.
 *
 * \since 5.0.0
 */
inline constexpr scan_code backspace{SDL_SCANCODE_BACKSPACE};

/**
 * \brief Represents the "Tab" key.
 *
 * \since 5.0.0
 */
inline constexpr scan_code tab{SDL_SCANCODE_TAB};

/**
 * \brief Represents the "Caps Lock" key.
 *
 * \since 5.0.0
 */
inline constexpr scan_code caps_lock{SDL_SCANCODE_CAPSLOCK};

/**
 * \brief Represents the left "Shift" key.
 *
 * \since 5.0.0
 */
inline constexpr scan_code left_shift{SDL_SCANCODE_LSHIFT};

/**
 * \brief Represents the right "Shift" key.
 *
 * \since 5.0.0
 */
inline constexpr scan_code right_shift{SDL_SCANCODE_RSHIFT};

/**
 * \brief Represents the left "CTRL" key.
 *
 * \since 5.0.0
 */
inline constexpr scan_code left_ctrl{SDL_SCANCODE_LCTRL};

/**
 * \brief Represents the right "CTRL" key.
 *
 * \since 5.0.0
 */
inline constexpr scan_code right_ctrl{SDL_SCANCODE_RCTRL};

/**
 * \brief Represents the left "Alt" key.
 *
 * \since 5.0.0
 */
inline constexpr scan_code left_alt{SDL_SCANCODE_LALT};

/**
 * \brief Represents the right "Alt" key.
 *
 * \since 5.0.0
 */
inline constexpr scan_code right_alt{SDL_SCANCODE_RALT};

/**
 * \brief Represents the left "GUI" key.
 *
 * \details On Windows, this is the "Windows key"; for macs it's the "CMD" key, etc.
 *
 * \since 5.0.0
 */
inline constexpr scan_code left_gui{SDL_SCANCODE_LGUI};

/**
 * \brief Represents the right "GUI" key.
 *
 * \details On Windows, this is the "Windows" key; for macs it's the "CMD" key, etc.
 *
 * \since 5.0.0
 */
inline constexpr scan_code right_gui{SDL_SCANCODE_RGUI};

/// \} End of scan code constants

/// \} End of group input

}  // namespace scancodes

}  // namespace cen

#endif  // CENTURION_SCANCODES_HEADER

// #include "centurion/input/sensor.hpp"
#ifndef CENTURION_SENSOR_HEADER
#define CENTURION_SENSOR_HEADER

#include <SDL.h>

#include <array>     // array
#include <optional>  // optional
#include <ostream>   // ostream
#include <string>    // string, to_string

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/owner.hpp"

// #include "../core/str.hpp"

// #include "../core/str_or_na.hpp"

// #include "../detail/address_of.hpp"

// #include "../detail/owner_handle_api.hpp"

// #include "sensor_type.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \typedef sensor_id
 *
 * \brief Used for unique sensor instance identifiers.
 *
 * \since 5.2.0
 */
using sensor_id = SDL_SensorID;

template <typename T>
class basic_sensor;

/**
 * \typedef sensor
 *
 * \brief Represents an owning sensor device.
 *
 * \since 5.2.0
 */
using sensor = basic_sensor<detail::owning_type>;

/**
 * \typedef sensor_handle
 *
 * \brief Represents a non-owning sensor device.
 *
 * \since 5.2.0
 */
using sensor_handle = basic_sensor<detail::handle_type>;

/**
 * \class basic_sensor
 *
 * \brief Represents a sensor device.
 *
 * \ownerhandle `sensor`/`sensor_handle`
 *
 * \see `sensor`
 * \see `sensor_handle`
 *
 * \since 5.2.0
 */
template <typename T>
class basic_sensor final
{
 public:
  /// \name Construction
  /// \{

  /**
   * \brief Creates a sensor instance based on an existing pointer.
   *
   * \note The created instance will claim ownership of the supplied pointer if the class
   * has owning semantics.
   *
   * \param sensor a pointer to the SDL sensor data.
   *
   * \throws cen_error if the supplied pointer is null and the class has owning semantics.
   *
   * \since 5.2.0
   */
  explicit basic_sensor(maybe_owner<SDL_Sensor*> sensor) noexcept(!detail::is_owning<T>())
      : m_sensor{sensor}
  {
    if constexpr (detail::is_owning<T>()) {
      if (!m_sensor) {
        throw cen_error{"Null sensor pointer!"};
      }
    }
  }

  /**
   * \brief Creates an owning sensor instance based on a device index.
   *
   * \param index the device index of the sensor.
   *
   * \throws sdl_error if the sensor cannot be opened.
   *
   * \since 5.2.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_sensor(const int index = 0) : m_sensor{SDL_SensorOpen(index)}
  {
    if (!m_sensor) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates a sensor handle based on an owning sensor.
   *
   * \param owner the associated owning sensor.
   *
   * \since 5.2.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit basic_sensor(const sensor& owner) noexcept : m_sensor{owner.get()}
  {}

  /// \} End of construction

  /**
   * \brief Updates the state of all open sensors.
   *
   * \note This is done automatically by the event loop if sensor events are enabled.
   *
   * \since 5.2.0
   */
  static void update() noexcept
  {
    SDL_SensorUpdate();
  }

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Locks access to the sensors for multi-threading.
   *
   * \note Refer to the SDL documentation for more details regarding this.
   *
   * \see SDL_LockSensors
   *
   * \since 5.2.0
   */
  static void lock() noexcept
  {
    SDL_LockSensors();
  }

  /**
   * \brief Unlocks access to the sensors.
   *
   * \note Refer to the SDL documentation for more details regarding this.
   *
   * \see SDL_UnlockSensors
   *
   * \since 5.2.0
   */
  static void unlock() noexcept
  {
    SDL_UnlockSensors();
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Returns the amount of sensors currently attached to the system.
   *
   * \return the current amount of system sensors.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto count() noexcept -> int
  {
    return SDL_NumSensors();
  }

  /// \name Instance-based queries
  /// \{

  /**
   * \brief Returns the unique identifier associated with the sensor instance.
   *
   * \return a unique instance ID.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto id() const noexcept -> sensor_id
  {
    return SDL_SensorGetInstanceID(m_sensor);
  }

  /**
   * \brief Returns the name associated with the sensor device.
   *
   * \return the name of the sensor device; a null pointer is returned if the name isn't
   * available.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto name() const noexcept -> str
  {
    return SDL_SensorGetName(m_sensor);
  }

  /**
   * \brief Returns the type associated with the sensor device.
   *
   * \return the type of the sensor device.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto type() const noexcept -> sensor_type
  {
    return static_cast<sensor_type>(SDL_SensorGetType(m_sensor));
  }

  /**
   * \brief Returns the non-portable type associated with the sensor.
   *
   * \return a non-portable sensor type value.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto non_portable_type() const noexcept -> int
  {
    return SDL_SensorGetNonPortableType(m_sensor);
  }

  /**
   * \brief Returns the sensor-dependent data.
   *
   * \tparam Size the number of data elements, varies from sensor to sensor.
   *
   * \return the data associated with the sensor; `std::nullopt` if something goes wrong.
   *
   * \since 5.2.0
   */
  template <usize Size>
  [[nodiscard]] auto data() const noexcept -> std::optional<std::array<float, Size>>
  {
    std::array<float, Size> array{};
    if (SDL_SensorGetData(m_sensor, array.data(), isize(array)) != -1) {
      return array;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns a pointer to the associated SDL sensor.
   *
   * \warning Don't take ownership of the returned pointer!
   *
   * \return a pointer to the associated SDL sensor.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_Sensor*
  {
    return m_sensor.get();
  }

  /// \} End of instance-based queries

  /// \name Index-based queries
  /// \{

  /**
   * \brief Returns the unique identifier associated with a sensor instance.
   *
   * \param index the index of the sensor device that will be queried.
   *
   * \return the unique instance ID associated with a sensor; `std::nullopt` if the index
   * is invalid.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto id(const int index) noexcept -> std::optional<sensor_id>
  {
    const auto id = SDL_SensorGetDeviceInstanceID(index);
    if (id != -1) {
      return id;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the name associated with a sensor device.
   *
   * \param index the index of the sensor device that will be queried.
   *
   * \return the name of the sensor device; a null pointer is returned if the name isn't
   * available or if the index was invalid.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto name(const int index) noexcept -> str
  {
    return SDL_SensorGetDeviceName(index);
  }

  /**
   * \brief Returns the type associated with a sensor device.
   *
   * \param index the index of the sensor device that will be queried.
   *
   * \return the type of the sensor device.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto type(const int index) noexcept -> sensor_type
  {
    return static_cast<sensor_type>(SDL_SensorGetDeviceType(index));
  }

  /**
   * \brief Returns the non-portable type associated with a sensor.
   *
   * \param index the index of the sensor device that will be queried.
   *
   * \return a non-portable sensor type value; `std::nullopt` if the index is invalid.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto non_portable_type(const int index) noexcept -> std::optional<int>
  {
    const auto type = SDL_SensorGetDeviceNonPortableType(index);
    if (type != -1) {
      return type;
    }
    else {
      return std::nullopt;
    }
  }

  /// \} End of index-based queries

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not the handle holds a non-null pointer.
   *
   * \return `true` if the handle holds a non-null pointer; `false` otherwise.
   *
   * \since 5.2.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit operator bool() const noexcept
  {
    return m_sensor != nullptr;
  }

  /// \} End of conversions

 private:
  struct deleter final
  {
    void operator()(SDL_Sensor* sensor) noexcept
    {
      SDL_SensorClose(sensor);
    }
  };
  detail::pointer_manager<T, SDL_Sensor, deleter> m_sensor;
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a sensor instance.
 *
 * \param sensor the sensor that will be converted.
 *
 * \return a string that represents a sensor instance.
 *
 * \since 5.2.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_sensor<T>& sensor) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("sensor{{data: {}, id: {}, name: {}}}",
                     detail::address_of(sensor.get()),
                     sensor.id(),
                     str_or_na(sensor.name()));
#else
  return "sensor{data: " + detail::address_of(sensor.get()) +
         ", id: " + std::to_string(sensor.id()) + ", name: " + str_or_na(sensor.name()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a sensor instance using a stream.
 *
 * \param stream the stream that will be used.
 * \param sensor the sensor that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.2.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_sensor<T>& sensor) -> std::ostream&
{
  return stream << to_string(sensor);
}

/// \} End of streaming

/**
 * \brief Returns the standard gravity value.
 *
 * \return the standard gravity value.
 *
 * \since 5.2.0
 */
[[nodiscard]] constexpr auto standard_gravity() noexcept -> float
{
  return SDL_STANDARD_GRAVITY;
}

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_SENSOR_HEADER

// #include "centurion/input/sensor_type.hpp"
#ifndef CENTURION_SENSOR_TYPE_HEADER
#define CENTURION_SENSOR_TYPE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup input
/// \{

/**
 * \enum sensor_type
 *
 * \brief Provides values that represent different sensor types.
 *
 * \see SDL_SensorType
 *
 * \since 5.2.0
 */
enum class sensor_type
{
  invalid = SDL_SENSOR_INVALID,      ///< Invalid sensor
  unknown = SDL_SENSOR_UNKNOWN,      ///< Unknown sensor
  accelerometer = SDL_SENSOR_ACCEL,  ///< Accelerometer
  gyroscope = SDL_SENSOR_GYRO        ///< Gyroscope
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied sensor type.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(sensor_type::gyroscope) == "gyroscope"`.
 *
 * \param type the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const sensor_type type) -> std::string_view
{
  switch (type) {
    case sensor_type::invalid:
      return "invalid";

    case sensor_type::unknown:
      return "unknown";

    case sensor_type::accelerometer:
      return "accelerometer";

    case sensor_type::gyroscope:
      return "gyroscope";

    default:
      throw cen_error{"Did not recognize sensor type!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a sensor type enumerator.
 *
 * \param stream the output stream that will be used.
 * \param type the enumerator that will be printed.
 *
 * \see `to_string(sensor_type)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const sensor_type type) -> std::ostream&
{
  return stream << to_string(type);
}

/// \} End of streaming

/// \name Sensor type comparison operators
/// \{

/**
 * \brief Indicates whether or not two sensor types values are equal.
 *
 * \param lhs the left-hand side sensor type.
 * \param rhs the right-hand side sensor type.
 *
 * \return `true` if the two sensor types are equal; `false` otherwise.
 *
 * \since 5.2.0
 */
[[nodiscard]] constexpr auto operator==(const sensor_type lhs,
                                        const SDL_SensorType rhs) noexcept -> bool
{
  return static_cast<SDL_SensorType>(lhs) == rhs;
}

/// \copydoc operator==(const sensor_type, const SDL_SensorType)
[[nodiscard]] constexpr auto operator==(const SDL_SensorType lhs,
                                        const sensor_type rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two sensor types values aren't equal.
 *
 * \param lhs the left-hand side sensor type.
 * \param rhs the right-hand side sensor type.
 *
 * \return `true` if the two sensor types aren't equal; `false` otherwise.
 *
 * \since 5.2.0
 */
[[nodiscard]] constexpr auto operator!=(const sensor_type lhs,
                                        const SDL_SensorType rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const sensor_type, const SDL_SensorType)
[[nodiscard]] constexpr auto operator!=(const SDL_SensorType lhs,
                                        const sensor_type rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of sensor type comparison operators

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_SENSOR_TYPE_HEADER

// #include "centurion/input/touch.hpp"
#ifndef CENTURION_TOUCH_HEADER
#define CENTURION_TOUCH_HEADER

#include <SDL.h>

#include <optional>  // optional

// #include "../core/integers.hpp"

// #include "button_state.hpp"

// #include "touch_device_type.hpp"


/**
 * \namespace cen::touch
 *
 * \ingroup input
 *
 * \brief Provides the touch API components and methods.
 *
 * \since 4.3.0
 */
namespace cen::touch {

/// \addtogroup input
/// \{

/**
 * \struct finger_state
 *
 * \brief Represents the state of a finger.
 *
 * \todo Centurion 7: Rename to touch_finger_state and move out of touch namespace.
 *
 * \since 5.2.0
 */
struct finger_state final
{
  button_state state;  ///< Whether or not the finger is pressed or release.
  float x;             ///< The current x-coordinate.
  float y;             ///< The current y-coordinate.
  float pressure;      ///< The current applied pressure.
};

/**
 * \brief Returns the number of registered touch devices.
 *
 * \return the number of registered touch devices.
 *
 * \since 4.3.0
 */
[[nodiscard]] inline auto device_count() noexcept -> int
{
  return SDL_GetNumTouchDevices();
}

/**
 * \brief Returns the touch device ID associated with the specified index.
 *
 * \param index the index of the desired touch device.
 *
 * \return the touch device ID associated with the index; `std::nullopt` if there is no
 * such value.
 *
 * \since 4.3.0
 */
[[nodiscard]] inline auto get_device(const int index) noexcept -> std::optional<SDL_TouchID>
{
  const auto device = SDL_GetTouchDevice(index);
  if (device != 0) {
    return device;
  }
  else {
    return std::nullopt;
  }
}

/**
 * \brief Returns the type of a touch device.
 *
 * \param id the touch device that will be queried.
 *
 * \return the type of the specified touch device.
 *
 * \since 4.3.0
 */
[[nodiscard]] inline auto type_of(const SDL_TouchID id) noexcept -> device_type
{
  return static_cast<device_type>(SDL_GetTouchDeviceType(id));
}

/**
 * \brief Returns the number of active fingers for a given touch device.
 *
 * \param id the touch device that will be queried.
 *
 * \return the amount of active fingers in a touch device.
 *
 * \since 4.3.0
 */
[[nodiscard]] inline auto finger_count(const SDL_TouchID id) noexcept -> int
{
  return SDL_GetNumTouchFingers(id);
}

/**
 * \brief Returns the finger associated with the specified touch ID and index.
 *
 * \param id the touch ID of the finger.
 * \param index the index of the finger object.
 *
 * \return the associated finger; `std::nullopt` if no such instance could be obtained.
 *
 * \since 4.3.0
 */
[[nodiscard]] inline auto get_finger(const SDL_TouchID id, const int index) noexcept
    -> std::optional<SDL_Finger>
{
  if (const auto* finger = SDL_GetTouchFinger(id, index)) {
    return *finger;
  }
  else {
    return std::nullopt;
  }
}

/**
 * \brief Returns the device ID used for mouse events simulated with touch input.
 *
 * \return a device ID.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto touch_mouse_id() noexcept -> u32
{
  return SDL_TOUCH_MOUSEID;
}

/**
 * \brief Returns the touch ID used by touch events simulated with mouse input.
 *
 * \return the touch ID used by touch events simulated with mouse input.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto mouse_touch_id() noexcept -> SDL_TouchID
{
  return SDL_MOUSE_TOUCHID;
}

/// \} End of group input

}  // namespace cen::touch

namespace cen {

/// \addtogroup input
/// \{

// Added for consistency with rest of codebase (no classes in nested namespaces)
using touch_finger_state = touch::finger_state;

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_TOUCH_HEADER
// #include "centurion/input/touch_device_type.hpp"
#ifndef CENTURION_TOUCH_DEVICE_TYPE_HEADER
#define CENTURION_TOUCH_DEVICE_TYPE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

namespace touch {

/// \addtogroup input
/// \{

/**
 * \enum device_type
 *
 * \brief Provides values that represent different touch device types.
 *
 * \see `SDL_TouchDeviceType`
 *
 * \todo Centurion 7: Rename to touch_device_type and move out of touch namespace.
 *
 * \since 4.3.0
 */
enum class device_type
{
  // clang-format off
  invalid = SDL_TOUCH_DEVICE_INVALID,                      ///< Invalid touch device.
  direct = SDL_TOUCH_DEVICE_DIRECT,                        ///< Touch screen with window-relative coordinates.
  indirect_absolute = SDL_TOUCH_DEVICE_INDIRECT_ABSOLUTE,  ///< Trackpad with absolute device coordinates.
  indirect_relative = SDL_TOUCH_DEVICE_INDIRECT_RELATIVE   ///< Trackpad with screen cursor-relative coordinates.
  // clang-format on
};

/// \name Touch device comparison operators
/// \{

/**
 * \brief Indicates whether or not two touch device types are the same.
 *
 * \param lhs the left-hand side touch device type.
 * \param rhs the right-hand side touch device type.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator==(const device_type lhs,
                                        const SDL_TouchDeviceType rhs) noexcept -> bool
{
  return static_cast<SDL_TouchDeviceType>(lhs) == rhs;
}

/// \copydoc operator==(device_type, SDL_TouchDeviceType)
[[nodiscard]] constexpr auto operator==(const SDL_TouchDeviceType lhs,
                                        const device_type rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two touch device types aren't the same.
 *
 * \param lhs the left-hand side touch device type.
 * \param rhs the right-hand side touch device type.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 4.3.0
 */
[[nodiscard]] constexpr auto operator!=(const device_type lhs,
                                        const SDL_TouchDeviceType rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(device_type, SDL_TouchDeviceType)
[[nodiscard]] constexpr auto operator!=(const SDL_TouchDeviceType lhs,
                                        const device_type rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of touch device comparison operators

/// \} End of group input

}  // namespace touch

/// \addtogroup input
/// \{

// Added for consistency with rest of codebase (no classes in nested namespaces)
using touch_device_type = touch::device_type;

[[nodiscard]] constexpr auto to_string(touch_device_type type) -> std::string_view;

namespace touch {

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a touch device type enumerator.
 *
 * \param stream the output stream that will be used.
 * \param type the enumerator that will be printed.
 *
 * \see `to_string(touch_device_type)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const touch_device_type type) -> std::ostream&
{
  return stream << to_string(type);
}

/// \} End of streaming

}  // namespace touch

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied touch device type.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(device_type::direct) == "direct"`.
 *
 * \param type the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const touch_device_type type) -> std::string_view
{
  switch (type) {
    case touch_device_type::invalid:
      return "invalid";

    case touch_device_type::direct:
      return "direct";

    case touch_device_type::indirect_absolute:
      return "indirect_absolute";

    case touch_device_type::indirect_relative:
      return "indirect_relative";

    default:
      throw cen_error{"Did not recognize touch device type!"};
  }
}

/// \} End of string conversions

/// \} End of group input

}  // namespace cen

#endif  // CENTURION_TOUCH_DEVICE_TYPE_HEADER

// #include "centurion/math/area.hpp"
#ifndef CENTURION_AREA_HEADER
#define CENTURION_AREA_HEADER

#include <ostream>      // ostream
#include <string>       // string, to_string
#include <type_traits>  // is_integral_v, is_floating_point_v, is_same_v

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/cast.hpp"
#ifndef CENTURION_CAST_HEADER
#define CENTURION_CAST_HEADER

namespace cen {

/**
 * \brief Casts a value to a value of another type.
 *
 * \ingroup core
 *
 * \details This is the default implementation, which simply attempts to use
 * `static_cast`. The idea is that this function will be specialized for various Centurion
 * and SDL types. This is useful because it isn't always possible to implement conversion
 * operators as members.
 *
 * \tparam To the type of the value that will be converted.
 * \tparam From the type that the value will be casted to.
 *
 * \param from the value that will be converted.
 *
 * \return the result of casting the supplied value to the specified type.
 *
 * \since 5.0.0
 */
template <typename To, typename From>
[[nodiscard]] constexpr auto cast(const From& from) noexcept -> To
{
  return static_cast<To>(from);
}

}  // namespace cen

#endif  // CENTURION_CAST_HEADER


namespace cen {

/// \addtogroup math
/// \{

template <typename T>
struct basic_area;

/**
 * \typedef iarea
 *
 * \brief An alias for `int` areas.
 *
 * \since 4.1.0
 */
using iarea = basic_area<int>;

/**
 * \typedef farea
 *
 * \brief An alias for `float` areas.
 *
 * \since 4.1.0
 */
using farea = basic_area<float>;

/**
 * \typedef darea
 *
 * \brief An alias for `double` areas.
 *
 * \since 4.1.0
 */
using darea = basic_area<double>;

/**
 * \struct basic_area
 *
 * \brief Simply represents an area with a width and height.
 *
 * \serializable
 *
 * \tparam T the type of the components of the area. Must be either an integral or
 * floating-point type. Can't be `bool`.
 *
 * \since 4.0.0
 *
 * \see `iarea`
 * \see `farea`
 * \see `darea`
 */
template <typename T>
struct basic_area final
{
  static_assert(std::is_integral_v<T> || std::is_floating_point_v<T>);
  static_assert(!std::is_same_v<T, bool>);

  using value_type = T;

  T width{0};   ///< The width of the area.
  T height{0};  ///< The height of the area.

#if CENTURION_HAS_FEATURE_SPACESHIP

  [[nodiscard]] constexpr auto operator==(const basic_area&) const noexcept -> bool = default;

#endif  // CENTURION_HAS_FEATURE_SPACESHIP
};

/// \name Area-related functions
/// \{

/**
 * \brief Creates an area instance with automatically deduced precision.
 *
 * \tparam T the deduced type of the width and height values.
 *
 * \param width the width of the area.
 * \param height the height of the area.
 *
 * \return an area instance with the specified width and height.
 *
 * \since 6.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto area(const T width, const T height) noexcept -> basic_area<T>
{
  return {width, height};
}

/**
 * \brief Returns the size (width x height) of an area.
 *
 * \tparam T the representation type.
 *
 * \param area the area instance that will be calculated.
 *
 * \return the size of the area.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto area_of(const basic_area<T> area) noexcept -> T
{
  return area.width * area.height;
}

/// \} End of area-related functions

/**
 * \brief Serializes an area instance.
 *
 * \details This function expects that the archive provides an overloaded `operator()`,
 * used for serializing data. This API is based on the Cereal serialization library.
 *
 * \tparam Archive the type of the archive.
 * \tparam T the type of the area components.
 *
 * \param archive the archive used to serialize the area.
 * \param area the area that will be serialized.
 *
 * \since 5.3.0
 */
template <typename Archive, typename T>
void serialize(Archive& archive, basic_area<T>& area)
{
  archive(area.width, area.height);
}

/// \name Area cast specializations
/// \{

template <>
[[nodiscard]] constexpr auto cast(const iarea& from) noexcept -> darea
{
  return {static_cast<double>(from.width), static_cast<double>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const iarea& from) noexcept -> farea
{
  return {static_cast<float>(from.width), static_cast<float>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const farea& from) noexcept -> darea
{
  return {static_cast<double>(from.width), static_cast<double>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const farea& from) noexcept -> iarea
{
  return {static_cast<int>(from.width), static_cast<int>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const darea& from) noexcept -> farea
{
  return {static_cast<float>(from.width), static_cast<float>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const darea& from) noexcept -> iarea
{
  return {static_cast<int>(from.width), static_cast<int>(from.height)};
}

/// \} End of area cast specializations

/// \name Area comparison operators
/// \{

#if !CENTURION_HAS_FEATURE_SPACESHIP

/**
 * \brief Indicates whether or not two areas are considered to be equal.
 *
 * \param lhs the left-hand side area.
 * \param rhs the right-hand side area.
 *
 * \return `true` if the areas are equal; `false` otherwise.
 *
 * \since 4.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator==(const basic_area<T>& lhs,
                                        const basic_area<T>& rhs) noexcept -> bool
{
  return (lhs.width == rhs.width) && (lhs.height == rhs.height);
}

/**
 * \brief Indicates whether or not two areas aren't considered to be equal.
 *
 * \param lhs the left-hand side area.
 * \param rhs the right-hand side area.
 *
 * \return `true` if the areas aren't equal; `false` otherwise.
 *
 * \since 4.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator!=(const basic_area<T>& lhs,
                                        const basic_area<T>& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

#endif  // CENTURION_HAS_FEATURE_SPACESHIP

/// \} End of area comparison operators

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of an area.
 *
 * \tparam T the type of the area components.
 *
 * \param area the area that will be converted.
 *
 * \return a string that represents the area.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_area<T>& area) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("area{{width: {}, height: {}}}", area.width, area.height);
#else
  return "area{width: " + std::to_string(area.width) +
         ", height: " + std::to_string(area.height) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of an area using a stream.
 *
 * \tparam T the type of the area components.
 *
 * \param stream the stream that will be used.
 * \param area the are that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_area<T>& area) -> std::ostream&
{
  return stream << to_string(area);
}

/// \} End of streaming

/// \} End of group math

}  // namespace cen

#endif  // CENTURION_AREA_HEADER
// #include "centurion/math/point.hpp"
#ifndef CENTURION_POINT_HEADER
#define CENTURION_POINT_HEADER

#include <SDL.h>

#include <cmath>        // sqrt, abs, round
#include <ostream>      // ostream
#include <string>       // string, to_string
#include <type_traits>  // conditional_t, is_integral_v, is_floating_point_v, ...

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/cast.hpp"

// #include "../core/sfinae.hpp"
#ifndef CENTURION_SFINAE_HEADER
#define CENTURION_SFINAE_HEADER

#include <type_traits>  // enable_if_t, is_same_v, is_integral_v, is_floating_point_v, ...

namespace cen {

/// \addtogroup core
/// \{

// clang-format off

/// Enables a template if the type is either integral of floating-point, but not a boolean.
template <typename T>
using enable_if_number_t = std::enable_if_t<!std::is_same_v<T, bool> &&
                                            (std::is_integral_v<T> ||
                                             std::is_floating_point_v<T>), int>;

// clang-format on

/// Enables a template if the type is a pointer.
template <typename T>
using enable_if_pointer_v = std::enable_if_t<std::is_pointer_v<T>, int>;

/// Enables a template if T is convertible to any of the specified types.
template <typename T, typename... Args>
using enable_if_convertible_t = std::enable_if_t<(std::is_convertible_v<T, Args> || ...), int>;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_SFINAE_HEADER


namespace cen {

/// \addtogroup math
/// \{

/**
 * \brief Provides traits used by the `basic_point` class.
 *
 * \tparam T the representation type. Must be convertible to `int` or `float`.
 *
 * \since 5.0.0
 *
 * \see `basic_point`
 * \see `ipoint`
 * \see `fpoint`
 */
template <typename T, enable_if_convertible_t<T, int, float> = 0>
class point_traits final
{
 public:
  /**
   * \var isIntegral
   *
   * \brief Indicates whether or not the point is based on an integral type.
   *
   * \since 5.0.0
   */
  inline constexpr static bool isIntegral = std::is_integral_v<T>;

  /**
   * \var isFloating
   *
   * \brief Indicates whether or not the point is based on a floating-point
   * type.
   *
   * \since 5.0.0
   */
  inline constexpr static bool isFloating = std::is_floating_point_v<T>;

  /**
   * \typedef value_type
   *
   * \brief The actual representation type, i.e. `int` or `float`.
   *
   * \since 5.0.0
   */
  using value_type = std::conditional_t<isIntegral, int, float>;

  /**
   * \typedef point_type
   *
   * \brief The SDL point type, i.e. `SDL_Point` or `SDL_FPoint`.
   *
   * \since 5.0.0
   */
  using point_type = std::conditional_t<isIntegral, SDL_Point, SDL_FPoint>;
};

template <typename T>
class basic_point;

/**
 * \typedef ipoint
 *
 * \brief Alias for an `int`-based point.
 *
 * \details This type corresponds to `SDL_Point`.
 *
 * \since 5.0.0
 */
using ipoint = basic_point<int>;

/**
 * \typedef fpoint
 *
 * \brief Alias for a `float`-based point.
 *
 * \details This type corresponds to `SDL_FPoint`.
 *
 * \since 5.0.0
 */
using fpoint = basic_point<float>;

/**
 * \class basic_point
 *
 * \brief Represents a two-dimensional point.
 *
 * \serializable
 *
 * \details This class is designed as a wrapper for `SDL_Point` and `SDL_FPoint`. The
 * representation is specified by the type parameter.
 *
 * \note This point class will only use `int` or `float` as the actual internal
 * representation.
 *
 * \tparam T the representation type. Must be convertible to `int` or `float`.
 *
 * \since 5.0.0
 *
 * \see `ipoint`
 * \see `fpoint`
 * \see `point()`
 * \see `distance()`
 */
template <typename T>
class basic_point final
{
 public:
  /// \copydoc point_traits::isIntegral
  inline constexpr static bool isIntegral = point_traits<T>::isIntegral;

  /// \copydoc point_traits::isFloating
  inline constexpr static bool isFloating = point_traits<T>::isFloating;

  /// \copydoc point_traits::value_type
  using value_type = typename point_traits<T>::value_type;

  /// \copydoc point_traits::point_type
  using point_type = typename point_traits<T>::point_type;

  /// \name Construction
  /// \{

  /**
   * \brief Creates a zero-initialized point.
   *
   * \since 5.0.0
   */
  constexpr basic_point() noexcept = default;

  /**
   * \brief Creates a point with the specified coordinates.
   *
   * \param x the x-coordinate that will be used.
   * \param y the y-coordinate that will be used.
   *
   * \since 5.0.0
   */
  constexpr basic_point(const value_type x, const value_type y) noexcept
  {
    m_point.x = x;
    m_point.y = y;
  };

  /// \} End of construction

  /// \name Setters
  /// \{

  /**
   * \brief Sets the x-coordinate of the point.
   *
   * \param x the new x-coordinate.
   *
   * \since 5.0.0
   */
  constexpr void set_x(const value_type x) noexcept
  {
    m_point.x = x;
  }

  /**
   * \brief Sets the y-coordinate of the point.
   *
   * \param y the new y-coordinate.
   *
   * \since 5.0.0
   */
  constexpr void set_y(const value_type y) noexcept
  {
    m_point.y = y;
  }

  /// \} End of setters

  /// \name Getters
  /// \{

  /**
   * \brief Returns the x-coordinate of the point.
   *
   * \return the x-coordinate.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto x() const noexcept -> value_type
  {
    return m_point.x;
  }

  /**
   * \brief Returns the y-coordinate of the point.
   *
   * \return the y-coordinate.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto y() const noexcept -> value_type
  {
    return m_point.y;
  }

  /**
   * \brief Returns the internal point representation.
   *
   * \return a reference to the internal representation.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto get() noexcept -> point_type&
  {
    return m_point;
  }

  /// \copydoc get
  [[nodiscard]] constexpr auto get() const noexcept -> const point_type&
  {
    return m_point;
  }

  /**
   * \brief Returns a pointer to the internal point representation.
   *
   * \note Don't cache the returned pointer.
   *
   * \return a pointer to the point representation.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto data() noexcept -> point_type*
  {
    return &m_point;
  }

  /// \copydoc data
  [[nodiscard]] auto data() const noexcept -> const point_type*
  {
    return &m_point;
  }

  /// \} End of getters

  /// \name Conversions
  /// \{

  /**
   * \brief Converts to the internal representation.
   *
   * \return a copy of the internal point.
   *
   * \see `cen::cast`
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr explicit operator point_type() const noexcept
  {
    return m_point;
  }

  /// \copydoc data()
  [[nodiscard]] explicit operator point_type*() noexcept
  {
    return data();
  }

  /// \copydoc data()
  [[nodiscard]] explicit operator const point_type*() const noexcept
  {
    return data();
  }

  /// \} End of conversions

  /**
   * \brief Serializes the point.
   *
   * \details This function expects that the archive provides an overloaded `operator()`,
   * used for serializing data. This API is based on the Cereal serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the point.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_point.x, m_point.y);
  }

 private:
  point_type m_point{0, 0};
};

/// \name Point-related functions
/// \{

/**
 * \brief Creates a point instance with automatically deduced precision.
 *
 * \note The only supported precisions for points are `int` and `float`, so this function
 * will cast the supplied values to the corresponding type. For example, if you supply two
 * doubles to this function, the returned point will use float as the precision.
 *
 * \tparam T the deduced precision type, must be a numerical type other than `bool`.
 *
 * \param x the x-coordinate of the point.
 * \param y the y-coordinate of the point.
 *
 * \return the created point.
 *
 * \since 6.0.0
 */
template <typename T, enable_if_number_t<T> = 0>
[[nodiscard]] constexpr auto point(const T x, const T y) noexcept
    -> basic_point<typename point_traits<T>::value_type>
{
  using value_type = typename point_traits<T>::value_type;
  return basic_point<value_type>{static_cast<value_type>(x), static_cast<value_type>(y)};
}

/**
 * \brief Returns the distance between two points.
 *
 * \tparam T the representation type used by the points.
 *
 * \param from the first point.
 * \param to the second point.
 *
 * \return the distance between the two points.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto distance(const basic_point<T> from, const basic_point<T> to) noexcept ->
    typename point_traits<T>::value_type
{
  if constexpr (basic_point<T>::isIntegral) {
    const auto xDiff = std::pow(from.x() - to.x(), 2);
    const auto yDiff = std::pow(from.y() - to.y(), 2);
    const auto dist = std::sqrt(xDiff + yDiff);
    return static_cast<int>(std::round(dist));
  }
  else {
    return std::sqrt(std::pow(from.x() - to.x(), 2) + std::pow(from.y() - to.y(), 2));
  }
}

/// \} End of point-related functions

/// \name String conversions
/// \{

[[nodiscard]] inline auto to_string(const ipoint point) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("ipoint{{x: {}, y: {}}}", point.x(), point.y());
#else
  return "ipoint{x: " + std::to_string(point.x()) + ", y: " + std::to_string(point.y()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

[[nodiscard]] inline auto to_string(const fpoint point) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("fpoint{{x: {}, y: {}}}", point.x(), point.y());
#else
  return "fpoint{x: " + std::to_string(point.x()) + ", y: " + std::to_string(point.y()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

template <typename T>
auto operator<<(std::ostream& stream, const basic_point<T>& point) -> std::ostream&
{
  return stream << to_string(point);
}

/// \} End of streaming

/// \name Point cast specializations
/// \{

/**
 * \brief Converts an `fpoint` instance to the corresponding `ipoint`.
 *
 * \details This function casts the coordinates of the supplied point to `int`, and uses
 * the obtained values to create an `ipoint` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `ipoint` instance that corresponds to the supplied `fpoint`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const fpoint& from) noexcept -> ipoint
{
  const auto x = static_cast<int>(from.x());
  const auto y = static_cast<int>(from.y());
  return ipoint{x, y};
}

/**
 * \brief Converts an `ipoint` instance to the corresponding `fpoint`.
 *
 * \details This function casts the coordinates of the supplied point to `float`, and uses
 * the obtained values to create an `fpoint` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `fpoint` instance that corresponds to the supplied `ipoint`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const ipoint& from) noexcept -> fpoint
{
  const auto x = static_cast<float>(from.x());
  const auto y = static_cast<float>(from.y());
  return fpoint{x, y};
}

/**
 * \brief Converts an `SDL_FPoint` instance to the corresponding `SDL_Point`.
 *
 * \details This function casts the coordinates of the supplied point to `int`, and uses
 * the obtained values to create an `SDL_Point` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `SDL_Point` instance that corresponds to the supplied `SDL_FPoint`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const SDL_FPoint& from) noexcept -> SDL_Point
{
  const auto x = static_cast<int>(from.x);
  const auto y = static_cast<int>(from.y);
  return SDL_Point{x, y};
}

/**
 * \brief Converts an `SDL_Point` instance to the corresponding `SDL_FPoint`.
 *
 * \details This function casts the coordinates of the supplied point to `float`, and uses
 * the obtained values to create an `SDL_FPoint` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `SDL_FPoint` instance that corresponds to the supplied `SDL_Point`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const SDL_Point& from) noexcept -> SDL_FPoint
{
  const auto x = static_cast<float>(from.x);
  const auto y = static_cast<float>(from.y);
  return SDL_FPoint{x, y};
}

/// \} End of point cast specializations

/// \name Point addition and subtraction operators
/// \{

template <typename T>
[[nodiscard]] constexpr auto operator+(const basic_point<T>& lhs,
                                       const basic_point<T>& rhs) noexcept -> basic_point<T>
{
  return {lhs.x() + rhs.x(), lhs.y() + rhs.y()};
}

template <typename T>
[[nodiscard]] constexpr auto operator-(const basic_point<T>& lhs,
                                       const basic_point<T>& rhs) noexcept -> basic_point<T>
{
  return {lhs.x() - rhs.x(), lhs.y() - rhs.y()};
}

/// \} End of point addition and subtraction operators

/// \name Point comparison operators
/// \{

template <typename T>
[[nodiscard]] constexpr auto operator==(const basic_point<T> lhs,
                                        const basic_point<T> rhs) noexcept -> bool
{
  return (lhs.x() == rhs.x()) && (lhs.y() == rhs.y());
}

template <typename T>
[[nodiscard]] constexpr auto operator!=(const basic_point<T> lhs,
                                        const basic_point<T> rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of point comparison operators

/// \} End of group math

}  // namespace cen

#endif  // CENTURION_POINT_HEADER
// #include "centurion/math/rect.hpp"
#ifndef CENTURION_RECTANGLE_HEADER
#define CENTURION_RECTANGLE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string>       // string, to_string
#include <type_traits>  // conditional_t, is_integral_v, is_floating_point_v, ...

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/cast.hpp"

// #include "../core/sfinae.hpp"

// #include "../detail/max.hpp"
#ifndef CENTURION_DETAIL_MAX_HEADER
#define CENTURION_DETAIL_MAX_HEADER

/// \cond FALSE
namespace cen::detail {

template <typename T>
[[nodiscard]] constexpr auto max(const T& a, const T& b) noexcept(noexcept(a < b)) -> T
{
  return (a < b) ? b : a;
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_MAX_HEADER

// #include "../detail/min.hpp"
#ifndef CENTURION_DETAIL_MIN_HEADER
#define CENTURION_DETAIL_MIN_HEADER

/// \cond FALSE
namespace cen::detail {

template <typename T>
[[nodiscard]] constexpr auto min(const T& a, const T& b) noexcept(noexcept(a < b)) -> T
{
  return (a < b) ? a : b;
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_MIN_HEADER

// #include "area.hpp"
#ifndef CENTURION_AREA_HEADER
#define CENTURION_AREA_HEADER

#include <ostream>      // ostream
#include <string>       // string, to_string
#include <type_traits>  // is_integral_v, is_floating_point_v, is_same_v

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/cast.hpp"


namespace cen {

/// \addtogroup math
/// \{

template <typename T>
struct basic_area;

/**
 * \typedef iarea
 *
 * \brief An alias for `int` areas.
 *
 * \since 4.1.0
 */
using iarea = basic_area<int>;

/**
 * \typedef farea
 *
 * \brief An alias for `float` areas.
 *
 * \since 4.1.0
 */
using farea = basic_area<float>;

/**
 * \typedef darea
 *
 * \brief An alias for `double` areas.
 *
 * \since 4.1.0
 */
using darea = basic_area<double>;

/**
 * \struct basic_area
 *
 * \brief Simply represents an area with a width and height.
 *
 * \serializable
 *
 * \tparam T the type of the components of the area. Must be either an integral or
 * floating-point type. Can't be `bool`.
 *
 * \since 4.0.0
 *
 * \see `iarea`
 * \see `farea`
 * \see `darea`
 */
template <typename T>
struct basic_area final
{
  static_assert(std::is_integral_v<T> || std::is_floating_point_v<T>);
  static_assert(!std::is_same_v<T, bool>);

  using value_type = T;

  T width{0};   ///< The width of the area.
  T height{0};  ///< The height of the area.

#if CENTURION_HAS_FEATURE_SPACESHIP

  [[nodiscard]] constexpr auto operator==(const basic_area&) const noexcept -> bool = default;

#endif  // CENTURION_HAS_FEATURE_SPACESHIP
};

/// \name Area-related functions
/// \{

/**
 * \brief Creates an area instance with automatically deduced precision.
 *
 * \tparam T the deduced type of the width and height values.
 *
 * \param width the width of the area.
 * \param height the height of the area.
 *
 * \return an area instance with the specified width and height.
 *
 * \since 6.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto area(const T width, const T height) noexcept -> basic_area<T>
{
  return {width, height};
}

/**
 * \brief Returns the size (width x height) of an area.
 *
 * \tparam T the representation type.
 *
 * \param area the area instance that will be calculated.
 *
 * \return the size of the area.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto area_of(const basic_area<T> area) noexcept -> T
{
  return area.width * area.height;
}

/// \} End of area-related functions

/**
 * \brief Serializes an area instance.
 *
 * \details This function expects that the archive provides an overloaded `operator()`,
 * used for serializing data. This API is based on the Cereal serialization library.
 *
 * \tparam Archive the type of the archive.
 * \tparam T the type of the area components.
 *
 * \param archive the archive used to serialize the area.
 * \param area the area that will be serialized.
 *
 * \since 5.3.0
 */
template <typename Archive, typename T>
void serialize(Archive& archive, basic_area<T>& area)
{
  archive(area.width, area.height);
}

/// \name Area cast specializations
/// \{

template <>
[[nodiscard]] constexpr auto cast(const iarea& from) noexcept -> darea
{
  return {static_cast<double>(from.width), static_cast<double>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const iarea& from) noexcept -> farea
{
  return {static_cast<float>(from.width), static_cast<float>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const farea& from) noexcept -> darea
{
  return {static_cast<double>(from.width), static_cast<double>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const farea& from) noexcept -> iarea
{
  return {static_cast<int>(from.width), static_cast<int>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const darea& from) noexcept -> farea
{
  return {static_cast<float>(from.width), static_cast<float>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const darea& from) noexcept -> iarea
{
  return {static_cast<int>(from.width), static_cast<int>(from.height)};
}

/// \} End of area cast specializations

/// \name Area comparison operators
/// \{

#if !CENTURION_HAS_FEATURE_SPACESHIP

/**
 * \brief Indicates whether or not two areas are considered to be equal.
 *
 * \param lhs the left-hand side area.
 * \param rhs the right-hand side area.
 *
 * \return `true` if the areas are equal; `false` otherwise.
 *
 * \since 4.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator==(const basic_area<T>& lhs,
                                        const basic_area<T>& rhs) noexcept -> bool
{
  return (lhs.width == rhs.width) && (lhs.height == rhs.height);
}

/**
 * \brief Indicates whether or not two areas aren't considered to be equal.
 *
 * \param lhs the left-hand side area.
 * \param rhs the right-hand side area.
 *
 * \return `true` if the areas aren't equal; `false` otherwise.
 *
 * \since 4.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator!=(const basic_area<T>& lhs,
                                        const basic_area<T>& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

#endif  // CENTURION_HAS_FEATURE_SPACESHIP

/// \} End of area comparison operators

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of an area.
 *
 * \tparam T the type of the area components.
 *
 * \param area the area that will be converted.
 *
 * \return a string that represents the area.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_area<T>& area) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("area{{width: {}, height: {}}}", area.width, area.height);
#else
  return "area{width: " + std::to_string(area.width) +
         ", height: " + std::to_string(area.height) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of an area using a stream.
 *
 * \tparam T the type of the area components.
 *
 * \param stream the stream that will be used.
 * \param area the are that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_area<T>& area) -> std::ostream&
{
  return stream << to_string(area);
}

/// \} End of streaming

/// \} End of group math

}  // namespace cen

#endif  // CENTURION_AREA_HEADER
// #include "point.hpp"
#ifndef CENTURION_POINT_HEADER
#define CENTURION_POINT_HEADER

#include <SDL.h>

#include <cmath>        // sqrt, abs, round
#include <ostream>      // ostream
#include <string>       // string, to_string
#include <type_traits>  // conditional_t, is_integral_v, is_floating_point_v, ...

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/cast.hpp"

// #include "../core/sfinae.hpp"


namespace cen {

/// \addtogroup math
/// \{

/**
 * \brief Provides traits used by the `basic_point` class.
 *
 * \tparam T the representation type. Must be convertible to `int` or `float`.
 *
 * \since 5.0.0
 *
 * \see `basic_point`
 * \see `ipoint`
 * \see `fpoint`
 */
template <typename T, enable_if_convertible_t<T, int, float> = 0>
class point_traits final
{
 public:
  /**
   * \var isIntegral
   *
   * \brief Indicates whether or not the point is based on an integral type.
   *
   * \since 5.0.0
   */
  inline constexpr static bool isIntegral = std::is_integral_v<T>;

  /**
   * \var isFloating
   *
   * \brief Indicates whether or not the point is based on a floating-point
   * type.
   *
   * \since 5.0.0
   */
  inline constexpr static bool isFloating = std::is_floating_point_v<T>;

  /**
   * \typedef value_type
   *
   * \brief The actual representation type, i.e. `int` or `float`.
   *
   * \since 5.0.0
   */
  using value_type = std::conditional_t<isIntegral, int, float>;

  /**
   * \typedef point_type
   *
   * \brief The SDL point type, i.e. `SDL_Point` or `SDL_FPoint`.
   *
   * \since 5.0.0
   */
  using point_type = std::conditional_t<isIntegral, SDL_Point, SDL_FPoint>;
};

template <typename T>
class basic_point;

/**
 * \typedef ipoint
 *
 * \brief Alias for an `int`-based point.
 *
 * \details This type corresponds to `SDL_Point`.
 *
 * \since 5.0.0
 */
using ipoint = basic_point<int>;

/**
 * \typedef fpoint
 *
 * \brief Alias for a `float`-based point.
 *
 * \details This type corresponds to `SDL_FPoint`.
 *
 * \since 5.0.0
 */
using fpoint = basic_point<float>;

/**
 * \class basic_point
 *
 * \brief Represents a two-dimensional point.
 *
 * \serializable
 *
 * \details This class is designed as a wrapper for `SDL_Point` and `SDL_FPoint`. The
 * representation is specified by the type parameter.
 *
 * \note This point class will only use `int` or `float` as the actual internal
 * representation.
 *
 * \tparam T the representation type. Must be convertible to `int` or `float`.
 *
 * \since 5.0.0
 *
 * \see `ipoint`
 * \see `fpoint`
 * \see `point()`
 * \see `distance()`
 */
template <typename T>
class basic_point final
{
 public:
  /// \copydoc point_traits::isIntegral
  inline constexpr static bool isIntegral = point_traits<T>::isIntegral;

  /// \copydoc point_traits::isFloating
  inline constexpr static bool isFloating = point_traits<T>::isFloating;

  /// \copydoc point_traits::value_type
  using value_type = typename point_traits<T>::value_type;

  /// \copydoc point_traits::point_type
  using point_type = typename point_traits<T>::point_type;

  /// \name Construction
  /// \{

  /**
   * \brief Creates a zero-initialized point.
   *
   * \since 5.0.0
   */
  constexpr basic_point() noexcept = default;

  /**
   * \brief Creates a point with the specified coordinates.
   *
   * \param x the x-coordinate that will be used.
   * \param y the y-coordinate that will be used.
   *
   * \since 5.0.0
   */
  constexpr basic_point(const value_type x, const value_type y) noexcept
  {
    m_point.x = x;
    m_point.y = y;
  };

  /// \} End of construction

  /// \name Setters
  /// \{

  /**
   * \brief Sets the x-coordinate of the point.
   *
   * \param x the new x-coordinate.
   *
   * \since 5.0.0
   */
  constexpr void set_x(const value_type x) noexcept
  {
    m_point.x = x;
  }

  /**
   * \brief Sets the y-coordinate of the point.
   *
   * \param y the new y-coordinate.
   *
   * \since 5.0.0
   */
  constexpr void set_y(const value_type y) noexcept
  {
    m_point.y = y;
  }

  /// \} End of setters

  /// \name Getters
  /// \{

  /**
   * \brief Returns the x-coordinate of the point.
   *
   * \return the x-coordinate.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto x() const noexcept -> value_type
  {
    return m_point.x;
  }

  /**
   * \brief Returns the y-coordinate of the point.
   *
   * \return the y-coordinate.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto y() const noexcept -> value_type
  {
    return m_point.y;
  }

  /**
   * \brief Returns the internal point representation.
   *
   * \return a reference to the internal representation.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto get() noexcept -> point_type&
  {
    return m_point;
  }

  /// \copydoc get
  [[nodiscard]] constexpr auto get() const noexcept -> const point_type&
  {
    return m_point;
  }

  /**
   * \brief Returns a pointer to the internal point representation.
   *
   * \note Don't cache the returned pointer.
   *
   * \return a pointer to the point representation.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto data() noexcept -> point_type*
  {
    return &m_point;
  }

  /// \copydoc data
  [[nodiscard]] auto data() const noexcept -> const point_type*
  {
    return &m_point;
  }

  /// \} End of getters

  /// \name Conversions
  /// \{

  /**
   * \brief Converts to the internal representation.
   *
   * \return a copy of the internal point.
   *
   * \see `cen::cast`
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr explicit operator point_type() const noexcept
  {
    return m_point;
  }

  /// \copydoc data()
  [[nodiscard]] explicit operator point_type*() noexcept
  {
    return data();
  }

  /// \copydoc data()
  [[nodiscard]] explicit operator const point_type*() const noexcept
  {
    return data();
  }

  /// \} End of conversions

  /**
   * \brief Serializes the point.
   *
   * \details This function expects that the archive provides an overloaded `operator()`,
   * used for serializing data. This API is based on the Cereal serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the point.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_point.x, m_point.y);
  }

 private:
  point_type m_point{0, 0};
};

/// \name Point-related functions
/// \{

/**
 * \brief Creates a point instance with automatically deduced precision.
 *
 * \note The only supported precisions for points are `int` and `float`, so this function
 * will cast the supplied values to the corresponding type. For example, if you supply two
 * doubles to this function, the returned point will use float as the precision.
 *
 * \tparam T the deduced precision type, must be a numerical type other than `bool`.
 *
 * \param x the x-coordinate of the point.
 * \param y the y-coordinate of the point.
 *
 * \return the created point.
 *
 * \since 6.0.0
 */
template <typename T, enable_if_number_t<T> = 0>
[[nodiscard]] constexpr auto point(const T x, const T y) noexcept
    -> basic_point<typename point_traits<T>::value_type>
{
  using value_type = typename point_traits<T>::value_type;
  return basic_point<value_type>{static_cast<value_type>(x), static_cast<value_type>(y)};
}

/**
 * \brief Returns the distance between two points.
 *
 * \tparam T the representation type used by the points.
 *
 * \param from the first point.
 * \param to the second point.
 *
 * \return the distance between the two points.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto distance(const basic_point<T> from, const basic_point<T> to) noexcept ->
    typename point_traits<T>::value_type
{
  if constexpr (basic_point<T>::isIntegral) {
    const auto xDiff = std::pow(from.x() - to.x(), 2);
    const auto yDiff = std::pow(from.y() - to.y(), 2);
    const auto dist = std::sqrt(xDiff + yDiff);
    return static_cast<int>(std::round(dist));
  }
  else {
    return std::sqrt(std::pow(from.x() - to.x(), 2) + std::pow(from.y() - to.y(), 2));
  }
}

/// \} End of point-related functions

/// \name String conversions
/// \{

[[nodiscard]] inline auto to_string(const ipoint point) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("ipoint{{x: {}, y: {}}}", point.x(), point.y());
#else
  return "ipoint{x: " + std::to_string(point.x()) + ", y: " + std::to_string(point.y()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

[[nodiscard]] inline auto to_string(const fpoint point) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("fpoint{{x: {}, y: {}}}", point.x(), point.y());
#else
  return "fpoint{x: " + std::to_string(point.x()) + ", y: " + std::to_string(point.y()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

template <typename T>
auto operator<<(std::ostream& stream, const basic_point<T>& point) -> std::ostream&
{
  return stream << to_string(point);
}

/// \} End of streaming

/// \name Point cast specializations
/// \{

/**
 * \brief Converts an `fpoint` instance to the corresponding `ipoint`.
 *
 * \details This function casts the coordinates of the supplied point to `int`, and uses
 * the obtained values to create an `ipoint` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `ipoint` instance that corresponds to the supplied `fpoint`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const fpoint& from) noexcept -> ipoint
{
  const auto x = static_cast<int>(from.x());
  const auto y = static_cast<int>(from.y());
  return ipoint{x, y};
}

/**
 * \brief Converts an `ipoint` instance to the corresponding `fpoint`.
 *
 * \details This function casts the coordinates of the supplied point to `float`, and uses
 * the obtained values to create an `fpoint` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `fpoint` instance that corresponds to the supplied `ipoint`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const ipoint& from) noexcept -> fpoint
{
  const auto x = static_cast<float>(from.x());
  const auto y = static_cast<float>(from.y());
  return fpoint{x, y};
}

/**
 * \brief Converts an `SDL_FPoint` instance to the corresponding `SDL_Point`.
 *
 * \details This function casts the coordinates of the supplied point to `int`, and uses
 * the obtained values to create an `SDL_Point` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `SDL_Point` instance that corresponds to the supplied `SDL_FPoint`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const SDL_FPoint& from) noexcept -> SDL_Point
{
  const auto x = static_cast<int>(from.x);
  const auto y = static_cast<int>(from.y);
  return SDL_Point{x, y};
}

/**
 * \brief Converts an `SDL_Point` instance to the corresponding `SDL_FPoint`.
 *
 * \details This function casts the coordinates of the supplied point to `float`, and uses
 * the obtained values to create an `SDL_FPoint` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `SDL_FPoint` instance that corresponds to the supplied `SDL_Point`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const SDL_Point& from) noexcept -> SDL_FPoint
{
  const auto x = static_cast<float>(from.x);
  const auto y = static_cast<float>(from.y);
  return SDL_FPoint{x, y};
}

/// \} End of point cast specializations

/// \name Point addition and subtraction operators
/// \{

template <typename T>
[[nodiscard]] constexpr auto operator+(const basic_point<T>& lhs,
                                       const basic_point<T>& rhs) noexcept -> basic_point<T>
{
  return {lhs.x() + rhs.x(), lhs.y() + rhs.y()};
}

template <typename T>
[[nodiscard]] constexpr auto operator-(const basic_point<T>& lhs,
                                       const basic_point<T>& rhs) noexcept -> basic_point<T>
{
  return {lhs.x() - rhs.x(), lhs.y() - rhs.y()};
}

/// \} End of point addition and subtraction operators

/// \name Point comparison operators
/// \{

template <typename T>
[[nodiscard]] constexpr auto operator==(const basic_point<T> lhs,
                                        const basic_point<T> rhs) noexcept -> bool
{
  return (lhs.x() == rhs.x()) && (lhs.y() == rhs.y());
}

template <typename T>
[[nodiscard]] constexpr auto operator!=(const basic_point<T> lhs,
                                        const basic_point<T> rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of point comparison operators

/// \} End of group math

}  // namespace cen

#endif  // CENTURION_POINT_HEADER

namespace cen {

/// \addtogroup math
/// \{

/**
 * \class rect_traits
 *
 * \brief Provides rectangle traits used by `basic_rect`.
 *
 * \note Whilst it is possible to supply a type that isn't `int` or `float`, rectangles
 * will always use one of them as the representation type.
 *
 * \tparam T the representation type, must be convertible to `int` or `float`.
 *
 * \see `basic_rect`
 * \see `irect`
 * \see `frect`
 *
 * \since 5.0.0
 */
template <typename T, enable_if_convertible_t<T, int, float> = 0>
class rect_traits final
{
 public:
  inline constexpr static bool isIntegral = std::is_integral_v<T>;
  inline constexpr static bool isFloating = std::is_floating_point_v<T>;

  using value_type = std::conditional_t<isIntegral, int, float>;
  using point_type = std::conditional_t<isIntegral, ipoint, fpoint>;
  using area_type = std::conditional_t<isIntegral, iarea, farea>;
  using rect_type = std::conditional_t<isIntegral, SDL_Rect, SDL_FRect>;
};

template <typename T>
class basic_rect;

/**
 * \typedef irect
 *
 * \brief Alias for an `int`-based rectangle.
 *
 * \since 5.0.0
 */
using irect = basic_rect<int>;

/**
 * \typedef frect
 *
 * \brief Alias for a `float`-based rectangle.
 *
 * \since 5.0.0
 */
using frect = basic_rect<float>;

/**
 * \class basic_rect
 *
 * \brief A simple rectangle implementation, based on either `SDL_Rect` or `SDL_FRect`.
 *
 * \serializable
 *
 * \tparam T the representation type. Must be convertible to either `int` or `float`.
 *
 * \see `irect`
 * \see `frect`
 * \see `rect()`
 * \see `intersects()`
 * \see `collides()`
 * \see `get_union()`
 *
 * \since 4.0.0
 */
template <typename T>
class basic_rect final
{
 public:
  /**
   * \brief Indicates whether or not the rectangle is based on an integral type.
   *
   * \since 5.0.0
   */
  inline constexpr static bool isIntegral = rect_traits<T>::isIntegral;

  /**
   * \brief Indicates whether or not the rectangle is based on a floating-point
   * type.
   *
   * \since 5.0.0
   */
  inline constexpr static bool isFloating = rect_traits<T>::isFloating;

  /**
   * \typedef value_type
   *
   * \brief The representation type, i.e. `int` or `float`.
   *
   * \since 5.0.0
   */
  using value_type = typename rect_traits<T>::value_type;

  /**
   * \typedef point_type
   *
   * \brief The point type used, i.e. `ipoint` or `fpoint`.
   *
   * \since 5.0.0
   */
  using point_type = typename rect_traits<T>::point_type;

  /**
   * \typedef area_type
   *
   * \brief The area type used, i.e. `iarea` or `farea`.
   *
   * \since 5.0.0
   */
  using area_type = typename rect_traits<T>::area_type;

  /**
   * \typedef rect_type
   *
   * \brief The underlying SDL rectangle type, i.e. `SDL_Rect` or `SDL_FRect`.
   *
   * \since 5.0.0
   */
  using rect_type = typename rect_traits<T>::rect_type;

  /// \name Construction
  /// \{

  /**
   * \brief Creates a rectangle with the components (0, 0, 0, 0).
   *
   * \since 4.0.0
   */
  constexpr basic_rect() noexcept = default;

  /**
   * \brief Creates a rectangle based on an SDL rectangle.
   *
   * \param rect the rectangle that will be copied.
   *
   * \since 5.3.0
   */
  constexpr explicit basic_rect(const rect_type& rect) noexcept : m_rect{rect}
  {}

  /**
   * \brief Creates a rectangle with the supplied position and size.
   *
   * \param position the position of the rectangle.
   * \param size the size of the rectangle.
   *
   * \since 4.1.0
   */
  constexpr basic_rect(const point_type& position, const area_type& size) noexcept
      : m_rect{position.x(), position.y(), size.width, size.height}
  {}

  /**
   * \brief Creates a rectangle with the supplied position and size.
   *
   * \param x the x-coordinate of the rectangle.
   * \param y the y-coordinate of the rectangle.
   * \param width the width of the rectangle.
   * \param height the height of the rectangle.
   *
   * \since 5.3.0
   */
  constexpr basic_rect(const value_type x,
                       const value_type y,
                       const value_type width,
                       const value_type height) noexcept
      : m_rect{x, y, width, height}
  {}

  /// \} End of construction

  /// \name Setters
  /// \{

  /**
   * \brief Sets the x-coordinate of the rectangle.
   *
   * \param x the new x-coordinate of the rectangle.
   *
   * \since 4.0.0
   */
  constexpr void set_x(const value_type x) noexcept
  {
    m_rect.x = x;
  }

  /**
   * \brief Sets the y-coordinate of the rectangle.
   *
   * \param y the new y-coordinate of the rectangle.
   *
   * \since 4.0.0
   */
  constexpr void set_y(const value_type y) noexcept
  {
    m_rect.y = y;
  }

  /**
   * \brief Sets the maximum x-coordinate of the rectangle.
   *
   * \note This function preserves the width of the rectangle.
   *
   * \param maxX the new maximum x-coordinate of the rectangle.
   *
   * \since 5.1.0
   */
  constexpr void set_max_x(const value_type maxX) noexcept
  {
    m_rect.x = maxX - m_rect.w;
  }

  /**
   * \brief Sets the maximum y-coordinate of the rectangle.
   *
   * \note This function preserves the height of the rectangle.
   *
   * \param maxY the new maximum y-coordinate of the rectangle.
   *
   * \since 5.1.0
   */
  constexpr void set_max_y(const value_type maxY) noexcept
  {
    m_rect.y = maxY - m_rect.h;
  }

  /**
   * \brief Offsets the x-coordinate of the rectangle by the specified amount.
   *
   * \details This function is effectively equivalent to calling `set_x()` with the sum of
   * `x()` and `offset`.
   *
   * \param offset the offset to the x-coordinate of the rectangle.
   *
   * \since 6.0.0
   */
  constexpr void offset_x(const value_type offset) noexcept
  {
    m_rect.x += offset;
  }

  /**
   * \brief Offsets the y-coordinate of the rectangle by the specified amount.
   *
   * \details This function is effectively equivalent to calling `set_y()` with the sum of
   * `y()` and `offset`.
   *
   * \param offset the offset to the y-coordinate of the rectangle.
   *
   * \since 6.0.0
   */
  constexpr void offset_y(const value_type offset) noexcept
  {
    m_rect.y += offset;
  }

  /**
   * \brief Tweaks the width of the rectangle by the specified amount.
   *
   * \details This function is effectively equivalent to calling `set_width()` with the
   * sum of `width()` and `offset`.
   *
   * \param offset the offset to the width of the rectangle.
   *
   * \since 6.0.0
   */
  constexpr void offset_width(const value_type offset) noexcept
  {
    m_rect.w += offset;
  }

  /**
   * \brief Tweaks the height of the rectangle by the specified amount.
   *
   * \details This function is effectively equivalent to calling `set_height()` with the
   * sum of `height()` and `offset`.
   *
   * \param offset the offset to the height of the rectangle.
   *
   * \since 6.0.0
   */
  constexpr void offset_height(const value_type offset) noexcept
  {
    m_rect.h += offset;
  }

  /**
   * \brief Sets the position of the rectangle.
   *
   * \note Some frameworks have this kind of function change the size of the rectangle.
   * However, this function does *not* change the size of the rectangle.
   *
   * \param pos the new position of the rectangle.
   *
   * \since 5.1.0
   */
  constexpr void set_position(const point_type& pos) noexcept
  {
    m_rect.x = pos.x();
    m_rect.y = pos.y();
  }

  /**
   * \brief Sets the width of the rectangle.
   *
   * \param width the new width of the rectangle.
   *
   * \since 4.0.0
   */
  constexpr void set_width(const value_type width) noexcept
  {
    m_rect.w = width;
  }

  /**
   * \brief Sets the height of the rectangle.
   *
   * \param height the new height of the rectangle.
   *
   * \since 4.0.0
   */
  constexpr void set_height(const value_type height) noexcept
  {
    m_rect.h = height;
  }

  /**
   * \brief Sets the size of the rectangle.
   *
   * \param size the new size of the rectangle.
   *
   * \since 5.1.0
   */
  constexpr void set_size(const area_type& size) noexcept
  {
    m_rect.w = size.width;
    m_rect.h = size.height;
  };

  /// \} End of setters

  /// \name Queries
  /// \{

  /**
   * \brief Returns the x-coordinate of the rectangle.
   *
   * \return the x-coordinate of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto x() const noexcept -> value_type
  {
    return m_rect.x;
  }

  /**
   * \brief Returns the y-coordinate of the rectangle.
   *
   * \return the y-coordinate of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto y() const noexcept -> value_type
  {
    return m_rect.y;
  }

  /**
   * \brief Returns the position of the rectangle.
   *
   * \return the position of the rectangle.
   *
   * \since 4.1.0
   */
  [[nodiscard]] constexpr auto position() const noexcept -> point_type
  {
    return point_type{m_rect.x, m_rect.y};
  }

  /**
   * \brief Returns the width of the rectangle.
   *
   * \return the width of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto width() const noexcept -> value_type
  {
    return m_rect.w;
  }

  /**
   * \brief Returns the height of the rectangle.
   *
   * \return the height of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto height() const noexcept -> value_type
  {
    return m_rect.h;
  }

  /**
   * \brief Returns the size of the rectangle.
   *
   * \return the size of the rectangle.
   *
   * \since 4.1.0
   */
  [[nodiscard]] constexpr auto size() const noexcept -> area_type
  {
    return area_type{m_rect.w, m_rect.h};
  }

  /**
   * \brief Returns the maximum x-coordinate of the rectangle.
   *
   * \return the maximum x-coordinate of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto max_x() const noexcept -> value_type
  {
    return x() + width();
  }

  /**
   * \brief Returns the maximum y-coordinate of the rectangle.
   *
   * \return the maximum y-coordinate of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto max_y() const noexcept -> value_type
  {
    return y() + height();
  }

  /**
   * \brief Returns the x-coordinate of the center point of the rectangle.
   *
   * \return the x-coordinate of the center point of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto center_x() const noexcept -> value_type
  {
    return x() + (width() / static_cast<value_type>(2));
  }

  /**
   * \brief Returns the y-coordinate of the center point of the rectangle.
   *
   * \return the y-coordinate of the center point of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto center_y() const noexcept -> value_type
  {
    return y() + (height() / static_cast<value_type>(2));
  }

  /**
   * \brief Returns the center point of the rectangle.
   *
   * \return the center point of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto center() const noexcept -> point_type
  {
    return {center_x(), center_y()};
  }

  /**
   * \brief Returns the total area of the rectangle.
   *
   * \return the area of the rectangle.
   *
   * \since 4.2.0
   */
  [[nodiscard]] constexpr auto area() const noexcept -> value_type
  {
    return width() * height();
  }

  /**
   * \brief Indicates whether or not the rectangle contains the point.
   *
   * \param point the point that will be checked.
   *
   * \return `true` if the rectangle contains the point; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto contains(const point_type& point) const noexcept -> bool
  {
    const auto px = point.x();
    const auto py = point.y();
    return !(px < x() || py < y() || px > max_x() || py > max_y());
  }

  /**
   * \brief Indicates whether or not the rectangle has an area.
   *
   * \details The rectangle has an area if both the width and height are
   * greater than zero.
   *
   * \return `true` if the rectangle has an area; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto has_area() const noexcept -> bool
  {
    return (width() > 0) && (height() > 0);
  }

  /**
   * \brief Returns a pointer to the internal rectangle representation.
   *
   * \note Don't cache the returned pointer.
   *
   * \return a pointer to the rectangle representation.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto data() noexcept -> rect_type*
  {
    return &m_rect;
  }

  /**
   * \copydoc data()
   */
  [[nodiscard]] auto data() const noexcept -> const rect_type*
  {
    return &m_rect;
  }

  /**
   * \brief Returns the internal rectangle.
   *
   * \return a reference to the internal rectangle.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto get() noexcept -> rect_type&
  {
    return m_rect;
  }

  /**
   * \brief Returns the internal rectangle.
   *
   * \return a reference to the internal rectangle.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto get() const noexcept -> const rect_type&
  {
    return m_rect;
  }

  /// \} End of queries

  /// \name Conversions
  /// \{

  /**
   * \brief Returns a pointer to the internal rectangle.
   *
   * \return a pointer to the internal rectangle.
   *
   * \since 5.0.0
   */
  [[nodiscard]] explicit operator rect_type*() noexcept
  {
    return &m_rect;
  }

  /**
   * \brief Returns a pointer to the internal rectangle.
   *
   * \return a pointer to the internal rectangle.
   *
   * \since 5.0.0
   */
  [[nodiscard]] explicit operator const rect_type*() const noexcept
  {
    return &m_rect;
  }

  /// \} End of conversions

  /**
   * \brief Serializes the rectangle.
   *
   * \details This function expects that the archive provides an overloaded `operator()`,
   * used for serializing data. This API is based on the Cereal serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the rectangle.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_rect.x, m_rect.y, m_rect.w, m_rect.h);
  }

 private:
  rect_type m_rect{0, 0, 0, 0};
};

/// \name Rectangle functions
/// \{

/**
 * \brief Creates a rectangle with automatically deduced precision.
 *
 * \note The only supported precisions for rectangles are `int` and `float`, so this
 * function will cast the supplied values to the corresponding type. For example, if you
 * supply doubles to this function, the returned point will use float as the precision.
 *
 * \tparam T the deduced precision type.
 *
 * \param x the x-coordinate of the rectangle.
 * \param y the y-coordinate of the rectangle.
 * \param width the width of the rectangle.
 * \param height the height of the rectangle.
 *
 * \return a rectangle with the specified position and size.
 *
 * \since 6.0.0
 */
template <typename T, enable_if_number_t<T> = 0>
[[nodiscard]] constexpr auto rect(const T x, const T y, const T width, const T height) noexcept
    -> basic_rect<typename rect_traits<T>::value_type>
{
  using value_type = typename rect_traits<T>::value_type;
  return basic_rect<value_type>{static_cast<value_type>(x),
                                static_cast<value_type>(y),
                                static_cast<value_type>(width),
                                static_cast<value_type>(height)};
}

/**
 * \brief Indicates whether or not the two rectangles intersect.
 *
 * \details This function does *not* consider rectangles with overlapping borders as
 * intersecting. If you want such behaviour, see the `collides` function.
 *
 * \tparam T the representation type used by the rectangles.
 *
 * \param fst the first rectangle.
 * \param snd the second rectangle.
 *
 * \return `true` if the rectangles intersect; `false` otherwise.
 *
 * \see `collides`
 *
 * \since 4.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto intersects(const basic_rect<T>& fst,
                                        const basic_rect<T>& snd) noexcept -> bool
{
  return !(fst.x() >= snd.max_x() || fst.max_x() <= snd.x() || fst.y() >= snd.max_y() ||
           fst.max_y() <= snd.y());
}

/**
 * \brief Indicates whether or not two rectangles are colliding.
 *
 * \details This function considers rectangles with overlapping borders as colliding.
 *
 * \tparam T the representation type used by the rectangles.
 *
 * \param fst the first rectangle.
 * \param snd the second rectangle.
 *
 * \return `true` if the rectangles collide; `false` otherwise.
 *
 * \see `intersects`
 *
 * \since 4.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto collides(const basic_rect<T>& fst,
                                      const basic_rect<T>& snd) noexcept -> bool
{
  return !(fst.x() > snd.max_x() || fst.max_x() < snd.x() || fst.y() > snd.max_y() ||
           fst.max_y() < snd.y());
}

/**
 * \brief Returns the union of two rectangles.
 *
 * \details Returns a rectangle that represents the union of two rectangles.
 *
 * \tparam T the representation type used by the rectangles.
 *
 * \param fst the first rectangle.
 * \param snd the second rectangle.
 *
 * \return a rectangle that represents the union of the rectangles.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto get_union(const basic_rect<T>& fst,
                                       const basic_rect<T>& snd) noexcept -> basic_rect<T>
{
  const auto fstHasArea = fst.has_area();
  const auto sndHasArea = snd.has_area();

  if (!fstHasArea && !sndHasArea) {
    return {};
  }
  else if (!fstHasArea) {
    return snd;
  }
  else if (!sndHasArea) {
    return fst;
  }

  const auto x = detail::min(fst.x(), snd.x());
  const auto y = detail::min(fst.y(), snd.y());
  const auto maxX = detail::max(fst.max_x(), snd.max_x());
  const auto maxY = detail::max(fst.max_y(), snd.max_y());

  return {{x, y}, {maxX - x, maxY - y}};
}

/// \} End of rectangle functions

/// \name Rectangle comparison operators
/// \{

/**
 * \brief Indicates whether or not two rectangles are equal.
 *
 * \tparam T the representation type used by the rectangles.
 *
 * \param lhs the left-hand side rectangle.
 * \param rhs the right-hand side rectangle.
 *
 * \return `true` if the rectangles are equal; `false` otherwise.
 *
 * \since 4.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator==(const basic_rect<T>& lhs,
                                        const basic_rect<T>& rhs) noexcept -> bool
{
  return (lhs.x() == rhs.x()) && (lhs.y() == rhs.y()) && (lhs.width() == rhs.width()) &&
         (lhs.height() == rhs.height());
}

/**
 * \brief Indicates whether or not two rectangles aren't equal.
 *
 * \tparam T the representation type used by the rectangles.
 *
 * \param lhs the left-hand side rectangle.
 * \param rhs the right-hand side rectangle.
 *
 * \return `true` if the rectangles aren't equal; `false` otherwise.
 *
 * \since 4.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator!=(const basic_rect<T>& lhs,
                                        const basic_rect<T>& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of rectangle comparison operators

/// \name Rectangle cast specializations
/// \{

template <>
[[nodiscard]] constexpr auto cast(const irect& from) noexcept -> frect
{
  const frect::point_type pos{static_cast<float>(from.x()), static_cast<float>(from.y())};
  const frect::area_type size{static_cast<float>(from.width()),
                              static_cast<float>(from.height())};
  return frect{pos, size};
}

template <>
[[nodiscard]] constexpr auto cast(const frect& from) noexcept -> irect
{
  const irect::point_type pos{static_cast<int>(from.x()), static_cast<int>(from.y())};
  const irect::area_type size{static_cast<int>(from.width()), static_cast<int>(from.height())};
  return irect{pos, size};
}

/// \} End of rectangle cast specializations

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a rectangle.
 *
 * \tparam T the representation type used by the rectangle.
 *
 * \param rect the rectangle that will be converted to a string.
 *
 * \return a textual representation of the rectangle.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_rect<T>& rect) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("rect{{x: {}, y: {}, width: {}, height: {}}}",
                     rect.x(),
                     rect.y(),
                     rect.width(),
                     rect.height());
#else
  return "rect{x: " + std::to_string(rect.x()) + ", y: " + std::to_string(rect.y()) +
         ", width: " + std::to_string(rect.width()) +
         ", height: " + std::to_string(rect.height()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a rectangle using a stream.
 *
 * \tparam T the representation type used by the rectangle.
 *
 * \param stream the stream that will be used.
 * \param rect the rectangle that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_rect<T>& rect) -> std::ostream&
{
  return stream << to_string(rect);
}

/// \} End of streaming

/// \} End of group math

}  // namespace cen

#endif  // CENTURION_RECTANGLE_HEADER
// #include "centurion/math/vector3.hpp"
#ifndef CENTURION_VECTOR3_HEADER
#define CENTURION_VECTOR3_HEADER

#include <ostream>  // ostream
#include <string>   // string, to_string

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

namespace cen {

/// \addtogroup math
/// \{

/**
 * \struct vector3
 *
 * \brief A simple representation of a 3-dimensional vector.
 *
 * \serializable
 *
 * \tparam T the representation type, e.g. `float` or `double`.
 *
 * \since 5.2.0
 */
template <typename T>
struct vector3 final
{
  using value_type = T;  ///< The type of the vector components.

  value_type x{};  ///< The x-coordinate of the vector.
  value_type y{};  ///< The y-coordinate of the vector.
  value_type z{};  ///< The z-coordinate of the vector.

#if CENTURION_HAS_FEATURE_SPACESHIP

  [[nodiscard]] constexpr auto operator<=>(const vector3&) const noexcept = default;

#endif  // CENTURION_HAS_FEATURE_SPACESHIP

  /**
   * \brief Casts the vector to a vector with another representation type.
   *
   * \tparam U the target vector type.
   *
   * \return the result vector.
   *
   * \since 5.2.0
   */
  template <typename U>
  [[nodiscard]] explicit operator vector3<U>() const noexcept
  {
    using target_value_type = typename vector3<U>::value_type;
    return vector3<U>{static_cast<target_value_type>(x),
                      static_cast<target_value_type>(y),
                      static_cast<target_value_type>(z)};
  }
};

/**
 * \brief Serializes a 3D-vector.
 *
 * \details This function expects that the archive provides an overloaded `operator()`,
 * used for serializing data. This API is based on the Cereal serialization library.
 *
 * \tparam Archive the type of the archive.
 * \tparam T the type of the vector components.
 *
 * \param archive the archive used to serialize the vector.
 * \param vector the vector that will be serialized.
 *
 * \since 5.3.0
 */
template <typename Archive, typename T>
void serialize(Archive& archive, vector3<T>& vector)
{
  archive(vector.x, vector.y, vector.z);
}

/// \name Vector3 comparison operators
/// \{

#if !CENTURION_HAS_FEATURE_SPACESHIP

/**
 * \brief Indicates whether or not two 3D vectors are equal.
 *
 * \tparam T the representation type used by the vectors.
 *
 * \param lhs the left-hand side vector.
 * \param rhs the right-hand side vector.
 *
 * \return `true` if the vectors are equal; `false` otherwise.
 *
 * \since 5.2.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator==(const vector3<T>& lhs, const vector3<T>& rhs) noexcept
    -> bool
{
  return (lhs.x == rhs.x) && (lhs.y == rhs.y) && (lhs.z == rhs.z);
}

/**
 * \brief Indicates whether or not two 3D vectors aren't equal.
 *
 * \tparam T the representation type used by the vectors.
 *
 * \param lhs the left-hand side vector.
 * \param rhs the right-hand side vector.
 *
 * \return `true` if the vectors aren't equal; `false` otherwise.
 *
 * \since 5.2.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator!=(const vector3<T>& lhs, const vector3<T>& rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

#endif  // CENTURION_HAS_FEATURE_SPACESHIP

/// \} End of vector3 comparison operators

/// \name String conversions
/// \{

/**
 * \brief Returns a string that represents a vector.
 *
 * \tparam T the representation type used by the vector.
 *
 * \param vector the vector that will be converted to a string.
 *
 * \return a string that represents the supplied vector.
 *
 * \since 5.2.0
 */
template <typename T>
[[nodiscard]] auto to_string(const vector3<T>& vector) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("vector3{{x: {}, y: {}, z: {}}}", vector.x, vector.y, vector.z);
#else
  return "vector3{x: " + std::to_string(vector.x) + ", y: " + std::to_string(vector.y) +
         ", z: " + std::to_string(vector.z) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a vector.
 *
 * \tparam T the representation type used by the vector.
 *
 * \param stream the stream that will be used.
 * \param vector the vector that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.2.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const vector3<T>& vector) -> std::ostream&
{
  return stream << to_string(vector);
}

/// \} End of streaming

/// \} End of group math

}  // namespace cen

#endif  // CENTURION_VECTOR3_HEADER

// #include "centurion/system/battery.hpp"
#ifndef CENTURION_BATTERY_HEADER
#define CENTURION_BATTERY_HEADER

#include <SDL.h>

#include <chrono>    // duration_cast
#include <optional>  // optional

// #include "../core/time.hpp"
#ifndef CENTURION_TIME_HEADER
#define CENTURION_TIME_HEADER

#include <chrono>  // duration
#include <ratio>   // milli, micro, nano

// #include "integers.hpp"
#ifndef CENTURION_INTEGERS_HEADER
#define CENTURION_INTEGERS_HEADER

#include <SDL.h>

#include <cstddef>  // size_t

namespace cen {

/// \addtogroup core
/// \{

/// \name Integer aliases
/// \{

using usize = std::size_t;

/// Alias for an unsigned integer.
using uint = unsigned int;

/// Alias for the type used for integer literal operators.
using ulonglong = unsigned long long;

/// Alias for a 64-bit unsigned integer.
using u64 = Uint64;

/// Alias for a 32-bit unsigned integer.
using u32 = Uint32;

/// Alias for a 16-bit unsigned integer.
using u16 = Uint16;

/// Alias for an 8-bit unsigned integer.
using u8 = Uint8;

/// Alias for a 64-bit signed integer.
using i64 = Sint64;

/// Alias for a 32-bit signed integer.
using i32 = Sint32;

/// Alias for a 16-bit signed integer.
using i16 = Sint16;

/// Alias for an 8-bit signed integer.
using i8 = Sint8;

/// \} End of integer aliases

// clang-format off

/**
 * \brief Obtains the size of a container as an `int`.
 *
 * \tparam T a "container" that provides a `size()` member function.
 *
 * \param container the container to query the size of.
 *
 * \return the size of the container as an `int` value.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto isize(const T& container) noexcept(noexcept(container.size()))
    -> int
{
  return static_cast<int>(container.size());
}

// clang-format on

namespace literals {

/**
 * \brief Creates an 8-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u8(const ulonglong value) noexcept -> u8
{
  return static_cast<u8>(value);
}

/**
 * \brief Creates a 16-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u16(const ulonglong value) noexcept -> u16
{
  return static_cast<u16>(value);
}

/**
 * \brief Creates a 32-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u32(const ulonglong value) noexcept -> u32
{
  return static_cast<u32>(value);
}

/**
 * \brief Creates a 64-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u64(const ulonglong value) noexcept -> u64
{
  return static_cast<u64>(value);
}

/**
 * \brief Creates an 8-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i8(const ulonglong value) noexcept -> i8
{
  return static_cast<i8>(value);
}

/**
 * \brief Creates a 16-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i16(const ulonglong value) noexcept -> i16
{
  return static_cast<i16>(value);
}

/**
 * \brief Creates a 32-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i32(const ulonglong value) noexcept -> i32
{
  return static_cast<i32>(value);
}

/**
 * \brief Creates a 64-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i64(const ulonglong value) noexcept -> i64
{
  return static_cast<i64>(value);
}

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_INTEGERS_HEADER


namespace cen {

/// \addtogroup core
/// \{

/// \name Time (std::chrono) aliases
/// \{

/**
 * \typedef seconds
 *
 * \brief Templated alias for durations in seconds.
 */
template <typename T>
using seconds = std::chrono::duration<T>;

/**
 * \typedef milliseconds
 *
 * \brief Templated alias for durations in milliseconds.
 */
template <typename T>
using milliseconds = std::chrono::duration<T, std::milli>;

/**
 * \typedef microseconds
 *
 * \brief Templated alias for durations in microseconds.
 */
template <typename T>
using microseconds = std::chrono::duration<T, std::micro>;

/**
 * \typedef nanoseconds
 *
 * \brief Templated alias for durations in nanoseconds.
 */
template <typename T>
using nanoseconds = std::chrono::duration<T, std::nano>;

/**
 * \typedef minutes
 *
 * \brief Templated alias for durations in minutes.
 */
template <typename T>
using minutes = std::chrono::duration<T, std::ratio<60>>;

/// \} End of time (std::chrono) aliases

namespace literals {

// clang-format off

[[nodiscard]] constexpr auto operator"" _ns(const ulonglong value) noexcept(noexcept(nanoseconds<u32>{}))
    -> nanoseconds<u32>
{
  return nanoseconds<u32>{value};
}

[[nodiscard]] constexpr auto operator"" _us(const ulonglong value) noexcept(noexcept(microseconds<u32>{}))
    -> microseconds<u32>
{
  return microseconds<u32>{value};
}

[[nodiscard]] constexpr auto operator"" _ms(const ulonglong value) noexcept(noexcept(milliseconds<u32>{}))
    -> milliseconds<u32>
{
  return milliseconds<u32>{value};
}

[[nodiscard]] constexpr auto operator"" _s(const ulonglong value) noexcept(noexcept(seconds<u32>{}))
    -> seconds<u32>
{
  return seconds<u32>{value};
}

// clang-format on

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_TIME_HEADER

// #include "../detail/any_eq.hpp"
#ifndef CENTURION_DETAIL_ANY_EQ_HEADER
#define CENTURION_DETAIL_ANY_EQ_HEADER

/// \cond FALSE
namespace cen::detail {

// clang-format off

/**
 * \brief Indicates whether or not any of the supplied values are equal to a specific value.
 *
 * \tparam T the type of the value to look for.
 *
 * \tparam Args the type of the arguments that will be checked.
 *
 * \param value the value to look for.
 * \param args the arguments that will be compared with the value.
 *
 * \return `true` if any of the supplied values are equal to `value`; `false` otherwise.
 *
 * \since 5.1.0
 */
template <typename T, typename... Args>
[[nodiscard]] constexpr auto any_eq(const T& value, Args&&... args)
    noexcept(noexcept( ((value == args) || ...) )) -> bool
{
  return ((value == args) || ...);
}

// clang-format on

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_ANY_EQ_HEADER

// #include "power_state.hpp"
#ifndef CENTURION_POWER_STATE_HEADER
#define CENTURION_POWER_STATE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER


namespace cen {

/// \addtogroup system
/// \{

/**
 * \enum power_state
 *
 * \brief Represents different battery power states.
 *
 * \since 3.0.0
 *
 * \see `SDL_PowerState`
 */
enum class power_state
{
  unknown = SDL_POWERSTATE_UNKNOWN,        ///< The status is unknown.
  on_battery = SDL_POWERSTATE_ON_BATTERY,  ///< Not plugged in and running on battery.
  no_battery = SDL_POWERSTATE_NO_BATTERY,  ///< No battery available.
  charging = SDL_POWERSTATE_CHARGING,      ///< Currently charging the battery.
  charged = SDL_POWERSTATE_CHARGED         ///< Currently plugged in and charged.
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied power state.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(power_state::on_battery) == "on_battery"`.
 *
 * \param state the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const power_state state) -> std::string_view
{
  switch (state) {
    case power_state::unknown:
      return "unknown";

    case power_state::on_battery:
      return "on_battery";

    case power_state::no_battery:
      return "no_battery";

    case power_state::charging:
      return "charging";

    case power_state::charged:
      return "charged";

    default:
      throw cen_error{"Did not recognize power state!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a power state enumerator.
 *
 * \param stream the output stream that will be used.
 * \param state the enumerator that will be printed.
 *
 * \see `to_string(power_state)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const power_state state) -> std::ostream&
{
  return stream << to_string(state);
}

/// \} End of streaming

/// \name Power state comparison operators
/// \{

/**
 * \brief Indicates whether or not two power states values are the same.
 *
 * \param lhs the left-hand side power state value.
 * \param rhs the right-hand side power state value.
 *
 * \return `true` if the power states are the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const power_state lhs,
                                        const SDL_PowerState rhs) noexcept -> bool
{
  return static_cast<SDL_PowerState>(lhs) == rhs;
}

/// \copydoc operator==(power_state, SDL_PowerState)
[[nodiscard]] constexpr auto operator==(const SDL_PowerState lhs,
                                        const power_state rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two power states values aren't the same.
 *
 * \param lhs the left-hand side power state value.
 * \param rhs the right-hand side power state value.
 *
 * \return `true` if the power states aren't the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator!=(const power_state lhs,
                                        const SDL_PowerState rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(power_state, SDL_PowerState)
[[nodiscard]] constexpr auto operator!=(const SDL_PowerState lhs,
                                        const power_state rhs) noexcept -> bool
{
  return rhs != lhs;
}

/// \} End of power state comparison operators

/// \} End of group system

}  // namespace cen

#endif  // CENTURION_POWER_STATE_HEADER


/**
 * \namespace cen::battery
 *
 * \brief Contains utilities related to the battery of the system.
 *
 * \ingroup system
 *
 * \since 5.0.0
 */
namespace cen::battery {

/// \addtogroup system
/// \{

/// \name Battery functions
/// \{

/**
 * \brief Returns the seconds of battery life that is remaining.
 *
 * \return seconds of remaining battery life; `std::nullopt` if the value cannot be
 * computed.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto seconds_left() -> std::optional<seconds<int>>
{
  int secondsLeft{-1};
  SDL_GetPowerInfo(&secondsLeft, nullptr);
  if (secondsLeft != -1) {
    return seconds<int>{secondsLeft};
  }
  else {
    return std::nullopt;
  }
}

/**
 * \brief Returns the amount of minutes of battery life that is remaining.
 *
 * \return minutes of remaining battery life; `std::nullopt` if the value cannot be
 * computed.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto minutes_left() -> std::optional<minutes<int>>
{
  if (const auto secondsLeft = seconds_left()) {
    return std::chrono::duration_cast<minutes<int>>(*secondsLeft);
  }
  else {
    return std::nullopt;
  }
}

/**
 * \brief Returns the percentage of battery life that is currently left.
 *
 * \return percentage of remaining battery life, in the range [0, 100]; `std::nullopt` if
 * the battery percentage isn't available.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto percentage() noexcept -> std::optional<int>
{
  int percentageLeft{-1};
  SDL_GetPowerInfo(nullptr, &percentageLeft);
  if (percentageLeft != -1) {
    return percentageLeft;
  }
  else {
    return std::nullopt;
  }
}

/**
 * \brief Returns the current power state.
 *
 * \return the current power state.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto state() noexcept -> power_state
{
  return static_cast<power_state>(SDL_GetPowerInfo(nullptr, nullptr));
}

/**
 * \brief Indicates whether or not the system is running on a battery.
 *
 * \details This function is simply a convenience function that is based on the
 * `battery::state()` function.
 *
 * \return `true` if the system is running on a battery; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] inline auto exists() noexcept -> bool
{
  return detail::any_eq(state(),
                        power_state::on_battery,
                        power_state::charged,
                        power_state::charging);
}

/**
 * \brief Indicate whether or not the battery is being charged.
 *
 * \details This convenience function is equivalent to checking if `battery::state()` is
 * equal to `power_state::charging`.
 *
 * \return `true` if the battery is charging; `false` otherwise.
 *
 * \since 5.1.0
 */
[[nodiscard]] inline auto is_charging() noexcept -> bool
{
  return state() == power_state::charging;
}

/**
 * \brief Indicate whether or not the battery is charged.
 *
 * \details This convenience function is equivalent to checking if `battery::state()` is
 * equal to `power_state::charged`.
 *
 * \return `true` if the battery is charged; `false` otherwise.
 *
 * \since 5.1.0
 */
[[nodiscard]] inline auto is_charged() noexcept -> bool
{
  return state() == power_state::charged;
}

/**
 * \brief Indicate whether or not a battery is available.
 *
 * \details This convenience function considers a battery available if the state returned
 * from `battery::state()` is neither `no_battery` nor `unknown`.
 *
 * \return `true` if a battery is available; `false` otherwise.
 *
 * \since 5.1.0
 */
[[nodiscard]] inline auto is_available() noexcept -> bool
{
  return !detail::any_eq(state(), power_state::no_battery, power_state::unknown);
}

/// \} End of battery functions

/// \} End of group system

}  // namespace cen::battery

#endif  // CENTURION_BATTERY_HEADER
// #include "centurion/system/byte_order.hpp"
#ifndef CENTURION_BYTE_ORDER_HEADER
#define CENTURION_BYTE_ORDER_HEADER

#include <SDL.h>

// #include "../core/integers.hpp"
#ifndef CENTURION_INTEGERS_HEADER
#define CENTURION_INTEGERS_HEADER

#include <SDL.h>

#include <cstddef>  // size_t

namespace cen {

/// \addtogroup core
/// \{

/// \name Integer aliases
/// \{

using usize = std::size_t;

/// Alias for an unsigned integer.
using uint = unsigned int;

/// Alias for the type used for integer literal operators.
using ulonglong = unsigned long long;

/// Alias for a 64-bit unsigned integer.
using u64 = Uint64;

/// Alias for a 32-bit unsigned integer.
using u32 = Uint32;

/// Alias for a 16-bit unsigned integer.
using u16 = Uint16;

/// Alias for an 8-bit unsigned integer.
using u8 = Uint8;

/// Alias for a 64-bit signed integer.
using i64 = Sint64;

/// Alias for a 32-bit signed integer.
using i32 = Sint32;

/// Alias for a 16-bit signed integer.
using i16 = Sint16;

/// Alias for an 8-bit signed integer.
using i8 = Sint8;

/// \} End of integer aliases

// clang-format off

/**
 * \brief Obtains the size of a container as an `int`.
 *
 * \tparam T a "container" that provides a `size()` member function.
 *
 * \param container the container to query the size of.
 *
 * \return the size of the container as an `int` value.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto isize(const T& container) noexcept(noexcept(container.size()))
    -> int
{
  return static_cast<int>(container.size());
}

// clang-format on

namespace literals {

/**
 * \brief Creates an 8-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u8(const ulonglong value) noexcept -> u8
{
  return static_cast<u8>(value);
}

/**
 * \brief Creates a 16-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u16(const ulonglong value) noexcept -> u16
{
  return static_cast<u16>(value);
}

/**
 * \brief Creates a 32-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u32(const ulonglong value) noexcept -> u32
{
  return static_cast<u32>(value);
}

/**
 * \brief Creates a 64-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u64(const ulonglong value) noexcept -> u64
{
  return static_cast<u64>(value);
}

/**
 * \brief Creates an 8-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i8(const ulonglong value) noexcept -> i8
{
  return static_cast<i8>(value);
}

/**
 * \brief Creates a 16-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i16(const ulonglong value) noexcept -> i16
{
  return static_cast<i16>(value);
}

/**
 * \brief Creates a 32-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i32(const ulonglong value) noexcept -> i32
{
  return static_cast<i32>(value);
}

/**
 * \brief Creates a 64-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i64(const ulonglong value) noexcept -> i64
{
  return static_cast<i64>(value);
}

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_INTEGERS_HEADER


namespace cen {

/// \addtogroup system
/// \{

/// \name Byte order swapping
/// \{

/**
 * \brief Swaps the byte order of the specified value and returns the result.
 *
 * \param value the value to swap the byte order of.
 *
 * \return the swapped byte order value.
 *
 * \since 5.3.0
 */
[[nodiscard]] inline auto swap_byte_order(const u16 value) noexcept -> u16
{
  return SDL_Swap16(value);
}

/// \copydoc swap_byte_order()
[[nodiscard]] inline auto swap_byte_order(const u32 value) noexcept -> u32
{
  return SDL_Swap32(value);
}

/// \copydoc swap_byte_order()
[[nodiscard]] inline auto swap_byte_order(const u64 value) noexcept -> u64
{
  return SDL_Swap64(value);
}

/// \copydoc swap_byte_order()
[[nodiscard]] inline auto swap_byte_order(const float value) noexcept -> float
{
  return SDL_SwapFloat(value);
}

/// \} End of byte order swapping

/// \name Swap from big endian to native format
/// \{

/**
 * \brief Swaps the big endian value to a little endian value and returns it.
 *
 * \param value the big endian value that will be swapped.
 *
 * \return the resulting little endian value.
 *
 * \since 5.3.0
 */
[[nodiscard]] inline auto swap_big_endian(const u16 value) noexcept -> u16
{
  return SDL_SwapBE16(value);
}

/// \copydoc swap_big_endian()
[[nodiscard]] inline auto swap_big_endian(const u32 value) noexcept -> u32
{
  return SDL_SwapBE32(value);
}

/// \copydoc swap_big_endian()
[[nodiscard]] inline auto swap_big_endian(const u64 value) noexcept -> u64
{
  return SDL_SwapBE64(value);
}

/// \copydoc swap_big_endian()
[[nodiscard]] inline auto swap_big_endian(const float value) noexcept -> float
{
  return SDL_SwapFloatBE(value);
}

/// \} End of swap from big endian to native format

/// \name Swap from little endian to native format
/// \{

/**
 * \brief Swaps the little endian value to a big endian value and returns it.
 *
 * \param value the little endian value that will be swapped.
 *
 * \return the resulting big endian value.
 *
 * \since 5.3.0
 */
[[nodiscard]] inline auto swap_little_endian(const u16 value) noexcept -> u16
{
  return SDL_SwapLE16(value);
}

/// \copydoc swap_little_endian()
[[nodiscard]] inline auto swap_little_endian(const u32 value) noexcept -> u32
{
  return SDL_SwapLE32(value);
}

/// \copydoc swap_little_endian()
[[nodiscard]] inline auto swap_little_endian(const u64 value) noexcept -> u64
{
  return SDL_SwapLE64(value);
}

/// \copydoc swap_little_endian()
[[nodiscard]] inline auto swap_little_endian(const float value) noexcept -> float
{
  return SDL_SwapFloatLE(value);
}

/// \} End of swap from little endian to native format

/// \} End of group system

}  // namespace cen

#endif  // CENTURION_BYTE_ORDER_HEADER

// #include "centurion/system/clipboard.hpp"
#ifndef CENTURION_CLIPBOARD_HEADER
#define CENTURION_CLIPBOARD_HEADER

#include <SDL.h>

#include <cassert>  // assert
#include <string>   // string

// #include "../core/not_null.hpp"
#ifndef CENTURION_NOT_NULL_HEADER
#define CENTURION_NOT_NULL_HEADER

// #include "sfinae.hpp"
#ifndef CENTURION_SFINAE_HEADER
#define CENTURION_SFINAE_HEADER

#include <type_traits>  // enable_if_t, is_same_v, is_integral_v, is_floating_point_v, ...

namespace cen {

/// \addtogroup core
/// \{

// clang-format off

/// Enables a template if the type is either integral of floating-point, but not a boolean.
template <typename T>
using enable_if_number_t = std::enable_if_t<!std::is_same_v<T, bool> &&
                                            (std::is_integral_v<T> ||
                                             std::is_floating_point_v<T>), int>;

// clang-format on

/// Enables a template if the type is a pointer.
template <typename T>
using enable_if_pointer_v = std::enable_if_t<std::is_pointer_v<T>, int>;

/// Enables a template if T is convertible to any of the specified types.
template <typename T, typename... Args>
using enable_if_convertible_t = std::enable_if_t<(std::is_convertible_v<T, Args> || ...), int>;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_SFINAE_HEADER


namespace cen {

/**
 * \typedef not_null
 *
 * \ingroup core
 *
 * \brief Tag used to indicate that a pointer cannot be null.
 *
 * \note This alias is equivalent to `T`, it is a no-op.
 *
 * \since 5.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using not_null = T;

}  // namespace cen

#endif  // CENTURION_NOT_NULL_HEADER

// #include "../core/result.hpp"
#ifndef CENTURION_RESULT_HEADER
#define CENTURION_RESULT_HEADER

#include <ostream>  // ostream
#include <string>   // string

namespace cen {

/// \addtogroup core
/// \{

/**
 * \class result
 *
 * \brief A simple indicator for the result of different operations.
 *
 * \details The idea behind this class is to make results of various operations
 * unambiguous. Quite an amount of functions in the library may fail, and earlier versions
 * of Centurion would usually return a `bool` in those cases, where `true` and `false`
 * would indicate success and failure, respectively. This class is a development of that
 * practice. For instance, this class is contextually convertible to `bool`, where a
 * successful result is still converted to `true`, and vice versa. However, this class
 * also enables explicit checks against `success` and `failure` constants, which makes
 * code very easy to read and unambiguous.
 * \code{cpp}
 *   cen::window window;
 *
 *   if (window.set_opacity(0.4f))
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::success)
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::failure)
 *   {
 *     // Failure!
 *   }
 * \endcode
 *
 * \see `success`
 * \see `failure`
 *
 * \since 6.0.0
 */
class result final
{
 public:
  /**
   * \brief Creates a result.
   *
   * \param success `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  constexpr result(const bool success) noexcept  // NOLINT implicit
      : m_success{success}
  {}

  /// \name Comparison operators
  /// \{

  /**
   * \brief Indicates whether or not two results have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results are equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator==(const result other) const noexcept -> bool
  {
    return m_success == other.m_success;
  }

  /**
   * \brief Indicates whether or not two results don't have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results aren't equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator!=(const result other) const noexcept -> bool
  {
    return !(*this == other);
  }

  /// \} End of comparison operators

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not the result is successful.
   *
   * \return `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr explicit operator bool() const noexcept
  {
    return m_success;
  }

  /// \} End of conversions

 private:
  bool m_success{};
};

/// Represents a successful result.
/// \since 6.0.0
inline constexpr result success{true};

/// Represents a failure of some kind.
/// \since 6.0.0
inline constexpr result failure{false};

/// \name String conversions
/// \{

/**
 * \brief Returns a string that represents a result value.
 *
 * \note The returned string is in a slightly different format compared to other Centurion
 * components.
 *
 * \param result the value that will be converted.
 *
 * \return `"success"` for a successful result; `"failure"` otherwise.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto to_string(const result result) -> std::string
{
  return result ? "success" : "failure";
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a result value using a stream.
 *
 * \param stream the stream that will be used.
 * \param result the result value that will be printed.
 *
 * \return the used stream.
 *
 * \since 6.0.0
 */
inline auto operator<<(std::ostream& stream, const result result) -> std::ostream&
{
  return stream << to_string(result);
}

/// \} End of streaming

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_RESULT_HEADER

// #include "../core/sdl_string.hpp"
#ifndef CENTURION_SDL_STRING_HEADER
#define CENTURION_SDL_STRING_HEADER

#include <SDL.h>

#include <memory>  // unique_ptr
#include <string>  // string

// #include "../detail/sdl_deleter.hpp"
#ifndef CENTURION_DETAIL_SDL_DELETER_HEADER
#define CENTURION_DETAIL_SDL_DELETER_HEADER

#include <SDL.h>

/// \cond FALSE
namespace cen::detail {

template <typename T>
struct sdl_deleter final
{
  void operator()(T* ptr) noexcept
  {
    SDL_free(ptr);
  }
};

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_SDL_DELETER_HEADER

// #include "owner.hpp"
#ifndef CENTURION_OWNER_HEADER
#define CENTURION_OWNER_HEADER

// #include "sfinae.hpp"


namespace cen {

/**
 * \typedef owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote ownership of raw pointers directly in code.
 *
 * \details If a function takes an `owner<T*>` as a parameter, then the function will
 * claim ownership of that pointer. Subsequently, if a function returns an `owner<T*>`,
 * then ownership is transferred to the caller.
 */
template <typename T, enable_if_pointer_v<T> = 0>
using owner = T;

/**
 * \typedef maybe_owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote conditional ownership of raw pointers directly in code.
 *
 * \details This is primarily used in constructors of owner/handle classes, where the
 * owner version will claim ownership of the pointer, whilst the handle does not.
 *
 * \since 6.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using maybe_owner = T;

}  // namespace cen

#endif  // CENTURION_OWNER_HEADER
// #include "str.hpp"


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class sdl_string
 *
 * \brief Represents an SDL string.
 *
 * \details Certain SDL APIs return `char*` strings that need to be freed using
 * `SDL_free`, this class serves as a small wrapper around such strings. Use the `copy()`
 * member function to convert the string into a corresponding `std::string`.
 *
 * \note Instances of `sdl_string` might manage null strings. Use the overloaded `operator
 * bool()` in order to determine whether or not any associated string is null.
 *
 * \since 5.0.0
 */
class sdl_string final
{
 public:
  /**
   * \brief Creates a string.
   *
   * \param str the string that will be claimed, can be null.
   *
   * \since 5.0.0
   */
  explicit sdl_string(owner<char*> str) noexcept : m_str{str}
  {}

  /**
   * \brief Returns the internal string, which might be null.
   *
   * \return the internal string; `nullptr` if there is none.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get() const noexcept -> str
  {
    return m_str.get();
  }

  /**
   * \brief Returns a copy of the internal string.
   *
   * \details This function returns the empty string if the internal string is a null
   * pointer.
   *
   * \return a copy of the internal string.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto copy() const -> std::string
  {
    if (m_str) {
      return std::string{get()};
    }
    else {
      return std::string{};
    }
  }

  /**
   * \brief Indicates whether or not the internal string is non-null.
   *
   * \return `true` if the internal string is non-null; `false` otherwise.
   *
   * \since 5.0.0
   */
  explicit operator bool() const noexcept
  {
    return m_str.operator bool();
  }

 private:
  std::unique_ptr<char, detail::sdl_deleter<char>> m_str;
};

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_SDL_STRING_HEADER

// #include "../core/str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


/**
 * \namespace cen::clipboard
 *
 * \brief Provides functions related to managing the clipboard.
 *
 * \ingroup system
 *
 * \since 5.0.0
 */
namespace cen::clipboard {

/// \addtogroup system
/// \{

/// \name Clipboard functions
/// \{

/**
 * \brief Indicates whether or not there is a clipboard exists and that it contains
 * non-empty text.
 *
 * \return `true` if there is a clipboard that contains non-empty text; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto has_text() noexcept -> bool
{
  return SDL_HasClipboardText();
}

/**
 * \brief Returns the current text in the clipboard.
 *
 * \note If the clipboard cannot be obtained, this function returns the empty string.
 *
 * \return the current clipboard text.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto get_text() -> std::string
{
  const sdl_string text{SDL_GetClipboardText()};
  return text.copy();
}

/**
 * \brief Sets the current clipboard text.
 *
 * \pre `text` cannot be null.
 *
 * \param text the text that will be stored in the clipboard.
 *
 * \return `true` if the clipboard text was successfully set; `false` otherwise.
 *
 * \since 5.0.0
 */
inline auto set_text(const not_null<str> text) noexcept -> bool
{
  assert(text);
  return SDL_SetClipboardText(text) == 0;
}

/**
 * \brief Sets the current clipboard text.
 *
 * \param text the text that will be stored in the clipboard.
 *
 * \return `success` if the clipboard text was successfully set; `failure` otherwise.
 *
 * \since 5.3.0
 */
inline auto set_text(const std::string& text) noexcept -> result
{
  return set_text(text.c_str());
}

/// \} End of clipboard functions

/// \} End of group system

}  // namespace cen::clipboard

#endif  // CENTURION_CLIPBOARD_HEADER

// #include "centurion/system/counter.hpp"
#ifndef CENTURION_TIMER_HEADER
#define CENTURION_TIMER_HEADER

#include <SDL.h>

// #include "../core/time.hpp"


/**
 * \namespace cen::counter
 *
 * \brief Provides timing utilities.
 *
 * \since 5.0.0
 */
namespace cen::counter {

/// \addtogroup system
/// \{

/// \name Counter functions
/// \{

/**
 * \brief Returns the frequency of the system high-performance counter.
 *
 * \return the frequency of the system high-performance counter.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto frequency() noexcept -> u64
{
  return SDL_GetPerformanceFrequency();
}

/**
 * \brief Returns the current raw value of the system high-performance counter.
 *
 * \note The unit of the returned value is platform dependent.
 *
 * \return the current value of the system high-performance counter.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto now() noexcept -> u64
{
  return SDL_GetPerformanceCounter();
}

/**
 * \brief Returns the value of the system high-performance counter in seconds.
 *
 * \tparam T the representation type.
 *
 * \return the value of the system high-performance counter, in seconds.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto now_in_seconds() noexcept(noexcept(seconds<T>{})) -> seconds<T>
{
  return seconds<T>{static_cast<T>(SDL_GetPerformanceCounter()) / static_cast<T>(frequency())};
}

/**
 * \brief Returns the amount of milliseconds since the library was initialized.
 *
 * \return the amount of milliseconds since the library was initialized.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto ticks() noexcept(noexcept(milliseconds<u32>{u32{}}))
    -> milliseconds<u32>
{
  return milliseconds<u32>{SDL_GetTicks()};
}

/// \} End of counter functions

/// \} End of group system

}  // namespace cen::counter

#endif  // CENTURION_TIMER_HEADER
// #include "centurion/system/cpu.hpp"
#ifndef CENTURION_CPU_HEADER
#define CENTURION_CPU_HEADER

#include <SDL.h>

#include <memory>  // unique_ptr

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup system
/// \{

/**
 * \class simd_block
 *
 * \brief Represents a block of memory, allocated in SIMD-friendly way.
 *
 * \since 5.2.0
 */
class simd_block final
{
 public:
  /**
   * \brief Allocates a block of SIMD-friendly memory.
   *
   * \note The allocation might fail, in which case the internal pointer is null.
   *
   * \param size the size of the memory block.
   *
   * \since 5.2.0
   */
  explicit simd_block(const usize size) noexcept : m_data{SDL_SIMDAlloc(size)}
  {}

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Reallocates the associated memory block.
   *
   * \param size the size of the new memory block.
   *
   * \since 5.2.0
   */
  void reallocate(const usize size) noexcept
  {
    /* We temporarily release the ownership of the pointer in order to avoid a double
       delete, since the reallocation will free the previously allocated memory. */
    auto* ptr = m_data.release();
    m_data.reset(SDL_SIMDRealloc(ptr, size));
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Returns a pointer to the associated memory block.
   *
   * \return a pointer to the memory block.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto data() noexcept -> void*
  {
    return m_data.get();
  }

  /// \copydoc data()
  [[nodiscard]] auto data() const noexcept -> const void*
  {
    return m_data.get();
  }

  /**
   * \brief Returns a reinterpreted pointer to the associated memory block.
   *
   * \warning It's your responsibility to make sure to avoid any potential undefined
   * behaviour using this function, since it uses `reinterpret_cast`.
   *
   * \tparam T the type used when reinterpreting the internal pointer.
   *
   * \return a pointer to the associated memory block.
   *
   * \since 5.2.0
   */
  template <typename T>
  [[nodiscard]] auto cast_data() noexcept -> T*
  {
    return reinterpret_cast<T*>(data());
  }

  /// \copydoc cast_data()
  template <typename T>
  [[nodiscard]] auto cast_data() const noexcept -> const T*
  {
    return reinterpret_cast<const T*>(data());
  }

  /**
   * \brief Indicates whether or not the internal pointer isn't null.
   *
   * \return `true` if the internal pointer is non-null; `false` otherwise.
   *
   * \since 5.2.0
   */
  explicit operator bool() const noexcept
  {
    return m_data.operator bool();
  }

 private:
  struct deleter final
  {
    void operator()(void* ptr) noexcept
    {
      SDL_SIMDFree(ptr);
    }
  };
  std::unique_ptr<void, deleter> m_data;
};

/// \} End of group system

}  // namespace cen

/**
 * \namespace cen::cpu
 *
 * \brief Provides methods for obtaining information about the processor.
 *
 * \since 5.0.0
 */
namespace cen::cpu {

/// \addtogroup system
/// \{

/// \name CPU functions
/// \{

/**
 * \brief Returns the CPU L1 cache line size.
 *
 * \return the L1 cache line size, in bytes.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto cache_line_size() noexcept -> int
{
  return SDL_GetCPUCacheLineSize();
}

/**
 * \brief Returns the amount of cores that the CPU has.
 *
 * \return the amount of cores.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto cores() noexcept -> int
{
  return SDL_GetCPUCount();
}

/**
 * \brief Indicates whether or not the CPU has the RDTSC instruction.
 *
 * \return `true` if the CPU has the RDTSC instruction; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] inline auto has_rdtsc() noexcept -> bool
{
  return SDL_HasRDTSC();
}

/**
 * \brief Indicates whether or not the CPU has AltiVec features.
 *
 * \return `true` if the CPU has AltiVec features; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] inline auto has_altivec() noexcept -> bool
{
  return SDL_HasAltiVec();
}

/**
 * \brief Indicates whether or not the CPU has MMX features.
 *
 * \return `true` if the CPU has MMX features; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] inline auto has_mmx() noexcept -> bool
{
  return SDL_HasMMX();
}

/**
 * \brief Indicates whether or not the CPU has 3DNow! features.
 *
 * \return `true` if the CPU has 3DNow! features; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] inline auto has_3dnow() noexcept -> bool
{
  return SDL_Has3DNow();
}

/**
 * \brief Indicates whether or not the CPU has SSE features.
 *
 * \return `true` if the CPU has SSE features; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] inline auto has_sse() noexcept -> bool
{
  return SDL_HasSSE();
}

/**
 * \brief Indicates whether or not the CPU has SSE2 features.
 *
 * \return `true` if the CPU has SSE2 features; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] inline auto has_sse2() noexcept -> bool
{
  return SDL_HasSSE2();
}
/**
 * \brief Indicates whether or not the CPU has SSE3 features.
 *
 * \return `true` if the CPU has SSE3 features; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] inline auto has_sse3() noexcept -> bool
{
  return SDL_HasSSE3();
}

/**
 * \brief Indicates whether or not the CPU has SSE4.1 features.
 *
 * \return `true` if the CPU has SSE4.1 features; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] inline auto has_sse41() noexcept -> bool
{
  return SDL_HasSSE41();
}

/**
 * \brief Indicates whether or not the CPU has SSE4.2 features.
 *
 * \return `true` if the CPU has SSE4.2 features; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] inline auto has_sse42() noexcept -> bool
{
  return SDL_HasSSE42();
}

/**
 * \brief Indicates whether or not the CPU has AVX features.
 *
 * \return `true` if the CPU has AVX features; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] inline auto has_avx() noexcept -> bool
{
  return SDL_HasAVX();
}

/**
 * \brief Indicates whether or not the CPU has AVX2 features.
 *
 * \return `true` if the CPU has AVX2 features; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] inline auto has_avx2() noexcept -> bool
{
  return SDL_HasAVX2();
}

/**
 * \brief Indicates whether or not the CPU has AVX-512F (foundation) features.
 *
 * \return `true` if the CPU has AVX-512F (foundation) features; `false`
 * otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] inline auto has_avx512f() noexcept -> bool
{
  return SDL_HasAVX512F();
}

/**
 * \brief Indicates whether or not the CPU has NEON (ARM SIMD) features.
 *
 * \return `true` if the CPU has NEON (ARM SIMD) features; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] inline auto has_neon() noexcept -> bool
{
  return SDL_HasNEON();
}

#if SDL_VERSION_ATLEAST(2, 0, 12)

/**
 * \brief Indicates whether or not the CPU has ARM SIMD (ARMv6+) features.
 *
 * \return `true` if the CPU has ARM SIMD (ARMv6+) features; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] inline auto has_arm_simd() noexcept -> bool
{
  return SDL_HasARMSIMD();
}

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

/**
 * \brief Returns the minimum number of bytes to which a pointer must be aligned to be
 * compatible with SIMD instructions on the current CPU.
 *
 * \return the minimum number of bytes to which a pointer must be aligned to be compatible
 * with SIMD instructions.
 *
 * \since 4.0.0
 */
[[nodiscard]] inline auto simd_alignment() noexcept -> usize
{
  return SDL_SIMDGetAlignment();
}

/**
 * \brief Indicates whether or not the CPU uses big-endian byte ordering.
 *
 * \return `true` if the CPU uses big-endian byte ordering; `false` otherwise.
 *
 * \since 3.1.0
 */
[[nodiscard]] constexpr auto is_big_endian() noexcept -> bool
{
  return SDL_BYTEORDER == SDL_BIG_ENDIAN;
}

/**
 * \brief Indicates whether or not the CPU uses little-endian byte ordering.
 *
 * \return `true` if the CPU uses little-endian byte ordering; `false` otherwise.
 *
 * \since 3.1.0
 */
[[nodiscard]] constexpr auto is_little_endian() noexcept -> bool
{
  return SDL_BYTEORDER == SDL_LIL_ENDIAN;
}

/// \} End of CPU functions

/// \} End of group system

}  // namespace cen::cpu

#endif  // CENTURION_CPU_HEADER
// #include "centurion/system/locale.hpp"
#ifndef CENTURION_LOCALE_HEADER
#define CENTURION_LOCALE_HEADER

#include <SDL.h>

#include <cassert>  // assert
#include <memory>   // unique_ptr

// #include "../core/integers.hpp"

// #include "../core/not_null.hpp"

// #include "../core/str.hpp"

// #include "../detail/czstring_eq.hpp"
#ifndef CENTURION_DETAIL_CZSTRING_EQ_HEADER
#define CENTURION_DETAIL_CZSTRING_EQ_HEADER

#include <cstring>  // strcmp

// #include "../core/str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


/// \cond FALSE
namespace cen::detail {

/**
 * \brief Indicates whether or not two C-style strings are equal.
 *
 * \param lhs the left-hand side string, can safely be null.
 * \param rhs the right-hand side string, can safely be null.
 *
 * \return `true` if the strings are equal; `false` otherwise.
 *
 * \since 4.1.0
 */
[[nodiscard]] inline auto czstring_eq(const str lhs, const str rhs) noexcept -> bool
{
  if (lhs && rhs) {
    return std::strcmp(lhs, rhs) == 0;
  }
  else {
    return false;
  }
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_CZSTRING_EQ_HEADER

// #include "../detail/sdl_deleter.hpp"
#ifndef CENTURION_DETAIL_SDL_DELETER_HEADER
#define CENTURION_DETAIL_SDL_DELETER_HEADER

#include <SDL.h>

/// \cond FALSE
namespace cen::detail {

template <typename T>
struct sdl_deleter final
{
  void operator()(T* ptr) noexcept
  {
    SDL_free(ptr);
  }
};

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_SDL_DELETER_HEADER


namespace cen {

#if SDL_VERSION_ATLEAST(2, 0, 14)

/// \addtogroup system
/// \{

/**
 * \class locale
 *
 * \brief Represents a set of locale entries.
 *
 * \since 5.2.0
 */
class locale final
{
 public:
  /**
   * \brief Returns the current preferred locales on the system.
   *
   * \note The preferred locales might change during the execution of the program.
   *
   * \return the preferred locales on the system.
   *
   * \since 5.2.0
   */
  [[nodiscard]] static auto get_preferred() noexcept -> locale
  {
    return locale{SDL_GetPreferredLocales()};
  }

  /**
   * \brief Indicates whether or not a language (and optionally a country) is part of the
   * locale.
   *
   * \param language the language that will be checked, e.g. "en" for english.
   * \param country optional country code that will be checked, e.g. "US" or "GB".
   *
   * \return `true` if the specified language and country is a part of the locale; `false`
   * otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto has_language(const not_null<str> language,
                                  const str country = nullptr) const noexcept -> bool
  {
    assert(language);

    if (const auto* array = m_locales.get()) {
      for (auto index = 0u; array[index].language; ++index) {
        const auto& item = array[index];

        if (country && item.country) {
          if (detail::czstring_eq(language, item.language) &&
              detail::czstring_eq(country, item.country)) {
            return true;
          }
        }
        else {
          if (detail::czstring_eq(language, item.language)) {
            return true;
          }
        }
      }
    }

    return false;
  }

  /**
   * \brief Returns the amount of entries in the locale.
   *
   * \return the amount of locale entries.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto count() const noexcept -> usize
  {
    usize result{0};

    if (const auto* array = m_locales.get()) {
      for (auto index = 0u; array[index].language; ++index) {
        ++result;
      }
    }

    return result;
  }

  /**
   * \brief Indicates whether or not the locale contains a non-null pointer.
   *
   * \note It's safe to call all member functions of this class, no matter if there is a
   * non-null internal pointer. This is intended as a quick and easy check to determine
   * whether or not there are any entries at all.
   *
   * \return `true` if the locale contains a non-null pointer; `false` otherwise.
   *
   * \since 5.2.0
   */
  explicit operator bool() const noexcept
  {
    return m_locales.operator bool();
  }

 private:
  std::unique_ptr<SDL_Locale, detail::sdl_deleter<SDL_Locale>> m_locales;

  explicit locale(SDL_Locale* locales) noexcept : m_locales{locales}
  {}
};

/// \} End of group system

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

}  // namespace cen

#endif  // CENTURION_LOCALE_HEADER

// #include "centurion/system/open_url.hpp"
#ifndef CENTURION_OPEN_URL_HEADER
#define CENTURION_OPEN_URL_HEADER

#include <SDL.h>

#include <cassert>  // assert
#include <string>   // string

// #include "../core/not_null.hpp"

// #include "../core/result.hpp"

// #include "../core/str.hpp"


namespace cen {

/// \addtogroup system
/// \{

#if SDL_VERSION_ATLEAST(2, 0, 14)

/**
 * \brief Attempts to open a URL using a web browser or even a file manager for local
 * files.
 *
 * \note This function will return `success` if there was at least an "attempt" to open
 * the specified URL, but it doesn't mean that the URL was successfully loaded.
 *
 * \remarks This function will differ greatly in its effects depending on the current
 * platform.
 *
 * \param url the URL that should be opened, cannot be null.
 *
 * \return `success` if there was an attempt to open the URL; `failure` otherwise.
 *
 * \since 5.2.0
 */
inline auto open_url(const not_null<str> url) noexcept -> result
{
  assert(url);
  return SDL_OpenURL(url) == 0;
}

/**
 * \see open_url()
 * \since 5.3.0
 */
inline auto open_url(const std::string& url) noexcept -> result
{
  return open_url(url.c_str());
}

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

/// \} End of group system

}  // namespace cen

#endif  // CENTURION_OPEN_URL_HEADER
// #include "centurion/system/platform.hpp"
#ifndef CENTURION_PLATFORM_HEADER
#define CENTURION_PLATFORM_HEADER

#include <SDL.h>

#include <optional>     // optional
#include <ostream>      // ostream
#include <string>       // string
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/str.hpp"

// #include "../detail/czstring_eq.hpp"


namespace cen {

/// \addtogroup system
/// \{

/**
 * \enum platform_id
 *
 * \brief Provides values that represent various different operating systems.
 *
 * \since 3.0.0
 */
enum class platform_id
{
  unknown,   ///< Indicates that the platform is unknown.
  windows,   ///< Represents the Windows platform.
  mac_osx,   ///< Represents the Apple OSX platform.
  linux_os,  ///< Represents the Linux platform.
  ios,       ///< Represents the Apple iOS platform.
  android    ///< Represents the Android platform.
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied platform ID.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(platform_id::windows) == "windows"`.
 *
 * \param id the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] inline auto to_string(const platform_id id) -> std::string_view
{
  switch (id) {
    case platform_id::unknown:
      return "unknown";

    case platform_id::windows:
      return "windows";

    case platform_id::mac_osx:
      return "mac_osx";

    case platform_id::linux_os:
      return "linux_os";

    case platform_id::ios:
      return "ios";

    case platform_id::android:
      return "android";

    default:
      throw cen_error{"Did not recognize platform ID!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a platform ID enumerator.
 *
 * \param stream the output stream that will be used.
 * \param id the enumerator that will be printed.
 *
 * \see `to_string(platform_id)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const platform_id id) -> std::ostream&
{
  return stream << to_string(id);
}

/// \} End of streaming

/// \name Platform information functions
/// \{

/**
 * \brief Returns the value that represents the current platform.
 *
 * \return the value that represents the current platform.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto current_platform() noexcept -> platform_id
{
  const str platform = SDL_GetPlatform();
  if (detail::czstring_eq(platform, "Windows")) {
    return platform_id::windows;
  }
  else if (detail::czstring_eq(platform, "Mac OS X")) {
    return platform_id::mac_osx;
  }
  else if (detail::czstring_eq(platform, "Linux")) {
    return platform_id::linux_os;
  }
  else if (detail::czstring_eq(platform, "iOS")) {
    return platform_id::ios;
  }
  else if (detail::czstring_eq(platform, "Android")) {
    return platform_id::android;
  }
  else {
    return platform_id::unknown;
  }
}

/**
 * \brief Indicates whether or not the current platform is Windows.
 *
 * \return `true` if the current platform is Windows; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto is_windows() noexcept -> bool
{
  return current_platform() == platform_id::windows;
}

/**
 * \brief Indicates whether or not the current platform is Mac OSX.
 *
 * \return `true` if the current platform is Mac OSX; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto is_mac_osx() noexcept -> bool
{
  return current_platform() == platform_id::mac_osx;
}

/**
 * \brief Indicates whether or not the current platform is Linux.
 *
 * \return `true` if the current platform is Linux; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto is_linux() noexcept -> bool
{
  return current_platform() == platform_id::linux_os;
}

/**
 * \brief Indicates whether or not the current platform is iOS.
 *
 * \return `true` if the current platform is iOS; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto is_ios() noexcept -> bool
{
  return current_platform() == platform_id::ios;
}

/**
 * \brief Indicates whether or not the current platform is Android.
 *
 * \return `true` if the current platform is Android; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto is_android() noexcept -> bool
{
  return current_platform() == platform_id::android;
}

/**
 * \brief Returns the name of the current platform.
 *
 * \return the name of the current platform; `std::nullopt` if the name cannot be deduced.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto platform_name() -> std::optional<std::string>
{
  const std::string name{SDL_GetPlatform()};
  if (name != "Unknown") {
    return name;
  }
  else {
    return std::nullopt;
  }
}

/**
 * \brief Indicates whether or not the current system is a tablet.
 *
 * \return `true` if the current system is a tablet; `false` otherwise.
 *
 * \since 5.2.0
 */
[[nodiscard]] inline auto is_tablet() noexcept -> bool
{
  return static_cast<bool>(SDL_IsTablet());
}

/**
 * \brief Indicates whether or not the current OS is 32-bit Windows.
 *
 * \note This function should return `true` on 64-bit Windows as well.
 *
 * \return `true` if the current OS is 32-bit Windows; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto ifdef_win32() noexcept -> bool
{
#ifdef _WIN32
  return true;
#else
  return false;
#endif
}

/**
 * \brief Indicates whether or not the current OS is 64-bit Windows.
 *
 * \return `true` if the current OS is 64-bit Windows; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto ifdef_win64() noexcept -> bool
{
#ifdef _WIN64
  return true;
#else
  return false;
#endif
}

/**
 * \brief Indicates whether or not the current OS is derived from Linux.
 *
 * \return `true` if the current OS is derived from Linux; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto ifdef_linux() noexcept -> bool
{
#ifdef __linux__
  return true;
#else
  return false;
#endif
}

/**
 * \brief Indicates whether or not the current OS is Android.
 *
 * \return `true` if the current OS is Android; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto ifdef_android() noexcept -> bool
{
#ifdef __ANDROID__
  return true;
#else
  return false;
#endif
}

/**
 * \brief Indicates whether or not the current OS is either MacOS or iOS.
 *
 * \return `true` if the current OS is Android; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto ifdef_apple() noexcept -> bool
{
#ifdef __APPLE__
  return true;
#else
  return false;
#endif
}

/// \} End of platform information functions

/// \} End of group system

}  // namespace cen

#endif  // CENTURION_PLATFORM_HEADER
// #include "centurion/system/power_state.hpp"
#ifndef CENTURION_POWER_STATE_HEADER
#define CENTURION_POWER_STATE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup system
/// \{

/**
 * \enum power_state
 *
 * \brief Represents different battery power states.
 *
 * \since 3.0.0
 *
 * \see `SDL_PowerState`
 */
enum class power_state
{
  unknown = SDL_POWERSTATE_UNKNOWN,        ///< The status is unknown.
  on_battery = SDL_POWERSTATE_ON_BATTERY,  ///< Not plugged in and running on battery.
  no_battery = SDL_POWERSTATE_NO_BATTERY,  ///< No battery available.
  charging = SDL_POWERSTATE_CHARGING,      ///< Currently charging the battery.
  charged = SDL_POWERSTATE_CHARGED         ///< Currently plugged in and charged.
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied power state.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(power_state::on_battery) == "on_battery"`.
 *
 * \param state the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const power_state state) -> std::string_view
{
  switch (state) {
    case power_state::unknown:
      return "unknown";

    case power_state::on_battery:
      return "on_battery";

    case power_state::no_battery:
      return "no_battery";

    case power_state::charging:
      return "charging";

    case power_state::charged:
      return "charged";

    default:
      throw cen_error{"Did not recognize power state!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a power state enumerator.
 *
 * \param stream the output stream that will be used.
 * \param state the enumerator that will be printed.
 *
 * \see `to_string(power_state)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const power_state state) -> std::ostream&
{
  return stream << to_string(state);
}

/// \} End of streaming

/// \name Power state comparison operators
/// \{

/**
 * \brief Indicates whether or not two power states values are the same.
 *
 * \param lhs the left-hand side power state value.
 * \param rhs the right-hand side power state value.
 *
 * \return `true` if the power states are the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const power_state lhs,
                                        const SDL_PowerState rhs) noexcept -> bool
{
  return static_cast<SDL_PowerState>(lhs) == rhs;
}

/// \copydoc operator==(power_state, SDL_PowerState)
[[nodiscard]] constexpr auto operator==(const SDL_PowerState lhs,
                                        const power_state rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two power states values aren't the same.
 *
 * \param lhs the left-hand side power state value.
 * \param rhs the right-hand side power state value.
 *
 * \return `true` if the power states aren't the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator!=(const power_state lhs,
                                        const SDL_PowerState rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(power_state, SDL_PowerState)
[[nodiscard]] constexpr auto operator!=(const SDL_PowerState lhs,
                                        const power_state rhs) noexcept -> bool
{
  return rhs != lhs;
}

/// \} End of power state comparison operators

/// \} End of group system

}  // namespace cen

#endif  // CENTURION_POWER_STATE_HEADER

// #include "centurion/system/ram.hpp"
#ifndef CENTURION_RAM_HEADER
#define CENTURION_RAM_HEADER

#include <SDL.h>

/**
 * \namespace cen::ram
 *
 * \brief Contains functions related to the system memory.
 *
 * \ingroup system
 *
 * \since 5.0.0
 */
namespace cen::ram {

/// \addtogroup system
/// \{

/// \name RAM functions
/// \{

/**
 * \brief Returns the total amount of system RAM in megabytes.
 *
 * \return the total amount of system RAM in megabytes.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto amount_mb() noexcept -> int
{
  return SDL_GetSystemRAM();
}

/**
 * \brief Returns the total amount of system RAM in gigabytes.
 *
 * \return the total amount of system RAM in gigabytes.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto amount_gb() noexcept -> int
{
  return amount_mb() / 1'000;
}

/// \} End of RAM functions

/// \} End of group system

}  // namespace cen::ram

#endif  // CENTURION_RAM_HEADER
// #include "centurion/system/shared_object.hpp"
#ifndef CENTURION_SHARED_OBJECT_HEADER
#define CENTURION_SHARED_OBJECT_HEADER

#include <SDL.h>

#include <cassert>  // assert
#include <memory>   // unique_ptr
#include <string>   // string

// #include "../core/exception.hpp"

// #include "../core/not_null.hpp"

// #include "../core/str.hpp"


namespace cen {

/// \addtogroup system
/// \{

/**
 * \class shared_object
 *
 * \brief Represents a shared object, such as dynamic libraries (e.g. `.so` and `.dll`
 * files).
 *
 * \since 5.3.0
 */
class shared_object final
{
 public:
  /**
   * \brief Loads a shared object.
   *
   * \param object the name of the shared object that will be loaded.
   *
   * \throws sdl_error if the shared object cannot be loaded.
   *
   * \since 5.3.0
   */
  explicit shared_object(const not_null<str> object) : m_object{SDL_LoadObject(object)}
  {
    if (!m_object) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Loads a shared object.
   *
   * \param object the name of the shared object that will be loaded.
   *
   * \throws sdl_error if the shared object cannot be loaded.
   *
   * \since 5.3.0
   */
  explicit shared_object(const std::string& object) : shared_object{object.c_str()}
  {}

  /**
   * \brief Attempts to load a function from the shared object.
   *
   * \note The function must be a C-function!
   *
   * \tparam T the signature of the function, e.g. `void(int, float)`.
   *
   * \param name the name of the function in the shared object.
   *
   * \return the loaded function; a null pointer is returned if something goes wrong.
   *
   * \since 5.3.0
   */
  template <typename T>
  [[nodiscard]] auto load_function(const not_null<str> name) const noexcept -> T*
  {
    assert(name);
    return reinterpret_cast<T*>(SDL_LoadFunction(m_object.get(), name));
  }

  /**
   * \brief Attempts to load a function from the shared object.
   *
   * \note The function must be a C-function!
   *
   * \tparam T the signature of the function, e.g. `void(int, float)`.
   *
   * \param name the name of the function in the shared object.
   *
   * \return the loaded function; a null pointer is returned if something goes wrong.
   *
   * \since 5.3.0
   */
  template <typename T>
  [[nodiscard]] auto load_function(const std::string& name) const noexcept -> T*
  {
    return load_function<T>(name.c_str());
  }

 private:
  struct deleter final
  {
    void operator()(void* object) noexcept
    {
      SDL_UnloadObject(object);
    }
  };
  std::unique_ptr<void, deleter> m_object;

#ifdef CENTURION_MOCK_FRIENDLY_MODE

 public:
  shared_object() = default;
#endif  // CENTURION_MOCK_FRIENDLY_MODE
};

/// \} End of group system

}  // namespace cen

#endif  // CENTURION_SHARED_OBJECT_HEADER

// #include "centurion/thread/condition.hpp"
#ifndef CENTURION_CONDITION_HEADER
#define CENTURION_CONDITION_HEADER

#include <SDL.h>

#include <memory>  // unique_ptr

// #include "../core/exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER

// #include "../core/integers.hpp"
#ifndef CENTURION_INTEGERS_HEADER
#define CENTURION_INTEGERS_HEADER

#include <SDL.h>

#include <cstddef>  // size_t

namespace cen {

/// \addtogroup core
/// \{

/// \name Integer aliases
/// \{

using usize = std::size_t;

/// Alias for an unsigned integer.
using uint = unsigned int;

/// Alias for the type used for integer literal operators.
using ulonglong = unsigned long long;

/// Alias for a 64-bit unsigned integer.
using u64 = Uint64;

/// Alias for a 32-bit unsigned integer.
using u32 = Uint32;

/// Alias for a 16-bit unsigned integer.
using u16 = Uint16;

/// Alias for an 8-bit unsigned integer.
using u8 = Uint8;

/// Alias for a 64-bit signed integer.
using i64 = Sint64;

/// Alias for a 32-bit signed integer.
using i32 = Sint32;

/// Alias for a 16-bit signed integer.
using i16 = Sint16;

/// Alias for an 8-bit signed integer.
using i8 = Sint8;

/// \} End of integer aliases

// clang-format off

/**
 * \brief Obtains the size of a container as an `int`.
 *
 * \tparam T a "container" that provides a `size()` member function.
 *
 * \param container the container to query the size of.
 *
 * \return the size of the container as an `int` value.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto isize(const T& container) noexcept(noexcept(container.size()))
    -> int
{
  return static_cast<int>(container.size());
}

// clang-format on

namespace literals {

/**
 * \brief Creates an 8-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u8(const ulonglong value) noexcept -> u8
{
  return static_cast<u8>(value);
}

/**
 * \brief Creates a 16-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u16(const ulonglong value) noexcept -> u16
{
  return static_cast<u16>(value);
}

/**
 * \brief Creates a 32-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u32(const ulonglong value) noexcept -> u32
{
  return static_cast<u32>(value);
}

/**
 * \brief Creates a 64-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u64(const ulonglong value) noexcept -> u64
{
  return static_cast<u64>(value);
}

/**
 * \brief Creates an 8-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i8(const ulonglong value) noexcept -> i8
{
  return static_cast<i8>(value);
}

/**
 * \brief Creates a 16-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i16(const ulonglong value) noexcept -> i16
{
  return static_cast<i16>(value);
}

/**
 * \brief Creates a 32-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i32(const ulonglong value) noexcept -> i32
{
  return static_cast<i32>(value);
}

/**
 * \brief Creates a 64-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i64(const ulonglong value) noexcept -> i64
{
  return static_cast<i64>(value);
}

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_INTEGERS_HEADER

// #include "../core/result.hpp"
#ifndef CENTURION_RESULT_HEADER
#define CENTURION_RESULT_HEADER

#include <ostream>  // ostream
#include <string>   // string

namespace cen {

/// \addtogroup core
/// \{

/**
 * \class result
 *
 * \brief A simple indicator for the result of different operations.
 *
 * \details The idea behind this class is to make results of various operations
 * unambiguous. Quite an amount of functions in the library may fail, and earlier versions
 * of Centurion would usually return a `bool` in those cases, where `true` and `false`
 * would indicate success and failure, respectively. This class is a development of that
 * practice. For instance, this class is contextually convertible to `bool`, where a
 * successful result is still converted to `true`, and vice versa. However, this class
 * also enables explicit checks against `success` and `failure` constants, which makes
 * code very easy to read and unambiguous.
 * \code{cpp}
 *   cen::window window;
 *
 *   if (window.set_opacity(0.4f))
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::success)
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::failure)
 *   {
 *     // Failure!
 *   }
 * \endcode
 *
 * \see `success`
 * \see `failure`
 *
 * \since 6.0.0
 */
class result final
{
 public:
  /**
   * \brief Creates a result.
   *
   * \param success `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  constexpr result(const bool success) noexcept  // NOLINT implicit
      : m_success{success}
  {}

  /// \name Comparison operators
  /// \{

  /**
   * \brief Indicates whether or not two results have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results are equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator==(const result other) const noexcept -> bool
  {
    return m_success == other.m_success;
  }

  /**
   * \brief Indicates whether or not two results don't have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results aren't equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator!=(const result other) const noexcept -> bool
  {
    return !(*this == other);
  }

  /// \} End of comparison operators

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not the result is successful.
   *
   * \return `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr explicit operator bool() const noexcept
  {
    return m_success;
  }

  /// \} End of conversions

 private:
  bool m_success{};
};

/// Represents a successful result.
/// \since 6.0.0
inline constexpr result success{true};

/// Represents a failure of some kind.
/// \since 6.0.0
inline constexpr result failure{false};

/// \name String conversions
/// \{

/**
 * \brief Returns a string that represents a result value.
 *
 * \note The returned string is in a slightly different format compared to other Centurion
 * components.
 *
 * \param result the value that will be converted.
 *
 * \return `"success"` for a successful result; `"failure"` otherwise.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto to_string(const result result) -> std::string
{
  return result ? "success" : "failure";
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a result value using a stream.
 *
 * \param stream the stream that will be used.
 * \param result the result value that will be printed.
 *
 * \return the used stream.
 *
 * \since 6.0.0
 */
inline auto operator<<(std::ostream& stream, const result result) -> std::ostream&
{
  return stream << to_string(result);
}

/// \} End of streaming

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_RESULT_HEADER

// #include "../core/time.hpp"
#ifndef CENTURION_TIME_HEADER
#define CENTURION_TIME_HEADER

#include <chrono>  // duration
#include <ratio>   // milli, micro, nano

// #include "integers.hpp"
#ifndef CENTURION_INTEGERS_HEADER
#define CENTURION_INTEGERS_HEADER

#include <SDL.h>

#include <cstddef>  // size_t

namespace cen {

/// \addtogroup core
/// \{

/// \name Integer aliases
/// \{

using usize = std::size_t;

/// Alias for an unsigned integer.
using uint = unsigned int;

/// Alias for the type used for integer literal operators.
using ulonglong = unsigned long long;

/// Alias for a 64-bit unsigned integer.
using u64 = Uint64;

/// Alias for a 32-bit unsigned integer.
using u32 = Uint32;

/// Alias for a 16-bit unsigned integer.
using u16 = Uint16;

/// Alias for an 8-bit unsigned integer.
using u8 = Uint8;

/// Alias for a 64-bit signed integer.
using i64 = Sint64;

/// Alias for a 32-bit signed integer.
using i32 = Sint32;

/// Alias for a 16-bit signed integer.
using i16 = Sint16;

/// Alias for an 8-bit signed integer.
using i8 = Sint8;

/// \} End of integer aliases

// clang-format off

/**
 * \brief Obtains the size of a container as an `int`.
 *
 * \tparam T a "container" that provides a `size()` member function.
 *
 * \param container the container to query the size of.
 *
 * \return the size of the container as an `int` value.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto isize(const T& container) noexcept(noexcept(container.size()))
    -> int
{
  return static_cast<int>(container.size());
}

// clang-format on

namespace literals {

/**
 * \brief Creates an 8-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u8(const ulonglong value) noexcept -> u8
{
  return static_cast<u8>(value);
}

/**
 * \brief Creates a 16-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u16(const ulonglong value) noexcept -> u16
{
  return static_cast<u16>(value);
}

/**
 * \brief Creates a 32-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u32(const ulonglong value) noexcept -> u32
{
  return static_cast<u32>(value);
}

/**
 * \brief Creates a 64-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u64(const ulonglong value) noexcept -> u64
{
  return static_cast<u64>(value);
}

/**
 * \brief Creates an 8-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i8(const ulonglong value) noexcept -> i8
{
  return static_cast<i8>(value);
}

/**
 * \brief Creates a 16-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i16(const ulonglong value) noexcept -> i16
{
  return static_cast<i16>(value);
}

/**
 * \brief Creates a 32-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i32(const ulonglong value) noexcept -> i32
{
  return static_cast<i32>(value);
}

/**
 * \brief Creates a 64-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i64(const ulonglong value) noexcept -> i64
{
  return static_cast<i64>(value);
}

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_INTEGERS_HEADER


namespace cen {

/// \addtogroup core
/// \{

/// \name Time (std::chrono) aliases
/// \{

/**
 * \typedef seconds
 *
 * \brief Templated alias for durations in seconds.
 */
template <typename T>
using seconds = std::chrono::duration<T>;

/**
 * \typedef milliseconds
 *
 * \brief Templated alias for durations in milliseconds.
 */
template <typename T>
using milliseconds = std::chrono::duration<T, std::milli>;

/**
 * \typedef microseconds
 *
 * \brief Templated alias for durations in microseconds.
 */
template <typename T>
using microseconds = std::chrono::duration<T, std::micro>;

/**
 * \typedef nanoseconds
 *
 * \brief Templated alias for durations in nanoseconds.
 */
template <typename T>
using nanoseconds = std::chrono::duration<T, std::nano>;

/**
 * \typedef minutes
 *
 * \brief Templated alias for durations in minutes.
 */
template <typename T>
using minutes = std::chrono::duration<T, std::ratio<60>>;

/// \} End of time (std::chrono) aliases

namespace literals {

// clang-format off

[[nodiscard]] constexpr auto operator"" _ns(const ulonglong value) noexcept(noexcept(nanoseconds<u32>{}))
    -> nanoseconds<u32>
{
  return nanoseconds<u32>{value};
}

[[nodiscard]] constexpr auto operator"" _us(const ulonglong value) noexcept(noexcept(microseconds<u32>{}))
    -> microseconds<u32>
{
  return microseconds<u32>{value};
}

[[nodiscard]] constexpr auto operator"" _ms(const ulonglong value) noexcept(noexcept(milliseconds<u32>{}))
    -> milliseconds<u32>
{
  return milliseconds<u32>{value};
}

[[nodiscard]] constexpr auto operator"" _s(const ulonglong value) noexcept(noexcept(seconds<u32>{}))
    -> seconds<u32>
{
  return seconds<u32>{value};
}

// clang-format on

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_TIME_HEADER

// #include "lock_status.hpp"
#ifndef CENTURION_LOCK_STATUS_HEADER
#define CENTURION_LOCK_STATUS_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup thread
/// \{

enum class lock_status
{
  success = 0,
  timed_out = SDL_MUTEX_TIMEDOUT,
  error = -1
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied lock status.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(lock_status::success) == "success"`.
 *
 * \param status the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const lock_status status) -> std::string_view
{
  switch (status) {
    case lock_status::success:
      return "success";

    case lock_status::timed_out:
      return "timed_out";

    case lock_status::error:
      return "error";

    default:
      throw cen_error{"Did not recognize lock status!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a lock status enumerator.
 *
 * \param stream the output stream that will be used.
 * \param status the enumerator that will be printed.
 *
 * \see `to_string(lock_status)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const lock_status status) -> std::ostream&
{
  return stream << to_string(status);
}

/// \} End of streaming

/// \} End of group thread

}  // namespace cen

#endif  // CENTURION_LOCK_STATUS_HEADER

// #include "mutex.hpp"
#ifndef CENTURION_MUTEX_HEADER
#define CENTURION_MUTEX_HEADER

#include <SDL.h>

#include <memory>  // unique_ptr

// #include "../core/exception.hpp"

// #include "../core/result.hpp"

// #include "lock_status.hpp"


namespace cen {

/// \addtogroup thread
/// \{

/**
 * \class mutex
 *
 * \brief Represents a recursive mutex.
 *
 * \details The fact that the mutex is recursive mutex means that it's possible to nest
 * lock and unlock calls with the same mutex.
 *
 * \since 5.0.0
 *
 * \see `scoped_lock`
 * \see `try_lock`
 */
class mutex final
{
 public:
  /**
   * \brief Creates an unlocked mutex.
   *
   * \throws sdl_error if the mutex cannot be created.
   *
   * \since 5.0.0
   */
  mutex() : m_mutex{SDL_CreateMutex()}
  {
    if (!m_mutex) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Attempts to lock the mutex, blocks if the mutex isn't available.
   *
   * \return `success` if the mutex was successfully locked; `failure` otherwise.
   *
   * \since 5.0.0
   */
  auto lock() noexcept -> result
  {
    return SDL_LockMutex(get()) == 0;
  }

  /**
   * \brief Attempts to lock the mutex, returns if the mutex isn't available.
   *
   * \return the result of the operation.
   *
   * \since 5.0.0
   */
  auto try_lock() noexcept -> lock_status
  {
    return static_cast<lock_status>(SDL_TryLockMutex(get()));
  }

  /**
   * \brief Attempts to unlock the mutex.
   *
   * \return `success` if the mutex was successfully unlocked; `failure` otherwise.
   *
   * \since 5.0.0
   */
  auto unlock() noexcept -> result
  {
    return SDL_UnlockMutex(get()) == 0;
  }

  /**
   * \brief Returns a pointer to the associated SDL mutex.
   *
   * \return a pointer to the internal mutex.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get() noexcept -> SDL_mutex*
  {
    return m_mutex.get();
  }

 private:
  struct deleter final
  {
    void operator()(SDL_mutex* mutex) noexcept
    {
      SDL_DestroyMutex(mutex);
    }
  };
  std::unique_ptr<SDL_mutex, deleter> m_mutex;

#ifdef CENTURION_MOCK_FRIENDLY_MODE

 public:
  explicit mutex(int){};
#endif  // CENTURION_MOCK_FRIENDLY_MODE
};

/// \} End of group thread

}  // namespace cen

#endif  // CENTURION_MUTEX_HEADER

// #include "scoped_lock.hpp"
#ifndef CENTURION_SCOPED_LOCK_HEADER
#define CENTURION_SCOPED_LOCK_HEADER

#include <SDL.h>

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER

// #include "../core/exception.hpp"

// #include "mutex.hpp"


namespace cen {

/// \addtogroup thread
/// \{

/**
 * \class scoped_lock
 *
 * \brief Represents an RAII-style blocking lock that automatically unlocks the associated
 * mutex upon destruction.
 *
 * \remarks This class is purposefully similar to `std::scoped_lock`.
 *
 * \since 5.0.0
 */
class scoped_lock final
{
 public:
  /**
   * \brief Attempts to lock the supplied mutex.
   *
   * \param mutex the mutex that will be locked.
   *
   * \throws sdl_error if the mutex can't be locked.
   *
   * \since 5.0.0
   */
  CENTURION_NODISCARD_CTOR explicit scoped_lock(mutex& mutex) : m_mutex{&mutex}
  {
    if (!mutex.lock()) {
      throw sdl_error{};
    }
  }

  scoped_lock(const scoped_lock&) = delete;

  auto operator=(const scoped_lock&) -> scoped_lock& = delete;

  /**
   * \brief Unlocks the associated mutex.
   *
   * \since 5.0.0
   */
  ~scoped_lock() noexcept
  {
    m_mutex->unlock();
  }

 private:
  mutex* m_mutex{};
};

/// \} End of group thread

}  // namespace cen

#endif  // CENTURION_SCOPED_LOCK_HEADER


namespace cen {

/// \addtogroup thread
/// \{

/**
 * \class condition
 *
 * \brief Represents a condition variable.
 *
 * \since 5.0.0
 */
class condition final
{
 public:
  condition() : m_cond{SDL_CreateCond()}
  {
    if (!m_cond) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Wakes up one of the threads that are waiting on the condition variable.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.0.0
   */
  auto signal() noexcept -> result
  {
    return SDL_CondSignal(m_cond.get()) == 0;
  }

  /**
   * \brief Wakes up all threads that are waiting on the condition variable.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.0.0
   */
  auto broadcast() noexcept -> result
  {
    return SDL_CondBroadcast(m_cond.get()) == 0;
  }

  /**
   * \brief Waits until the condition variable is signaled.
   *
   * \pre The mutex must be locked when the function is called!
   *
   * \param mutex the mutex used to coordinate thread access.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.0.0
   */
  auto wait(mutex& mutex) noexcept -> result
  {
    return SDL_CondWait(m_cond.get(), mutex.get()) == 0;
  }

  /**
   * \brief Waits until the condition variable is signaled or if the specified amount of
   * time has passed.
   *
   * \pre The mutex must be locked when the function is called!
   *
   * \note This function is implemented by looping with a delay of 1 ms on some platforms,
   * and should be avoided if possible.
   *
   * \param mutex the mutex used to coordinate thread access.
   * \param ms the maximum amount of time to wait.
   *
   * \return `true` if everything went OK; `false` on failure.
   *
   * \since 5.0.0
   */
  auto wait(mutex& mutex, const milliseconds<u32> ms) noexcept(noexcept(ms.count()))
      -> lock_status
  {
    return static_cast<lock_status>(
        SDL_CondWaitTimeout(m_cond.get(), mutex.get(), ms.count()));
  }

 private:
  struct deleter final
  {
    void operator()(SDL_cond* cond) noexcept
    {
      SDL_DestroyCond(cond);
    };
  };

  std::unique_ptr<SDL_cond, deleter> m_cond;
};

/// \} End of group thread

}  // namespace cen

#endif  // CENTURION_CONDITION_HEADER

// #include "centurion/thread/lock_status.hpp"
#ifndef CENTURION_LOCK_STATUS_HEADER
#define CENTURION_LOCK_STATUS_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup thread
/// \{

enum class lock_status
{
  success = 0,
  timed_out = SDL_MUTEX_TIMEDOUT,
  error = -1
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied lock status.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(lock_status::success) == "success"`.
 *
 * \param status the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const lock_status status) -> std::string_view
{
  switch (status) {
    case lock_status::success:
      return "success";

    case lock_status::timed_out:
      return "timed_out";

    case lock_status::error:
      return "error";

    default:
      throw cen_error{"Did not recognize lock status!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a lock status enumerator.
 *
 * \param stream the output stream that will be used.
 * \param status the enumerator that will be printed.
 *
 * \see `to_string(lock_status)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const lock_status status) -> std::ostream&
{
  return stream << to_string(status);
}

/// \} End of streaming

/// \} End of group thread

}  // namespace cen

#endif  // CENTURION_LOCK_STATUS_HEADER

// #include "centurion/thread/mutex.hpp"
#ifndef CENTURION_MUTEX_HEADER
#define CENTURION_MUTEX_HEADER

#include <SDL.h>

#include <memory>  // unique_ptr

// #include "../core/exception.hpp"

// #include "../core/result.hpp"

// #include "lock_status.hpp"


namespace cen {

/// \addtogroup thread
/// \{

/**
 * \class mutex
 *
 * \brief Represents a recursive mutex.
 *
 * \details The fact that the mutex is recursive mutex means that it's possible to nest
 * lock and unlock calls with the same mutex.
 *
 * \since 5.0.0
 *
 * \see `scoped_lock`
 * \see `try_lock`
 */
class mutex final
{
 public:
  /**
   * \brief Creates an unlocked mutex.
   *
   * \throws sdl_error if the mutex cannot be created.
   *
   * \since 5.0.0
   */
  mutex() : m_mutex{SDL_CreateMutex()}
  {
    if (!m_mutex) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Attempts to lock the mutex, blocks if the mutex isn't available.
   *
   * \return `success` if the mutex was successfully locked; `failure` otherwise.
   *
   * \since 5.0.0
   */
  auto lock() noexcept -> result
  {
    return SDL_LockMutex(get()) == 0;
  }

  /**
   * \brief Attempts to lock the mutex, returns if the mutex isn't available.
   *
   * \return the result of the operation.
   *
   * \since 5.0.0
   */
  auto try_lock() noexcept -> lock_status
  {
    return static_cast<lock_status>(SDL_TryLockMutex(get()));
  }

  /**
   * \brief Attempts to unlock the mutex.
   *
   * \return `success` if the mutex was successfully unlocked; `failure` otherwise.
   *
   * \since 5.0.0
   */
  auto unlock() noexcept -> result
  {
    return SDL_UnlockMutex(get()) == 0;
  }

  /**
   * \brief Returns a pointer to the associated SDL mutex.
   *
   * \return a pointer to the internal mutex.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get() noexcept -> SDL_mutex*
  {
    return m_mutex.get();
  }

 private:
  struct deleter final
  {
    void operator()(SDL_mutex* mutex) noexcept
    {
      SDL_DestroyMutex(mutex);
    }
  };
  std::unique_ptr<SDL_mutex, deleter> m_mutex;

#ifdef CENTURION_MOCK_FRIENDLY_MODE

 public:
  explicit mutex(int){};
#endif  // CENTURION_MOCK_FRIENDLY_MODE
};

/// \} End of group thread

}  // namespace cen

#endif  // CENTURION_MUTEX_HEADER

// #include "centurion/thread/scoped_lock.hpp"
#ifndef CENTURION_SCOPED_LOCK_HEADER
#define CENTURION_SCOPED_LOCK_HEADER

#include <SDL.h>

// #include "../compiler/features.hpp"

// #include "../core/exception.hpp"

// #include "mutex.hpp"


namespace cen {

/// \addtogroup thread
/// \{

/**
 * \class scoped_lock
 *
 * \brief Represents an RAII-style blocking lock that automatically unlocks the associated
 * mutex upon destruction.
 *
 * \remarks This class is purposefully similar to `std::scoped_lock`.
 *
 * \since 5.0.0
 */
class scoped_lock final
{
 public:
  /**
   * \brief Attempts to lock the supplied mutex.
   *
   * \param mutex the mutex that will be locked.
   *
   * \throws sdl_error if the mutex can't be locked.
   *
   * \since 5.0.0
   */
  CENTURION_NODISCARD_CTOR explicit scoped_lock(mutex& mutex) : m_mutex{&mutex}
  {
    if (!mutex.lock()) {
      throw sdl_error{};
    }
  }

  scoped_lock(const scoped_lock&) = delete;

  auto operator=(const scoped_lock&) -> scoped_lock& = delete;

  /**
   * \brief Unlocks the associated mutex.
   *
   * \since 5.0.0
   */
  ~scoped_lock() noexcept
  {
    m_mutex->unlock();
  }

 private:
  mutex* m_mutex{};
};

/// \} End of group thread

}  // namespace cen

#endif  // CENTURION_SCOPED_LOCK_HEADER

// #include "centurion/thread/semaphore.hpp"
#ifndef CENTURION_SEMAPHORE_HEADER
#define CENTURION_SEMAPHORE_HEADER

#include <SDL.h>

#include <memory>  // unique_ptr

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/result.hpp"

// #include "../core/time.hpp"

// #include "lock_status.hpp"


namespace cen {

/// \addtogroup thread
/// \{

/**
 * \class semaphore
 *
 * \brief Represents a semaphore with a set of "tokens" (or permits).
 *
 * \since 5.0.0
 */
class semaphore final
{
 public:
  /**
   * \brief Creates a semaphore with the specified amount of tokens.
   *
   * \param tokens the initial amount of tokens.
   *
   * \throws sdl_error if the semaphore cannot be created.
   *
   * \since 5.0.0
   */
  explicit semaphore(const u32 tokens) : m_semaphore{SDL_CreateSemaphore(tokens)}
  {
    if (!m_semaphore) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Acquires a token from the semaphore.
   *
   * \note This function blocks the calling thread until a token is available.
   *
   * \return `success` if a token was acquired; `failure` otherwise.
   *
   * \since 5.0.0
   */
  auto acquire() noexcept -> result
  {
    return SDL_SemWait(m_semaphore.get()) == 0;
  }

  /**
   * \brief Attempts to acquire a token from the semaphore.
   *
   * \param ms the maximum amount of time to wait.
   *
   * \return `success` if a token was acquired; `timed_out` if no token was acquired in
   * the specified duration; `error` if something goes wrong.
   *
   * \since 5.0.0
   */
  auto acquire(const milliseconds<u32> ms) noexcept(noexcept(ms.count())) -> lock_status
  {
    return static_cast<lock_status>(SDL_SemWaitTimeout(m_semaphore.get(), ms.count()));
  }

  /**
   * \brief Attempts to acquire a token from the semaphore.
   *
   * \return `success` if a token was acquired; `timed_out` if the thread would've been
   * blocked; `error` if something goes wrong.
   *
   * \since 5.0.0
   */
  auto try_acquire() noexcept -> lock_status
  {
    return static_cast<lock_status>(SDL_SemTryWait(m_semaphore.get()));
  }

  /**
   * \brief Returns a token to the semaphore and notifies waiting threads.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.0.0
   */
  auto release() noexcept -> result
  {
    return SDL_SemPost(m_semaphore.get()) == 0;
  }

  /**
   * \brief Returns the amount of available tokens.
   *
   * \return the current amount of available tokens.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto tokens() const noexcept -> u32
  {
    return SDL_SemValue(m_semaphore.get());
  }

 private:
  struct deleter final
  {
    void operator()(SDL_sem* semaphore) noexcept
    {
      SDL_DestroySemaphore(semaphore);
    }
  };
  std::unique_ptr<SDL_sem, deleter> m_semaphore;
};

/// \} End of group thread

}  // namespace cen

#endif  // CENTURION_SEMAPHORE_HEADER

// #include "centurion/thread/thread.hpp"
#ifndef CENTURION_THREAD_HEADER
#define CENTURION_THREAD_HEADER

#include <SDL.h>

#include <cassert>      // assert
#include <ostream>      // ostream
#include <string>       // string, to_string
#include <type_traits>  // invoke_result_t, declval

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_CONCEPTS

#include <concepts>  // convertible_to, default_initializable, invocable

#endif  // CENTURION_HAS_FEATURE_CONCEPTS

#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/is_stateless_callable.hpp"
#ifndef CENTURION_IS_STATELESS_CALLABLE_HEADER
#define CENTURION_IS_STATELESS_CALLABLE_HEADER

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER


#if CENTURION_HAS_FEATURE_CONCEPTS

#include <concepts>  // default_initializable, invocable

namespace cen {

/// \addtogroup core
/// \{

template <typename T, typename... Args>
concept is_stateless_callable = std::default_initializable<T> && std::invocable<T, Args...>;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_HAS_FEATURE_CONCEPTS
#endif  // CENTURION_IS_STATELESS_CALLABLE_HEADER

// #include "../core/not_null.hpp"
#ifndef CENTURION_NOT_NULL_HEADER
#define CENTURION_NOT_NULL_HEADER

// #include "sfinae.hpp"
#ifndef CENTURION_SFINAE_HEADER
#define CENTURION_SFINAE_HEADER

#include <type_traits>  // enable_if_t, is_same_v, is_integral_v, is_floating_point_v, ...

namespace cen {

/// \addtogroup core
/// \{

// clang-format off

/// Enables a template if the type is either integral of floating-point, but not a boolean.
template <typename T>
using enable_if_number_t = std::enable_if_t<!std::is_same_v<T, bool> &&
                                            (std::is_integral_v<T> ||
                                             std::is_floating_point_v<T>), int>;

// clang-format on

/// Enables a template if the type is a pointer.
template <typename T>
using enable_if_pointer_v = std::enable_if_t<std::is_pointer_v<T>, int>;

/// Enables a template if T is convertible to any of the specified types.
template <typename T, typename... Args>
using enable_if_convertible_t = std::enable_if_t<(std::is_convertible_v<T, Args> || ...), int>;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_SFINAE_HEADER


namespace cen {

/**
 * \typedef not_null
 *
 * \ingroup core
 *
 * \brief Tag used to indicate that a pointer cannot be null.
 *
 * \note This alias is equivalent to `T`, it is a no-op.
 *
 * \since 5.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using not_null = T;

}  // namespace cen

#endif  // CENTURION_NOT_NULL_HEADER

// #include "../core/result.hpp"

// #include "../core/str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER

// #include "../core/time.hpp"

// #include "../detail/address_of.hpp"
#ifndef CENTURION_DETAIL_ADDRESS_OF_HEADER
#define CENTURION_DETAIL_ADDRESS_OF_HEADER

#include <sstream>  // stringstream
#include <string>   // string

// #include "../compiler/compiler.hpp"
#ifndef CENTURION_COMPILER_HEADER
#define CENTURION_COMPILER_HEADER

#include <SDL.h>

namespace cen {

/// \addtogroup compiler
/// \{

/**
 * \brief Indicates whether or not a "debug" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a debug build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_debug_build() noexcept -> bool
{
#ifndef NDEBUG
  return true;
#else
  return false;
#endif  // NDEBUG
}

/**
 * \brief Indicates whether or not a "release" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a release build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_release_build() noexcept -> bool
{
  return !is_debug_build();
}

/**
 * \brief Indicates whether or not the compiler is MSVC.
 *
 * \return `true` if MSVC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_msvc() noexcept -> bool
{
#ifdef _MSC_VER
  return true;
#else
  return false;
#endif  // _MSC_VER
}

/**
 * \brief Indicates whether or not the compiler is GCC.
 *
 * \return `true` if GCC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_gcc() noexcept -> bool
{
#ifdef __GNUC__
  return true;
#else
  return false;
#endif  // __GNUC__
}

/**
 * \brief Indicates whether or not the compiler is Clang.
 *
 * \return `true` if Clang is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_clang() noexcept -> bool
{
#ifdef __clang__
  return true;
#else
  return false;
#endif  // __clang__
}

/**
 * \brief Indicates whether or not the compiler is Emscripten.
 *
 * \return `true` if Emscripten is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_emscripten() noexcept -> bool
{
#ifdef __EMSCRIPTEN__
  return true;
#else
  return false;
#endif  // __EMSCRIPTEN__
}

/**
 * \brief Indicates whether or not the compiler is Intel C++.
 *
 * \return `true` if Intel C++ is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_intel_cpp() noexcept -> bool
{
#ifdef __INTEL_COMPILER
  return true;
#else
  return false;
#endif  // __INTEL_COMPILER
}

/// \} End of compiler group

}  // namespace cen

#endif  // CENTURION_COMPILER_HEADER


/// \cond FALSE
namespace cen::detail {

/**
 * \brief Returns a string that represents the memory address of the supplied pointer.
 *
 * \details The empty string is returned if the supplied pointer is null.
 *
 * \tparam T the type of the pointer.
 * \param ptr the pointer that will be converted.
 *
 * \return a string that represents the memory address of the supplied pointer.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto address_of(const void* ptr) -> std::string
{
  if (ptr) {
    std::stringstream stream;

    if constexpr (on_msvc()) {
      stream << "0x";  // Only MSVC seems to omit this, add it for consistency
    }

    stream << ptr;
    return stream.str();
  }
  else {
    return std::string{};
  }
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_ADDRESS_OF_HEADER

// #include "thread_priority.hpp"
#ifndef CENTURION_THREAD_PRIORITY_HEADER
#define CENTURION_THREAD_PRIORITY_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup thread
/// \{

/**
 * \enum thread_priority
 *
 * \brief Represents different thread priorities.
 *
 * \note You might need higher privileges to use `high` or `critical` priorities.
 *
 * \since 5.0.0
 */
enum class thread_priority
{
  // clang-format off
  low = SDL_THREAD_PRIORITY_LOW,        ///< Non-urgent, background processing.
  normal = SDL_THREAD_PRIORITY_NORMAL,  ///< General purpose processing, this is the default.
  high = SDL_THREAD_PRIORITY_HIGH,              ///< For high-priority processing.
  critical = SDL_THREAD_PRIORITY_TIME_CRITICAL  ///< For timing-critical processing.
  // clang-format on
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied thread priority.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(thread_priority::high) == "high"`.
 *
 * \param priority the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const thread_priority priority) -> std::string_view
{
  switch (priority) {
    case thread_priority::low:
      return "low";

    case thread_priority::normal:
      return "normal";

    case thread_priority::high:
      return "high";

    case thread_priority::critical:
      return "critical";

    default:
      throw cen_error{"Did not recognize thread priority!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a thread priority enumerator.
 *
 * \param stream the output stream that will be used.
 * \param priority the enumerator that will be printed.
 *
 * \see `to_string(thread_priority)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const thread_priority priority) -> std::ostream&
{
  return stream << to_string(priority);
}

/// \} End of streaming

/// \name Thread priority comparison operators
/// \{

/**
 * \brief Indicates whether or not two thread priorities are the same.
 *
 * \param lhs the left-hand side thread priority.
 * \param rhs the right-hand side thread priority.
 *
 * \return `true` if the priorities are the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator==(const thread_priority lhs,
                                        const SDL_ThreadPriority rhs) noexcept -> bool
{
  return static_cast<SDL_ThreadPriority>(lhs) == rhs;
}

/// \copydoc operator==(thread_priority, SDL_ThreadPriority)
[[nodiscard]] constexpr auto operator==(const SDL_ThreadPriority lhs,
                                        const thread_priority rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two thread priorities aren't the same.
 *
 * \param lhs the left-hand side thread priority.
 * \param rhs the right-hand side thread priority.
 *
 * \return `true` if the priorities aren't the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator!=(const thread_priority lhs,
                                        const SDL_ThreadPriority rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(thread_priority, SDL_ThreadPriority)
[[nodiscard]] constexpr auto operator!=(const SDL_ThreadPriority lhs,
                                        const thread_priority rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of thread priority comparison operators

/// \} End of group thread

}  // namespace cen

#endif  // CENTURION_THREAD_PRIORITY_HEADER


namespace cen {

/// \addtogroup thread
/// \{

using thread_id = SDL_threadID;

/**
 * \class thread
 *
 * \brief Represents a single thread of execution.
 *
 * \remarks This class purposefully features an API similar to that of `std::thread`.
 * However, unlike `std::thread`, this class will automatically join itself upon
 * destruction if it wasn't already detached or joined.
 *
 * \note Beware that the C++ standard provides `std::thread` and `std::jthread`, along
 * with several other threading utilities. If possible, you should prefer using the
 * standard library API.
 *
 * \since 5.0.0
 */
class thread final
{
 public:
  /**
   * \typedef task_type
   *
   * \brief The signature of the function object that will be executed.
   *
   * \since 5.0.0
   */
  using task_type = SDL_ThreadFunction;

  /**
   * \typedef id
   *
   * \brief The type used for thread identifiers.
   *
   * \deprecated Since 6.2.0, use `thread_id` instead.
   *
   * \since 5.0.0
   */
  using id [[deprecated]] = SDL_threadID;

  /// \name Construction/Destruction
  /// \{

  /**
   * \brief Creates a thread and starts executing it.
   *
   * \param task the task that will be performed.
   * \param name the name of the thread, cannot be null.
   * \param data a pointer to optional user data that will be supplied to the task
   * function object.
   *
   * \throws sdl_error if the thread cannot be created.
   *
   * \since 5.0.0
   */
  CENTURION_NODISCARD_CTOR explicit thread(task_type task,
                                           const not_null<str> name = "thread",
                                           void* data = nullptr)
      : m_thread{SDL_CreateThread(task, name, data)}
  {
    if (!m_thread) {
      throw sdl_error{};
    }
  }

  thread(const thread&) = delete;

  auto operator=(const thread&) -> thread& = delete;

  /**
   * \brief If the thread is joinable, then the thread is joined.
   *
   * \since 5.0.0
   */
  ~thread() noexcept
  {
    if (joinable()) {
      join();
    }
  }

#if CENTURION_HAS_FEATURE_CONCEPTS

  /**
   * \brief Creates a thread that will execute the supplied callable.
   *
   * \details The supplied callable can either either return nothing or return a value
   * convertible to an `int`. If the callable returns nothing, the thread will simply
   * return `0`.
   *
   * \note If you supply a lambda to this function, it must be stateless.
   *
   * \tparam Callable the type of the callable.
   *
   * \param task the callable that will be invoked when the thread starts running.
   * \param name the name of the thread.
   *
   * \return the created thread.
   *
   * \since 6.2.0
   */
  template <is_stateless_callable Callable>
  [[nodiscard]] static auto init([[maybe_unused]] Callable&& task,
                                 const not_null<str> name = "thread") -> thread
  {
    assert(name);

    constexpr bool isNoexcept = noexcept(Callable{}());

    const auto wrapper = [](void* /*data*/) noexcept(isNoexcept) -> int {
      Callable callable;
      if constexpr (std::convertible_to<std::invoke_result_t<Callable>, int>) {
        return callable();
      }
      else {
        callable();
        return 0;
      }
    };

    return thread{wrapper, name};
  }

  /**
   * \brief Creates a thread that will execute the supplied callable.
   *
   * \details The supplied callable can either either return nothing or return a value
   * convertible to an `int`. If the callable returns nothing, the thread will simply
   * return `0`.
   *
   * \note If you supply a lambda to this function, it must be stateless.
   *
   * \tparam Callable the type of the callable.
   *
   * \param task the callable that will be invoked when the thread starts running.
   * \param userData optional user data that will be supplied to the callable.
   * \param name the name of the thread.
   *
   * \return the created thread.
   *
   * \since 6.2.0
   */
  template <typename T = void, is_stateless_callable<T*> Callable>
  [[nodiscard]] static auto init([[maybe_unused]] Callable&& task,
                                 T* userData = nullptr,
                                 const not_null<str> name = "thread") -> thread
  {
    assert(name);

    constexpr bool isNoexcept = noexcept(Callable{}(std::declval<T*>()));

    const auto wrapper = [](void* erased) noexcept(isNoexcept) -> int {
      auto* ptr = static_cast<T*>(erased);

      Callable callable;
      if constexpr (std::convertible_to<std::invoke_result_t<Callable, T*>, int>) {
        return callable(ptr);
      }
      else {
        callable(ptr);
        return 0;
      }
    };

    return thread{wrapper, name, userData};
  }

#endif  // CENTURION_HAS_FEATURE_CONCEPTS

  /// \} End of construction/destruction

  /**
   * \brief Forces the current thread to halt for at least the specified duration.
   *
   * \note The actual time spent sleeping may differ, depending on the scheduling of the
   * operating system. You shouldn't use this function for precise timing.
   *
   * \param ms the minimum amount of time to sleep for, in milliseconds.
   *
   * \since 5.0.0
   */
  static void sleep(const milliseconds<u32> ms) noexcept(noexcept(ms.count()))
  {
    SDL_Delay(ms.count());
  }

  /**
   * \brief Sets the priority of the current thread.
   *
   * \note You might need elevated privileges to use `high` or `critical` priorities.
   *
   * \param priority the priority that will be used.
   *
   * \return `success` if the priority was successfully set; `failure` otherwise.
   *
   * \since 5.0.0
   */
  static auto set_priority(const thread_priority priority) noexcept -> result
  {
    const auto prio = static_cast<SDL_ThreadPriority>(priority);
    return SDL_SetThreadPriority(prio) == 0;
  }

  /// \name Mutators
  /// \{

  /**
   * \brief Lets the thread terminate without having another thread join it.
   *
   * \note This function has no effect if the thread has already been joined or detached.
   *
   * \since 5.0.0
   */
  void detach() noexcept
  {
    if (m_joined || m_detached) {
      return;
    }

    SDL_DetachThread(m_thread);

    m_detached = true;
    assert(m_detached != m_joined);
  }

  /**
   * \brief Waits for the thread to finish its execution.
   *
   * \note This function just returns `0` if the thread has already been joined or
   * detached.
   *
   * \return the status code.
   *
   * \since 5.0.0
   */
  auto join() noexcept -> int
  {
    if (m_joined || m_detached) {
      return 0;
    }

    int status{};
    SDL_WaitThread(m_thread, &status);

    m_joined = true;
    assert(m_detached != m_joined);

    return status;
  }

  /// \} End of mutators

  /// \name Queries
  /// \{

  /**
   * \brief Indicates whether or not the thread can be joined.
   *
   * \details A thread is joinable if it hasn't been previously detached or joined.
   *
   * \note A joinable thread is also detachable.
   *
   * \return `true` if the thread can be joined; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto joinable() const noexcept -> bool
  {
    return !m_joined && !m_detached;
  }

  /**
   * \brief Indicates whether or not the thread was joined.
   *
   * \return `true` if the thread has been joined; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto was_joined() const noexcept -> bool
  {
    return m_joined;
  }

  /**
   * \brief Indicates whether or not the thread was detached.
   *
   * \return `true` if the thread has been detached; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto was_detached() const noexcept -> bool
  {
    return m_detached;
  }

  /**
   * \brief Returns the identifier associated with the thread.
   *
   * \return the ID of the thread.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get_id() const noexcept -> thread_id
  {
    return SDL_GetThreadID(m_thread);
  }

  /**
   * \brief Returns the identifier associated with the current thread.
   *
   * \return the ID of the current thread.
   *
   * \since 5.0.0
   */
  [[nodiscard]] static auto current_id() noexcept -> thread_id
  {
    return SDL_ThreadID();
  }

  /**
   * \brief Returns the name of the thread.
   *
   * \note The default name used is `"thread"`.
   *
   * \return the name of the thread.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto name() const -> std::string
  {
    return SDL_GetThreadName(m_thread);
  }

  /**
   * \brief Returns a pointer to the associated SDL thread.
   *
   * \return a pointer to the associated SDL thread.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get() noexcept -> SDL_Thread*
  {
    return m_thread;
  }

  /// \copydoc get
  [[nodiscard]] auto get() const noexcept -> const SDL_Thread*
  {
    return m_thread;
  }

  /// \} End of queries

 private:
  SDL_Thread* m_thread{};
  bool m_joined{false};
  bool m_detached{false};
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a thread.
 *
 * \param thread the thread that will be converted.
 *
 * \return a string that represents a thread.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto to_string(const thread& thread) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("thread{{data: {}, name: {}, id: {}}}",
                     detail::address_of(thread.get()),
                     thread.name(),
                     thread.get_id());
#else
  return "thread{data: " + detail::address_of(thread.get()) + ", name: " + thread.name() +
         ", id: " + std::to_string(thread.get_id()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a thread.
 *
 * \param stream the stream that will be used.
 * \param thread the thread that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
inline auto operator<<(std::ostream& stream, const thread& thread) -> std::ostream&
{
  stream << to_string(thread);
  return stream;
}

/// \} End of streaming

/// \} End of group thread

}  // namespace cen

#endif  // CENTURION_THREAD_HEADER

// #include "centurion/thread/thread_priority.hpp"
#ifndef CENTURION_THREAD_PRIORITY_HEADER
#define CENTURION_THREAD_PRIORITY_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup thread
/// \{

/**
 * \enum thread_priority
 *
 * \brief Represents different thread priorities.
 *
 * \note You might need higher privileges to use `high` or `critical` priorities.
 *
 * \since 5.0.0
 */
enum class thread_priority
{
  // clang-format off
  low = SDL_THREAD_PRIORITY_LOW,        ///< Non-urgent, background processing.
  normal = SDL_THREAD_PRIORITY_NORMAL,  ///< General purpose processing, this is the default.
  high = SDL_THREAD_PRIORITY_HIGH,              ///< For high-priority processing.
  critical = SDL_THREAD_PRIORITY_TIME_CRITICAL  ///< For timing-critical processing.
  // clang-format on
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied thread priority.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(thread_priority::high) == "high"`.
 *
 * \param priority the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const thread_priority priority) -> std::string_view
{
  switch (priority) {
    case thread_priority::low:
      return "low";

    case thread_priority::normal:
      return "normal";

    case thread_priority::high:
      return "high";

    case thread_priority::critical:
      return "critical";

    default:
      throw cen_error{"Did not recognize thread priority!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a thread priority enumerator.
 *
 * \param stream the output stream that will be used.
 * \param priority the enumerator that will be printed.
 *
 * \see `to_string(thread_priority)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const thread_priority priority) -> std::ostream&
{
  return stream << to_string(priority);
}

/// \} End of streaming

/// \name Thread priority comparison operators
/// \{

/**
 * \brief Indicates whether or not two thread priorities are the same.
 *
 * \param lhs the left-hand side thread priority.
 * \param rhs the right-hand side thread priority.
 *
 * \return `true` if the priorities are the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator==(const thread_priority lhs,
                                        const SDL_ThreadPriority rhs) noexcept -> bool
{
  return static_cast<SDL_ThreadPriority>(lhs) == rhs;
}

/// \copydoc operator==(thread_priority, SDL_ThreadPriority)
[[nodiscard]] constexpr auto operator==(const SDL_ThreadPriority lhs,
                                        const thread_priority rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two thread priorities aren't the same.
 *
 * \param lhs the left-hand side thread priority.
 * \param rhs the right-hand side thread priority.
 *
 * \return `true` if the priorities aren't the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] constexpr auto operator!=(const thread_priority lhs,
                                        const SDL_ThreadPriority rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(thread_priority, SDL_ThreadPriority)
[[nodiscard]] constexpr auto operator!=(const SDL_ThreadPriority lhs,
                                        const thread_priority rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of thread priority comparison operators

/// \} End of group thread

}  // namespace cen

#endif  // CENTURION_THREAD_PRIORITY_HEADER

// #include "centurion/thread/try_lock.hpp"
#ifndef CENTURION_TRY_LOCK_HEADER
#define CENTURION_TRY_LOCK_HEADER

#include <SDL.h>

// #include "../compiler/features.hpp"

// #include "lock_status.hpp"

// #include "mutex.hpp"


namespace cen {

/// \addtogroup thread
/// \{

/**
 * \class try_lock
 *
 * \brief Represents an RAII-style non-blocking lock that automatically unlocks the
 * associated mutex upon destruction.
 *
 * \since 5.0.0
 */
class try_lock final
{
 public:
  /**
   * \brief Attempts to lock the supplied mutex.
   *
   * \param mutex the mutex that will be locked.
   *
   * \since 5.0.0
   */
  CENTURION_NODISCARD_CTOR explicit try_lock(mutex& mutex) noexcept
      : m_mutex{&mutex}
      , m_status{mutex.try_lock()}
  {}

  try_lock(const try_lock&) = delete;

  auto operator=(const try_lock&) -> try_lock& = delete;

  /**
   * \brief Unlocks the associated mutex if it was successfully locked.
   *
   * \since 5.0.0
   */
  ~try_lock() noexcept
  {
    if (m_status == lock_status::success) {
      m_mutex->unlock();
    }
  }

  /**
   * \brief Returns the result of trying to lock the associated mutex.
   *
   * \return the lock status.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get_status() const noexcept -> lock_status
  {
    return m_status;
  }

  /**
   * \brief Indicates whether or not the mutex was successfully locked.
   *
   * \return `true` if the mutex was locked; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto success() const noexcept -> bool
  {
    return get_status() == lock_status::success;
  }

  /**
   * \brief Indicates whether or not the lock timed out whilst trying to lock the mutex.
   *
   * \return `true` if the locking timed out; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto timed_out() const noexcept -> bool
  {
    return get_status() == lock_status::timed_out;
  }

  /**
   * \brief Indicates whether or not there was an error whilst locking the mutex.
   *
   * \return `true` if something went wrong whilst locking the mutex; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto error() const noexcept -> bool
  {
    return get_status() == lock_status::error;
  }

  /// \copydoc success()
  [[nodiscard]] explicit operator bool() const noexcept
  {
    return success();
  }

 private:
  mutex* m_mutex{};
  lock_status m_status{};
};

/// \} End of group thread

}  // namespace cen

#endif  // CENTURION_TRY_LOCK_HEADER

// #include "centurion/video/blend_mode.hpp"
#ifndef CENTURION_BLEND_MODE_HEADER
#define CENTURION_BLEND_MODE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER

// #include "blend_factor.hpp"
#ifndef CENTURION_BLEND_FACTOR_HEADER
#define CENTURION_BLEND_FACTOR_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum blend_factor
 *
 * \brief Represents normalized factors used when multiplying pixel components.
 *
 * \see `blend_op`
 * \see `compose_blend_mode()`
 *
 * \since 6.3.0
 */
enum class blend_factor
{
  zero = SDL_BLENDFACTOR_ZERO,
  one = SDL_BLENDFACTOR_ONE,

  src_color = SDL_BLENDFACTOR_SRC_COLOR,
  one_minus_src_color = SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR,

  src_alpha = SDL_BLENDFACTOR_SRC_ALPHA,
  one_minus_src_alpha = SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA,

  dst_color = SDL_BLENDFACTOR_DST_COLOR,
  one_minus_dst_color = SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR,

  dst_alpha = SDL_BLENDFACTOR_DST_ALPHA,
  one_minus_dst_alpha = SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied blend factor.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(blend_factor::zero) == "zero"`.
 *
 * \param factor the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto to_string(const blend_factor factor) -> std::string_view
{
  switch (factor) {
    case blend_factor::zero:
      return "zero";

    case blend_factor::one:
      return "one";

    case blend_factor::src_color:
      return "src_color";

    case blend_factor::one_minus_src_color:
      return "one_minus_src_color";

    case blend_factor::src_alpha:
      return "src_alpha";

    case blend_factor::one_minus_src_alpha:
      return "one_minus_src_alpha";

    case blend_factor::dst_color:
      return "dst_color";

    case blend_factor::one_minus_dst_color:
      return "one_minus_dst_color";

    case blend_factor::dst_alpha:
      return "dst_alpha";

    case blend_factor::one_minus_dst_alpha:
      return "one_minus_dst_alpha";

    default:
      throw cen_error{"Did not recognize blend factor!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a blend factor enumerator.
 *
 * \param stream the output stream that will be used.
 * \param factor the enumerator that will be printed.
 *
 * \see `to_string(blend_factor)`
 *
 * \return the used stream.
 *
 * \since 6.3.0
 */
inline auto operator<<(std::ostream& stream, const blend_factor factor) -> std::ostream&
{
  return stream << to_string(factor);
}

/// \} End of streaming

/// \name Blend factor comparison operators
/// \{

/**
 * \brief Indicates whether or not two blend factor values are the same;
 *
 * \param lhs the left-hand side blend factor value.
 * \param rhs the right-hand side blend factor value.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto operator==(const blend_factor lhs,
                                        const SDL_BlendFactor rhs) noexcept -> bool
{
  return static_cast<SDL_BlendFactor>(lhs) == rhs;
}

/// \copydoc operator==(blend_factor, SDL_BlendFactor)
[[nodiscard]] constexpr auto operator==(const SDL_BlendFactor lhs,
                                        const blend_factor rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two blend factor values aren't the same;
 *
 * \param lhs the left-hand side blend factor value.
 * \param rhs the right-hand side blend factor value.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto operator!=(const blend_factor lhs,
                                        const SDL_BlendFactor rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(blend_factor, SDL_BlendFactor)
[[nodiscard]] constexpr auto operator!=(const SDL_BlendFactor lhs,
                                        const blend_factor rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of blend factor comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_BLEND_FACTOR_HEADER

// #include "blend_op.hpp"
#ifndef CENTURION_BLEND_OP_HEADER
#define CENTURION_BLEND_OP_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum blend_op
 *
 * \brief Represents different strategies used when combining pixel components.
 *
 * \see `blend_factor`
 * \see `compose_blend_mode()`
 *
 * \since 6.3.0
 */
enum class blend_op
{
  add = SDL_BLENDOPERATION_ADD,
  sub = SDL_BLENDOPERATION_SUBTRACT,
  reverse_sub = SDL_BLENDOPERATION_REV_SUBTRACT,
  min = SDL_BLENDOPERATION_MINIMUM,
  max = SDL_BLENDOPERATION_MAXIMUM
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied blend operation.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(blend_op::add) == "add"`.
 *
 * \param op the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto to_string(const blend_op op) -> std::string_view
{
  switch (op) {
    case blend_op::add:
      return "add";

    case blend_op::sub:
      return "sub";

    case blend_op::reverse_sub:
      return "reverse_sub";

    case blend_op::min:
      return "min";

    case blend_op::max:
      return "max";

    default:
      throw cen_error{"Did not recognize blend operation!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a blend operation enumerator.
 *
 * \param stream the output stream that will be used.
 * \param op the enumerator that will be printed.
 *
 * \see `to_string(blend_op)`
 *
 * \return the used stream.
 *
 * \since 6.3.0
 */
inline auto operator<<(std::ostream& stream, const blend_op op) -> std::ostream&
{
  return stream << to_string(op);
}

/// \} End of streaming

/// \name Blend operation comparison operators
/// \{

/**
 * \brief Indicates whether or not two blend operation values are the same;
 *
 * \param lhs the left-hand side blend operation value.
 * \param rhs the right-hand side blend operation value.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto operator==(const blend_op lhs,
                                        const SDL_BlendOperation rhs) noexcept -> bool
{
  return static_cast<SDL_BlendOperation>(lhs) == rhs;
}

/// \copydoc operator==(blend_op, SDL_BlendOperation)
[[nodiscard]] constexpr auto operator==(const SDL_BlendOperation lhs,
                                        const blend_op rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two blend operation values aren't the same;
 *
 * \param lhs the left-hand side blend operation value.
 * \param rhs the right-hand side blend operation value.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto operator!=(const blend_op lhs,
                                        const SDL_BlendOperation rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(blend_op, SDL_BlendOperation)
[[nodiscard]] constexpr auto operator!=(const SDL_BlendOperation lhs,
                                        const blend_op rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of blend operation comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_BLEND_OP_HEADER

namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum blend_mode
 *
 * \brief Provides values that represent various rendering blend modes.
 *
 * \since 3.0.0
 *
 * \see `SDL_BlendMode`
 */
enum class blend_mode
{
  none = SDL_BLENDMODE_NONE,    ///< Represents no blending.
  blend = SDL_BLENDMODE_BLEND,  ///< Represents alpha blending.
  add = SDL_BLENDMODE_ADD,      ///< Represents additive blending.
  mod = SDL_BLENDMODE_MOD,      ///< Represents color modulation.

#if SDL_VERSION_ATLEAST(2, 0, 12)

  mul = SDL_BLENDMODE_MUL,  ///< Represents color multiplication.

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

  invalid = SDL_BLENDMODE_INVALID  ///< Represents an invalid blend mode.
};

/**
 * \struct blend_task
 *
 * \brief Describes how a pair of blend mode factors will be combined.
 *
 * \see `compose_blend_mode()`
 *
 * \since 6.3.0
 */
struct blend_task final
{
  blend_factor src;  ///< The blend factor applied to the source pixels.
  blend_factor dst;  ///< The blend factor applied to the destination pixels.
  blend_op op;       ///< The operation used to combine the source and destination pixels.
};

/**
 * \brief Composes a custom blend mode.
 *
 * \param color the blend task descriptor used for RGB components.
 * \param alpha the blend task descriptor used for alpha components.
 *
 * \return the composed blend mode.
 *
 * \see `blend_task`
 * \see `blend_factor`
 * \see `blend_op`
 *
 * \see `SDL_ComposeCustomBlendMode()`
 * \see `basic_renderer::set_blend_mode()`
 * \see `basic_texture::set_blend_mode()`
 *
 * \since 6.3.0
 */
[[nodiscard]] inline auto compose_blend_mode(const blend_task& color,
                                             const blend_task& alpha) noexcept -> blend_mode
{
  const auto res = SDL_ComposeCustomBlendMode(static_cast<SDL_BlendFactor>(color.src),
                                              static_cast<SDL_BlendFactor>(color.dst),
                                              static_cast<SDL_BlendOperation>(color.op),
                                              static_cast<SDL_BlendFactor>(alpha.src),
                                              static_cast<SDL_BlendFactor>(alpha.dst),
                                              static_cast<SDL_BlendOperation>(alpha.op));
  return static_cast<blend_mode>(res);
}

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied blend mode.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(blend_mode::blend) == "blend"`.
 *
 * \param mode the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const blend_mode mode) -> std::string_view
{
  switch (mode) {
    case blend_mode::none:
      return "none";

    case blend_mode::blend:
      return "blend";

    case blend_mode::add:
      return "add";

    case blend_mode::mod:
      return "mod";

    case blend_mode::invalid:
      return "invalid";

#if SDL_VERSION_ATLEAST(2, 0, 12)

    case blend_mode::mul:
      return "mul";

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

    default:
      throw cen_error{"Did not recognize blend mode!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a blend mode enumerator.
 *
 * \param stream the output stream that will be used.
 * \param mode the enumerator that will be printed.
 *
 * \see `to_string(blend_mode)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const blend_mode mode) -> std::ostream&
{
  return stream << to_string(mode);
}

/// \} End of streaming

/// \name Blend mode comparison operators
/// \{

/**
 * \brief Indicates whether or not two blend mode values are the same;
 *
 * \param lhs the left-hand side blend mode value.
 * \param rhs the right-hand side blend mode value.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const blend_mode lhs, const SDL_BlendMode rhs) noexcept
    -> bool
{
  return static_cast<SDL_BlendMode>(lhs) == rhs;
}

/// \copydoc operator==(blend_mode, SDL_BlendMode)
[[nodiscard]] constexpr auto operator==(const SDL_BlendMode lhs, const blend_mode rhs) noexcept
    -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two blend mode values aren't the same;
 *
 * \param lhs the left-hand side blend mode value.
 * \param rhs the right-hand side blend mode value.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator!=(const blend_mode lhs, const SDL_BlendMode rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(blend_mode, SDL_BlendMode)
[[nodiscard]] constexpr auto operator!=(const SDL_BlendMode lhs, const blend_mode rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \} End of blend mode comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_BLEND_MODE_HEADER

// #include "centurion/video/button_order.hpp"
#ifndef CENTURION_BUTTON_ORDER_HEADER
#define CENTURION_BUTTON_ORDER_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"
#ifndef CENTURION_INTEGERS_HEADER
#define CENTURION_INTEGERS_HEADER

#include <SDL.h>

#include <cstddef>  // size_t

namespace cen {

/// \addtogroup core
/// \{

/// \name Integer aliases
/// \{

using usize = std::size_t;

/// Alias for an unsigned integer.
using uint = unsigned int;

/// Alias for the type used for integer literal operators.
using ulonglong = unsigned long long;

/// Alias for a 64-bit unsigned integer.
using u64 = Uint64;

/// Alias for a 32-bit unsigned integer.
using u32 = Uint32;

/// Alias for a 16-bit unsigned integer.
using u16 = Uint16;

/// Alias for an 8-bit unsigned integer.
using u8 = Uint8;

/// Alias for a 64-bit signed integer.
using i64 = Sint64;

/// Alias for a 32-bit signed integer.
using i32 = Sint32;

/// Alias for a 16-bit signed integer.
using i16 = Sint16;

/// Alias for an 8-bit signed integer.
using i8 = Sint8;

/// \} End of integer aliases

// clang-format off

/**
 * \brief Obtains the size of a container as an `int`.
 *
 * \tparam T a "container" that provides a `size()` member function.
 *
 * \param container the container to query the size of.
 *
 * \return the size of the container as an `int` value.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto isize(const T& container) noexcept(noexcept(container.size()))
    -> int
{
  return static_cast<int>(container.size());
}

// clang-format on

namespace literals {

/**
 * \brief Creates an 8-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u8(const ulonglong value) noexcept -> u8
{
  return static_cast<u8>(value);
}

/**
 * \brief Creates a 16-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u16(const ulonglong value) noexcept -> u16
{
  return static_cast<u16>(value);
}

/**
 * \brief Creates a 32-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u32(const ulonglong value) noexcept -> u32
{
  return static_cast<u32>(value);
}

/**
 * \brief Creates a 64-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u64(const ulonglong value) noexcept -> u64
{
  return static_cast<u64>(value);
}

/**
 * \brief Creates an 8-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i8(const ulonglong value) noexcept -> i8
{
  return static_cast<i8>(value);
}

/**
 * \brief Creates a 16-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i16(const ulonglong value) noexcept -> i16
{
  return static_cast<i16>(value);
}

/**
 * \brief Creates a 32-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i32(const ulonglong value) noexcept -> i32
{
  return static_cast<i32>(value);
}

/**
 * \brief Creates a 64-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i64(const ulonglong value) noexcept -> i64
{
  return static_cast<i64>(value);
}

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_INTEGERS_HEADER


namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum button_order
 *
 * \brief Provides hints for how the buttons in a message box should be aligned.
 *
 * \note This enum has no effect and shouldn't be used if you're using SDL 2.0.10!
 *
 * \since 4.0.0
 */
enum class button_order : u32
{
#if SDL_VERSION_ATLEAST(2, 0, 12)
  left_to_right = SDL_MESSAGEBOX_BUTTONS_LEFT_TO_RIGHT,
  right_to_left = SDL_MESSAGEBOX_BUTTONS_RIGHT_TO_LEFT
#else
  left_to_right,
  right_to_left
#endif  // SDL_VERSION_ATLEAST(2, 0, 12)
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied button order.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(button_order::left_to_right) == "left_to_right"`.
 *
 * \param order the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const button_order order) -> std::string_view
{
  switch (order) {
    case button_order::left_to_right:
      return "left_to_right";

    case button_order::right_to_left:
      return "right_to_left";

    default:
      throw cen_error{"Did not recognize button order!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a button order enumerator.
 *
 * \param stream the output stream that will be used.
 * \param order the enumerator that will be printed.
 *
 * \see `to_string(button_order)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const button_order order) -> std::ostream&
{
  return stream << to_string(order);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_BUTTON_ORDER_HEADER

// #include "centurion/video/color.hpp"
#ifndef CENTURION_COLOR_HEADER
#define CENTURION_COLOR_HEADER

#include <SDL.h>

#include <cassert>      // assert
#include <cmath>        // round, abs, fmod, lerp
#include <iomanip>      // setfill, setw
#include <ios>          // uppercase, hex
#include <optional>     // optional
#include <ostream>      // ostream
#include <sstream>      // stringstream
#include <string>       // string, to_string
#include <string_view>  // string_view

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../compiler/compiler.hpp"
#ifndef CENTURION_COMPILER_HEADER
#define CENTURION_COMPILER_HEADER

#include <SDL.h>

namespace cen {

/// \addtogroup compiler
/// \{

/**
 * \brief Indicates whether or not a "debug" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a debug build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_debug_build() noexcept -> bool
{
#ifndef NDEBUG
  return true;
#else
  return false;
#endif  // NDEBUG
}

/**
 * \brief Indicates whether or not a "release" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a release build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_release_build() noexcept -> bool
{
  return !is_debug_build();
}

/**
 * \brief Indicates whether or not the compiler is MSVC.
 *
 * \return `true` if MSVC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_msvc() noexcept -> bool
{
#ifdef _MSC_VER
  return true;
#else
  return false;
#endif  // _MSC_VER
}

/**
 * \brief Indicates whether or not the compiler is GCC.
 *
 * \return `true` if GCC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_gcc() noexcept -> bool
{
#ifdef __GNUC__
  return true;
#else
  return false;
#endif  // __GNUC__
}

/**
 * \brief Indicates whether or not the compiler is Clang.
 *
 * \return `true` if Clang is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_clang() noexcept -> bool
{
#ifdef __clang__
  return true;
#else
  return false;
#endif  // __clang__
}

/**
 * \brief Indicates whether or not the compiler is Emscripten.
 *
 * \return `true` if Emscripten is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_emscripten() noexcept -> bool
{
#ifdef __EMSCRIPTEN__
  return true;
#else
  return false;
#endif  // __EMSCRIPTEN__
}

/**
 * \brief Indicates whether or not the compiler is Intel C++.
 *
 * \return `true` if Intel C++ is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_intel_cpp() noexcept -> bool
{
#ifdef __INTEL_COMPILER
  return true;
#else
  return false;
#endif  // __INTEL_COMPILER
}

/// \} End of compiler group

}  // namespace cen

#endif  // CENTURION_COMPILER_HEADER

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../detail/clamp.hpp"
#ifndef CENTURION_DETAIL_CLAMP_HEADER
#define CENTURION_DETAIL_CLAMP_HEADER

#include <cassert>  // assert

/// \cond FALSE
namespace cen::detail {

// clang-format off

/**
 * \brief Clamps a value to be within the range [min, max].
 *
 * \pre `min` must be less than or equal to `max`.
 *
 * \note The standard library provides `std::clamp`, but it isn't mandated to be
 * `noexcept` (although MSVC does mark it as `noexcept`), which is the reason this
 * function exists.
 *
 * \tparam T the type of the values.
 *
 * \param value the value that will be clamped.
 * \param min the minimum value (inclusive).
 * \param max the maximum value (inclusive).
 *
 * \return the clamped value.
 *
 * \since 5.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto clamp(const T& value,
                                   const T& min,
                                   const T& max)
    noexcept(noexcept(value < min) && noexcept(value > max)) -> T
{
  assert(min <= max);
  if (value < min)
  {
    return min;
  }
  else if (value > max)
  {
    return max;
  }
  else
  {
    return value;
  }
}

// clang-format on

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_CLAMP_HEADER

// #include "../detail/from_string.hpp"
#ifndef CENTURION_DETAIL_FROM_STRING_HEADER
#define CENTURION_DETAIL_FROM_STRING_HEADER

#include <charconv>      // from_chars
#include <optional>      // optional
#include <string>        // string, stof
#include <string_view>   // string_view
#include <system_error>  // errc
#include <type_traits>   // is_floating_point_v

// #include "../compiler/compiler.hpp"
#ifndef CENTURION_COMPILER_HEADER
#define CENTURION_COMPILER_HEADER

#include <SDL.h>

namespace cen {

/// \addtogroup compiler
/// \{

/**
 * \brief Indicates whether or not a "debug" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a debug build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_debug_build() noexcept -> bool
{
#ifndef NDEBUG
  return true;
#else
  return false;
#endif  // NDEBUG
}

/**
 * \brief Indicates whether or not a "release" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a release build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_release_build() noexcept -> bool
{
  return !is_debug_build();
}

/**
 * \brief Indicates whether or not the compiler is MSVC.
 *
 * \return `true` if MSVC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_msvc() noexcept -> bool
{
#ifdef _MSC_VER
  return true;
#else
  return false;
#endif  // _MSC_VER
}

/**
 * \brief Indicates whether or not the compiler is GCC.
 *
 * \return `true` if GCC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_gcc() noexcept -> bool
{
#ifdef __GNUC__
  return true;
#else
  return false;
#endif  // __GNUC__
}

/**
 * \brief Indicates whether or not the compiler is Clang.
 *
 * \return `true` if Clang is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_clang() noexcept -> bool
{
#ifdef __clang__
  return true;
#else
  return false;
#endif  // __clang__
}

/**
 * \brief Indicates whether or not the compiler is Emscripten.
 *
 * \return `true` if Emscripten is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_emscripten() noexcept -> bool
{
#ifdef __EMSCRIPTEN__
  return true;
#else
  return false;
#endif  // __EMSCRIPTEN__
}

/**
 * \brief Indicates whether or not the compiler is Intel C++.
 *
 * \return `true` if Intel C++ is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_intel_cpp() noexcept -> bool
{
#ifdef __INTEL_COMPILER
  return true;
#else
  return false;
#endif  // __INTEL_COMPILER
}

/// \} End of compiler group

}  // namespace cen

#endif  // CENTURION_COMPILER_HEADER


/// \cond FALSE
namespace cen::detail {

template <typename T>
[[nodiscard]] auto from_string(const std::string_view str,
                               const int base = 10) noexcept(on_msvc()) -> std::optional<T>
{
  T value{};

  const auto begin = str.data();
  const auto end = str.data() + str.size();

  const char* mismatch = end;
  std::errc error{};

  if constexpr (std::is_floating_point_v<T>) {
    if constexpr (on_gcc() || on_clang()) {
      try {
        value = std::stof(std::string{str});
      }
      catch (...) {
        return std::nullopt;
      }
    }
    else {
      const auto [ptr, err] = std::from_chars(begin, end, value);
      mismatch = ptr;
      error = err;
    }
  }
  else {
    const auto [ptr, err] = std::from_chars(begin, end, value, base);
    mismatch = ptr;
    error = err;
  }

  if (mismatch == end && error == std::errc{}) {
    return value;
  }
  else {
    return std::nullopt;
  }
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_FROM_STRING_HEADER

// #include "../detail/lerp.hpp"
#ifndef CENTURION_DETAIL_LERP_HEADER
#define CENTURION_DETAIL_LERP_HEADER

#include <cmath>  // lerp

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER


/// \cond FALSE

namespace cen::detail {

[[nodiscard]] constexpr auto lerp(const float a, const float b, const float bias) noexcept
    -> float
{
#if CENTURION_HAS_FEATURE_LERP
  return std::lerp(a, b, bias);
#else
  return (a * (1.0f - bias)) + (b * bias);
#endif  // CENTURION_HAS_FEATURE_LERP
}

}  // namespace cen::detail

/// \endcond

#endif  // CENTURION_DETAIL_LERP_HEADER


namespace cen {

/// \addtogroup video
/// \{

/**
 * \class color
 *
 * \brief An 8-bit accuracy RGBA color.
 *
 * \serializable
 *
 * \details This class is designed to interact with the SDL colors, i.e. `SDL_Color` and
 * `SDL_MessageBoxColor`. For convenience, there are approximately 140 color constants
 * provided in the `colors` namespace,
 *
 * \since 3.0.0
 */
class color final
{
 public:
  /// \name Construction
  /// \{

  /**
   * \brief Creates a color. The created color will be equal to #000000FF.
   *
   * \since 3.0.0
   */
  constexpr color() noexcept = default;

  /**
   * \brief Creates a color.
   *
   * \param red the red component value, in the range [0, 255].
   * \param green the green component value, in the range [0, 255].
   * \param blue the blue component value, in the range [0, 255].
   * \param alpha the alpha component value, in the rage [0, 255]. Defaults to 255.
   *
   * \since 3.0.0
   */
  constexpr color(const u8 red, const u8 green, const u8 blue, const u8 alpha = max()) noexcept
      : m_color{red, green, blue, alpha}
  {}

  /**
   * \brief Creates a color that is a copy of the supplied `SDL_Color`.
   *
   * \param color the `SDL_Color` that will be copied.
   *
   * \since 3.0.0
   */
  constexpr explicit color(const SDL_Color& color) noexcept : m_color{color}
  {}

  /**
   * \brief Creates a color that is a copy of the supplied SDL_MessageBoxColor.
   *
   * \details Message box colors don't have an alpha component so the created color will
   * feature an alpha value of 255.
   *
   * \param color the message box color that will be copied.
   *
   * \since 3.0.0
   */
  constexpr explicit color(const SDL_MessageBoxColor& color) noexcept
      : m_color{color.r, color.g, color.b, max()}
  {}

  /**
   * \brief Creates a color from HSV-encoded values.
   *
   * \note The values will be clamped to be within their respective ranges.
   *
   * \param hue the hue of the color, in the range [0, 360].
   * \param saturation the saturation of the color, in the range [0, 100].
   * \param value the value of the color, in the range [0, 100].
   *
   * \return an RGBA color converted from the HSV values.
   *
   * \since 5.3.0
   */
  [[nodiscard]] static auto from_hsv(float hue, float saturation, float value) -> color
  {
    hue = detail::clamp(hue, 0.0f, 360.0f);
    saturation = detail::clamp(saturation, 0.0f, 100.0f);
    value = detail::clamp(value, 0.0f, 100.0f);

    const auto v = (value / 100.0f);
    const auto chroma = v * (saturation / 100.0f);
    const auto hp = hue / 60.0f;

    const auto x = chroma * (1.0f - std::abs(std::fmod(hp, 2.0f) - 1.0f));

    float red{};
    float green{};
    float blue{};

    if (0 <= hp && hp <= 1) {
      red = chroma;
      green = x;
      blue = 0;
    }
    else if (1 < hp && hp <= 2) {
      red = x;
      green = chroma;
      blue = 0;
    }
    else if (2 < hp && hp <= 3) {
      red = 0;
      green = chroma;
      blue = x;
    }
    else if (3 < hp && hp <= 4) {
      red = 0;
      green = x;
      blue = chroma;
    }
    else if (4 < hp && hp <= 5) {
      red = x;
      green = 0;
      blue = chroma;
    }
    else if (5 < hp && hp <= 6) {
      red = chroma;
      green = 0;
      blue = x;
    }

    const auto m = v - chroma;

    const auto r = static_cast<u8>(std::round((red + m) * 255.0f));
    const auto g = static_cast<u8>(std::round((green + m) * 255.0f));
    const auto b = static_cast<u8>(std::round((blue + m) * 255.0f));

    return color{r, g, b};
  }

  /**
   * \brief Creates a color from HSL-encoded values.
   *
   * \note The values will be clamped to be within their respective ranges.
   *
   * \param hue the hue of the color, in the range [0, 360].
   * \param saturation the saturation of the color, in the range [0, 100].
   * \param lightness the lightness of the color, in the range [0, 100].
   *
   * \return an RGBA color converted from the HSL values.
   *
   * \since 5.3.0
   */
  [[nodiscard]] static auto from_hsl(float hue, float saturation, float lightness) -> color
  {
    hue = detail::clamp(hue, 0.0f, 360.0f);
    saturation = detail::clamp(saturation, 0.0f, 100.0f);
    lightness = detail::clamp(lightness, 0.0f, 100.0f);

    const auto s = saturation / 100.0f;
    const auto l = lightness / 100.0f;

    const auto chroma = (1.0f - std::abs(2.0f * l - 1.0f)) * s;
    const auto hp = hue / 60.0f;

    const auto x = chroma * (1.0f - std::abs(std::fmod(hp, 2.0f) - 1.0f));

    float red{};
    float green{};
    float blue{};

    if (0 <= hp && hp < 1) {
      red = chroma;
      green = x;
      blue = 0;
    }
    else if (1 <= hp && hp < 2) {
      red = x;
      green = chroma;
      blue = 0;
    }
    else if (2 <= hp && hp < 3) {
      red = 0;
      green = chroma;
      blue = x;
    }
    else if (3 <= hp && hp < 4) {
      red = 0;
      green = x;
      blue = chroma;
    }
    else if (4 <= hp && hp < 5) {
      red = x;
      green = 0;
      blue = chroma;
    }
    else if (5 <= hp && hp < 6) {
      red = chroma;
      green = 0;
      blue = x;
    }

    const auto m = l - (chroma / 2.0f);

    const auto r = static_cast<u8>(std::round((red + m) * 255.0f));
    const auto g = static_cast<u8>(std::round((green + m) * 255.0f));
    const auto b = static_cast<u8>(std::round((blue + m) * 255.0f));

    return color{r, g, b};
  }

  /**
   * \brief Creates a color from a hexadecimal RGB color string.
   *
   * \details The supplied string must feature a leading '#' character, and be 7
   * characters long.
   *
   * \param rgb the hexadecimal RGB color string, using the format "#RRGGBB".
   *
   * \return a corresponding color; `std::nullopt` if something goes wrong.
   *
   * \see `from_rgba()`
   * \see `from_argb()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] static auto from_rgb(const std::string_view rgb) -> std::optional<color>
  {
    if (rgb.length() != 7 || rgb.at(0) != '#') {
      return std::nullopt;
    }

    const auto noHash = rgb.substr(1);

    const auto rr = noHash.substr(0, 2);
    const auto gg = noHash.substr(2, 2);
    const auto bb = noHash.substr(4, 2);

    const auto red = detail::from_string<u8>(rr, 16);
    const auto green = detail::from_string<u8>(gg, 16);
    const auto blue = detail::from_string<u8>(bb, 16);

    if (red && green && blue) {
      return cen::color{*red, *green, *blue};
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Creates a color from a hexadecimal RGBA color string.
   *
   * \details The supplied string must feature a leading '#' character, and be 9
   * characters long.
   *
   * \param rgba the hexadecimal RGBA color string, using the format "#RRGGBBAA".
   *
   * \return a corresponding color; `std::nullopt` if something goes wrong.
   *
   * \see `from_rgb()`
   * \see `from_argb()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] static auto from_rgba(const std::string_view rgba) -> std::optional<color>
  {
    if (rgba.length() != 9 || rgba.at(0) != '#') {
      return std::nullopt;
    }

    const auto noHash = rgba.substr(1);

    const auto rr = noHash.substr(0, 2);
    const auto gg = noHash.substr(2, 2);
    const auto bb = noHash.substr(4, 2);
    const auto aa = noHash.substr(6, 2);

    const auto red = detail::from_string<u8>(rr, 16);
    const auto green = detail::from_string<u8>(gg, 16);
    const auto blue = detail::from_string<u8>(bb, 16);
    const auto alpha = detail::from_string<u8>(aa, 16);

    if (red && green && blue && alpha) {
      return cen::color{*red, *green, *blue, *alpha};
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Creates a color from a hexadecimal ARGB color string.
   *
   * \details The supplied string must feature a leading '#' character, and be 9
   * characters long.
   *
   * \param argb the hexadecimal ARGB color string, using the format "#AARRGGBB".
   *
   * \return a corresponding color; `std::nullopt` if something goes wrong.
   *
   * \see `from_rgb()`
   * \see `from_rgba()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] static auto from_argb(const std::string_view argb) -> std::optional<color>
  {
    if (argb.length() != 9 || argb.at(0) != '#') {
      return std::nullopt;
    }

    const auto noHash = argb.substr(1);

    const auto aa = noHash.substr(0, 2);
    const auto rr = noHash.substr(2, 2);
    const auto gg = noHash.substr(4, 2);
    const auto bb = noHash.substr(6, 2);

    const auto alpha = detail::from_string<u8>(aa, 16);
    const auto red = detail::from_string<u8>(rr, 16);
    const auto green = detail::from_string<u8>(gg, 16);
    const auto blue = detail::from_string<u8>(bb, 16);

    if (alpha && red && green && blue) {
      return cen::color{*red, *green, *blue, *alpha};
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Creates a color from normalized color component values.
   *
   * \note The color components will be clamped to the range [0, 1].
   *
   * \param red the red component value, in the range [0, 1].
   * \param green the green component value, in the range [0, 1].
   * \param blue the blue component value, in the range [0, 1].
   * \param alpha the alpha component value, in the range [0, 1].
   *
   * \return a color with the supplied color components.
   *
   * \since 6.1.0
   */
  [[nodiscard]] static auto from_norm(float red,
                                      float green,
                                      float blue,
                                      float alpha = 1.0f) noexcept(on_msvc()) -> color
  {
    red = detail::clamp(red, 0.0f, 1.0f);
    green = detail::clamp(green, 0.0f, 1.0f);
    blue = detail::clamp(blue, 0.0f, 1.0f);
    alpha = detail::clamp(alpha, 0.0f, 1.0f);

    const auto r = static_cast<u8>(std::round(red * 255.0f));
    const auto g = static_cast<u8>(std::round(green * 255.0f));
    const auto b = static_cast<u8>(std::round(blue * 255.0f));
    const auto a = static_cast<u8>(std::round(alpha * 255.0f));

    return color{r, g, b, a};
  }

  /// \} End of construction

  /// \name Setters
  /// \{

  /**
   * \brief Sets the value of the red component.
   *
   * \param red the new value of the red component.
   *
   * \since 3.0.0
   */
  constexpr void set_red(const u8 red) noexcept
  {
    m_color.r = red;
  }

  /**
   * \brief Sets the value of the green component.
   *
   * \param green the new value of the green component.
   *
   * \since 3.0.0
   */
  constexpr void set_green(const u8 green) noexcept
  {
    m_color.g = green;
  }

  /**
   * \brief Sets the value of the blue component.
   *
   * \param blue the new value of the blue component.
   *
   * \since 3.0.0
   */
  constexpr void set_blue(const u8 blue) noexcept
  {
    m_color.b = blue;
  }

  /**
   * \brief Sets the value of the alpha component.
   *
   * \param alpha the new value of the alpha component.
   *
   * \since 3.0.0
   */
  constexpr void set_alpha(const u8 alpha) noexcept
  {
    m_color.a = alpha;
  }

  /// \} End of setters

  /// \name Getters
  /// \{

  /**
   * \brief Returns the value of the red component.
   *
   * \return the value of the red component, in the range [0, 255].
   *
   * \since 3.0.0
   */
  [[nodiscard]] constexpr auto red() const noexcept -> u8
  {
    return m_color.r;
  }

  /**
   * \brief Returns the value of the green component.
   *
   * \return the value of the green component, in the range [0, 255].
   *
   * \since 3.0.0
   */
  [[nodiscard]] constexpr auto green() const noexcept -> u8
  {
    return m_color.g;
  }

  /**
   * \brief Returns the value of the blue component.
   *
   * \return the value of the blue component, in the range [0, 255].
   *
   * \since 3.0.0
   */
  [[nodiscard]] constexpr auto blue() const noexcept -> u8
  {
    return m_color.b;
  }

  /**
   * \brief Returns the value of the alpha component.
   *
   * \return the value of the alpha component, in the range [0, 255].
   *
   * \since 3.0.0
   */
  [[nodiscard]] constexpr auto alpha() const noexcept -> u8
  {
    return m_color.a;
  }

  /**
   * \brief Returns the normalized red component of the color.
   *
   * \return the red component value, in the range [0, 1].
   *
   * \since 6.1.0
   */
  [[nodiscard]] constexpr auto red_norm() const noexcept -> float
  {
    return static_cast<float>(m_color.r) / 255.0f;
  }

  /**
   * \brief Returns the normalized green component of the color.
   *
   * \return the green component value, in the range [0, 1].
   *
   * \since 6.1.0
   */
  [[nodiscard]] constexpr auto green_norm() const noexcept -> float
  {
    return static_cast<float>(m_color.g) / 255.0f;
  }

  /**
   * \brief Returns the normalized blue component of the color.
   *
   * \return the blue component value, in the range [0, 1].
   *
   * \since 6.1.0
   */
  [[nodiscard]] constexpr auto blue_norm() const noexcept -> float
  {
    return static_cast<float>(m_color.b) / 255.0f;
  }

  /**
   * \brief Returns the normalized alpha component of the color.
   *
   * \return the alpha component value, in the range [0, 1].
   *
   * \since 6.1.0
   */
  [[nodiscard]] constexpr auto alpha_norm() const noexcept -> float
  {
    return static_cast<float>(m_color.a) / 255.0f;
  }

  /**
   * \brief Returns a pointer to the internal SDL color.
   *
   * \warning Do not cache the returned pointer!
   *
   * \return a pointer to the internal color instance.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto data() noexcept -> SDL_Color*
  {
    return &m_color;
  }

  /// \copydoc data()
  [[nodiscard]] auto data() const noexcept -> const SDL_Color*
  {
    return &m_color;
  }

  /**
   * \brief Returns the internal color instance.
   *
   * \return a reference to the internal color.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get() const noexcept -> const SDL_Color&
  {
    return m_color;
  }

  /// \} End of getters

  /// \name Color string conversions
  /// \{

  /**
   * \brief Returns a hexadecimal RGB color string that represents the color.
   *
   * \details The returned string is guaranteed to use uppercase hexadecimal digits (A-F).
   *
   * \return a hexadecimal color string representation, on the format "#RRGGBB".
   *
   * \see `as_rgba()`
   * \see `as_argb()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto as_rgb() const -> std::string
  {
    std::stringstream stream;
    stream << std::setfill('0') << std::hex << std::uppercase;

    stream << '#';
    stream << std::setw(2) << +m_color.r;
    stream << std::setw(2) << +m_color.g;
    stream << std::setw(2) << +m_color.b;

    return stream.str();
  }

  /**
   * \brief Returns a hexadecimal RGBA color string that represents the color.
   *
   * \details The returned string is guaranteed to use uppercase hexadecimal digits (A-F).
   *
   * \return a hexadecimal color string representation, on the format "#RRGGBBAA".
   *
   * \see `as_rgb()`
   * \see `as_argb()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto as_rgba() const -> std::string
  {
    std::stringstream stream;
    stream << std::setfill('0') << std::hex << std::uppercase;

    stream << '#';
    stream << std::setw(2) << +m_color.r;
    stream << std::setw(2) << +m_color.g;
    stream << std::setw(2) << +m_color.b;
    stream << std::setw(2) << +m_color.a;

    return stream.str();
  }

  /**
   * \brief Returns a hexadecimal ARGB color string that represents the color.
   *
   * \details The returned string is guaranteed to use uppercase hexadecimal digits (A-F).
   *
   * \return a hexadecimal color string representation, on the format "#AARRGGBB".
   *
   * \see `as_rgb()`
   * \see `as_rgba()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto as_argb() const -> std::string
  {
    std::stringstream stream;
    stream << std::setfill('0') << std::hex << std::uppercase;

    stream << '#';
    stream << std::setw(2) << +m_color.a;
    stream << std::setw(2) << +m_color.r;
    stream << std::setw(2) << +m_color.g;
    stream << std::setw(2) << +m_color.b;

    return stream.str();
  }

  /// \} End of color string conversions

  /// \name Conversions
  /// \{

  /**
   * \brief Converts the the color into an `SDL_Color`.
   *
   * \return an `SDL_Color` that is equivalent to this color.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit constexpr operator SDL_Color() const noexcept
  {
    return {red(), green(), blue(), alpha()};
  }

  /**
   * \brief Converts the the color into an `SDL_MessageBoxColor`.
   *
   * \note Message box colors don't feature an alpha value!
   *
   * \return an `SDL_MessageBoxColor` that is equivalent to this color.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit constexpr operator SDL_MessageBoxColor() const noexcept
  {
    return {red(), green(), blue()};
  }

  /**
   * \brief Converts the color to `SDL_Color*`.
   *
   * \warning The returned pointer is not to be freed or stored away!
   *
   * \return a pointer to the internal color instance.
   *
   * \since 4.0,0
   */
  [[nodiscard]] explicit operator SDL_Color*() noexcept
  {
    return &m_color;
  }

  /**
   * \brief Converts the color to `const SDL_Color*`.
   *
   * \warning The returned pointer is not to be freed or stored away!
   *
   * \return a pointer to the internal color instance.
   *
   * \since 4.0,0
   */
  [[nodiscard]] explicit operator const SDL_Color*() const noexcept
  {
    return &m_color;
  }

  /// \} End of conversions

  /**
   * \brief Serializes the color.
   *
   * \details This function expects that the archive provides an overloaded `operator()`,
   * used for serializing data. This API is based on the Cereal serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the color.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_color.r, m_color.g, m_color.b, m_color.a);
  }

  /**
   * \brief Returns a copy of the color with the specified alpha value.
   *
   * \param alpha the alpha component value that will be used by the new color.
   *
   * \return a color that is identical to the color except for the alpha component.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto with_alpha(const u8 alpha) const noexcept -> color
  {
    return {red(), green(), blue(), alpha};
  }

  /**
   * \brief Returns the maximum possible value of a color component.
   *
   * \return the maximum possible value of a color component.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr static auto max() noexcept -> u8
  {
    return 0xFF;
  }

 private:
  SDL_Color m_color{0, 0, 0, max()};
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of the color.
 *
 * \param color the color that will be converted.
 *
 * \return a textual representation of the color.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto to_string(const color& color) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("color{{r: {}, g: {}, b: {}: a: {}}}",
                     +color.red(),
                     +color.green(),
                     +color.blue(),
                     +color.alpha());
#else
  return "color{r: " + std::to_string(color.red()) + ", g: " + std::to_string(color.green()) +
         ", b: " + std::to_string(color.blue()) + ", a: " + std::to_string(color.alpha()) +
         "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a color.
 *
 * \param stream the stream that will be used.
 * \param color the color that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
inline auto operator<<(std::ostream& stream, const color& color) -> std::ostream&
{
  return stream << to_string(color);
}

/// \} End of streaming

/**
 * \brief Blends two colors according to the specified bias.
 *
 * \pre `bias` should be in the range [0, 1].
 *
 * \details This function applies a linear interpolation for each color component to
 * obtain the blended color. The bias parameter is the "alpha" for the interpolation,
 * which determines how the input colors are blended. For example, a bias of 0 or 1 will
 * simply result in the first or second color being returned, respectively.
 * Subsequently, a bias of 0.5 will blend the two colors evenly.
 *
 * \param a the first color.
 * \param b the second color.
 * \param bias the bias that determines how the colors are blended, in the range [0, 1].
 *
 * \return a color obtained by blending the two supplied colors.
 *
 * \todo Default the bias to 0.5 when the `double` overload has been removed.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto blend(const color& a, const color& b, const float bias) -> color
{
  assert(bias >= 0);
  assert(bias <= 1.0f);

  const auto red = detail::lerp(a.red_norm(), b.red_norm(), bias);
  const auto green = detail::lerp(a.green_norm(), b.green_norm(), bias);
  const auto blue = detail::lerp(a.blue_norm(), b.blue_norm(), bias);
  const auto alpha = detail::lerp(a.alpha_norm(), b.alpha_norm(), bias);

  return color::from_norm(red, green, blue, alpha);
}

/// \copydoc blend()
/// \deprecated Since 6.2.0, use the overload using a `float` bias parameter instead.
[[nodiscard, deprecated]] inline auto blend(const color& a,
                                            const color& b,
                                            const double bias = 0.5) -> color
{
  return blend(a, b, static_cast<float>(bias));
}

/// \name Color comparison operators
/// \{

/**
 * \brief Indicates whether or not the two colors are equal.
 *
 * \param lhs the left-hand side color.
 * \param rhs the right-hand side color.
 *
 * \return `true` if the colors are equal; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const color& lhs, const color& rhs) noexcept -> bool
{
  return (lhs.red() == rhs.red()) && (lhs.green() == rhs.green()) &&
         (lhs.blue() == rhs.blue()) && (lhs.alpha() == rhs.alpha());
}

/// \copydoc operator==(const color&, const color&)
[[nodiscard]] constexpr auto operator==(const color& lhs, const SDL_Color& rhs) noexcept
    -> bool
{
  return (lhs.red() == rhs.r) && (lhs.green() == rhs.g) && (lhs.blue() == rhs.b) &&
         (lhs.alpha() == rhs.a);
}

/// \copydoc operator==(const color&, const color&)
[[nodiscard]] constexpr auto operator==(const SDL_Color& lhs, const color& rhs) noexcept
    -> bool
{
  return rhs == lhs;
}

/**
 * \copybrief operator==(const color&, const color&)
 *
 * \note The alpha components are not taken into account.
 *
 * \param lhs the left-hand side color.
 * \param rhs the right-hand side color.
 *
 * \return `true` if the colors are equal; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const color& lhs,
                                        const SDL_MessageBoxColor& rhs) noexcept -> bool
{
  return (lhs.red() == rhs.r) && (lhs.green() == rhs.g) && (lhs.blue() == rhs.b);
}

/// \copydoc operator==(const color&, const SDL_MessageBoxColor&)
[[nodiscard]] constexpr auto operator==(const SDL_MessageBoxColor& lhs,
                                        const color& rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the two colors aren't equal.
 *
 * \param lhs the left-hand side color.
 * \param rhs the right-hand side color.
 *
 * \return `true` if the colors aren't equal; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator!=(const color& lhs, const color& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const color&, const color&)
[[nodiscard]] constexpr auto operator!=(const color& lhs, const SDL_Color& rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const color&, const color&)
[[nodiscard]] constexpr auto operator!=(const SDL_Color& lhs, const color& rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/**
 * \copybrief operator!=(const color&, const color&)
 *
 * \note The alpha components are not taken into account.
 *
 * \param lhs the left-hand side color.
 * \param rhs the right-hand side color.
 *
 * \return `true` if the colors aren't equal; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator!=(const color& lhs,
                                        const SDL_MessageBoxColor& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const color&, const SDL_MessageBoxColor&)
[[nodiscard]] constexpr auto operator!=(const SDL_MessageBoxColor& lhs,
                                        const color& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of color comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_COLOR_HEADER

// #include "centurion/video/colors.hpp"
#ifndef CENTURION_COLORS_HEADER
#define CENTURION_COLORS_HEADER

// #include "color.hpp"
#ifndef CENTURION_COLOR_HEADER
#define CENTURION_COLOR_HEADER

#include <SDL.h>

#include <cassert>      // assert
#include <cmath>        // round, abs, fmod, lerp
#include <iomanip>      // setfill, setw
#include <ios>          // uppercase, hex
#include <optional>     // optional
#include <ostream>      // ostream
#include <sstream>      // stringstream
#include <string>       // string, to_string
#include <string_view>  // string_view

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../compiler/compiler.hpp"

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../detail/clamp.hpp"

// #include "../detail/from_string.hpp"

// #include "../detail/lerp.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \class color
 *
 * \brief An 8-bit accuracy RGBA color.
 *
 * \serializable
 *
 * \details This class is designed to interact with the SDL colors, i.e. `SDL_Color` and
 * `SDL_MessageBoxColor`. For convenience, there are approximately 140 color constants
 * provided in the `colors` namespace,
 *
 * \since 3.0.0
 */
class color final
{
 public:
  /// \name Construction
  /// \{

  /**
   * \brief Creates a color. The created color will be equal to #000000FF.
   *
   * \since 3.0.0
   */
  constexpr color() noexcept = default;

  /**
   * \brief Creates a color.
   *
   * \param red the red component value, in the range [0, 255].
   * \param green the green component value, in the range [0, 255].
   * \param blue the blue component value, in the range [0, 255].
   * \param alpha the alpha component value, in the rage [0, 255]. Defaults to 255.
   *
   * \since 3.0.0
   */
  constexpr color(const u8 red, const u8 green, const u8 blue, const u8 alpha = max()) noexcept
      : m_color{red, green, blue, alpha}
  {}

  /**
   * \brief Creates a color that is a copy of the supplied `SDL_Color`.
   *
   * \param color the `SDL_Color` that will be copied.
   *
   * \since 3.0.0
   */
  constexpr explicit color(const SDL_Color& color) noexcept : m_color{color}
  {}

  /**
   * \brief Creates a color that is a copy of the supplied SDL_MessageBoxColor.
   *
   * \details Message box colors don't have an alpha component so the created color will
   * feature an alpha value of 255.
   *
   * \param color the message box color that will be copied.
   *
   * \since 3.0.0
   */
  constexpr explicit color(const SDL_MessageBoxColor& color) noexcept
      : m_color{color.r, color.g, color.b, max()}
  {}

  /**
   * \brief Creates a color from HSV-encoded values.
   *
   * \note The values will be clamped to be within their respective ranges.
   *
   * \param hue the hue of the color, in the range [0, 360].
   * \param saturation the saturation of the color, in the range [0, 100].
   * \param value the value of the color, in the range [0, 100].
   *
   * \return an RGBA color converted from the HSV values.
   *
   * \since 5.3.0
   */
  [[nodiscard]] static auto from_hsv(float hue, float saturation, float value) -> color
  {
    hue = detail::clamp(hue, 0.0f, 360.0f);
    saturation = detail::clamp(saturation, 0.0f, 100.0f);
    value = detail::clamp(value, 0.0f, 100.0f);

    const auto v = (value / 100.0f);
    const auto chroma = v * (saturation / 100.0f);
    const auto hp = hue / 60.0f;

    const auto x = chroma * (1.0f - std::abs(std::fmod(hp, 2.0f) - 1.0f));

    float red{};
    float green{};
    float blue{};

    if (0 <= hp && hp <= 1) {
      red = chroma;
      green = x;
      blue = 0;
    }
    else if (1 < hp && hp <= 2) {
      red = x;
      green = chroma;
      blue = 0;
    }
    else if (2 < hp && hp <= 3) {
      red = 0;
      green = chroma;
      blue = x;
    }
    else if (3 < hp && hp <= 4) {
      red = 0;
      green = x;
      blue = chroma;
    }
    else if (4 < hp && hp <= 5) {
      red = x;
      green = 0;
      blue = chroma;
    }
    else if (5 < hp && hp <= 6) {
      red = chroma;
      green = 0;
      blue = x;
    }

    const auto m = v - chroma;

    const auto r = static_cast<u8>(std::round((red + m) * 255.0f));
    const auto g = static_cast<u8>(std::round((green + m) * 255.0f));
    const auto b = static_cast<u8>(std::round((blue + m) * 255.0f));

    return color{r, g, b};
  }

  /**
   * \brief Creates a color from HSL-encoded values.
   *
   * \note The values will be clamped to be within their respective ranges.
   *
   * \param hue the hue of the color, in the range [0, 360].
   * \param saturation the saturation of the color, in the range [0, 100].
   * \param lightness the lightness of the color, in the range [0, 100].
   *
   * \return an RGBA color converted from the HSL values.
   *
   * \since 5.3.0
   */
  [[nodiscard]] static auto from_hsl(float hue, float saturation, float lightness) -> color
  {
    hue = detail::clamp(hue, 0.0f, 360.0f);
    saturation = detail::clamp(saturation, 0.0f, 100.0f);
    lightness = detail::clamp(lightness, 0.0f, 100.0f);

    const auto s = saturation / 100.0f;
    const auto l = lightness / 100.0f;

    const auto chroma = (1.0f - std::abs(2.0f * l - 1.0f)) * s;
    const auto hp = hue / 60.0f;

    const auto x = chroma * (1.0f - std::abs(std::fmod(hp, 2.0f) - 1.0f));

    float red{};
    float green{};
    float blue{};

    if (0 <= hp && hp < 1) {
      red = chroma;
      green = x;
      blue = 0;
    }
    else if (1 <= hp && hp < 2) {
      red = x;
      green = chroma;
      blue = 0;
    }
    else if (2 <= hp && hp < 3) {
      red = 0;
      green = chroma;
      blue = x;
    }
    else if (3 <= hp && hp < 4) {
      red = 0;
      green = x;
      blue = chroma;
    }
    else if (4 <= hp && hp < 5) {
      red = x;
      green = 0;
      blue = chroma;
    }
    else if (5 <= hp && hp < 6) {
      red = chroma;
      green = 0;
      blue = x;
    }

    const auto m = l - (chroma / 2.0f);

    const auto r = static_cast<u8>(std::round((red + m) * 255.0f));
    const auto g = static_cast<u8>(std::round((green + m) * 255.0f));
    const auto b = static_cast<u8>(std::round((blue + m) * 255.0f));

    return color{r, g, b};
  }

  /**
   * \brief Creates a color from a hexadecimal RGB color string.
   *
   * \details The supplied string must feature a leading '#' character, and be 7
   * characters long.
   *
   * \param rgb the hexadecimal RGB color string, using the format "#RRGGBB".
   *
   * \return a corresponding color; `std::nullopt` if something goes wrong.
   *
   * \see `from_rgba()`
   * \see `from_argb()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] static auto from_rgb(const std::string_view rgb) -> std::optional<color>
  {
    if (rgb.length() != 7 || rgb.at(0) != '#') {
      return std::nullopt;
    }

    const auto noHash = rgb.substr(1);

    const auto rr = noHash.substr(0, 2);
    const auto gg = noHash.substr(2, 2);
    const auto bb = noHash.substr(4, 2);

    const auto red = detail::from_string<u8>(rr, 16);
    const auto green = detail::from_string<u8>(gg, 16);
    const auto blue = detail::from_string<u8>(bb, 16);

    if (red && green && blue) {
      return cen::color{*red, *green, *blue};
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Creates a color from a hexadecimal RGBA color string.
   *
   * \details The supplied string must feature a leading '#' character, and be 9
   * characters long.
   *
   * \param rgba the hexadecimal RGBA color string, using the format "#RRGGBBAA".
   *
   * \return a corresponding color; `std::nullopt` if something goes wrong.
   *
   * \see `from_rgb()`
   * \see `from_argb()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] static auto from_rgba(const std::string_view rgba) -> std::optional<color>
  {
    if (rgba.length() != 9 || rgba.at(0) != '#') {
      return std::nullopt;
    }

    const auto noHash = rgba.substr(1);

    const auto rr = noHash.substr(0, 2);
    const auto gg = noHash.substr(2, 2);
    const auto bb = noHash.substr(4, 2);
    const auto aa = noHash.substr(6, 2);

    const auto red = detail::from_string<u8>(rr, 16);
    const auto green = detail::from_string<u8>(gg, 16);
    const auto blue = detail::from_string<u8>(bb, 16);
    const auto alpha = detail::from_string<u8>(aa, 16);

    if (red && green && blue && alpha) {
      return cen::color{*red, *green, *blue, *alpha};
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Creates a color from a hexadecimal ARGB color string.
   *
   * \details The supplied string must feature a leading '#' character, and be 9
   * characters long.
   *
   * \param argb the hexadecimal ARGB color string, using the format "#AARRGGBB".
   *
   * \return a corresponding color; `std::nullopt` if something goes wrong.
   *
   * \see `from_rgb()`
   * \see `from_rgba()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] static auto from_argb(const std::string_view argb) -> std::optional<color>
  {
    if (argb.length() != 9 || argb.at(0) != '#') {
      return std::nullopt;
    }

    const auto noHash = argb.substr(1);

    const auto aa = noHash.substr(0, 2);
    const auto rr = noHash.substr(2, 2);
    const auto gg = noHash.substr(4, 2);
    const auto bb = noHash.substr(6, 2);

    const auto alpha = detail::from_string<u8>(aa, 16);
    const auto red = detail::from_string<u8>(rr, 16);
    const auto green = detail::from_string<u8>(gg, 16);
    const auto blue = detail::from_string<u8>(bb, 16);

    if (alpha && red && green && blue) {
      return cen::color{*red, *green, *blue, *alpha};
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Creates a color from normalized color component values.
   *
   * \note The color components will be clamped to the range [0, 1].
   *
   * \param red the red component value, in the range [0, 1].
   * \param green the green component value, in the range [0, 1].
   * \param blue the blue component value, in the range [0, 1].
   * \param alpha the alpha component value, in the range [0, 1].
   *
   * \return a color with the supplied color components.
   *
   * \since 6.1.0
   */
  [[nodiscard]] static auto from_norm(float red,
                                      float green,
                                      float blue,
                                      float alpha = 1.0f) noexcept(on_msvc()) -> color
  {
    red = detail::clamp(red, 0.0f, 1.0f);
    green = detail::clamp(green, 0.0f, 1.0f);
    blue = detail::clamp(blue, 0.0f, 1.0f);
    alpha = detail::clamp(alpha, 0.0f, 1.0f);

    const auto r = static_cast<u8>(std::round(red * 255.0f));
    const auto g = static_cast<u8>(std::round(green * 255.0f));
    const auto b = static_cast<u8>(std::round(blue * 255.0f));
    const auto a = static_cast<u8>(std::round(alpha * 255.0f));

    return color{r, g, b, a};
  }

  /// \} End of construction

  /// \name Setters
  /// \{

  /**
   * \brief Sets the value of the red component.
   *
   * \param red the new value of the red component.
   *
   * \since 3.0.0
   */
  constexpr void set_red(const u8 red) noexcept
  {
    m_color.r = red;
  }

  /**
   * \brief Sets the value of the green component.
   *
   * \param green the new value of the green component.
   *
   * \since 3.0.0
   */
  constexpr void set_green(const u8 green) noexcept
  {
    m_color.g = green;
  }

  /**
   * \brief Sets the value of the blue component.
   *
   * \param blue the new value of the blue component.
   *
   * \since 3.0.0
   */
  constexpr void set_blue(const u8 blue) noexcept
  {
    m_color.b = blue;
  }

  /**
   * \brief Sets the value of the alpha component.
   *
   * \param alpha the new value of the alpha component.
   *
   * \since 3.0.0
   */
  constexpr void set_alpha(const u8 alpha) noexcept
  {
    m_color.a = alpha;
  }

  /// \} End of setters

  /// \name Getters
  /// \{

  /**
   * \brief Returns the value of the red component.
   *
   * \return the value of the red component, in the range [0, 255].
   *
   * \since 3.0.0
   */
  [[nodiscard]] constexpr auto red() const noexcept -> u8
  {
    return m_color.r;
  }

  /**
   * \brief Returns the value of the green component.
   *
   * \return the value of the green component, in the range [0, 255].
   *
   * \since 3.0.0
   */
  [[nodiscard]] constexpr auto green() const noexcept -> u8
  {
    return m_color.g;
  }

  /**
   * \brief Returns the value of the blue component.
   *
   * \return the value of the blue component, in the range [0, 255].
   *
   * \since 3.0.0
   */
  [[nodiscard]] constexpr auto blue() const noexcept -> u8
  {
    return m_color.b;
  }

  /**
   * \brief Returns the value of the alpha component.
   *
   * \return the value of the alpha component, in the range [0, 255].
   *
   * \since 3.0.0
   */
  [[nodiscard]] constexpr auto alpha() const noexcept -> u8
  {
    return m_color.a;
  }

  /**
   * \brief Returns the normalized red component of the color.
   *
   * \return the red component value, in the range [0, 1].
   *
   * \since 6.1.0
   */
  [[nodiscard]] constexpr auto red_norm() const noexcept -> float
  {
    return static_cast<float>(m_color.r) / 255.0f;
  }

  /**
   * \brief Returns the normalized green component of the color.
   *
   * \return the green component value, in the range [0, 1].
   *
   * \since 6.1.0
   */
  [[nodiscard]] constexpr auto green_norm() const noexcept -> float
  {
    return static_cast<float>(m_color.g) / 255.0f;
  }

  /**
   * \brief Returns the normalized blue component of the color.
   *
   * \return the blue component value, in the range [0, 1].
   *
   * \since 6.1.0
   */
  [[nodiscard]] constexpr auto blue_norm() const noexcept -> float
  {
    return static_cast<float>(m_color.b) / 255.0f;
  }

  /**
   * \brief Returns the normalized alpha component of the color.
   *
   * \return the alpha component value, in the range [0, 1].
   *
   * \since 6.1.0
   */
  [[nodiscard]] constexpr auto alpha_norm() const noexcept -> float
  {
    return static_cast<float>(m_color.a) / 255.0f;
  }

  /**
   * \brief Returns a pointer to the internal SDL color.
   *
   * \warning Do not cache the returned pointer!
   *
   * \return a pointer to the internal color instance.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto data() noexcept -> SDL_Color*
  {
    return &m_color;
  }

  /// \copydoc data()
  [[nodiscard]] auto data() const noexcept -> const SDL_Color*
  {
    return &m_color;
  }

  /**
   * \brief Returns the internal color instance.
   *
   * \return a reference to the internal color.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get() const noexcept -> const SDL_Color&
  {
    return m_color;
  }

  /// \} End of getters

  /// \name Color string conversions
  /// \{

  /**
   * \brief Returns a hexadecimal RGB color string that represents the color.
   *
   * \details The returned string is guaranteed to use uppercase hexadecimal digits (A-F).
   *
   * \return a hexadecimal color string representation, on the format "#RRGGBB".
   *
   * \see `as_rgba()`
   * \see `as_argb()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto as_rgb() const -> std::string
  {
    std::stringstream stream;
    stream << std::setfill('0') << std::hex << std::uppercase;

    stream << '#';
    stream << std::setw(2) << +m_color.r;
    stream << std::setw(2) << +m_color.g;
    stream << std::setw(2) << +m_color.b;

    return stream.str();
  }

  /**
   * \brief Returns a hexadecimal RGBA color string that represents the color.
   *
   * \details The returned string is guaranteed to use uppercase hexadecimal digits (A-F).
   *
   * \return a hexadecimal color string representation, on the format "#RRGGBBAA".
   *
   * \see `as_rgb()`
   * \see `as_argb()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto as_rgba() const -> std::string
  {
    std::stringstream stream;
    stream << std::setfill('0') << std::hex << std::uppercase;

    stream << '#';
    stream << std::setw(2) << +m_color.r;
    stream << std::setw(2) << +m_color.g;
    stream << std::setw(2) << +m_color.b;
    stream << std::setw(2) << +m_color.a;

    return stream.str();
  }

  /**
   * \brief Returns a hexadecimal ARGB color string that represents the color.
   *
   * \details The returned string is guaranteed to use uppercase hexadecimal digits (A-F).
   *
   * \return a hexadecimal color string representation, on the format "#AARRGGBB".
   *
   * \see `as_rgb()`
   * \see `as_rgba()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto as_argb() const -> std::string
  {
    std::stringstream stream;
    stream << std::setfill('0') << std::hex << std::uppercase;

    stream << '#';
    stream << std::setw(2) << +m_color.a;
    stream << std::setw(2) << +m_color.r;
    stream << std::setw(2) << +m_color.g;
    stream << std::setw(2) << +m_color.b;

    return stream.str();
  }

  /// \} End of color string conversions

  /// \name Conversions
  /// \{

  /**
   * \brief Converts the the color into an `SDL_Color`.
   *
   * \return an `SDL_Color` that is equivalent to this color.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit constexpr operator SDL_Color() const noexcept
  {
    return {red(), green(), blue(), alpha()};
  }

  /**
   * \brief Converts the the color into an `SDL_MessageBoxColor`.
   *
   * \note Message box colors don't feature an alpha value!
   *
   * \return an `SDL_MessageBoxColor` that is equivalent to this color.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit constexpr operator SDL_MessageBoxColor() const noexcept
  {
    return {red(), green(), blue()};
  }

  /**
   * \brief Converts the color to `SDL_Color*`.
   *
   * \warning The returned pointer is not to be freed or stored away!
   *
   * \return a pointer to the internal color instance.
   *
   * \since 4.0,0
   */
  [[nodiscard]] explicit operator SDL_Color*() noexcept
  {
    return &m_color;
  }

  /**
   * \brief Converts the color to `const SDL_Color*`.
   *
   * \warning The returned pointer is not to be freed or stored away!
   *
   * \return a pointer to the internal color instance.
   *
   * \since 4.0,0
   */
  [[nodiscard]] explicit operator const SDL_Color*() const noexcept
  {
    return &m_color;
  }

  /// \} End of conversions

  /**
   * \brief Serializes the color.
   *
   * \details This function expects that the archive provides an overloaded `operator()`,
   * used for serializing data. This API is based on the Cereal serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the color.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_color.r, m_color.g, m_color.b, m_color.a);
  }

  /**
   * \brief Returns a copy of the color with the specified alpha value.
   *
   * \param alpha the alpha component value that will be used by the new color.
   *
   * \return a color that is identical to the color except for the alpha component.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto with_alpha(const u8 alpha) const noexcept -> color
  {
    return {red(), green(), blue(), alpha};
  }

  /**
   * \brief Returns the maximum possible value of a color component.
   *
   * \return the maximum possible value of a color component.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr static auto max() noexcept -> u8
  {
    return 0xFF;
  }

 private:
  SDL_Color m_color{0, 0, 0, max()};
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of the color.
 *
 * \param color the color that will be converted.
 *
 * \return a textual representation of the color.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto to_string(const color& color) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("color{{r: {}, g: {}, b: {}: a: {}}}",
                     +color.red(),
                     +color.green(),
                     +color.blue(),
                     +color.alpha());
#else
  return "color{r: " + std::to_string(color.red()) + ", g: " + std::to_string(color.green()) +
         ", b: " + std::to_string(color.blue()) + ", a: " + std::to_string(color.alpha()) +
         "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a color.
 *
 * \param stream the stream that will be used.
 * \param color the color that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
inline auto operator<<(std::ostream& stream, const color& color) -> std::ostream&
{
  return stream << to_string(color);
}

/// \} End of streaming

/**
 * \brief Blends two colors according to the specified bias.
 *
 * \pre `bias` should be in the range [0, 1].
 *
 * \details This function applies a linear interpolation for each color component to
 * obtain the blended color. The bias parameter is the "alpha" for the interpolation,
 * which determines how the input colors are blended. For example, a bias of 0 or 1 will
 * simply result in the first or second color being returned, respectively.
 * Subsequently, a bias of 0.5 will blend the two colors evenly.
 *
 * \param a the first color.
 * \param b the second color.
 * \param bias the bias that determines how the colors are blended, in the range [0, 1].
 *
 * \return a color obtained by blending the two supplied colors.
 *
 * \todo Default the bias to 0.5 when the `double` overload has been removed.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto blend(const color& a, const color& b, const float bias) -> color
{
  assert(bias >= 0);
  assert(bias <= 1.0f);

  const auto red = detail::lerp(a.red_norm(), b.red_norm(), bias);
  const auto green = detail::lerp(a.green_norm(), b.green_norm(), bias);
  const auto blue = detail::lerp(a.blue_norm(), b.blue_norm(), bias);
  const auto alpha = detail::lerp(a.alpha_norm(), b.alpha_norm(), bias);

  return color::from_norm(red, green, blue, alpha);
}

/// \copydoc blend()
/// \deprecated Since 6.2.0, use the overload using a `float` bias parameter instead.
[[nodiscard, deprecated]] inline auto blend(const color& a,
                                            const color& b,
                                            const double bias = 0.5) -> color
{
  return blend(a, b, static_cast<float>(bias));
}

/// \name Color comparison operators
/// \{

/**
 * \brief Indicates whether or not the two colors are equal.
 *
 * \param lhs the left-hand side color.
 * \param rhs the right-hand side color.
 *
 * \return `true` if the colors are equal; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const color& lhs, const color& rhs) noexcept -> bool
{
  return (lhs.red() == rhs.red()) && (lhs.green() == rhs.green()) &&
         (lhs.blue() == rhs.blue()) && (lhs.alpha() == rhs.alpha());
}

/// \copydoc operator==(const color&, const color&)
[[nodiscard]] constexpr auto operator==(const color& lhs, const SDL_Color& rhs) noexcept
    -> bool
{
  return (lhs.red() == rhs.r) && (lhs.green() == rhs.g) && (lhs.blue() == rhs.b) &&
         (lhs.alpha() == rhs.a);
}

/// \copydoc operator==(const color&, const color&)
[[nodiscard]] constexpr auto operator==(const SDL_Color& lhs, const color& rhs) noexcept
    -> bool
{
  return rhs == lhs;
}

/**
 * \copybrief operator==(const color&, const color&)
 *
 * \note The alpha components are not taken into account.
 *
 * \param lhs the left-hand side color.
 * \param rhs the right-hand side color.
 *
 * \return `true` if the colors are equal; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const color& lhs,
                                        const SDL_MessageBoxColor& rhs) noexcept -> bool
{
  return (lhs.red() == rhs.r) && (lhs.green() == rhs.g) && (lhs.blue() == rhs.b);
}

/// \copydoc operator==(const color&, const SDL_MessageBoxColor&)
[[nodiscard]] constexpr auto operator==(const SDL_MessageBoxColor& lhs,
                                        const color& rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the two colors aren't equal.
 *
 * \param lhs the left-hand side color.
 * \param rhs the right-hand side color.
 *
 * \return `true` if the colors aren't equal; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator!=(const color& lhs, const color& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const color&, const color&)
[[nodiscard]] constexpr auto operator!=(const color& lhs, const SDL_Color& rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const color&, const color&)
[[nodiscard]] constexpr auto operator!=(const SDL_Color& lhs, const color& rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/**
 * \copybrief operator!=(const color&, const color&)
 *
 * \note The alpha components are not taken into account.
 *
 * \param lhs the left-hand side color.
 * \param rhs the right-hand side color.
 *
 * \return `true` if the colors aren't equal; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator!=(const color& lhs,
                                        const SDL_MessageBoxColor& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const color&, const SDL_MessageBoxColor&)
[[nodiscard]] constexpr auto operator!=(const SDL_MessageBoxColor& lhs,
                                        const color& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of color comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_COLOR_HEADER


/**
 * \namespace cen::colors
 *
 * \brief Contains pre-defined `color` constants.
 *
 * \see cen::color
 */
namespace cen::colors {

/// \addtogroup video
/// \{

/**
 * \brief An invisible color. Hex: 000000.
 *
 * \since 3.0.0
 */
inline constexpr color transparent{0, 0, 0, 0};

/**
 * \brief Hex: FFFFFF.
 *
 * \since 3.0.0
 */
inline constexpr color white{0xFF, 0xFF, 0xFF};

/**
 * \brief Hex: 000000.
 *
 * \since 3.0.0
 */
inline constexpr color black{0, 0, 0};

/**
 * \brief Hex: F0F8FF.
 *
 * \since 3.0.0
 */
inline constexpr color alice_blue{0xF0, 0xF8, 0xFF};

/**
 * \brief Hex: FAEBD7.
 *
 * \since 3.0.0
 */
inline constexpr color antique_white{0xFA, 0xEB, 0xD7};

/**
 * \brief Hex: 00FFFF.
 *
 * \since 3.0.0
 */
inline constexpr color aqua{0, 0xFF, 0xFF};

/**
 * \brief Hex: 7FFFD4.
 *
 * \since 3.0.0
 */
inline constexpr color aquamarine{0x7F, 0xFF, 0xD4};

/**
 * \brief Hex: F0FFFF.
 *
 * \since 3.0.0
 */
inline constexpr color azure{0xF0, 0xFF, 0xFF};

/**
 * \brief Hex: F5F5DC.
 *
 * \since 3.0.0
 */
inline constexpr color beige{0xF5, 0xF5, 0xDC};

/**
 * \brief Hex: FFE4C4.
 *
 * \since 3.0.0
 */
inline constexpr color bisque{0xFF, 0xE4, 0xC4};

/**
 * \brief Hex: FFEBCD.
 *
 * \since 3.0.0
 */
inline constexpr color blanched_almond{0xFF, 0xEB, 0xCD};

/**
 * \brief Hex: 0000FF.
 *
 * \since 3.0.0
 */
inline constexpr color blue{0, 0, 0xFF};

/**
 * \brief Hex: 8A2BE2.
 *
 * \since 3.0.0
 */
inline constexpr color blue_violet{0x8A, 0x2B, 0xE2};

/**
 * \brief Hex: A52A2A.
 *
 * \since 3.0.0
 */
inline constexpr color brown{0xA5, 0x2A, 0x2A};

/**
 * \brief Hex: DEB887.
 *
 * \since 3.0.0
 */
inline constexpr color burly_wood{0xDE, 0xB8, 0x87};

/**
 * \brief Hex: 5F9EA0.
 *
 * \since 3.0.0
 */
inline constexpr color cadet_blue{0x5F, 0x9E, 0xA0};

/**
 * \brief Hex: 7FFF00.
 *
 * \since 3.0.0
 */
inline constexpr color chartreuse{0x7F, 0xFF, 0};

/**
 * \brief Hex: D2691E.
 *
 * \since 3.0.0
 */
inline constexpr color chocolate{0xD2, 0x69, 0x1E};

/**
 * \brief Hex: FF7F50.
 *
 * \since 3.0.0
 */
inline constexpr color coral{0xFF, 0x7F, 0x50};

/**
 * \brief Hex: 6495ED.
 *
 * \since 3.0.0
 */
inline constexpr color cornflower_blue{0x64, 0x95, 0xED};

/**
 * \brief Hex: FFF8DC.
 *
 * \since 3.0.0
 */
inline constexpr color cornsilk{0xFF, 0xF8, 0xDC};

/**
 * \brief Hex: DC143C.
 *
 * \since 3.0.0
 */
inline constexpr color crimson{0xDC, 0x14, 0x3C};

/**
 * \brief Hex: 00FFFF.
 *
 * \since 3.0.0
 */
inline constexpr color cyan{0, 0xFF, 0xFF};

/**
 * \brief Hex: 00008B.
 *
 * \since 3.0.0
 */
inline constexpr color dark_blue{0, 0, 0x8B};

/**
 * \brief Hex: 008B8B.
 *
 * \since 3.0.0
 */
inline constexpr color dark_cyan{0, 0x8B, 0x8B};

/**
 * \brief Hex: B8860B.
 *
 * \since 3.0.0
 */
inline constexpr color dark_golden_rod{0xB8, 0x86, 0x0B};

/**
 * \brief Hex: A9A9A9.
 *
 * \since 3.0.0
 */
inline constexpr color dark_gray{0xA9, 0xA9, 0xA9};

/**
 * \brief Hex: A9A9A9.
 *
 * \since 3.0.0
 */
inline constexpr color dark_grey{dark_gray};

/**
 * \brief Hex: 006400.
 *
 * \since 3.0.0
 */
inline constexpr color dark_green{0, 0x64, 0};

/**
 * \brief Hex: BDB76B.
 *
 * \since 3.0.0
 */
inline constexpr color dark_khaki{0xBD, 0xB7, 0x6B};

/**
 * \brief Hex: 8B008B.
 *
 * \since 3.0.0
 */
inline constexpr color dark_magenta{0x8B, 0, 0x8B};

/**
 * \brief Hex: 556B2F.
 *
 * \since 3.0.0
 */
inline constexpr color dark_olive_green{0x55, 0x6B, 0x2F};

/**
 * \brief Hex: FF8C00.
 *
 * \since 3.0.0
 */
inline constexpr color dark_orange{0xFF, 0x8C, 0};

/**
 * \brief Hex: 9932CC.
 *
 * \since 3.0.0
 */
inline constexpr color dark_orchid{0x99, 0x32, 0xCC};

/**
 * \brief Hex: 8B0000.
 *
 * \since 3.0.0
 */
inline constexpr color dark_red{0x8B, 0, 0};

/**
 * \brief Hex: E9967A.
 *
 * \since 3.0.0
 */
inline constexpr color dark_salmon{0xE9, 0x96, 0x7A};

/**
 * \brief Hex: 8FBC8F.
 *
 * \since 3.0.0
 */
inline constexpr color dark_sea_green{0x8F, 0xBC, 0x8F};

/**
 * \brief Hex: 483D8B.
 *
 * \since 3.0.0
 */
inline constexpr color dark_slate_blue{0x48, 0x3D, 0x8B};

/**
 * \brief Hex: 2F4F4F.
 *
 * \since 3.0.0
 */
inline constexpr color dark_slate_gray{0x2F, 0x4F, 0x4F};

/**
 * \brief Hex: 2F4F4F.
 *
 * \since 3.0.0
 */
inline constexpr color dark_slate_grey{dark_slate_gray};

/**
 * \brief Hex: 00CED1.
 *
 * \since 3.0.0
 */
inline constexpr color dark_turquoise{0, 0xCE, 0xD1};

/**
 * \brief Hex: 9400D3.
 *
 * \since 3.0.0
 */
inline constexpr color dark_violet{0x94, 0, 0xD3};

/**
 * \brief Hex: FF1493.
 *
 * \since 3.0.0
 */
inline constexpr color deep_pink{0xFF, 0x14, 0x93};

/**
 * \brief Hex: 00BFFF.
 *
 * \since 3.0.0
 */
inline constexpr color deep_sky_blue{0, 0xBF, 0xFF};

/**
 * \brief Hex: 696969.
 *
 * \since 3.0.0
 */
inline constexpr color dim_gray{0x69, 0x69, 0x69};

/**
 * \brief Hex: 696969.
 *
 * \since 3.0.0
 */
inline constexpr color dim_grey{dim_gray};

/**
 * \brief Hex: 1E90FF.
 *
 * \since 3.0.0
 */
inline constexpr color dodger_blue{0x1E, 0x90, 0xFF};

/**
 * \brief Hex: B22222.
 *
 * \since 3.0.0
 */
inline constexpr color fire_brick{0xB2, 0x22, 0x22};

/**
 * \brief Hex: FFFAF0.
 *
 * \since 3.0.0
 */
inline constexpr color floral_white{0xFF, 0xFA, 0xF0};

/**
 * \brief Hex: 228B22.
 *
 * \since 3.0.0
 */
inline constexpr color forest_green{0x22, 0x8B, 0x22};

/**
 * \brief Hex: FF00FF.
 *
 * \since 3.0.0
 */
inline constexpr color fuchsia{0xFF, 0, 0xFF};

/**
 * \brief Hex: DCDCDC.
 *
 * \since 3.0.0
 */
inline constexpr color gainsboro{0xDC, 0xDC, 0xDC};

/**
 * \brief Hex: F8F8FF.
 *
 * \since 3.0.0
 */
inline constexpr color ghost_white{0xF8, 0xF8, 0xFF};

/**
 * \brief Hex: FFD700.
 *
 * \since 3.0.0
 */
inline constexpr color gold{0xFF, 0xD7, 0};

/**
 * \brief Hex: DAA520.
 *
 * \since 3.0.0
 */
inline constexpr color golden_rod{0xDA, 0xA5, 0x20};

/**
 * \brief Hex: 808080.
 *
 * \since 3.0.0
 */
inline constexpr color gray{0x80, 0x80, 0x80};

/**
 * \brief Hex: 808080.
 *
 * \since 3.0.0
 */
inline constexpr color grey{gray};

/**
 * \brief Hex: 008000.
 *
 * \since 3.0.0
 */
inline constexpr color green{0, 0x80, 0};

/**
 * \brief Hex: ADFF2F.
 *
 * \since 3.0.0
 */
inline constexpr color green_yellow{0xAD, 0xFF, 0x2F};

/**
 * \brief Hex: F0FFF0.
 *
 * \since 3.0.0
 */
inline constexpr color honey_dew{0xF0, 0xFF, 0xF0};

/**
 * \brief Hex: FF69B4.
 *
 * \since 3.0.0
 */
inline constexpr color hot_pink{0xFF, 0x69, 0xB4};

/**
 * \brief Hex: CD5C5C.
 *
 * \since 3.0.0
 */
inline constexpr color indian_red{0xCD, 0x5C, 0x5C};

/**
 * \brief Hex: 4B0082.
 *
 * \since 3.0.0
 */
inline constexpr color indigo{0x4B, 0, 0x82};

/**
 * \brief Hex: FFFFF0.
 *
 * \since 3.0.0
 */
inline constexpr color ivory{0xFF, 0xFF, 0xF0};

/**
 * \brief Hex: F0E68C.
 *
 * \since 3.0.0
 */
inline constexpr color khaki{0xF0, 0xE6, 0x8C};

/**
 * \brief Hex: E6E6FA.
 *
 * \since 3.0.0
 */
inline constexpr color lavender{0xE6, 0xE6, 0xFA};

/**
 * \brief Hex: FFF0F5.
 *
 * \since 3.0.0
 */
inline constexpr color lavender_blush{0xFF, 0xF0, 0xF5};

/**
 * \brief Hex: 7CFC00.
 *
 * \since 3.0.0
 */
inline constexpr color lawn_green{0x7C, 0xFC, 0};

/**
 * \brief Hex: FFFACD.
 *
 * \since 3.0.0
 */
inline constexpr color lemon_chiffon{0xFF, 0xFA, 0xCD};

/**
 * \brief Hex: ADD8E6.
 *
 * \since 3.0.0
 */
inline constexpr color light_blue{0xAD, 0xD8, 0xE6};

/**
 * \brief Hex: F08080.
 *
 * \since 3.0.0
 */
inline constexpr color light_coral{0xF0, 0x80, 0x80};

/**
 * \brief Hex: E0FFFF.
 *
 * \since 3.0.0
 */
inline constexpr color light_cyan{0xE0, 0xFF, 0xFF};

/**
 * \brief Hex: FAFAD2.
 *
 * \since 3.0.0
 */
inline constexpr color light_golden_rod_yellow{0xFA, 0xFA, 0xD2};

/**
 * \brief Hex: D3D3D3.
 *
 * \since 3.0.0
 */
inline constexpr color light_gray{0xD3, 0xD3, 0xD3};

/**
 * \brief Hex: D3D3D3.
 *
 * \since 3.0.0
 */
inline constexpr color light_grey{light_gray};

/**
 * \brief Hex: 90EE90.
 *
 * \since 3.0.0
 */
inline constexpr color light_green{0x90, 0xEE, 0x90};

/**
 * \brief Hex: FFB6C1.
 *
 * \since 3.0.0
 */
inline constexpr color light_pink{0xFF, 0xB6, 0xC1};

/**
 * \brief Hex: FFA07A.
 *
 * \since 3.0.0
 */
inline constexpr color light_salmon{0xFF, 0xA0, 0x7A};

/**
 * \brief Hex: 20B2AA.
 *
 * \since 3.0.0
 */
inline constexpr color light_sea_green{0x20, 0xB2, 0xAA};

/**
 * \brief Hex: 87CEFA.
 *
 * \since 3.0.0
 */
inline constexpr color light_sky_blue{0x87, 0xCE, 0xFA};

/**
 * \brief Hex: 778899.
 *
 * \since 3.0.0
 */
inline constexpr color light_slate_gray{0x77, 0x88, 0x99};

/**
 * \brief Hex: 778899.
 *
 * \since 3.0.0
 */
inline constexpr color light_slate_grey{light_slate_gray};

/**
 * \brief Hex: B0C4DE.
 *
 * \since 3.0.0
 */
inline constexpr color light_steel_blue{0xB0, 0xC4, 0xDE};

/**
 * \brief Hex: FFFFE0.
 *
 * \since 3.0.0
 */
inline constexpr color light_yellow{0xFF, 0xFF, 0xE0};

/**
 * \brief Hex: 00FF00.
 *
 * \since 3.0.0
 */
inline constexpr color lime{0, 0xFF, 0};

/**
 * \brief Hex: 32CD32.
 *
 * \since 3.0.0
 */
inline constexpr color lime_green{0x32, 0xCD, 0x32};

/**
 * \brief Hex: FAF0E6.
 *
 * \since 3.0.0
 */
inline constexpr color linen{0xFA, 0xF0, 0xE6};

/**
 * \brief Hex: FF00FF.
 *
 * \since 3.0.0
 */
inline constexpr color magenta{0xFF, 0, 0xFF};

/**
 * \brief Hex: 800000.
 *
 * \since 3.0.0
 */
inline constexpr color maroon{0x80, 0, 0};

/**
 * \brief Hex: 66CDAA.
 *
 * \since 3.0.0
 */
inline constexpr color medium_aqua_marine{0x66, 0xCD, 0xAA};

/**
 * \brief Hex: 0000CD.
 *
 * \since 3.0.0
 */
inline constexpr color medium_blue{0, 0, 0xCD};

/**
 * \brief Hex: BA55D3.
 *
 * \since 3.0.0
 */
inline constexpr color medium_orchid{0xBA, 0x55, 0xD3};

/**
 * \brief Hex: 9370DB.
 *
 * \since 3.0.0
 */
inline constexpr color medium_purple{0x93, 0x70, 0xDB};

/**
 * \brief Hex: 3CB371.
 *
 * \since 3.0.0
 */
inline constexpr color medium_sea_green{0x3C, 0xB3, 0x71};

/**
 * \brief Hex: 7B68EE.
 *
 * \since 3.0.0
 */
inline constexpr color medium_slate_blue{0x7B, 0x68, 0xEE};

/**
 * \brief Hex: 00FA9A.
 *
 * \since 3.0.0
 */
inline constexpr color medium_spring_green{0, 0xFA, 0x9A};

/**
 * \brief Hex: 48D1CC.
 *
 * \since 3.0.0
 */
inline constexpr color medium_turquoise{0x48, 0xD1, 0xCC};

/**
 * \brief Hex: C71585.
 *
 * \since 3.0.0
 */
inline constexpr color medium_violet_red{0xC7, 0x15, 0x85};

/**
 * \brief Hex: 191970.
 *
 * \since 3.0.0
 */
inline constexpr color midnight_blue{0x19, 0x19, 0x70};

/**
 * \brief Hex: F5FFFA.
 *
 * \since 3.0.0
 */
inline constexpr color mint_cream{0xF5, 0xFF, 0xFA};

/**
 * \brief Hex: FFE4E1.
 *
 * \since 3.0.0
 */
inline constexpr color misty_rose{0xFF, 0xE4, 0xE1};

/**
 * \brief Hex: FFE4B5.
 *
 * \since 3.0.0
 */
inline constexpr color moccasin{0xFF, 0xE4, 0xB5};

/**
 * \brief Hex: FFDEAD.
 *
 * \since 3.0.0
 */
inline constexpr color navajo_white{0xFF, 0xDE, 0xAD};

/**
 * \brief Hex: 000080.
 *
 * \since 3.0.0
 */
inline constexpr color navy{0, 0, 0x80};

/**
 * \brief Hex: FDF5E6.
 *
 * \since 3.0.0
 */
inline constexpr color old_lace{0xFD, 0xF5, 0xE6};

/**
 * \brief Hex: 808000.
 *
 * \since 3.0.0
 */
inline constexpr color olive{0x80, 0x80, 0};

/**
 * \brief Hex: 6B8E23.
 *
 * \since 3.0.0
 */
inline constexpr color olive_drab{0x6B, 0x8E, 0x23};

/**
 * \brief Hex: FFA500.
 *
 * \since 3.0.0
 */
inline constexpr color orange{0xFF, 0xA5, 0};

/**
 * \brief Hex: FF4500.
 *
 * \since 3.0.0
 */
inline constexpr color orange_red{0xFF, 0x45, 0};

/**
 * \brief Hex: DA70D6.
 *
 * \since 3.0.0
 */
inline constexpr color orchid{0xDA, 0x70, 0xD6};

/**
 * \brief Hex: EEE8AA.
 *
 * \since 3.0.0
 */
inline constexpr color pale_golden_rod{0xEE, 0xE8, 0xAA};

/**
 * \brief Hex: 98FB98.
 *
 * \since 3.0.0
 */
inline constexpr color pale_green{0x98, 0xFB, 0x98};

/**
 * \brief Hex: AFEEEE.
 *
 * \since 3.0.0
 */
inline constexpr color pale_turquoise{0xAF, 0xEE, 0xEE};

/**
 * \brief Hex: DB7093.
 *
 * \since 3.0.0
 */
inline constexpr color pale_violet_red{0xDB, 0x70, 0x93};

/**
 * \brief Hex: FFEFD5.
 *
 * \since 3.0.0
 */
inline constexpr color papaya_whip{0xFF, 0xEF, 0xD5};

/**
 * \brief Hex: FFDAB9.
 *
 * \since 3.0.0
 */
inline constexpr color peach_puff{0xFF, 0xDA, 0xB9};

/**
 * \brief Hex: CD853F.
 *
 * \since 3.0.0
 */
inline constexpr color peru{0xCD, 0x85, 0x3F};

/**
 * \brief Hex: FFC0CB.
 *
 * \since 3.0.0
 */
inline constexpr color pink{0xFF, 0xC0, 0xCB};

/**
 * \brief Hex: DDA0DD.
 *
 * \since 3.0.0
 */
inline constexpr color plum{0xDD, 0xA0, 0xDD};

/**
 * \brief Hex: B0E0E6.
 *
 * \since 3.0.0
 */
inline constexpr color powder_blue{0xB0, 0xE0, 0xE6};

/**
 * \brief Hex: 800080.
 *
 * \since 3.0.0
 */
inline constexpr color purple{0x80, 0, 0x80};

/**
 * \brief Hex: 663399.
 *
 * \since 3.0.0
 */
inline constexpr color rebecca_purple{0x66, 0x33, 0x99};

/**
 * \brief Hex: FF0000.
 *
 * \since 3.0.0
 */
inline constexpr color red{0xFF, 0, 0};

/**
 * \brief Hex: BC8F8F.
 *
 * \since 3.0.0
 */
inline constexpr color rosy_brown{0xBC, 0x8F, 0x8F};

/**
 * \brief Hex: 4169E1.
 *
 * \since 3.0.0
 */
inline constexpr color royal_blue{0x41, 0x69, 0xE1};

/**
 * \brief Hex: 8B4513.
 *
 * \since 3.0.0
 */
inline constexpr color saddle_brown{0x8B, 0x45, 0x13};

/**
 * \brief Hex: FA8072.
 *
 * \since 3.0.0
 */
inline constexpr color salmon{0xFA, 0x80, 0x72};

/**
 * \brief Hex: F4A460.
 *
 * \since 3.0.0
 */
inline constexpr color sandy_brown{0xF4, 0xA4, 0x60};

/**
 * \brief Hex: 2E8B57.
 *
 * \since 3.0.0
 */
inline constexpr color sea_green{0x2E, 0x8B, 0x57};

/**
 * \brief Hex: FFF5EE.
 *
 * \since 3.0.0
 */
inline constexpr color sea_shell{0xFF, 0xF5, 0xEE};

/**
 * \brief Hex: A0522D.
 *
 * \since 3.0.0
 */
inline constexpr color sienna{0xA0, 0x52, 0x2D};

/**
 * \brief Hex: C0C0C0.
 *
 * \since 3.0.0
 */
inline constexpr color silver{0xC0, 0xC0, 0xC0};

/**
 * \brief Hex: 87CEEB.
 *
 * \since 3.0.0
 */
inline constexpr color sky_blue{0x87, 0xCE, 0xEB};

/**
 * \brief Hex: 6A5ACD.
 *
 * \since 3.0.0
 */
inline constexpr color slate_blue{0x6A, 0x5A, 0xCD};

/**
 * \brief Hex: 708090.
 *
 * \since 3.0.0
 */
inline constexpr color slate_gray{0x70, 0x80, 0x90};

/**
 * \brief Hex: 708090.
 *
 * \since 3.0.0
 */
inline constexpr color slate_grey{slate_gray};

/**
 * \brief Hex: FFFAFA.
 *
 * \since 3.0.0
 */
inline constexpr color snow{0xFF, 0xFA, 0xFA};

/**
 * \brief Hex: 00FF7F.
 *
 * \since 3.0.0
 */
inline constexpr color spring_green{0, 0xFF, 0x7F};

/**
 * \brief Hex: 4682B4.
 *
 * \since 3.0.0
 */
inline constexpr color steel_blue{0x46, 0x82, 0xB4};

/**
 * \brief Hex: D2B48C.
 *
 * \since 3.0.0
 */
inline constexpr color tan{0xD2, 0xB4, 0x8C};

/**
 * \brief Hex: 008080.
 *
 * \since 3.0.0
 */
inline constexpr color teal{0, 0x80, 0x80};

/**
 * \brief Hex: D8BFD8.
 *
 * \since 3.0.0
 */
inline constexpr color thistle{0xD8, 0xBF, 0xD8};

/**
 * \brief Hex: FF6347.
 *
 * \since 3.0.0
 */
inline constexpr color tomato{0xFF, 0x63, 0x47};

/**
 * \brief Hex: 40E0D0.
 *
 * \since 3.0.0
 */
inline constexpr color turquoise{0x40, 0xE0, 0xD0};

/**
 * \brief Hex: EE82EE.
 *
 * \since 3.0.0
 */
inline constexpr color violet{0xEE, 0x82, 0xEE};

/**
 * \brief Hex: F5DEB3.
 *
 * \since 3.0.0
 */
inline constexpr color wheat{0xF5, 0xDE, 0xB3};

/**
 * \brief Hex: F5F5F5.
 *
 * \since 3.0.0
 */
inline constexpr color white_smoke{0xF5, 0xF5, 0xF5};

/**
 * \brief Hex: FFFF00.
 *
 * \since 3.0.0
 */
inline constexpr color yellow{0xFF, 0xFF, 0};

/**
 * \brief Hex: 9ACD32.
 *
 * \since 3.0.0
 */
inline constexpr color yellow_green{0x9A, 0xCD, 0x32};

/// \} End of group video

}  // namespace cen::colors

#endif  // CENTURION_COLORS_HEADER

// #include "centurion/video/cursor.hpp"
#ifndef CENTURION_CURSOR_HEADER
#define CENTURION_CURSOR_HEADER

#include <SDL.h>

// #include "../detail/owner_handle_api.hpp"
#ifndef CENTURION_DETAIL_OWNER_HANDLE_API_HEADER
#define CENTURION_DETAIL_OWNER_HANDLE_API_HEADER

#include <cassert>      // assert
#include <memory>       // unique_ptr
#include <type_traits>  // enable_if_t, is_same_v, true_type, false_type

// #include "../core/exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER


/// \cond FALSE
namespace cen::detail {

using owning_type = std::true_type;
using handle_type = std::false_type;

template <typename T>
using is_owner = std::enable_if_t<std::is_same_v<T, owning_type>, int>;

template <typename T>
using is_handle = std::enable_if_t<std::is_same_v<T, handle_type>, int>;

template <typename T>
[[nodiscard]] constexpr auto is_owning() noexcept -> bool
{
  return std::is_same_v<T, owning_type>;
}

template <typename B, typename Type, typename Deleter>
class pointer_manager final
{
  using managed_ptr = std::unique_ptr<Type, Deleter>;
  using raw_ptr = Type*;
  using pointer_type = std::conditional_t<B::value, managed_ptr, raw_ptr>;

 public:
  pointer_manager() noexcept = default;

  explicit pointer_manager(Type* ptr) noexcept : m_ptr{ptr}
  {}

  template <typename BB = B, is_owner<BB> = 0>
  void reset(Type* ptr) noexcept
  {
    m_ptr.reset(ptr);
  }

  auto operator->() noexcept -> Type*
  {
    return get();
  }

  auto operator->() const noexcept -> const Type*
  {
    return get();
  }

  auto operator*() noexcept -> Type&
  {
    assert(m_ptr);
    return *m_ptr;
  }

  auto operator*() const noexcept -> const Type&
  {
    assert(m_ptr);
    return *m_ptr;
  }

  explicit operator bool() const noexcept
  {
    return m_ptr != nullptr;
  }

  /*implicit*/ operator Type*() const noexcept
  {
    return get();
  }

  template <typename BB = B, is_owner<BB> = 0>
  [[nodiscard]] auto release() noexcept -> Type*
  {
    return m_ptr.release();
  }

  [[nodiscard]] auto get() const noexcept -> Type*
  {
    if constexpr (B::value) {
      return m_ptr.get();
    }
    else {
      return m_ptr;
    }
  }

 private:
  pointer_type m_ptr{};
};

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_OWNER_HANDLE_API_HEADER

// #include "../math/point.hpp"
#ifndef CENTURION_POINT_HEADER
#define CENTURION_POINT_HEADER

#include <SDL.h>

#include <cmath>        // sqrt, abs, round
#include <ostream>      // ostream
#include <string>       // string, to_string
#include <type_traits>  // conditional_t, is_integral_v, is_floating_point_v, ...

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/cast.hpp"
#ifndef CENTURION_CAST_HEADER
#define CENTURION_CAST_HEADER

namespace cen {

/**
 * \brief Casts a value to a value of another type.
 *
 * \ingroup core
 *
 * \details This is the default implementation, which simply attempts to use
 * `static_cast`. The idea is that this function will be specialized for various Centurion
 * and SDL types. This is useful because it isn't always possible to implement conversion
 * operators as members.
 *
 * \tparam To the type of the value that will be converted.
 * \tparam From the type that the value will be casted to.
 *
 * \param from the value that will be converted.
 *
 * \return the result of casting the supplied value to the specified type.
 *
 * \since 5.0.0
 */
template <typename To, typename From>
[[nodiscard]] constexpr auto cast(const From& from) noexcept -> To
{
  return static_cast<To>(from);
}

}  // namespace cen

#endif  // CENTURION_CAST_HEADER

// #include "../core/sfinae.hpp"
#ifndef CENTURION_SFINAE_HEADER
#define CENTURION_SFINAE_HEADER

#include <type_traits>  // enable_if_t, is_same_v, is_integral_v, is_floating_point_v, ...

namespace cen {

/// \addtogroup core
/// \{

// clang-format off

/// Enables a template if the type is either integral of floating-point, but not a boolean.
template <typename T>
using enable_if_number_t = std::enable_if_t<!std::is_same_v<T, bool> &&
                                            (std::is_integral_v<T> ||
                                             std::is_floating_point_v<T>), int>;

// clang-format on

/// Enables a template if the type is a pointer.
template <typename T>
using enable_if_pointer_v = std::enable_if_t<std::is_pointer_v<T>, int>;

/// Enables a template if T is convertible to any of the specified types.
template <typename T, typename... Args>
using enable_if_convertible_t = std::enable_if_t<(std::is_convertible_v<T, Args> || ...), int>;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_SFINAE_HEADER


namespace cen {

/// \addtogroup math
/// \{

/**
 * \brief Provides traits used by the `basic_point` class.
 *
 * \tparam T the representation type. Must be convertible to `int` or `float`.
 *
 * \since 5.0.0
 *
 * \see `basic_point`
 * \see `ipoint`
 * \see `fpoint`
 */
template <typename T, enable_if_convertible_t<T, int, float> = 0>
class point_traits final
{
 public:
  /**
   * \var isIntegral
   *
   * \brief Indicates whether or not the point is based on an integral type.
   *
   * \since 5.0.0
   */
  inline constexpr static bool isIntegral = std::is_integral_v<T>;

  /**
   * \var isFloating
   *
   * \brief Indicates whether or not the point is based on a floating-point
   * type.
   *
   * \since 5.0.0
   */
  inline constexpr static bool isFloating = std::is_floating_point_v<T>;

  /**
   * \typedef value_type
   *
   * \brief The actual representation type, i.e. `int` or `float`.
   *
   * \since 5.0.0
   */
  using value_type = std::conditional_t<isIntegral, int, float>;

  /**
   * \typedef point_type
   *
   * \brief The SDL point type, i.e. `SDL_Point` or `SDL_FPoint`.
   *
   * \since 5.0.0
   */
  using point_type = std::conditional_t<isIntegral, SDL_Point, SDL_FPoint>;
};

template <typename T>
class basic_point;

/**
 * \typedef ipoint
 *
 * \brief Alias for an `int`-based point.
 *
 * \details This type corresponds to `SDL_Point`.
 *
 * \since 5.0.0
 */
using ipoint = basic_point<int>;

/**
 * \typedef fpoint
 *
 * \brief Alias for a `float`-based point.
 *
 * \details This type corresponds to `SDL_FPoint`.
 *
 * \since 5.0.0
 */
using fpoint = basic_point<float>;

/**
 * \class basic_point
 *
 * \brief Represents a two-dimensional point.
 *
 * \serializable
 *
 * \details This class is designed as a wrapper for `SDL_Point` and `SDL_FPoint`. The
 * representation is specified by the type parameter.
 *
 * \note This point class will only use `int` or `float` as the actual internal
 * representation.
 *
 * \tparam T the representation type. Must be convertible to `int` or `float`.
 *
 * \since 5.0.0
 *
 * \see `ipoint`
 * \see `fpoint`
 * \see `point()`
 * \see `distance()`
 */
template <typename T>
class basic_point final
{
 public:
  /// \copydoc point_traits::isIntegral
  inline constexpr static bool isIntegral = point_traits<T>::isIntegral;

  /// \copydoc point_traits::isFloating
  inline constexpr static bool isFloating = point_traits<T>::isFloating;

  /// \copydoc point_traits::value_type
  using value_type = typename point_traits<T>::value_type;

  /// \copydoc point_traits::point_type
  using point_type = typename point_traits<T>::point_type;

  /// \name Construction
  /// \{

  /**
   * \brief Creates a zero-initialized point.
   *
   * \since 5.0.0
   */
  constexpr basic_point() noexcept = default;

  /**
   * \brief Creates a point with the specified coordinates.
   *
   * \param x the x-coordinate that will be used.
   * \param y the y-coordinate that will be used.
   *
   * \since 5.0.0
   */
  constexpr basic_point(const value_type x, const value_type y) noexcept
  {
    m_point.x = x;
    m_point.y = y;
  };

  /// \} End of construction

  /// \name Setters
  /// \{

  /**
   * \brief Sets the x-coordinate of the point.
   *
   * \param x the new x-coordinate.
   *
   * \since 5.0.0
   */
  constexpr void set_x(const value_type x) noexcept
  {
    m_point.x = x;
  }

  /**
   * \brief Sets the y-coordinate of the point.
   *
   * \param y the new y-coordinate.
   *
   * \since 5.0.0
   */
  constexpr void set_y(const value_type y) noexcept
  {
    m_point.y = y;
  }

  /// \} End of setters

  /// \name Getters
  /// \{

  /**
   * \brief Returns the x-coordinate of the point.
   *
   * \return the x-coordinate.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto x() const noexcept -> value_type
  {
    return m_point.x;
  }

  /**
   * \brief Returns the y-coordinate of the point.
   *
   * \return the y-coordinate.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto y() const noexcept -> value_type
  {
    return m_point.y;
  }

  /**
   * \brief Returns the internal point representation.
   *
   * \return a reference to the internal representation.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto get() noexcept -> point_type&
  {
    return m_point;
  }

  /// \copydoc get
  [[nodiscard]] constexpr auto get() const noexcept -> const point_type&
  {
    return m_point;
  }

  /**
   * \brief Returns a pointer to the internal point representation.
   *
   * \note Don't cache the returned pointer.
   *
   * \return a pointer to the point representation.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto data() noexcept -> point_type*
  {
    return &m_point;
  }

  /// \copydoc data
  [[nodiscard]] auto data() const noexcept -> const point_type*
  {
    return &m_point;
  }

  /// \} End of getters

  /// \name Conversions
  /// \{

  /**
   * \brief Converts to the internal representation.
   *
   * \return a copy of the internal point.
   *
   * \see `cen::cast`
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr explicit operator point_type() const noexcept
  {
    return m_point;
  }

  /// \copydoc data()
  [[nodiscard]] explicit operator point_type*() noexcept
  {
    return data();
  }

  /// \copydoc data()
  [[nodiscard]] explicit operator const point_type*() const noexcept
  {
    return data();
  }

  /// \} End of conversions

  /**
   * \brief Serializes the point.
   *
   * \details This function expects that the archive provides an overloaded `operator()`,
   * used for serializing data. This API is based on the Cereal serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the point.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_point.x, m_point.y);
  }

 private:
  point_type m_point{0, 0};
};

/// \name Point-related functions
/// \{

/**
 * \brief Creates a point instance with automatically deduced precision.
 *
 * \note The only supported precisions for points are `int` and `float`, so this function
 * will cast the supplied values to the corresponding type. For example, if you supply two
 * doubles to this function, the returned point will use float as the precision.
 *
 * \tparam T the deduced precision type, must be a numerical type other than `bool`.
 *
 * \param x the x-coordinate of the point.
 * \param y the y-coordinate of the point.
 *
 * \return the created point.
 *
 * \since 6.0.0
 */
template <typename T, enable_if_number_t<T> = 0>
[[nodiscard]] constexpr auto point(const T x, const T y) noexcept
    -> basic_point<typename point_traits<T>::value_type>
{
  using value_type = typename point_traits<T>::value_type;
  return basic_point<value_type>{static_cast<value_type>(x), static_cast<value_type>(y)};
}

/**
 * \brief Returns the distance between two points.
 *
 * \tparam T the representation type used by the points.
 *
 * \param from the first point.
 * \param to the second point.
 *
 * \return the distance between the two points.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto distance(const basic_point<T> from, const basic_point<T> to) noexcept ->
    typename point_traits<T>::value_type
{
  if constexpr (basic_point<T>::isIntegral) {
    const auto xDiff = std::pow(from.x() - to.x(), 2);
    const auto yDiff = std::pow(from.y() - to.y(), 2);
    const auto dist = std::sqrt(xDiff + yDiff);
    return static_cast<int>(std::round(dist));
  }
  else {
    return std::sqrt(std::pow(from.x() - to.x(), 2) + std::pow(from.y() - to.y(), 2));
  }
}

/// \} End of point-related functions

/// \name String conversions
/// \{

[[nodiscard]] inline auto to_string(const ipoint point) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("ipoint{{x: {}, y: {}}}", point.x(), point.y());
#else
  return "ipoint{x: " + std::to_string(point.x()) + ", y: " + std::to_string(point.y()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

[[nodiscard]] inline auto to_string(const fpoint point) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("fpoint{{x: {}, y: {}}}", point.x(), point.y());
#else
  return "fpoint{x: " + std::to_string(point.x()) + ", y: " + std::to_string(point.y()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

template <typename T>
auto operator<<(std::ostream& stream, const basic_point<T>& point) -> std::ostream&
{
  return stream << to_string(point);
}

/// \} End of streaming

/// \name Point cast specializations
/// \{

/**
 * \brief Converts an `fpoint` instance to the corresponding `ipoint`.
 *
 * \details This function casts the coordinates of the supplied point to `int`, and uses
 * the obtained values to create an `ipoint` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `ipoint` instance that corresponds to the supplied `fpoint`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const fpoint& from) noexcept -> ipoint
{
  const auto x = static_cast<int>(from.x());
  const auto y = static_cast<int>(from.y());
  return ipoint{x, y};
}

/**
 * \brief Converts an `ipoint` instance to the corresponding `fpoint`.
 *
 * \details This function casts the coordinates of the supplied point to `float`, and uses
 * the obtained values to create an `fpoint` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `fpoint` instance that corresponds to the supplied `ipoint`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const ipoint& from) noexcept -> fpoint
{
  const auto x = static_cast<float>(from.x());
  const auto y = static_cast<float>(from.y());
  return fpoint{x, y};
}

/**
 * \brief Converts an `SDL_FPoint` instance to the corresponding `SDL_Point`.
 *
 * \details This function casts the coordinates of the supplied point to `int`, and uses
 * the obtained values to create an `SDL_Point` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `SDL_Point` instance that corresponds to the supplied `SDL_FPoint`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const SDL_FPoint& from) noexcept -> SDL_Point
{
  const auto x = static_cast<int>(from.x);
  const auto y = static_cast<int>(from.y);
  return SDL_Point{x, y};
}

/**
 * \brief Converts an `SDL_Point` instance to the corresponding `SDL_FPoint`.
 *
 * \details This function casts the coordinates of the supplied point to `float`, and uses
 * the obtained values to create an `SDL_FPoint` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `SDL_FPoint` instance that corresponds to the supplied `SDL_Point`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const SDL_Point& from) noexcept -> SDL_FPoint
{
  const auto x = static_cast<float>(from.x);
  const auto y = static_cast<float>(from.y);
  return SDL_FPoint{x, y};
}

/// \} End of point cast specializations

/// \name Point addition and subtraction operators
/// \{

template <typename T>
[[nodiscard]] constexpr auto operator+(const basic_point<T>& lhs,
                                       const basic_point<T>& rhs) noexcept -> basic_point<T>
{
  return {lhs.x() + rhs.x(), lhs.y() + rhs.y()};
}

template <typename T>
[[nodiscard]] constexpr auto operator-(const basic_point<T>& lhs,
                                       const basic_point<T>& rhs) noexcept -> basic_point<T>
{
  return {lhs.x() - rhs.x(), lhs.y() - rhs.y()};
}

/// \} End of point addition and subtraction operators

/// \name Point comparison operators
/// \{

template <typename T>
[[nodiscard]] constexpr auto operator==(const basic_point<T> lhs,
                                        const basic_point<T> rhs) noexcept -> bool
{
  return (lhs.x() == rhs.x()) && (lhs.y() == rhs.y());
}

template <typename T>
[[nodiscard]] constexpr auto operator!=(const basic_point<T> lhs,
                                        const basic_point<T> rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of point comparison operators

/// \} End of group math

}  // namespace cen

#endif  // CENTURION_POINT_HEADER
// #include "surface.hpp"
#ifndef CENTURION_SURFACE_HEADER
#define CENTURION_SURFACE_HEADER

#include <SDL.h>

// #include "../compiler/features.hpp"


#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#include <cassert>  // assert
#include <ostream>  // ostream
#include <string>   // string, to_string

#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/not_null.hpp"
#ifndef CENTURION_NOT_NULL_HEADER
#define CENTURION_NOT_NULL_HEADER

// #include "sfinae.hpp"
#ifndef CENTURION_SFINAE_HEADER
#define CENTURION_SFINAE_HEADER

#include <type_traits>  // enable_if_t, is_same_v, is_integral_v, is_floating_point_v, ...

namespace cen {

/// \addtogroup core
/// \{

// clang-format off

/// Enables a template if the type is either integral of floating-point, but not a boolean.
template <typename T>
using enable_if_number_t = std::enable_if_t<!std::is_same_v<T, bool> &&
                                            (std::is_integral_v<T> ||
                                             std::is_floating_point_v<T>), int>;

// clang-format on

/// Enables a template if the type is a pointer.
template <typename T>
using enable_if_pointer_v = std::enable_if_t<std::is_pointer_v<T>, int>;

/// Enables a template if T is convertible to any of the specified types.
template <typename T, typename... Args>
using enable_if_convertible_t = std::enable_if_t<(std::is_convertible_v<T, Args> || ...), int>;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_SFINAE_HEADER


namespace cen {

/**
 * \typedef not_null
 *
 * \ingroup core
 *
 * \brief Tag used to indicate that a pointer cannot be null.
 *
 * \note This alias is equivalent to `T`, it is a no-op.
 *
 * \since 5.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using not_null = T;

}  // namespace cen

#endif  // CENTURION_NOT_NULL_HEADER

// #include "../core/owner.hpp"
#ifndef CENTURION_OWNER_HEADER
#define CENTURION_OWNER_HEADER

// #include "sfinae.hpp"


namespace cen {

/**
 * \typedef owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote ownership of raw pointers directly in code.
 *
 * \details If a function takes an `owner<T*>` as a parameter, then the function will
 * claim ownership of that pointer. Subsequently, if a function returns an `owner<T*>`,
 * then ownership is transferred to the caller.
 */
template <typename T, enable_if_pointer_v<T> = 0>
using owner = T;

/**
 * \typedef maybe_owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote conditional ownership of raw pointers directly in code.
 *
 * \details This is primarily used in constructors of owner/handle classes, where the
 * owner version will claim ownership of the pointer, whilst the handle does not.
 *
 * \since 6.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using maybe_owner = T;

}  // namespace cen

#endif  // CENTURION_OWNER_HEADER
// #include "../core/result.hpp"
#ifndef CENTURION_RESULT_HEADER
#define CENTURION_RESULT_HEADER

#include <ostream>  // ostream
#include <string>   // string

namespace cen {

/// \addtogroup core
/// \{

/**
 * \class result
 *
 * \brief A simple indicator for the result of different operations.
 *
 * \details The idea behind this class is to make results of various operations
 * unambiguous. Quite an amount of functions in the library may fail, and earlier versions
 * of Centurion would usually return a `bool` in those cases, where `true` and `false`
 * would indicate success and failure, respectively. This class is a development of that
 * practice. For instance, this class is contextually convertible to `bool`, where a
 * successful result is still converted to `true`, and vice versa. However, this class
 * also enables explicit checks against `success` and `failure` constants, which makes
 * code very easy to read and unambiguous.
 * \code{cpp}
 *   cen::window window;
 *
 *   if (window.set_opacity(0.4f))
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::success)
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::failure)
 *   {
 *     // Failure!
 *   }
 * \endcode
 *
 * \see `success`
 * \see `failure`
 *
 * \since 6.0.0
 */
class result final
{
 public:
  /**
   * \brief Creates a result.
   *
   * \param success `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  constexpr result(const bool success) noexcept  // NOLINT implicit
      : m_success{success}
  {}

  /// \name Comparison operators
  /// \{

  /**
   * \brief Indicates whether or not two results have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results are equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator==(const result other) const noexcept -> bool
  {
    return m_success == other.m_success;
  }

  /**
   * \brief Indicates whether or not two results don't have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results aren't equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator!=(const result other) const noexcept -> bool
  {
    return !(*this == other);
  }

  /// \} End of comparison operators

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not the result is successful.
   *
   * \return `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr explicit operator bool() const noexcept
  {
    return m_success;
  }

  /// \} End of conversions

 private:
  bool m_success{};
};

/// Represents a successful result.
/// \since 6.0.0
inline constexpr result success{true};

/// Represents a failure of some kind.
/// \since 6.0.0
inline constexpr result failure{false};

/// \name String conversions
/// \{

/**
 * \brief Returns a string that represents a result value.
 *
 * \note The returned string is in a slightly different format compared to other Centurion
 * components.
 *
 * \param result the value that will be converted.
 *
 * \return `"success"` for a successful result; `"failure"` otherwise.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto to_string(const result result) -> std::string
{
  return result ? "success" : "failure";
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a result value using a stream.
 *
 * \param stream the stream that will be used.
 * \param result the result value that will be printed.
 *
 * \return the used stream.
 *
 * \since 6.0.0
 */
inline auto operator<<(std::ostream& stream, const result result) -> std::ostream&
{
  return stream << to_string(result);
}

/// \} End of streaming

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_RESULT_HEADER

// #include "../core/str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER

// #include "../core/to_underlying.hpp"
#ifndef CENTURION_TO_UNDERLYING_HEADER
#define CENTURION_TO_UNDERLYING_HEADER

#include <type_traits>  // underlying_type_t, enable_if_t, is_enum_v

namespace cen {

/**
 * \brief Converts an enum value to an integral value using the underlying type.
 *
 * \ingroup core
 *
 * \note If you're using C++23, see `std::to_underlying()`.
 *
 * \tparam Enum the enum type.
 *
 * \param value the enum value that will be converted.
 *
 * \return the value of the enum, in the underlying type.
 *
 * \since 6.0.0
 */
template <typename Enum, std::enable_if_t<std::is_enum_v<Enum>, int> = 0>
[[nodiscard]] constexpr auto to_underlying(const Enum value) noexcept
    -> std::underlying_type_t<Enum>
{
  return static_cast<std::underlying_type_t<Enum>>(value);
}

}  // namespace cen

#endif  // CENTURION_TO_UNDERLYING_HEADER

// #include "../detail/address_of.hpp"
#ifndef CENTURION_DETAIL_ADDRESS_OF_HEADER
#define CENTURION_DETAIL_ADDRESS_OF_HEADER

#include <sstream>  // stringstream
#include <string>   // string

// #include "../compiler/compiler.hpp"


/// \cond FALSE
namespace cen::detail {

/**
 * \brief Returns a string that represents the memory address of the supplied pointer.
 *
 * \details The empty string is returned if the supplied pointer is null.
 *
 * \tparam T the type of the pointer.
 * \param ptr the pointer that will be converted.
 *
 * \return a string that represents the memory address of the supplied pointer.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto address_of(const void* ptr) -> std::string
{
  if (ptr) {
    std::stringstream stream;

    if constexpr (on_msvc()) {
      stream << "0x";  // Only MSVC seems to omit this, add it for consistency
    }

    stream << ptr;
    return stream.str();
  }
  else {
    return std::string{};
  }
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_ADDRESS_OF_HEADER

// #include "../detail/owner_handle_api.hpp"

// #include "../math/area.hpp"
#ifndef CENTURION_AREA_HEADER
#define CENTURION_AREA_HEADER

#include <ostream>      // ostream
#include <string>       // string, to_string
#include <type_traits>  // is_integral_v, is_floating_point_v, is_same_v

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/cast.hpp"


namespace cen {

/// \addtogroup math
/// \{

template <typename T>
struct basic_area;

/**
 * \typedef iarea
 *
 * \brief An alias for `int` areas.
 *
 * \since 4.1.0
 */
using iarea = basic_area<int>;

/**
 * \typedef farea
 *
 * \brief An alias for `float` areas.
 *
 * \since 4.1.0
 */
using farea = basic_area<float>;

/**
 * \typedef darea
 *
 * \brief An alias for `double` areas.
 *
 * \since 4.1.0
 */
using darea = basic_area<double>;

/**
 * \struct basic_area
 *
 * \brief Simply represents an area with a width and height.
 *
 * \serializable
 *
 * \tparam T the type of the components of the area. Must be either an integral or
 * floating-point type. Can't be `bool`.
 *
 * \since 4.0.0
 *
 * \see `iarea`
 * \see `farea`
 * \see `darea`
 */
template <typename T>
struct basic_area final
{
  static_assert(std::is_integral_v<T> || std::is_floating_point_v<T>);
  static_assert(!std::is_same_v<T, bool>);

  using value_type = T;

  T width{0};   ///< The width of the area.
  T height{0};  ///< The height of the area.

#if CENTURION_HAS_FEATURE_SPACESHIP

  [[nodiscard]] constexpr auto operator==(const basic_area&) const noexcept -> bool = default;

#endif  // CENTURION_HAS_FEATURE_SPACESHIP
};

/// \name Area-related functions
/// \{

/**
 * \brief Creates an area instance with automatically deduced precision.
 *
 * \tparam T the deduced type of the width and height values.
 *
 * \param width the width of the area.
 * \param height the height of the area.
 *
 * \return an area instance with the specified width and height.
 *
 * \since 6.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto area(const T width, const T height) noexcept -> basic_area<T>
{
  return {width, height};
}

/**
 * \brief Returns the size (width x height) of an area.
 *
 * \tparam T the representation type.
 *
 * \param area the area instance that will be calculated.
 *
 * \return the size of the area.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto area_of(const basic_area<T> area) noexcept -> T
{
  return area.width * area.height;
}

/// \} End of area-related functions

/**
 * \brief Serializes an area instance.
 *
 * \details This function expects that the archive provides an overloaded `operator()`,
 * used for serializing data. This API is based on the Cereal serialization library.
 *
 * \tparam Archive the type of the archive.
 * \tparam T the type of the area components.
 *
 * \param archive the archive used to serialize the area.
 * \param area the area that will be serialized.
 *
 * \since 5.3.0
 */
template <typename Archive, typename T>
void serialize(Archive& archive, basic_area<T>& area)
{
  archive(area.width, area.height);
}

/// \name Area cast specializations
/// \{

template <>
[[nodiscard]] constexpr auto cast(const iarea& from) noexcept -> darea
{
  return {static_cast<double>(from.width), static_cast<double>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const iarea& from) noexcept -> farea
{
  return {static_cast<float>(from.width), static_cast<float>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const farea& from) noexcept -> darea
{
  return {static_cast<double>(from.width), static_cast<double>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const farea& from) noexcept -> iarea
{
  return {static_cast<int>(from.width), static_cast<int>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const darea& from) noexcept -> farea
{
  return {static_cast<float>(from.width), static_cast<float>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const darea& from) noexcept -> iarea
{
  return {static_cast<int>(from.width), static_cast<int>(from.height)};
}

/// \} End of area cast specializations

/// \name Area comparison operators
/// \{

#if !CENTURION_HAS_FEATURE_SPACESHIP

/**
 * \brief Indicates whether or not two areas are considered to be equal.
 *
 * \param lhs the left-hand side area.
 * \param rhs the right-hand side area.
 *
 * \return `true` if the areas are equal; `false` otherwise.
 *
 * \since 4.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator==(const basic_area<T>& lhs,
                                        const basic_area<T>& rhs) noexcept -> bool
{
  return (lhs.width == rhs.width) && (lhs.height == rhs.height);
}

/**
 * \brief Indicates whether or not two areas aren't considered to be equal.
 *
 * \param lhs the left-hand side area.
 * \param rhs the right-hand side area.
 *
 * \return `true` if the areas aren't equal; `false` otherwise.
 *
 * \since 4.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator!=(const basic_area<T>& lhs,
                                        const basic_area<T>& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

#endif  // CENTURION_HAS_FEATURE_SPACESHIP

/// \} End of area comparison operators

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of an area.
 *
 * \tparam T the type of the area components.
 *
 * \param area the area that will be converted.
 *
 * \return a string that represents the area.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_area<T>& area) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("area{{width: {}, height: {}}}", area.width, area.height);
#else
  return "area{width: " + std::to_string(area.width) +
         ", height: " + std::to_string(area.height) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of an area using a stream.
 *
 * \tparam T the type of the area components.
 *
 * \param stream the stream that will be used.
 * \param area the are that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_area<T>& area) -> std::ostream&
{
  return stream << to_string(area);
}

/// \} End of streaming

/// \} End of group math

}  // namespace cen

#endif  // CENTURION_AREA_HEADER
// #include "../math/rect.hpp"
#ifndef CENTURION_RECTANGLE_HEADER
#define CENTURION_RECTANGLE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string>       // string, to_string
#include <type_traits>  // conditional_t, is_integral_v, is_floating_point_v, ...

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/cast.hpp"

// #include "../core/sfinae.hpp"

// #include "../detail/max.hpp"
#ifndef CENTURION_DETAIL_MAX_HEADER
#define CENTURION_DETAIL_MAX_HEADER

/// \cond FALSE
namespace cen::detail {

template <typename T>
[[nodiscard]] constexpr auto max(const T& a, const T& b) noexcept(noexcept(a < b)) -> T
{
  return (a < b) ? b : a;
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_MAX_HEADER

// #include "../detail/min.hpp"
#ifndef CENTURION_DETAIL_MIN_HEADER
#define CENTURION_DETAIL_MIN_HEADER

/// \cond FALSE
namespace cen::detail {

template <typename T>
[[nodiscard]] constexpr auto min(const T& a, const T& b) noexcept(noexcept(a < b)) -> T
{
  return (a < b) ? a : b;
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_MIN_HEADER

// #include "area.hpp"
#ifndef CENTURION_AREA_HEADER
#define CENTURION_AREA_HEADER

#include <ostream>      // ostream
#include <string>       // string, to_string
#include <type_traits>  // is_integral_v, is_floating_point_v, is_same_v

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/cast.hpp"


namespace cen {

/// \addtogroup math
/// \{

template <typename T>
struct basic_area;

/**
 * \typedef iarea
 *
 * \brief An alias for `int` areas.
 *
 * \since 4.1.0
 */
using iarea = basic_area<int>;

/**
 * \typedef farea
 *
 * \brief An alias for `float` areas.
 *
 * \since 4.1.0
 */
using farea = basic_area<float>;

/**
 * \typedef darea
 *
 * \brief An alias for `double` areas.
 *
 * \since 4.1.0
 */
using darea = basic_area<double>;

/**
 * \struct basic_area
 *
 * \brief Simply represents an area with a width and height.
 *
 * \serializable
 *
 * \tparam T the type of the components of the area. Must be either an integral or
 * floating-point type. Can't be `bool`.
 *
 * \since 4.0.0
 *
 * \see `iarea`
 * \see `farea`
 * \see `darea`
 */
template <typename T>
struct basic_area final
{
  static_assert(std::is_integral_v<T> || std::is_floating_point_v<T>);
  static_assert(!std::is_same_v<T, bool>);

  using value_type = T;

  T width{0};   ///< The width of the area.
  T height{0};  ///< The height of the area.

#if CENTURION_HAS_FEATURE_SPACESHIP

  [[nodiscard]] constexpr auto operator==(const basic_area&) const noexcept -> bool = default;

#endif  // CENTURION_HAS_FEATURE_SPACESHIP
};

/// \name Area-related functions
/// \{

/**
 * \brief Creates an area instance with automatically deduced precision.
 *
 * \tparam T the deduced type of the width and height values.
 *
 * \param width the width of the area.
 * \param height the height of the area.
 *
 * \return an area instance with the specified width and height.
 *
 * \since 6.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto area(const T width, const T height) noexcept -> basic_area<T>
{
  return {width, height};
}

/**
 * \brief Returns the size (width x height) of an area.
 *
 * \tparam T the representation type.
 *
 * \param area the area instance that will be calculated.
 *
 * \return the size of the area.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto area_of(const basic_area<T> area) noexcept -> T
{
  return area.width * area.height;
}

/// \} End of area-related functions

/**
 * \brief Serializes an area instance.
 *
 * \details This function expects that the archive provides an overloaded `operator()`,
 * used for serializing data. This API is based on the Cereal serialization library.
 *
 * \tparam Archive the type of the archive.
 * \tparam T the type of the area components.
 *
 * \param archive the archive used to serialize the area.
 * \param area the area that will be serialized.
 *
 * \since 5.3.0
 */
template <typename Archive, typename T>
void serialize(Archive& archive, basic_area<T>& area)
{
  archive(area.width, area.height);
}

/// \name Area cast specializations
/// \{

template <>
[[nodiscard]] constexpr auto cast(const iarea& from) noexcept -> darea
{
  return {static_cast<double>(from.width), static_cast<double>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const iarea& from) noexcept -> farea
{
  return {static_cast<float>(from.width), static_cast<float>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const farea& from) noexcept -> darea
{
  return {static_cast<double>(from.width), static_cast<double>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const farea& from) noexcept -> iarea
{
  return {static_cast<int>(from.width), static_cast<int>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const darea& from) noexcept -> farea
{
  return {static_cast<float>(from.width), static_cast<float>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const darea& from) noexcept -> iarea
{
  return {static_cast<int>(from.width), static_cast<int>(from.height)};
}

/// \} End of area cast specializations

/// \name Area comparison operators
/// \{

#if !CENTURION_HAS_FEATURE_SPACESHIP

/**
 * \brief Indicates whether or not two areas are considered to be equal.
 *
 * \param lhs the left-hand side area.
 * \param rhs the right-hand side area.
 *
 * \return `true` if the areas are equal; `false` otherwise.
 *
 * \since 4.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator==(const basic_area<T>& lhs,
                                        const basic_area<T>& rhs) noexcept -> bool
{
  return (lhs.width == rhs.width) && (lhs.height == rhs.height);
}

/**
 * \brief Indicates whether or not two areas aren't considered to be equal.
 *
 * \param lhs the left-hand side area.
 * \param rhs the right-hand side area.
 *
 * \return `true` if the areas aren't equal; `false` otherwise.
 *
 * \since 4.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator!=(const basic_area<T>& lhs,
                                        const basic_area<T>& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

#endif  // CENTURION_HAS_FEATURE_SPACESHIP

/// \} End of area comparison operators

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of an area.
 *
 * \tparam T the type of the area components.
 *
 * \param area the area that will be converted.
 *
 * \return a string that represents the area.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_area<T>& area) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("area{{width: {}, height: {}}}", area.width, area.height);
#else
  return "area{width: " + std::to_string(area.width) +
         ", height: " + std::to_string(area.height) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of an area using a stream.
 *
 * \tparam T the type of the area components.
 *
 * \param stream the stream that will be used.
 * \param area the are that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_area<T>& area) -> std::ostream&
{
  return stream << to_string(area);
}

/// \} End of streaming

/// \} End of group math

}  // namespace cen

#endif  // CENTURION_AREA_HEADER
// #include "point.hpp"
#ifndef CENTURION_POINT_HEADER
#define CENTURION_POINT_HEADER

#include <SDL.h>

#include <cmath>        // sqrt, abs, round
#include <ostream>      // ostream
#include <string>       // string, to_string
#include <type_traits>  // conditional_t, is_integral_v, is_floating_point_v, ...

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/cast.hpp"

// #include "../core/sfinae.hpp"


namespace cen {

/// \addtogroup math
/// \{

/**
 * \brief Provides traits used by the `basic_point` class.
 *
 * \tparam T the representation type. Must be convertible to `int` or `float`.
 *
 * \since 5.0.0
 *
 * \see `basic_point`
 * \see `ipoint`
 * \see `fpoint`
 */
template <typename T, enable_if_convertible_t<T, int, float> = 0>
class point_traits final
{
 public:
  /**
   * \var isIntegral
   *
   * \brief Indicates whether or not the point is based on an integral type.
   *
   * \since 5.0.0
   */
  inline constexpr static bool isIntegral = std::is_integral_v<T>;

  /**
   * \var isFloating
   *
   * \brief Indicates whether or not the point is based on a floating-point
   * type.
   *
   * \since 5.0.0
   */
  inline constexpr static bool isFloating = std::is_floating_point_v<T>;

  /**
   * \typedef value_type
   *
   * \brief The actual representation type, i.e. `int` or `float`.
   *
   * \since 5.0.0
   */
  using value_type = std::conditional_t<isIntegral, int, float>;

  /**
   * \typedef point_type
   *
   * \brief The SDL point type, i.e. `SDL_Point` or `SDL_FPoint`.
   *
   * \since 5.0.0
   */
  using point_type = std::conditional_t<isIntegral, SDL_Point, SDL_FPoint>;
};

template <typename T>
class basic_point;

/**
 * \typedef ipoint
 *
 * \brief Alias for an `int`-based point.
 *
 * \details This type corresponds to `SDL_Point`.
 *
 * \since 5.0.0
 */
using ipoint = basic_point<int>;

/**
 * \typedef fpoint
 *
 * \brief Alias for a `float`-based point.
 *
 * \details This type corresponds to `SDL_FPoint`.
 *
 * \since 5.0.0
 */
using fpoint = basic_point<float>;

/**
 * \class basic_point
 *
 * \brief Represents a two-dimensional point.
 *
 * \serializable
 *
 * \details This class is designed as a wrapper for `SDL_Point` and `SDL_FPoint`. The
 * representation is specified by the type parameter.
 *
 * \note This point class will only use `int` or `float` as the actual internal
 * representation.
 *
 * \tparam T the representation type. Must be convertible to `int` or `float`.
 *
 * \since 5.0.0
 *
 * \see `ipoint`
 * \see `fpoint`
 * \see `point()`
 * \see `distance()`
 */
template <typename T>
class basic_point final
{
 public:
  /// \copydoc point_traits::isIntegral
  inline constexpr static bool isIntegral = point_traits<T>::isIntegral;

  /// \copydoc point_traits::isFloating
  inline constexpr static bool isFloating = point_traits<T>::isFloating;

  /// \copydoc point_traits::value_type
  using value_type = typename point_traits<T>::value_type;

  /// \copydoc point_traits::point_type
  using point_type = typename point_traits<T>::point_type;

  /// \name Construction
  /// \{

  /**
   * \brief Creates a zero-initialized point.
   *
   * \since 5.0.0
   */
  constexpr basic_point() noexcept = default;

  /**
   * \brief Creates a point with the specified coordinates.
   *
   * \param x the x-coordinate that will be used.
   * \param y the y-coordinate that will be used.
   *
   * \since 5.0.0
   */
  constexpr basic_point(const value_type x, const value_type y) noexcept
  {
    m_point.x = x;
    m_point.y = y;
  };

  /// \} End of construction

  /// \name Setters
  /// \{

  /**
   * \brief Sets the x-coordinate of the point.
   *
   * \param x the new x-coordinate.
   *
   * \since 5.0.0
   */
  constexpr void set_x(const value_type x) noexcept
  {
    m_point.x = x;
  }

  /**
   * \brief Sets the y-coordinate of the point.
   *
   * \param y the new y-coordinate.
   *
   * \since 5.0.0
   */
  constexpr void set_y(const value_type y) noexcept
  {
    m_point.y = y;
  }

  /// \} End of setters

  /// \name Getters
  /// \{

  /**
   * \brief Returns the x-coordinate of the point.
   *
   * \return the x-coordinate.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto x() const noexcept -> value_type
  {
    return m_point.x;
  }

  /**
   * \brief Returns the y-coordinate of the point.
   *
   * \return the y-coordinate.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto y() const noexcept -> value_type
  {
    return m_point.y;
  }

  /**
   * \brief Returns the internal point representation.
   *
   * \return a reference to the internal representation.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto get() noexcept -> point_type&
  {
    return m_point;
  }

  /// \copydoc get
  [[nodiscard]] constexpr auto get() const noexcept -> const point_type&
  {
    return m_point;
  }

  /**
   * \brief Returns a pointer to the internal point representation.
   *
   * \note Don't cache the returned pointer.
   *
   * \return a pointer to the point representation.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto data() noexcept -> point_type*
  {
    return &m_point;
  }

  /// \copydoc data
  [[nodiscard]] auto data() const noexcept -> const point_type*
  {
    return &m_point;
  }

  /// \} End of getters

  /// \name Conversions
  /// \{

  /**
   * \brief Converts to the internal representation.
   *
   * \return a copy of the internal point.
   *
   * \see `cen::cast`
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr explicit operator point_type() const noexcept
  {
    return m_point;
  }

  /// \copydoc data()
  [[nodiscard]] explicit operator point_type*() noexcept
  {
    return data();
  }

  /// \copydoc data()
  [[nodiscard]] explicit operator const point_type*() const noexcept
  {
    return data();
  }

  /// \} End of conversions

  /**
   * \brief Serializes the point.
   *
   * \details This function expects that the archive provides an overloaded `operator()`,
   * used for serializing data. This API is based on the Cereal serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the point.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_point.x, m_point.y);
  }

 private:
  point_type m_point{0, 0};
};

/// \name Point-related functions
/// \{

/**
 * \brief Creates a point instance with automatically deduced precision.
 *
 * \note The only supported precisions for points are `int` and `float`, so this function
 * will cast the supplied values to the corresponding type. For example, if you supply two
 * doubles to this function, the returned point will use float as the precision.
 *
 * \tparam T the deduced precision type, must be a numerical type other than `bool`.
 *
 * \param x the x-coordinate of the point.
 * \param y the y-coordinate of the point.
 *
 * \return the created point.
 *
 * \since 6.0.0
 */
template <typename T, enable_if_number_t<T> = 0>
[[nodiscard]] constexpr auto point(const T x, const T y) noexcept
    -> basic_point<typename point_traits<T>::value_type>
{
  using value_type = typename point_traits<T>::value_type;
  return basic_point<value_type>{static_cast<value_type>(x), static_cast<value_type>(y)};
}

/**
 * \brief Returns the distance between two points.
 *
 * \tparam T the representation type used by the points.
 *
 * \param from the first point.
 * \param to the second point.
 *
 * \return the distance between the two points.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto distance(const basic_point<T> from, const basic_point<T> to) noexcept ->
    typename point_traits<T>::value_type
{
  if constexpr (basic_point<T>::isIntegral) {
    const auto xDiff = std::pow(from.x() - to.x(), 2);
    const auto yDiff = std::pow(from.y() - to.y(), 2);
    const auto dist = std::sqrt(xDiff + yDiff);
    return static_cast<int>(std::round(dist));
  }
  else {
    return std::sqrt(std::pow(from.x() - to.x(), 2) + std::pow(from.y() - to.y(), 2));
  }
}

/// \} End of point-related functions

/// \name String conversions
/// \{

[[nodiscard]] inline auto to_string(const ipoint point) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("ipoint{{x: {}, y: {}}}", point.x(), point.y());
#else
  return "ipoint{x: " + std::to_string(point.x()) + ", y: " + std::to_string(point.y()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

[[nodiscard]] inline auto to_string(const fpoint point) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("fpoint{{x: {}, y: {}}}", point.x(), point.y());
#else
  return "fpoint{x: " + std::to_string(point.x()) + ", y: " + std::to_string(point.y()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

template <typename T>
auto operator<<(std::ostream& stream, const basic_point<T>& point) -> std::ostream&
{
  return stream << to_string(point);
}

/// \} End of streaming

/// \name Point cast specializations
/// \{

/**
 * \brief Converts an `fpoint` instance to the corresponding `ipoint`.
 *
 * \details This function casts the coordinates of the supplied point to `int`, and uses
 * the obtained values to create an `ipoint` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `ipoint` instance that corresponds to the supplied `fpoint`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const fpoint& from) noexcept -> ipoint
{
  const auto x = static_cast<int>(from.x());
  const auto y = static_cast<int>(from.y());
  return ipoint{x, y};
}

/**
 * \brief Converts an `ipoint` instance to the corresponding `fpoint`.
 *
 * \details This function casts the coordinates of the supplied point to `float`, and uses
 * the obtained values to create an `fpoint` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `fpoint` instance that corresponds to the supplied `ipoint`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const ipoint& from) noexcept -> fpoint
{
  const auto x = static_cast<float>(from.x());
  const auto y = static_cast<float>(from.y());
  return fpoint{x, y};
}

/**
 * \brief Converts an `SDL_FPoint` instance to the corresponding `SDL_Point`.
 *
 * \details This function casts the coordinates of the supplied point to `int`, and uses
 * the obtained values to create an `SDL_Point` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `SDL_Point` instance that corresponds to the supplied `SDL_FPoint`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const SDL_FPoint& from) noexcept -> SDL_Point
{
  const auto x = static_cast<int>(from.x);
  const auto y = static_cast<int>(from.y);
  return SDL_Point{x, y};
}

/**
 * \brief Converts an `SDL_Point` instance to the corresponding `SDL_FPoint`.
 *
 * \details This function casts the coordinates of the supplied point to `float`, and uses
 * the obtained values to create an `SDL_FPoint` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `SDL_FPoint` instance that corresponds to the supplied `SDL_Point`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const SDL_Point& from) noexcept -> SDL_FPoint
{
  const auto x = static_cast<float>(from.x);
  const auto y = static_cast<float>(from.y);
  return SDL_FPoint{x, y};
}

/// \} End of point cast specializations

/// \name Point addition and subtraction operators
/// \{

template <typename T>
[[nodiscard]] constexpr auto operator+(const basic_point<T>& lhs,
                                       const basic_point<T>& rhs) noexcept -> basic_point<T>
{
  return {lhs.x() + rhs.x(), lhs.y() + rhs.y()};
}

template <typename T>
[[nodiscard]] constexpr auto operator-(const basic_point<T>& lhs,
                                       const basic_point<T>& rhs) noexcept -> basic_point<T>
{
  return {lhs.x() - rhs.x(), lhs.y() - rhs.y()};
}

/// \} End of point addition and subtraction operators

/// \name Point comparison operators
/// \{

template <typename T>
[[nodiscard]] constexpr auto operator==(const basic_point<T> lhs,
                                        const basic_point<T> rhs) noexcept -> bool
{
  return (lhs.x() == rhs.x()) && (lhs.y() == rhs.y());
}

template <typename T>
[[nodiscard]] constexpr auto operator!=(const basic_point<T> lhs,
                                        const basic_point<T> rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of point comparison operators

/// \} End of group math

}  // namespace cen

#endif  // CENTURION_POINT_HEADER

namespace cen {

/// \addtogroup math
/// \{

/**
 * \class rect_traits
 *
 * \brief Provides rectangle traits used by `basic_rect`.
 *
 * \note Whilst it is possible to supply a type that isn't `int` or `float`, rectangles
 * will always use one of them as the representation type.
 *
 * \tparam T the representation type, must be convertible to `int` or `float`.
 *
 * \see `basic_rect`
 * \see `irect`
 * \see `frect`
 *
 * \since 5.0.0
 */
template <typename T, enable_if_convertible_t<T, int, float> = 0>
class rect_traits final
{
 public:
  inline constexpr static bool isIntegral = std::is_integral_v<T>;
  inline constexpr static bool isFloating = std::is_floating_point_v<T>;

  using value_type = std::conditional_t<isIntegral, int, float>;
  using point_type = std::conditional_t<isIntegral, ipoint, fpoint>;
  using area_type = std::conditional_t<isIntegral, iarea, farea>;
  using rect_type = std::conditional_t<isIntegral, SDL_Rect, SDL_FRect>;
};

template <typename T>
class basic_rect;

/**
 * \typedef irect
 *
 * \brief Alias for an `int`-based rectangle.
 *
 * \since 5.0.0
 */
using irect = basic_rect<int>;

/**
 * \typedef frect
 *
 * \brief Alias for a `float`-based rectangle.
 *
 * \since 5.0.0
 */
using frect = basic_rect<float>;

/**
 * \class basic_rect
 *
 * \brief A simple rectangle implementation, based on either `SDL_Rect` or `SDL_FRect`.
 *
 * \serializable
 *
 * \tparam T the representation type. Must be convertible to either `int` or `float`.
 *
 * \see `irect`
 * \see `frect`
 * \see `rect()`
 * \see `intersects()`
 * \see `collides()`
 * \see `get_union()`
 *
 * \since 4.0.0
 */
template <typename T>
class basic_rect final
{
 public:
  /**
   * \brief Indicates whether or not the rectangle is based on an integral type.
   *
   * \since 5.0.0
   */
  inline constexpr static bool isIntegral = rect_traits<T>::isIntegral;

  /**
   * \brief Indicates whether or not the rectangle is based on a floating-point
   * type.
   *
   * \since 5.0.0
   */
  inline constexpr static bool isFloating = rect_traits<T>::isFloating;

  /**
   * \typedef value_type
   *
   * \brief The representation type, i.e. `int` or `float`.
   *
   * \since 5.0.0
   */
  using value_type = typename rect_traits<T>::value_type;

  /**
   * \typedef point_type
   *
   * \brief The point type used, i.e. `ipoint` or `fpoint`.
   *
   * \since 5.0.0
   */
  using point_type = typename rect_traits<T>::point_type;

  /**
   * \typedef area_type
   *
   * \brief The area type used, i.e. `iarea` or `farea`.
   *
   * \since 5.0.0
   */
  using area_type = typename rect_traits<T>::area_type;

  /**
   * \typedef rect_type
   *
   * \brief The underlying SDL rectangle type, i.e. `SDL_Rect` or `SDL_FRect`.
   *
   * \since 5.0.0
   */
  using rect_type = typename rect_traits<T>::rect_type;

  /// \name Construction
  /// \{

  /**
   * \brief Creates a rectangle with the components (0, 0, 0, 0).
   *
   * \since 4.0.0
   */
  constexpr basic_rect() noexcept = default;

  /**
   * \brief Creates a rectangle based on an SDL rectangle.
   *
   * \param rect the rectangle that will be copied.
   *
   * \since 5.3.0
   */
  constexpr explicit basic_rect(const rect_type& rect) noexcept : m_rect{rect}
  {}

  /**
   * \brief Creates a rectangle with the supplied position and size.
   *
   * \param position the position of the rectangle.
   * \param size the size of the rectangle.
   *
   * \since 4.1.0
   */
  constexpr basic_rect(const point_type& position, const area_type& size) noexcept
      : m_rect{position.x(), position.y(), size.width, size.height}
  {}

  /**
   * \brief Creates a rectangle with the supplied position and size.
   *
   * \param x the x-coordinate of the rectangle.
   * \param y the y-coordinate of the rectangle.
   * \param width the width of the rectangle.
   * \param height the height of the rectangle.
   *
   * \since 5.3.0
   */
  constexpr basic_rect(const value_type x,
                       const value_type y,
                       const value_type width,
                       const value_type height) noexcept
      : m_rect{x, y, width, height}
  {}

  /// \} End of construction

  /// \name Setters
  /// \{

  /**
   * \brief Sets the x-coordinate of the rectangle.
   *
   * \param x the new x-coordinate of the rectangle.
   *
   * \since 4.0.0
   */
  constexpr void set_x(const value_type x) noexcept
  {
    m_rect.x = x;
  }

  /**
   * \brief Sets the y-coordinate of the rectangle.
   *
   * \param y the new y-coordinate of the rectangle.
   *
   * \since 4.0.0
   */
  constexpr void set_y(const value_type y) noexcept
  {
    m_rect.y = y;
  }

  /**
   * \brief Sets the maximum x-coordinate of the rectangle.
   *
   * \note This function preserves the width of the rectangle.
   *
   * \param maxX the new maximum x-coordinate of the rectangle.
   *
   * \since 5.1.0
   */
  constexpr void set_max_x(const value_type maxX) noexcept
  {
    m_rect.x = maxX - m_rect.w;
  }

  /**
   * \brief Sets the maximum y-coordinate of the rectangle.
   *
   * \note This function preserves the height of the rectangle.
   *
   * \param maxY the new maximum y-coordinate of the rectangle.
   *
   * \since 5.1.0
   */
  constexpr void set_max_y(const value_type maxY) noexcept
  {
    m_rect.y = maxY - m_rect.h;
  }

  /**
   * \brief Offsets the x-coordinate of the rectangle by the specified amount.
   *
   * \details This function is effectively equivalent to calling `set_x()` with the sum of
   * `x()` and `offset`.
   *
   * \param offset the offset to the x-coordinate of the rectangle.
   *
   * \since 6.0.0
   */
  constexpr void offset_x(const value_type offset) noexcept
  {
    m_rect.x += offset;
  }

  /**
   * \brief Offsets the y-coordinate of the rectangle by the specified amount.
   *
   * \details This function is effectively equivalent to calling `set_y()` with the sum of
   * `y()` and `offset`.
   *
   * \param offset the offset to the y-coordinate of the rectangle.
   *
   * \since 6.0.0
   */
  constexpr void offset_y(const value_type offset) noexcept
  {
    m_rect.y += offset;
  }

  /**
   * \brief Tweaks the width of the rectangle by the specified amount.
   *
   * \details This function is effectively equivalent to calling `set_width()` with the
   * sum of `width()` and `offset`.
   *
   * \param offset the offset to the width of the rectangle.
   *
   * \since 6.0.0
   */
  constexpr void offset_width(const value_type offset) noexcept
  {
    m_rect.w += offset;
  }

  /**
   * \brief Tweaks the height of the rectangle by the specified amount.
   *
   * \details This function is effectively equivalent to calling `set_height()` with the
   * sum of `height()` and `offset`.
   *
   * \param offset the offset to the height of the rectangle.
   *
   * \since 6.0.0
   */
  constexpr void offset_height(const value_type offset) noexcept
  {
    m_rect.h += offset;
  }

  /**
   * \brief Sets the position of the rectangle.
   *
   * \note Some frameworks have this kind of function change the size of the rectangle.
   * However, this function does *not* change the size of the rectangle.
   *
   * \param pos the new position of the rectangle.
   *
   * \since 5.1.0
   */
  constexpr void set_position(const point_type& pos) noexcept
  {
    m_rect.x = pos.x();
    m_rect.y = pos.y();
  }

  /**
   * \brief Sets the width of the rectangle.
   *
   * \param width the new width of the rectangle.
   *
   * \since 4.0.0
   */
  constexpr void set_width(const value_type width) noexcept
  {
    m_rect.w = width;
  }

  /**
   * \brief Sets the height of the rectangle.
   *
   * \param height the new height of the rectangle.
   *
   * \since 4.0.0
   */
  constexpr void set_height(const value_type height) noexcept
  {
    m_rect.h = height;
  }

  /**
   * \brief Sets the size of the rectangle.
   *
   * \param size the new size of the rectangle.
   *
   * \since 5.1.0
   */
  constexpr void set_size(const area_type& size) noexcept
  {
    m_rect.w = size.width;
    m_rect.h = size.height;
  };

  /// \} End of setters

  /// \name Queries
  /// \{

  /**
   * \brief Returns the x-coordinate of the rectangle.
   *
   * \return the x-coordinate of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto x() const noexcept -> value_type
  {
    return m_rect.x;
  }

  /**
   * \brief Returns the y-coordinate of the rectangle.
   *
   * \return the y-coordinate of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto y() const noexcept -> value_type
  {
    return m_rect.y;
  }

  /**
   * \brief Returns the position of the rectangle.
   *
   * \return the position of the rectangle.
   *
   * \since 4.1.0
   */
  [[nodiscard]] constexpr auto position() const noexcept -> point_type
  {
    return point_type{m_rect.x, m_rect.y};
  }

  /**
   * \brief Returns the width of the rectangle.
   *
   * \return the width of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto width() const noexcept -> value_type
  {
    return m_rect.w;
  }

  /**
   * \brief Returns the height of the rectangle.
   *
   * \return the height of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto height() const noexcept -> value_type
  {
    return m_rect.h;
  }

  /**
   * \brief Returns the size of the rectangle.
   *
   * \return the size of the rectangle.
   *
   * \since 4.1.0
   */
  [[nodiscard]] constexpr auto size() const noexcept -> area_type
  {
    return area_type{m_rect.w, m_rect.h};
  }

  /**
   * \brief Returns the maximum x-coordinate of the rectangle.
   *
   * \return the maximum x-coordinate of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto max_x() const noexcept -> value_type
  {
    return x() + width();
  }

  /**
   * \brief Returns the maximum y-coordinate of the rectangle.
   *
   * \return the maximum y-coordinate of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto max_y() const noexcept -> value_type
  {
    return y() + height();
  }

  /**
   * \brief Returns the x-coordinate of the center point of the rectangle.
   *
   * \return the x-coordinate of the center point of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto center_x() const noexcept -> value_type
  {
    return x() + (width() / static_cast<value_type>(2));
  }

  /**
   * \brief Returns the y-coordinate of the center point of the rectangle.
   *
   * \return the y-coordinate of the center point of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto center_y() const noexcept -> value_type
  {
    return y() + (height() / static_cast<value_type>(2));
  }

  /**
   * \brief Returns the center point of the rectangle.
   *
   * \return the center point of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto center() const noexcept -> point_type
  {
    return {center_x(), center_y()};
  }

  /**
   * \brief Returns the total area of the rectangle.
   *
   * \return the area of the rectangle.
   *
   * \since 4.2.0
   */
  [[nodiscard]] constexpr auto area() const noexcept -> value_type
  {
    return width() * height();
  }

  /**
   * \brief Indicates whether or not the rectangle contains the point.
   *
   * \param point the point that will be checked.
   *
   * \return `true` if the rectangle contains the point; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto contains(const point_type& point) const noexcept -> bool
  {
    const auto px = point.x();
    const auto py = point.y();
    return !(px < x() || py < y() || px > max_x() || py > max_y());
  }

  /**
   * \brief Indicates whether or not the rectangle has an area.
   *
   * \details The rectangle has an area if both the width and height are
   * greater than zero.
   *
   * \return `true` if the rectangle has an area; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto has_area() const noexcept -> bool
  {
    return (width() > 0) && (height() > 0);
  }

  /**
   * \brief Returns a pointer to the internal rectangle representation.
   *
   * \note Don't cache the returned pointer.
   *
   * \return a pointer to the rectangle representation.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto data() noexcept -> rect_type*
  {
    return &m_rect;
  }

  /**
   * \copydoc data()
   */
  [[nodiscard]] auto data() const noexcept -> const rect_type*
  {
    return &m_rect;
  }

  /**
   * \brief Returns the internal rectangle.
   *
   * \return a reference to the internal rectangle.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto get() noexcept -> rect_type&
  {
    return m_rect;
  }

  /**
   * \brief Returns the internal rectangle.
   *
   * \return a reference to the internal rectangle.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto get() const noexcept -> const rect_type&
  {
    return m_rect;
  }

  /// \} End of queries

  /// \name Conversions
  /// \{

  /**
   * \brief Returns a pointer to the internal rectangle.
   *
   * \return a pointer to the internal rectangle.
   *
   * \since 5.0.0
   */
  [[nodiscard]] explicit operator rect_type*() noexcept
  {
    return &m_rect;
  }

  /**
   * \brief Returns a pointer to the internal rectangle.
   *
   * \return a pointer to the internal rectangle.
   *
   * \since 5.0.0
   */
  [[nodiscard]] explicit operator const rect_type*() const noexcept
  {
    return &m_rect;
  }

  /// \} End of conversions

  /**
   * \brief Serializes the rectangle.
   *
   * \details This function expects that the archive provides an overloaded `operator()`,
   * used for serializing data. This API is based on the Cereal serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the rectangle.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_rect.x, m_rect.y, m_rect.w, m_rect.h);
  }

 private:
  rect_type m_rect{0, 0, 0, 0};
};

/// \name Rectangle functions
/// \{

/**
 * \brief Creates a rectangle with automatically deduced precision.
 *
 * \note The only supported precisions for rectangles are `int` and `float`, so this
 * function will cast the supplied values to the corresponding type. For example, if you
 * supply doubles to this function, the returned point will use float as the precision.
 *
 * \tparam T the deduced precision type.
 *
 * \param x the x-coordinate of the rectangle.
 * \param y the y-coordinate of the rectangle.
 * \param width the width of the rectangle.
 * \param height the height of the rectangle.
 *
 * \return a rectangle with the specified position and size.
 *
 * \since 6.0.0
 */
template <typename T, enable_if_number_t<T> = 0>
[[nodiscard]] constexpr auto rect(const T x, const T y, const T width, const T height) noexcept
    -> basic_rect<typename rect_traits<T>::value_type>
{
  using value_type = typename rect_traits<T>::value_type;
  return basic_rect<value_type>{static_cast<value_type>(x),
                                static_cast<value_type>(y),
                                static_cast<value_type>(width),
                                static_cast<value_type>(height)};
}

/**
 * \brief Indicates whether or not the two rectangles intersect.
 *
 * \details This function does *not* consider rectangles with overlapping borders as
 * intersecting. If you want such behaviour, see the `collides` function.
 *
 * \tparam T the representation type used by the rectangles.
 *
 * \param fst the first rectangle.
 * \param snd the second rectangle.
 *
 * \return `true` if the rectangles intersect; `false` otherwise.
 *
 * \see `collides`
 *
 * \since 4.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto intersects(const basic_rect<T>& fst,
                                        const basic_rect<T>& snd) noexcept -> bool
{
  return !(fst.x() >= snd.max_x() || fst.max_x() <= snd.x() || fst.y() >= snd.max_y() ||
           fst.max_y() <= snd.y());
}

/**
 * \brief Indicates whether or not two rectangles are colliding.
 *
 * \details This function considers rectangles with overlapping borders as colliding.
 *
 * \tparam T the representation type used by the rectangles.
 *
 * \param fst the first rectangle.
 * \param snd the second rectangle.
 *
 * \return `true` if the rectangles collide; `false` otherwise.
 *
 * \see `intersects`
 *
 * \since 4.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto collides(const basic_rect<T>& fst,
                                      const basic_rect<T>& snd) noexcept -> bool
{
  return !(fst.x() > snd.max_x() || fst.max_x() < snd.x() || fst.y() > snd.max_y() ||
           fst.max_y() < snd.y());
}

/**
 * \brief Returns the union of two rectangles.
 *
 * \details Returns a rectangle that represents the union of two rectangles.
 *
 * \tparam T the representation type used by the rectangles.
 *
 * \param fst the first rectangle.
 * \param snd the second rectangle.
 *
 * \return a rectangle that represents the union of the rectangles.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto get_union(const basic_rect<T>& fst,
                                       const basic_rect<T>& snd) noexcept -> basic_rect<T>
{
  const auto fstHasArea = fst.has_area();
  const auto sndHasArea = snd.has_area();

  if (!fstHasArea && !sndHasArea) {
    return {};
  }
  else if (!fstHasArea) {
    return snd;
  }
  else if (!sndHasArea) {
    return fst;
  }

  const auto x = detail::min(fst.x(), snd.x());
  const auto y = detail::min(fst.y(), snd.y());
  const auto maxX = detail::max(fst.max_x(), snd.max_x());
  const auto maxY = detail::max(fst.max_y(), snd.max_y());

  return {{x, y}, {maxX - x, maxY - y}};
}

/// \} End of rectangle functions

/// \name Rectangle comparison operators
/// \{

/**
 * \brief Indicates whether or not two rectangles are equal.
 *
 * \tparam T the representation type used by the rectangles.
 *
 * \param lhs the left-hand side rectangle.
 * \param rhs the right-hand side rectangle.
 *
 * \return `true` if the rectangles are equal; `false` otherwise.
 *
 * \since 4.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator==(const basic_rect<T>& lhs,
                                        const basic_rect<T>& rhs) noexcept -> bool
{
  return (lhs.x() == rhs.x()) && (lhs.y() == rhs.y()) && (lhs.width() == rhs.width()) &&
         (lhs.height() == rhs.height());
}

/**
 * \brief Indicates whether or not two rectangles aren't equal.
 *
 * \tparam T the representation type used by the rectangles.
 *
 * \param lhs the left-hand side rectangle.
 * \param rhs the right-hand side rectangle.
 *
 * \return `true` if the rectangles aren't equal; `false` otherwise.
 *
 * \since 4.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator!=(const basic_rect<T>& lhs,
                                        const basic_rect<T>& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of rectangle comparison operators

/// \name Rectangle cast specializations
/// \{

template <>
[[nodiscard]] constexpr auto cast(const irect& from) noexcept -> frect
{
  const frect::point_type pos{static_cast<float>(from.x()), static_cast<float>(from.y())};
  const frect::area_type size{static_cast<float>(from.width()),
                              static_cast<float>(from.height())};
  return frect{pos, size};
}

template <>
[[nodiscard]] constexpr auto cast(const frect& from) noexcept -> irect
{
  const irect::point_type pos{static_cast<int>(from.x()), static_cast<int>(from.y())};
  const irect::area_type size{static_cast<int>(from.width()), static_cast<int>(from.height())};
  return irect{pos, size};
}

/// \} End of rectangle cast specializations

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a rectangle.
 *
 * \tparam T the representation type used by the rectangle.
 *
 * \param rect the rectangle that will be converted to a string.
 *
 * \return a textual representation of the rectangle.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_rect<T>& rect) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("rect{{x: {}, y: {}, width: {}, height: {}}}",
                     rect.x(),
                     rect.y(),
                     rect.width(),
                     rect.height());
#else
  return "rect{x: " + std::to_string(rect.x()) + ", y: " + std::to_string(rect.y()) +
         ", width: " + std::to_string(rect.width()) +
         ", height: " + std::to_string(rect.height()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a rectangle using a stream.
 *
 * \tparam T the representation type used by the rectangle.
 *
 * \param stream the stream that will be used.
 * \param rect the rectangle that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_rect<T>& rect) -> std::ostream&
{
  return stream << to_string(rect);
}

/// \} End of streaming

/// \} End of group math

}  // namespace cen

#endif  // CENTURION_RECTANGLE_HEADER
// #include "blend_mode.hpp"
#ifndef CENTURION_BLEND_MODE_HEADER
#define CENTURION_BLEND_MODE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "blend_factor.hpp"

// #include "blend_op.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum blend_mode
 *
 * \brief Provides values that represent various rendering blend modes.
 *
 * \since 3.0.0
 *
 * \see `SDL_BlendMode`
 */
enum class blend_mode
{
  none = SDL_BLENDMODE_NONE,    ///< Represents no blending.
  blend = SDL_BLENDMODE_BLEND,  ///< Represents alpha blending.
  add = SDL_BLENDMODE_ADD,      ///< Represents additive blending.
  mod = SDL_BLENDMODE_MOD,      ///< Represents color modulation.

#if SDL_VERSION_ATLEAST(2, 0, 12)

  mul = SDL_BLENDMODE_MUL,  ///< Represents color multiplication.

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

  invalid = SDL_BLENDMODE_INVALID  ///< Represents an invalid blend mode.
};

/**
 * \struct blend_task
 *
 * \brief Describes how a pair of blend mode factors will be combined.
 *
 * \see `compose_blend_mode()`
 *
 * \since 6.3.0
 */
struct blend_task final
{
  blend_factor src;  ///< The blend factor applied to the source pixels.
  blend_factor dst;  ///< The blend factor applied to the destination pixels.
  blend_op op;       ///< The operation used to combine the source and destination pixels.
};

/**
 * \brief Composes a custom blend mode.
 *
 * \param color the blend task descriptor used for RGB components.
 * \param alpha the blend task descriptor used for alpha components.
 *
 * \return the composed blend mode.
 *
 * \see `blend_task`
 * \see `blend_factor`
 * \see `blend_op`
 *
 * \see `SDL_ComposeCustomBlendMode()`
 * \see `basic_renderer::set_blend_mode()`
 * \see `basic_texture::set_blend_mode()`
 *
 * \since 6.3.0
 */
[[nodiscard]] inline auto compose_blend_mode(const blend_task& color,
                                             const blend_task& alpha) noexcept -> blend_mode
{
  const auto res = SDL_ComposeCustomBlendMode(static_cast<SDL_BlendFactor>(color.src),
                                              static_cast<SDL_BlendFactor>(color.dst),
                                              static_cast<SDL_BlendOperation>(color.op),
                                              static_cast<SDL_BlendFactor>(alpha.src),
                                              static_cast<SDL_BlendFactor>(alpha.dst),
                                              static_cast<SDL_BlendOperation>(alpha.op));
  return static_cast<blend_mode>(res);
}

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied blend mode.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(blend_mode::blend) == "blend"`.
 *
 * \param mode the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const blend_mode mode) -> std::string_view
{
  switch (mode) {
    case blend_mode::none:
      return "none";

    case blend_mode::blend:
      return "blend";

    case blend_mode::add:
      return "add";

    case blend_mode::mod:
      return "mod";

    case blend_mode::invalid:
      return "invalid";

#if SDL_VERSION_ATLEAST(2, 0, 12)

    case blend_mode::mul:
      return "mul";

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

    default:
      throw cen_error{"Did not recognize blend mode!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a blend mode enumerator.
 *
 * \param stream the output stream that will be used.
 * \param mode the enumerator that will be printed.
 *
 * \see `to_string(blend_mode)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const blend_mode mode) -> std::ostream&
{
  return stream << to_string(mode);
}

/// \} End of streaming

/// \name Blend mode comparison operators
/// \{

/**
 * \brief Indicates whether or not two blend mode values are the same;
 *
 * \param lhs the left-hand side blend mode value.
 * \param rhs the right-hand side blend mode value.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const blend_mode lhs, const SDL_BlendMode rhs) noexcept
    -> bool
{
  return static_cast<SDL_BlendMode>(lhs) == rhs;
}

/// \copydoc operator==(blend_mode, SDL_BlendMode)
[[nodiscard]] constexpr auto operator==(const SDL_BlendMode lhs, const blend_mode rhs) noexcept
    -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two blend mode values aren't the same;
 *
 * \param lhs the left-hand side blend mode value.
 * \param rhs the right-hand side blend mode value.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator!=(const blend_mode lhs, const SDL_BlendMode rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(blend_mode, SDL_BlendMode)
[[nodiscard]] constexpr auto operator!=(const SDL_BlendMode lhs, const blend_mode rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \} End of blend mode comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_BLEND_MODE_HEADER

// #include "color.hpp"

// #include "pixel_format_info.hpp"
#ifndef CENTURION_PIXEL_FORMAT_INFO_HEADER
#define CENTURION_PIXEL_FORMAT_INFO_HEADER

#include <SDL.h>

#include <ostream>  // ostream
#include <string>   // string, to_string

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/not_null.hpp"

// #include "../core/owner.hpp"

// #include "../core/str.hpp"

// #include "../core/to_underlying.hpp"

// #include "../detail/address_of.hpp"

// #include "../detail/owner_handle_api.hpp"

// #include "color.hpp"

// #include "pixel_format.hpp"
#ifndef CENTURION_PIXEL_FORMAT_HEADER
#define CENTURION_PIXEL_FORMAT_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum pixel_format
 *
 * \brief Represents different pixel formats.
 *
 * \see `SDL_PixelFormatEnum`
 *
 * \since 3.1.0
 */
enum class pixel_format : u32
{
  unknown = SDL_PIXELFORMAT_UNKNOWN,

  index1lsb = SDL_PIXELFORMAT_INDEX1LSB,
  index1msb = SDL_PIXELFORMAT_INDEX1MSB,
  index4lsb = SDL_PIXELFORMAT_INDEX4LSB,
  index4msb = SDL_PIXELFORMAT_INDEX4MSB,
  index8 = SDL_PIXELFORMAT_INDEX8,

#if SDL_VERSION_ATLEAST(2, 0, 14)
  xrgb4444 = SDL_PIXELFORMAT_XRGB4444,
  xbgr4444 = SDL_PIXELFORMAT_XBGR4444,

  xrgb1555 = SDL_PIXELFORMAT_XRGB1555,
  xbgr1555 = SDL_PIXELFORMAT_XBGR1555,

  xrgb8888 = SDL_PIXELFORMAT_XRGB8888,
  xbgr8888 = SDL_PIXELFORMAT_XBGR8888,
#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  rgb332 = SDL_PIXELFORMAT_RGB332,
  rgb444 = SDL_PIXELFORMAT_RGB444,

#if SDL_VERSION_ATLEAST(2, 0, 12)
  bgr444 = SDL_PIXELFORMAT_BGR444,
#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

  rgb555 = SDL_PIXELFORMAT_RGB555,
  bgr555 = SDL_PIXELFORMAT_BGR555,

  argb4444 = SDL_PIXELFORMAT_ARGB4444,
  rgba4444 = SDL_PIXELFORMAT_RGBA4444,
  abgr4444 = SDL_PIXELFORMAT_ABGR4444,
  bgra4444 = SDL_PIXELFORMAT_BGRA4444,

  argb1555 = SDL_PIXELFORMAT_ARGB1555,
  rgba5551 = SDL_PIXELFORMAT_RGBA5551,
  abgr1555 = SDL_PIXELFORMAT_ABGR1555,
  bgra5551 = SDL_PIXELFORMAT_BGRA5551,

  rgb565 = SDL_PIXELFORMAT_RGB565,
  bgr565 = SDL_PIXELFORMAT_BGR565,

  rgb24 = SDL_PIXELFORMAT_RGB24,
  bgr24 = SDL_PIXELFORMAT_BGR24,

  rgb888 = SDL_PIXELFORMAT_RGB888,
  rgbx8888 = SDL_PIXELFORMAT_RGBX8888,
  bgr888 = SDL_PIXELFORMAT_BGR888,
  bgrx8888 = SDL_PIXELFORMAT_BGRX8888,

  argb8888 = SDL_PIXELFORMAT_ARGB8888,
  rgba8888 = SDL_PIXELFORMAT_RGBA8888,
  abgr8888 = SDL_PIXELFORMAT_ABGR8888,
  bgra8888 = SDL_PIXELFORMAT_BGRA8888,

  argb2101010 = SDL_PIXELFORMAT_ARGB2101010,

#if SDL_BYTEORDER == SDL_BIG_ENDIAN
  rgba32 = SDL_PIXELFORMAT_RGBA8888,
  argb32 = SDL_PIXELFORMAT_ARGB8888,
  bgra32 = SDL_PIXELFORMAT_BGRA8888,
  abgr32 = SDL_PIXELFORMAT_ABGR8888,
#else
  rgba32 = SDL_PIXELFORMAT_ABGR8888,
  argb32 = SDL_PIXELFORMAT_BGRA8888,
  bgra32 = SDL_PIXELFORMAT_ARGB8888,
  abgr32 = SDL_PIXELFORMAT_RGBA8888,
#endif

  yv12 = SDL_PIXELFORMAT_YV12,
  iyuv = SDL_PIXELFORMAT_IYUV,
  yuy2 = SDL_PIXELFORMAT_YUY2,
  uyvy = SDL_PIXELFORMAT_UYVY,
  yvyu = SDL_PIXELFORMAT_YVYU,
  nv12 = SDL_PIXELFORMAT_NV12,
  nv21 = SDL_PIXELFORMAT_NV21,
  external_oes = SDL_PIXELFORMAT_EXTERNAL_OES
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied pixel format.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(pixel_format::rgba8888) == "rgba8888"`.
 *
 * \param format the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const pixel_format format) -> std::string_view
{
  switch (format) {
    case pixel_format::unknown:
      return "unknown";

    case pixel_format::index1lsb:
      return "index1lsb";

    case pixel_format::index1msb:
      return "index1msb";

    case pixel_format::index4lsb:
      return "index4lsb";

    case pixel_format::index4msb:
      return "index4msb";

    case pixel_format::index8:
      return "index8";

    case pixel_format::rgb332:
      return "rgb332";

    case pixel_format::argb4444:
      return "argb4444";

    case pixel_format::rgba4444:
      return "rgba4444";

    case pixel_format::abgr4444:
      return "abgr4444";

    case pixel_format::bgra4444:
      return "bgra4444";

    case pixel_format::argb1555:
      return "argb1555";

    case pixel_format::rgba5551:
      return "rgba5551";

    case pixel_format::abgr1555:
      return "abgr1555";

    case pixel_format::bgra5551:
      return "bgra5551";

    case pixel_format::rgb565:
      return "rgb565";

    case pixel_format::bgr565:
      return "bgr565";

    case pixel_format::rgb24:
      return "rgb24";

    case pixel_format::bgr24:
      return "bgr24";

    case pixel_format::rgbx8888:
      return "rgbx8888";

    case pixel_format::bgrx8888:
      return "bgrx8888";

    case pixel_format::argb8888:
      return "argb8888";

    case pixel_format::rgba8888:
      return "rgba8888";

    case pixel_format::abgr8888:
      return "abgr8888";

    case pixel_format::bgra8888:
      return "bgra8888";

    case pixel_format::argb2101010:
      return "argb2101010";

    case pixel_format::yv12:
      return "yv12";

    case pixel_format::iyuv:
      return "iyuv";

    case pixel_format::yuy2:
      return "yuy2";

    case pixel_format::uyvy:
      return "uyvy";

    case pixel_format::yvyu:
      return "yvyu";

    case pixel_format::nv12:
      return "nv12";

    case pixel_format::nv21:
      return "nv21";

    case pixel_format::external_oes:
      return "external_oes";

#if SDL_VERSION_ATLEAST(2, 0, 14)

    case pixel_format::xrgb4444:
      return "xrgb4444";

    case pixel_format::xbgr4444:
      return "xbgr4444";

    case pixel_format::xrgb1555:
      return "xrgb1555";

    case pixel_format::xbgr1555:
      return "xbgr1555";

    case pixel_format::xrgb8888:
      return "xrgb8888";

    case pixel_format::xbgr8888:
      return "xbgr8888";

#elif SDL_VERSION_ATLEAST(2, 0, 12)

    case pixel_format::bgr444:  // Equal to xbgr4444
      return "bgr444";

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

    default:
      throw cen_error{"Did not recognize pixel format mode!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a pixel format enumerator.
 *
 * \param stream the output stream that will be used.
 * \param format the enumerator that will be printed.
 *
 * \see `to_string(pixel_format)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const pixel_format format) -> std::ostream&
{
  return stream << to_string(format);
}

/// \} End of streaming

/// \name Pixel format comparison operators
/// \{

/**
 * \brief Indicates whether or not the two pixel format values are the same.
 *
 * \param lhs the left-hand side pixel format value.
 * \param rhs the right-hand side pixel format value.
 *
 * \return `true` if the pixel format values are the same; `false` otherwise.
 *
 * \since 3.1.0
 */
[[nodiscard]] constexpr auto operator==(const pixel_format lhs,
                                        const SDL_PixelFormatEnum rhs) noexcept -> bool
{
  return static_cast<SDL_PixelFormatEnum>(lhs) == rhs;
}

/// \copydoc operator==(pixel_format, SDL_PixelFormatEnum)
[[nodiscard]] constexpr auto operator==(const SDL_PixelFormatEnum lhs,
                                        const pixel_format rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the two pixel format values aren't the same.
 *
 * \param lhs the left-hand side pixel format value.
 * \param rhs the right-hand side pixel format value.
 *
 * \return `true` if the pixel format values aren't the same; `false` otherwise.
 *
 * \since 3.1.0
 */
[[nodiscard]] constexpr auto operator!=(const pixel_format lhs,
                                        const SDL_PixelFormatEnum rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(pixel_format, SDL_PixelFormatEnum)
[[nodiscard]] constexpr auto operator!=(const SDL_PixelFormatEnum lhs,
                                        const pixel_format rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of pixel format comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_PIXEL_FORMAT_HEADER


namespace cen {

/// \addtogroup video
/// \{

template <typename B>
class basic_pixel_format_info;

/**
 * \typedef pixel_format_info
 *
 * \brief Represents an owning pixel format info instance.
 *
 * \since 5.2.0
 */
using pixel_format_info = basic_pixel_format_info<detail::owning_type>;

/**
 * \typedef pixel_format_info_handle
 *
 * \brief Represents a non-owning pixel format info instance.
 *
 * \since 5.2.0
 */
using pixel_format_info_handle = basic_pixel_format_info<detail::handle_type>;

/**
 * \class basic_pixel_format_info
 *
 * \brief Provides information about a pixel format.
 *
 * \ownerhandle `pixel_format_info`/ `pixel_format_info_handle`
 *
 * \see `pixel_format`
 * \see `pixel_format_info`
 * \see `pixel_format_info_handle`
 * \see `SDL_PixelFormat`
 * \see `SDL_PixelFormatEnum`
 *
 * \since 5.2.0
 */
template <typename B>
class basic_pixel_format_info final
{
 public:
  /// \name Construction
  /// \{

  // clang-format off

  /**
   * \brief Creates a pixel format info instance based on an existing pointer.
   *
   * \note Ownership of the supplied pointer might be claimed, depending on the
   * ownership semantics of the class.
   *
   * \param format a pointer to the associated pixel format.
   *
   * \throws cen_error if the supplied pointer is null *and* the class has owning semantics.
   *
   * \since 5.2.0
   */
  explicit basic_pixel_format_info(maybe_owner<SDL_PixelFormat*> format) noexcept(!detail::is_owning<B>())
      : m_format{format}
  {
    if constexpr (detail::is_owning<B>())
    {
      if (!m_format)
      {
        throw cen_error{"Null pixel format!"};
      }
    }
  }

  // clang-format on

  /**
   * \brief Creates an owning instance based on a pixel format.
   *
   * \tparam BB dummy template parameter for SFINAE.
   *
   * \param format the associated pixel format.
   *
   * \throws sdl_error if the pixel format info could not be obtained.
   *
   * \since 5.2.0
   */
  template <typename BB = B, detail::is_owner<BB> = 0>
  explicit basic_pixel_format_info(const pixel_format format)
      : m_format{SDL_AllocFormat(to_underlying(format))}
  {
    if (!m_format) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates a handle based on an owning pixel format info instance.
   *
   * \param info the associated pixel format info instance.
   *
   * \since 5.2.0
   */
  template <typename BB = B, detail::is_handle<BB> = 0>
  explicit basic_pixel_format_info(const pixel_format_info& info) noexcept
      : m_format{info.get()}
  {}

  /// \} End of construction

  /// \name Pixel/RGB/RGBA conversions
  /// \{

  /**
   * \brief Returns a color that corresponds to a masked pixel value.
   *
   * \param pixel the masked pixel value.
   *
   * \return a color that corresponds to a pixel value, according to the format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto pixel_to_rgb(const u32 pixel) const noexcept -> color
  {
    u8 red{};
    u8 green{};
    u8 blue{};
    SDL_GetRGB(pixel, m_format, &red, &green, &blue);
    return color{red, green, blue};
  }

  /**
   * \brief Returns a color that corresponds to a masked pixel value.
   *
   * \param pixel the masked pixel value.
   *
   * \return a color that corresponds to a pixel value, according to the format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto pixel_to_rgba(const u32 pixel) const noexcept -> color
  {
    u8 red{};
    u8 green{};
    u8 blue{};
    u8 alpha{};
    SDL_GetRGBA(pixel, m_format, &red, &green, &blue, &alpha);
    return color{red, green, blue, alpha};
  }

  /**
   * \brief Returns a pixel color value based on the RGB values of a color.
   *
   * \note The alpha component is assumed to be `0xFF`, i.e. fully opaque.
   *
   * \param color the color that will be converted.
   *
   * \return a masked pixel color value, based on the pixel format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto rgb_to_pixel(const color& color) const noexcept -> u32
  {
    return SDL_MapRGB(m_format, color.red(), color.green(), color.blue());
  }

  /**
   * \brief Returns a pixel color value based on the RGBA values of a color.
   *
   * \param color the color that will be converted.
   *
   * \return a masked pixel color value, based on the pixel format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto rgba_to_pixel(const color& color) const noexcept -> u32
  {
    return SDL_MapRGBA(m_format, color.red(), color.green(), color.blue(), color.alpha());
  }

  /// \} End of pixel/RGB/RGBA conversions

  /// \name Queries
  /// \{

  /**
   * \brief Returns the associated pixel format.
   *
   * \return the associated pixel format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto format() const noexcept -> pixel_format
  {
    return static_cast<pixel_format>(m_format->format);
  }

  /**
   * \brief Returns a human-readable name associated with the format.
   *
   * \details This function never returns a null-pointer, instead it returns
   * "SDL_PIXELFORMAT_UNKNOWN" if the format is ill-formed.
   *
   * \return a human-readable name associated with the format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto name() const noexcept -> not_null<str>
  {
    return SDL_GetPixelFormatName(m_format->format);
  }

  /**
   * \brief Returns a pointer to the associated pixel format instance.
   *
   * \warning Do not claim ownership of the returned pointer.
   *
   * \return a pointer to the internal pixel format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_PixelFormat*
  {
    return m_format.get();
  }

  /// \} End of queries

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not a handle holds a non-null pointer.
   *
   * \return `true` if the handle holds a non-null pointer; `false` otherwise.
   *
   * \since 5.2.0
   */
  template <typename BB = B, detail::is_handle<BB> = 0>
  [[nodiscard]] explicit operator bool() const noexcept
  {
    return m_format;
  }

  /// \} End of conversions

 private:
  struct deleter final
  {
    void operator()(SDL_PixelFormat* format) noexcept
    {
      SDL_FreeFormat(format);
    }
  };
  detail::pointer_manager<B, SDL_PixelFormat, deleter> m_format;
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a pixel format info instance.
 *
 * \tparam T the ownership semantics tag.
 *
 * \param info the pixel format info instance that will be converted.
 *
 * \return a string that represents the pixel format info.
 *
 * \since 6.2.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_pixel_format_info<T>& info) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("pixel_format_info{{data: {}, name: {}}}",
                     detail::address_of(info.get()),
                     info.name());
#else
  return "pixel_format_info{data: " + detail::address_of(info.get()) +
         ", name: " + info.name() + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a pixel format info instance.
 *
 * \tparam T the ownership semantics tag.
 *
 * \param stream the output stream that will be used.
 * \param info the pixel format info that will be printed.
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_pixel_format_info<T>& info) -> std::ostream&
{
  return stream << to_string(info);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_PIXEL_FORMAT_INFO_HEADER


namespace cen {

/// \addtogroup video
/// \{

template <typename T>
class basic_surface;

/**
 * \typedef surface
 *
 * \brief Represents an owning surface.
 *
 * \since 5.0.0
 */
using surface = basic_surface<detail::owning_type>;

/**
 * \typedef surface_handle
 *
 * \brief Represents a non-owning surface.
 *
 * \since 5.0.0
 */
using surface_handle = basic_surface<detail::handle_type>;

/**
 * \class basic_surface
 *
 * \brief Represents a non-accelerated image.
 *
 * \ownerhandle `surface`/`surface_handle`
 *
 * \details Surfaces are often used for icons and snapshots, or as an "intermediate"
 * representation that can be manipulated, unlike textures. There is no support
 * for directly rendering surfaces. However, surfaces can be converted to textures, which
 * in turn can be rendered.
 *
 * \note Unlike most other Centurion components, surfaces can be copied.
 *
 * \since 4.0.0
 *
 * \see `surface`
 * \see `surface_handle`
 */
template <typename T>
class basic_surface final
{
 public:
  /// \name Construction
  /// \{

  // clang-format off

  /**
   * \brief Creates a surface from a pointer to an SDL surface.
   *
   * \note Depending on the type of the surface, ownership of the supplied SDL
   * surface might be claimed.
   *
   * \param surface a pointer to the associated surface.
   *
   * \since 4.0.0
   */
  explicit basic_surface(maybe_owner<SDL_Surface*> surface) noexcept(!detail::is_owning<T>())
      : m_surface{surface}
  {
    if constexpr (detail::is_owning<T>())
    {
      if (!m_surface)
      {
        throw cen_error{"Cannot create surface from null pointer!"};
      }
    }
  }

  // clang-format on

#ifndef CENTURION_NO_SDL_IMAGE

  /**
   * \brief Creates a surface based on the image at the specified path.
   *
   * \tparam BB dummy parameter for SFINAE.
   *
   * \param file the file path of the image file that will be loaded, can't
   * be null.
   *
   * \throws img_error if the surface cannot be created.
   *
   * \since 4.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_surface(const not_null<str> file) : m_surface{IMG_Load(file)}
  {
    if (!m_surface) {
      throw img_error{};
    }
  }

  /**
   * \brief Creates a surface based on the image at the specified path.
   *
   * \tparam BB dummy parameter for SFINAE.
   *
   * \param file the file path of the image file that will be loaded.
   *
   * \throws img_error if the surface cannot be created.
   *
   * \since 5.3.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_surface(const std::string& file) : basic_surface{file.c_str()}
  {}

#endif  // CENTURION_NO_SDL_IMAGE

  /**
   * \brief Creates a surface with the specified dimensions and pixel format.
   *
   * \tparam BB dummy parameter for SFINAE.
   *
   * \param size the size of the surface.
   * \param pixelFormat the pixel format that will be used by the surface.
   *
   * \throws sdl_error if the surface cannot be created.
   *
   * \since 5.3.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  basic_surface(const iarea size, const pixel_format pixelFormat)
      : m_surface{SDL_CreateRGBSurfaceWithFormat(0,
                                                 size.width,
                                                 size.height,
                                                 0,
                                                 to_underlying(pixelFormat))}
  {
    if (!m_surface) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates and returns a surface with the specified characteristics.
   *
   * \tparam BB dummy parameter for SFINAE.
   *
   * \param file the file path of the image that the surface will be based on.
   * \param blendMode the blend mode that will be used.
   * \param pixelFormat the pixel format that will be used.
   *
   * \return an owning surface, with the specified blend mode and pixel format.
   *
   * \since 5.2.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto with_format(const not_null<str> file,
                                        const blend_mode blendMode,
                                        const pixel_format pixelFormat) -> basic_surface
  {
    assert(file);

    basic_surface source{file};
    source.set_blend_mode(blendMode);

    return source.convert(pixelFormat);
  }

  /**
   * \see with_format()
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto with_format(const std::string& file,
                                        const blend_mode blendMode,
                                        const pixel_format pixelFormat) -> basic_surface
  {
    return with_format(file.c_str(), blendMode, pixelFormat);
  }

  /**
   * \brief Creates and returns a surface based on a BMP file.
   *
   * \tparam BB dummy parameter for SFINAE.
   *
   * \param file the path to the BMP file that contains the surface data.
   *
   * \return the created surface.
   *
   * \throws sdl_error if the surface couldn't be loaded.
   *
   * \since 5.3.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto from_bmp(const not_null<str> file) -> basic_surface
  {
    assert(file);
    return basic_surface{SDL_LoadBMP(file)};
  }

  /**
   * \see from_bmp()
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto from_bmp(const std::string& file) -> basic_surface
  {
    return from_bmp(file.c_str());
  }

  /**
   * \brief Creates a copy of the supplied surface.
   *
   * \param other the surface that will be copied.
   *
   * \since 4.0.0
   */
  basic_surface(const basic_surface& other) noexcept(!detail::is_owning<T>())
  {
    if constexpr (detail::is_owning<T>()) {
      copy(other);
    }
    else {
      m_surface = other.get();
    }
  }

  /**
   * \brief Creates a surface by moving the supplied surface.
   *
   * \param other the surface that will be moved.
   *
   * \since 4.0.0
   */
  basic_surface(basic_surface&& other) noexcept = default;

  /// \} End of construction

  /**
   * \brief Copies the supplied surface.
   *
   * \param other the surface that will be copied.
   *
   * \throws sdl_error if the supplied surface couldn't be copied.
   *
   * \since 4.0.0
   */
  auto operator=(const basic_surface& other) noexcept(!detail::is_owning<T>())
      -> basic_surface&
  {
    if (this != &other) {
      if constexpr (detail::is_owning<T>()) {
        copy(other);
      }
      else {
        m_surface = other.get();
      }
    }
    return *this;
  }

  /**
   * \brief Moves the supplied surface into this surface.
   *
   * \param other the surface that will be moved.
   *
   * \return the surface that claimed the supplied surface.
   *
   * \since 4.0.0
   */
  auto operator=(basic_surface&& other) noexcept -> basic_surface& = default;

  /// \name Save functions
  /// \{

  /**
   * \brief Saves the surface as a BMP image.
   *
   * \param file the file path that the surface data will be saved at.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.3.0
   */
  auto save_as_bmp(const not_null<str> file) const noexcept -> result
  {
    assert(file);
    return SDL_SaveBMP(get(), file) != -1;
  }

  /**
   * \see save_as_bmp()
   * \since 6.0.0
   */
  auto save_as_bmp(const std::string& file) const noexcept -> result  // NOLINT
  {
    return save_as_bmp(file.c_str());
  }

#ifndef CENTURION_NO_SDL_IMAGE

  /**
   * \brief Saves the surface as a PNG image.
   *
   * \param file the file path that the surface data will be saved at.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 6.0.0
   */
  auto save_as_png(const not_null<str> file) const noexcept -> result
  {
    assert(file);
    return IMG_SavePNG(get(), file) != -1;
  }

  /**
   * \see save_as_png()
   * \since 6.0.0
   */
  auto save_as_png(const std::string& file) const noexcept -> result  // NOLINT
  {
    return save_as_png(file.c_str());
  }

  /**
   * \brief Saves the surface as a JPG image.
   *
   * \note The quality parameter is supplied to libjpeg in the SDL
   * implementation, but the limitations on its values are unknown at the time
   * of writing.
   *
   * \param file the file path that the surface data will be saved at.
   * \param quality the quality of the JPG image.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 6.0.0
   */
  auto save_as_jpg(const not_null<str> file, const int quality) const noexcept -> result
  {
    assert(file);
    return IMG_SaveJPG(get(), file, quality) != -1;
  }

  /**
   * \see save_as_jpg()
   * \since 6.0.0
   */
  auto save_as_jpg(const std::string& file, const int quality) const noexcept -> result
  {
    return save_as_jpg(file.c_str(), quality);
  }

#endif  // CENTURION_NO_SDL_IMAGE

  /// \} End of save functions

  /// \name Locking
  /// \{

  /**
   * \brief Attempts to lock the surface, so that the associated pixel data can
   * be modified.
   *
   * \details This function has no effect if `must_lock()` returns `false`.
   *
   * \return `success` if the locking of the surface was successful or if
   * locking isn't required for modifying the surface; `failure` if something
   * went wrong.
   *
   * \since 4.0.0
   */
  auto lock() noexcept -> result
  {
    if (must_lock()) {
      return SDL_LockSurface(m_surface) == 0;
    }
    else {
      return true;
    }
  }

  /**
   * \brief Unlocks the surface.
   *
   * \details This function has no effect if `must_lock()` returns `false`.
   *
   * \since 4.0.0
   */
  void unlock() noexcept
  {
    if (must_lock()) {
      SDL_UnlockSurface(m_surface);
    }
  }

  /**
   * \brief Indicates whether or not the surface must be locked before modifying
   * the pixel data associated with the surface.
   *
   * \return `true` if the surface must be locked before modification; `false`
   * otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto must_lock() const noexcept -> bool
  {
    return SDL_MUSTLOCK(m_surface);
  }

  /// \} End of locking

  /// \name Setters
  /// \{

  /**
   * \brief Sets the color of the pixel at the specified coordinate.
   *
   * \details This function has no effect if the coordinate is out-of-bounds or if
   * something goes wrong when attempting to modify the pixel data.
   *
   * \param pixel the pixel that will be changed.
   * \param color the new color of the pixel.
   *
   * \since 4.0.0
   */
  void set_pixel(const ipoint pixel, const color& color) noexcept
  {
    if (!in_bounds(pixel) || !lock()) {
      return;
    }

    const int nPixels = (m_surface->pitch / 4) * height();
    const int index = (pixel.y() * width()) + pixel.x();

    if ((index >= 0) && (index < nPixels)) {
      const auto info = format_info();
      auto* pixels = reinterpret_cast<u32*>(m_surface->pixels);
      pixels[index] = info.rgba_to_pixel(color);
    }

    unlock();
  }

  /**
   * \brief Sets the alpha component modulation value.
   *
   * \param alpha the new alpha component value, in the range [0, 255].
   *
   * \since 4.0.0
   */
  void set_alpha(const u8 alpha) noexcept
  {
    SDL_SetSurfaceAlphaMod(m_surface, alpha);
  }

  /**
   * \brief Sets the color modulation that will be used by the surface.
   *
   * \param color the color that represents the color modulation that will be
   * used.
   *
   * \since 4.0.0
   */
  void set_color_mod(const color& color) noexcept
  {
    SDL_SetSurfaceColorMod(m_surface, color.red(), color.green(), color.blue());
  }

  /**
   * \brief Sets the blend mode that will be used by the surface.
   *
   * \param mode the blend mode that will be used.
   *
   * \since 4.0.0
   */
  void set_blend_mode(const blend_mode mode) noexcept
  {
    SDL_SetSurfaceBlendMode(m_surface, static_cast<SDL_BlendMode>(mode));
  }

  /**
   * \brief Sets the value of the RLE acceleration hint.
   *
   * \param enabled `true` if the RLE optimization hint should be enabled;
   * `false` otherwise.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \see is_rle_enabled()
   *
   * \since 5.2.0
   */
  auto set_rle_hint(const bool enabled) noexcept -> result
  {
    return SDL_SetSurfaceRLE(m_surface, enabled ? 1 : 0) == 0;
  }

  /// \} End of setters

  /// \name Getters
  /// \{

  /**
   * \brief Returns the alpha component modulation of the surface.
   *
   * \return the alpha modulation value, in the range [0, 255].
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto alpha() const noexcept -> u8
  {
    u8 alpha{0xFF};
    SDL_GetSurfaceAlphaMod(m_surface, &alpha);
    return alpha;
  }

  /**
   * \brief Returns the color modulation of the surface.
   *
   * \return a color that represents the color modulation of the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto color_mod() const noexcept -> color
  {
    u8 red{};
    u8 green{};
    u8 blue{};
    SDL_GetSurfaceColorMod(m_surface, &red, &green, &blue);
    return color{red, green, blue};
  }

  /**
   * \brief Returns the blend mode that is being used by the surface.
   *
   * \return the blend mode that the surface uses.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get_blend_mode() const noexcept -> blend_mode
  {
    SDL_BlendMode mode{};
    SDL_GetSurfaceBlendMode(m_surface, &mode);
    return static_cast<blend_mode>(mode);
  }

  /**
   * \brief Creates and returns a surface based on this surface with the
   * specified pixel format.
   *
   * \param format the pixel format that will be used by the new surface.
   *
   * \return a surface based on this surface with the specified
   * pixel format.
   *
   * \throws sdl_error if the surface cannot be created.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto convert(const pixel_format format) const -> basic_surface
  {
    if (auto* converted = SDL_ConvertSurfaceFormat(m_surface, to_underlying(format), 0)) {
      basic_surface result{converted};
      result.set_blend_mode(get_blend_mode());
      return result;
    }
    else {
      throw sdl_error{};
    }
  }

  /**
   * \brief Returns the width of the surface.
   *
   * \return the width of the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto width() const noexcept -> int
  {
    return m_surface->w;
  }

  /**
   * \brief Returns the height of the surface.
   *
   * \return the height of the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto height() const noexcept -> int
  {
    return m_surface->h;
  }

  /**
   * \brief Returns the size of the surface.
   *
   * \return the size of the surface.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto size() const noexcept -> iarea
  {
    return iarea{width(), height()};
  }

  /**
   * \brief Returns the pitch (the length of a row of pixels in bytes) of the
   * surface.
   *
   * \return the pitch of the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto pitch() const noexcept -> int
  {
    return m_surface->pitch;
  }

  /**
   * \brief Returns a pointer to the pixel data of the surface.
   *
   * \details It's possible to modify the surface through the returned pointer.
   *
   * \return a pointer to the pixel data of the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto pixels() noexcept -> void*
  {
    return m_surface->pixels;
  }

  /**
   * \brief Returns a pointer to the pixel data of the surface.
   *
   * \return a pointer to the pixel data of the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto pixels() const noexcept -> const void*
  {
    return m_surface->pixels;
  }

  /**
   * \brief Returns a pointer to the pixel data of the surface.
   *
   * \return a pointer to the pixel data of the surface.
   *
   * \since 5.3.0
   */
  [[nodiscard]] auto data() noexcept -> void*
  {
    return pixels();
  }

  /**
   * \copydoc data()
   */
  [[nodiscard]] auto data() const noexcept -> const void*
  {
    return pixels();
  }

  /**
   * \brief Returns the pixel format info associated with the surface.
   *
   * \return the associated pixel format info.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto format_info() const noexcept -> pixel_format_info_handle
  {
    return pixel_format_info_handle{m_surface->format};
  }

  /**
   * \brief Returns the clipping information associated with the surface.
   *
   * \return the clipping information associated with the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto clip() const noexcept -> irect
  {
    const auto rect = m_surface->clip_rect;
    return {{rect.x, rect.y}, {rect.w, rect.h}};
  }

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Indicates whether or not the surface is RLE-enabled.
   *
   * \return `true` if the surface is RLE-enabled; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto is_rle_enabled() const noexcept -> bool
  {
    return SDL_HasSurfaceRLE(m_surface) == SDL_TRUE;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Returns a pointer to the associated `SDL_Surface`.
   *
   * \warning Don't take ownership of the returned pointer!
   *
   * \return a pointer to the associated `SDL_Surface`.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_Surface*
  {
    return m_surface.get();
  }

  /// \} End of getters

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not a surface handle holds a non-null pointer.
   *
   * \tparam BB dummy parameter for SFINAE.
   *
   * \return `true` if the surface handle holds a non-null pointer; `false`
   * otherwise.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit operator bool() const noexcept
  {
    return m_surface != nullptr;
  }

  /**
   * \brief Converts to `SDL_Surface*`.
   *
   * \return a pointer to the associated `SDL_Surface`.
   *
   * \since 4.0.0
   */
  [[nodiscard]] explicit operator SDL_Surface*() noexcept
  {
    return get();
  }

  /**
   * \brief Converts to `const SDL_Surface*`.
   *
   * \return a pointer to the associated `SDL_Surface`.
   *
   * \since 4.0.0
   */
  [[nodiscard]] explicit operator const SDL_Surface*() const noexcept
  {
    return get();
  }

  /// \} End of conversions

 private:
  struct deleter final
  {
    void operator()(SDL_Surface* surface) noexcept
    {
      SDL_FreeSurface(surface);
    }
  };
  detail::pointer_manager<T, SDL_Surface, deleter> m_surface;

  /**
   * \brief Copies the contents of the supplied surface instance into this
   * instance.
   *
   * \param other the instance that will be copied.
   *
   * \throws sdl_error if the surface cannot be copied.
   *
   * \since 4.0.0
   */
  void copy(const basic_surface& other)
  {
    m_surface.reset(other.copy_surface());
  }

  /**
   * \brief Indicates whether or not the supplied point is within the bounds of
   * the surface.
   *
   * \param point the point that will be checked.
   *
   * \return `true` if the point is within the bounds of the surface; `false`
   * otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto in_bounds(const ipoint point) const noexcept -> bool
  {
    return !(point.x() < 0 || point.y() < 0 || point.x() >= width() || point.y() >= height());
  }

  /**
   * \brief Creates and returns copy of the associated `SDL_Surface`.
   *
   * \return a copy of the associated `SDL_Surface`, the returned pointer won't
   * be null.
   *
   * \throws sdl_error if the copy couldn't be created.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto copy_surface() const -> owner<SDL_Surface*>
  {
    if (auto* copy = SDL_DuplicateSurface(m_surface)) {
      return copy;
    }
    else {
      throw sdl_error{};
    }
  }

#ifdef CENTURION_MOCK_FRIENDLY_MODE

 public:
  basic_surface() = default;
#endif  // CENTURION_MOCK_FRIENDLY_MODE
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a surface.
 *
 * \param surface the surface that will be converted.
 *
 * \return a textual representation of the surface.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_surface<T>& surface) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("surface{{data: {}, width: {}, height: {}}}",
                     detail::address_of(surface.get()),
                     surface.width(),
                     surface.height());
#else
  return "surface{data: " + detail::address_of(surface.get()) +
         ", width: " + std::to_string(surface.width()) +
         ", height: " + std::to_string(surface.height()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a surface.
 *
 * \param stream the stream that will be used.
 * \param surface the surface that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_surface<T>& surface) -> std::ostream&
{
  return stream << to_string(surface);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_SURFACE_HEADER

// #include "system_cursor.hpp"
#ifndef CENTURION_SYSTEM_CURSOR_HEADER
#define CENTURION_SYSTEM_CURSOR_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum system_cursor
 *
 * \brief Represents the various available system cursors.
 *
 * \since 4.0.0
 *
 * \see `SDL_SystemCursor`
 * \see `system_cursor_count()`
 */
enum class system_cursor
{
  arrow = SDL_SYSTEM_CURSOR_ARROW,
  ibeam = SDL_SYSTEM_CURSOR_IBEAM,
  wait = SDL_SYSTEM_CURSOR_WAIT,
  crosshair = SDL_SYSTEM_CURSOR_CROSSHAIR,
  wait_arrow = SDL_SYSTEM_CURSOR_WAITARROW,
  arrow_nw_se = SDL_SYSTEM_CURSOR_SIZENWSE,
  arrow_ne_sw = SDL_SYSTEM_CURSOR_SIZENESW,
  arrow_w_e = SDL_SYSTEM_CURSOR_SIZEWE,
  arrow_n_s = SDL_SYSTEM_CURSOR_SIZENS,
  arrow_all = SDL_SYSTEM_CURSOR_SIZEALL,
  no = SDL_SYSTEM_CURSOR_NO,
  hand = SDL_SYSTEM_CURSOR_HAND
};

/**
 * \brief Returns the number of available system cursors.
 *
 * \return the number of system cursors.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto system_cursor_count() noexcept -> int
{
  return SDL_NUM_SYSTEM_CURSORS;
}

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied system cursor.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(system_cursor::hand) == "hand"`.
 *
 * \param cursor the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const system_cursor cursor) -> std::string_view
{
  switch (cursor) {
    case system_cursor::arrow:
      return "arrow";

    case system_cursor::ibeam:
      return "ibeam";

    case system_cursor::wait:
      return "wait";

    case system_cursor::crosshair:
      return "crosshair";

    case system_cursor::wait_arrow:
      return "wait_arrow";

    case system_cursor::arrow_nw_se:
      return "arrow_nw_se";

    case system_cursor::arrow_ne_sw:
      return "arrow_ne_sw";

    case system_cursor::arrow_w_e:
      return "arrow_w_e";

    case system_cursor::arrow_n_s:
      return "arrow_n_s";

    case system_cursor::arrow_all:
      return "arrow_all";

    case system_cursor::no:
      return "no";

    case system_cursor::hand:
      return "hand";

    default:
      throw cen_error{"Did not recognize system cursor!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a system cursor enumerator.
 *
 * \param stream the output stream that will be used.
 * \param cursor the enumerator that will be printed.
 *
 * \see `to_string(system_cursor)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const system_cursor cursor) -> std::ostream&
{
  return stream << to_string(cursor);
}

/// \} End of streaming

/// \name System cursor comparison operators
/// \{

/**
 * \brief Indicates whether or not two system cursor values are the same.
 *
 * \param lhs the left-hand side system cursor value.
 * \param rhs the right-hand side system cursor value.
 *
 * \return `true` if the system cursor values are the same; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator==(const system_cursor lhs,
                                        const SDL_SystemCursor rhs) noexcept -> bool
{
  return static_cast<SDL_SystemCursor>(lhs) == rhs;
}

/// \copydoc operator==(system_cursor, SDL_SystemCursor)
[[nodiscard]] constexpr auto operator==(const SDL_SystemCursor lhs,
                                        const system_cursor rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two system cursor values aren't the same.
 *
 * \param lhs the left-hand side system cursor value.
 * \param rhs the right-hand side system cursor value.
 *
 * \return `true` if the system cursor values aren't the same; `false`
 * otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator!=(const system_cursor lhs,
                                        const SDL_SystemCursor rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(system_cursor, SDL_SystemCursor)
[[nodiscard]] constexpr auto operator!=(const SDL_SystemCursor lhs,
                                        const system_cursor rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of system cursor comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_SYSTEM_CURSOR_HEADER


namespace cen {

/// \addtogroup video
/// \{

template <typename T>
class basic_cursor;

/**
 * \typedef cursor
 *
 * \brief Represents an owning cursor.
 *
 * \since 5.0.0
 */
using cursor = basic_cursor<detail::owning_type>;

/**
 * \typedef cursor_handle
 *
 * \brief Represents a non-owning cursor.
 *
 * \since 5.0.0
 */
using cursor_handle = basic_cursor<detail::handle_type>;

/**
 * \class basic_cursor
 *
 * \brief Represents a mouse cursor.
 *
 * \ownerhandle `cursor`/`cursor_handle`
 *
 * \since 5.0.0
 *
 * \see `cursor`
 * \see `cursor_handle`
 */
template <typename T>
class basic_cursor final
{
 public:
  /// \name Construction
  /// \{

  /**
   * \brief Creates a cursor based on a cursor type.
   *
   * \param cursor the type of the cursor that will be created.
   *
   * \throws sdl_error if the cursor cannot be created.
   *
   * \since 4.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_cursor(const system_cursor cursor)
      : m_cursor{SDL_CreateSystemCursor(static_cast<SDL_SystemCursor>(cursor))}
  {
    if (!m_cursor) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates a cursor based on a surface and an associated hotspot.
   *
   * \param surface the icon associated with the cursor.
   * \param hotspot the hotspot that will be used to determine the location of mouse
   * clicks.
   *
   * \throws sdl_error if the cursor cannot be created.
   *
   * \since 4.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  basic_cursor(const surface& surface, const ipoint hotspot)
      : m_cursor{SDL_CreateColorCursor(surface.get(), hotspot.x(), hotspot.y())}
  {
    if (!m_cursor) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates a handle to a cursor based on a raw pointer.
   *
   * \note This constructor is only available for handles since it would be very easy to
   * introduce subtle bugs by creating owning cursors from `SDL_GetCursor` or
   * `SDL_GetDefaultCursor`, which should not be freed.
   *
   * \param cursor a pointer to the associated cursor.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit basic_cursor(SDL_Cursor* cursor) noexcept : m_cursor{cursor}
  {}

  /**
   * \brief Creates a handle to an owning cursor.
   *
   * \param owner the associated owning cursor.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit basic_cursor(const cursor& owner) noexcept : m_cursor{owner.get()}
  {}

  /// \} End of construction

  /// \name Static members
  /// \{

  /**
   * \brief Resets the active cursor to the system default.
   *
   * \since 4.0.0
   */
  static void reset() noexcept
  {
    SDL_SetCursor(SDL_GetDefaultCursor());
  }

  /**
   * \brief Forces a cursor redraw.
   *
   * \since 4.0.0
   */
  static void force_redraw() noexcept
  {
    SDL_SetCursor(nullptr);
  }

  /**
   * \brief Sets whether or not any mouse cursor is visible.
   *
   * \param visible `true` if cursors should be visible; `false` otherwise.
   *
   * \since 4.0.0
   */
  static void set_visible(const bool visible) noexcept
  {
    SDL_ShowCursor(visible ? SDL_ENABLE : SDL_DISABLE);
  }

  /**
   * \brief Returns a handle to the default cursor for the system.
   *
   * \return a handle to the default cursor for the system; might not be present.
   *
   * \since 5.0.0
   */
  [[nodiscard]] static auto get_default() noexcept -> cursor_handle
  {
    return cursor_handle{SDL_GetDefaultCursor()};
  }

  /**
   * \brief Returns a handle to the currently active cursor.
   *
   * \return a handle to the currently active cursor; might not be present.
   *
   * \since 5.0.0
   */
  [[nodiscard]] static auto get_current() noexcept -> cursor_handle
  {
    return cursor_handle{SDL_GetCursor()};
  }

  /**
   * \brief Indicates whether or not cursors are visible.
   *
   * \return `true` if cursors are visible; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] static auto visible() noexcept -> bool
  {
    return SDL_ShowCursor(SDL_QUERY) == SDL_ENABLE;
  }

  /**
   * \brief Returns the number of system cursors.
   *
   * \return the amount of system cursors.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr static auto count() noexcept -> int
  {
    return SDL_NUM_SYSTEM_CURSORS;
  }

  /// \} End of static members

  /// \name Instance members
  /// \{

  /**
   * \brief Enables the cursor by making it the currently active cursor.
   *
   * \since 4.0.0
   */
  void enable() noexcept
  {
    SDL_SetCursor(m_cursor);
  }

  /**
   * \brief Indicates whether or not this cursor is currently active.
   *
   * \note This function checks whether or not the associated cursor is active by
   * comparing the pointer obtained from `SDL_GetCursor` with the internal pointer.
   *
   * \return `true` if the cursor is currently enabled; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_enabled() const noexcept -> bool
  {
    return SDL_GetCursor() == get();
  }

  /**
   * \brief Returns a pointer to the associated cursor.
   *
   * \warning Don't take ownership of the returned pointer!
   *
   * \return a pointer to the associated cursor.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_Cursor*
  {
    return m_cursor.get();
  }

  /// \} End of instance members

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not the cursor handle holds a non-null pointer.
   *
   * \return `true` if the internal pointer is not null; `false` otherwise.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit operator bool() const noexcept
  {
    return m_cursor != nullptr;
  }

  /// \} End of conversions

 private:
  struct deleter final
  {
    void operator()(SDL_Cursor* cursor) noexcept
    {
      SDL_FreeCursor(cursor);
    }
  };
  detail::pointer_manager<T, SDL_Cursor, deleter> m_cursor;
};

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_CURSOR_HEADER
// #include "centurion/video/flash_op.hpp"
#ifndef CENTURION_FLASH_OP_HEADER
#define CENTURION_FLASH_OP_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


#if SDL_VERSION_ATLEAST(2, 0, 16)

namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum flash_op
 *
 * \brief Represents different window flash operations.
 *
 * \see `basic_window::flash()`
 * \see `to_string(flash_op)`
 *
 * \since 6.2.0
 */
enum class flash_op
{
  cancel = SDL_FLASH_CANCEL,               ///< Cancel any current flashing.
  briefly = SDL_FLASH_BRIEFLY,             ///< Briefly flash the window.
  until_focused = SDL_FLASH_UNTIL_FOCUSED  ///< Flash the window until it's focused.
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied window flash operation.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(flash_op::briefly) == "briefly"`.
 *
 * \param op the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const flash_op op) -> std::string_view
{
  switch (op) {
    case flash_op::cancel:
      return "cancel";

    case flash_op::briefly:
      return "briefly";

    case flash_op::until_focused:
      return "until_focused";

    default:
      throw cen_error{"Did not recognize window flash operation!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a window flash operation enumerator.
 *
 * \param stream the output stream that will be used.
 * \param op the enumerator that will be printed.
 *
 * \see `to_string(flash_op)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const flash_op op) -> std::ostream&
{
  return stream << to_string(op);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // SDL_VERSION_ATLEAST(2, 0, 16)

#endif  // CENTURION_FLASH_OP_HEADER

// #include "centurion/video/font.hpp"
#ifndef CENTURION_FONT_HEADER
#define CENTURION_FONT_HEADER

#ifndef CENTURION_NO_SDL_TTF

#include <SDL_ttf.h>

#include <cassert>      // assert
#include <memory>       // unique_ptr
#include <optional>     // optional
#include <ostream>      // ostream
#include <string>       // string, to_string
#include <string_view>  // string_view

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/not_null.hpp"

// #include "../core/str.hpp"

// #include "../core/to_underlying.hpp"

// #include "../detail/address_of.hpp"

// #include "../math/area.hpp"

// #include "unicode_string.hpp"
#ifndef CENTURION_UNICODE_STRING_HEADER
#define CENTURION_UNICODE_STRING_HEADER

#include <cassert>           // assert
#include <initializer_list>  // initializer_list
#include <type_traits>       // is_same_v, decay_t
#include <vector>            // vector

// #include "../compiler/compiler.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \typedef unicode
 *
 * \brief The representation of Unicode glyphs.
 *
 * \since 5.0.0
 */
using unicode = u16;

/**
 * \class unicode_string
 *
 * \brief Represents a null-terminated string encoded in unicode.
 *
 * \serializable
 *
 * \details This class is a wrapper around a `std::vector<unicode>`, that provides a
 * similar interface to that of `std::string`.
 */
class unicode_string final
{
 public:
  using value_type = std::vector<unicode>::value_type;

  using pointer = std::vector<unicode>::pointer;
  using const_pointer = std::vector<unicode>::const_pointer;

  using reference = std::vector<unicode>::reference;
  using const_reference = std::vector<unicode>::const_reference;

  using iterator = std::vector<unicode>::iterator;
  using const_iterator = std::vector<unicode>::const_iterator;

  using reverse_iterator = std::vector<unicode>::reverse_iterator;
  using const_reverse_iterator = std::vector<unicode>::const_reverse_iterator;

  using size_type = std::vector<unicode>::size_type;
  using difference_type = std::vector<unicode>::difference_type;

  /// \name Construction
  /// \{

  /**
   * \brief Creates an empty Unicode string.
   *
   * \since 5.0.0
   */
  unicode_string()
  {
    m_data.push_back(0);
  }

  /**
   * \brief Creates a Unicode string based on the supplied values.
   *
   * \param codes the list of glyphs that will be used.
   *
   * \since 5.0.0
   */
  unicode_string(std::initializer_list<unicode> codes)
  {
    reserve(codes.size() + 1);
    m_data.insert(m_data.end(), codes.begin(), codes.end());
    m_data.push_back(0);
  }

  /// \} End of construction

  /**
   * \brief Reserves enough memory to hold the specified amount of elements.
   *
   * \details Use this function to optimize additions to the string when you know or can
   * approximate the amount of elements that will be added. This can reduce the amount of
   * unnecessary allocations and copies of the underlying array.
   *
   * \param n the amount of elements to allocate memory for.
   *
   * \since 5.0.0
   */
  void reserve(const size_type n)
  {
    m_data.reserve(n);
  }

  /**
   * \brief Appends a Unicode glyph to the end of the string.
   *
   * \param ch the glyph that will be appended.
   *
   * \since 5.0.0
   */
  void append(const unicode ch)
  {
    m_data.insert(m_data.end() - 1, ch);
  }

  /**
   * \brief Appends a series of glyphs to the string.
   *
   * \tparam First the type of the first glyph, always `unicode`.
   * \tparam Character the types of the other glyphs, always `unicode`.
   *
   * \param code the pack of glyphs that will be added, cannot be empty.
   *
   * \since 5.0.0
   */
  template <typename... Character>
  void append(Character... code)
  {
    static_assert(sizeof...(Character) != 0, "Function requires at least 1 argument!");
    static_assert((std::is_same_v<unicode, std::decay_t<Character>> && ...),
                  "Cannot append values that aren't of type \"unicode\"!");
    (append(code), ...);
  }

  /// \copydoc append(unicode)
  void operator+=(const unicode ch)
  {
    append(ch);
  }

  /**
   * \brief Removes the last element from the string.
   *
   * \details This function has no effect if the string is empty.
   *
   * \since 5.0.0
   */
  void pop_back()
  {
    if (!empty()) {
      m_data.erase(m_data.end() - 2);
    }
  }

  /**
   * \brief Returns the number of elements stored in the string.
   *
   * \note This function does *not* include the null-terminator.
   *
   * \return the number of elements in the string.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto size() const noexcept -> size_type
  {
    return m_data.size() - 1;
  }

  /**
   * \brief Returns the capacity of the string.
   *
   * \return the capacity of the string (the amount of elements that can be stored before
   * needing to allocate more memory).
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto capacity() const noexcept -> size_type
  {
    return m_data.capacity();
  }

  /**
   * \brief Indicates whether or not the string is empty.
   *
   * \note The string is considered empty if the only element is the null-terminator.
   *
   * \return `true` if the string is empty; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto empty() const noexcept -> bool
  {
    return m_data.size() == 1;
  }

  /**
   * \brief Returns a pointer to the first glyph.
   *
   * \return a pointer to the first glyph.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto data() noexcept -> pointer
  {
    return m_data.data();
  }

  /// \copydoc data
  [[nodiscard]] auto data() const noexcept -> const_pointer
  {
    return m_data.data();
  }

  /**
   * \brief Returns an iterator that points to the first element in the string.
   *
   * \details Iteration using the iterator is done consecutively, as you would expect.
   *
   * \return an iterator that points to the first element in the string.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto begin() noexcept -> iterator
  {
    return m_data.begin();
  }

  /// \copydoc begin
  [[nodiscard]] auto begin() const noexcept -> const_iterator
  {
    return m_data.begin();
  }

  /**
   * \brief Returns an iterator that points one-past the last element in the string.
   *
   * \note The null-terminator is purposefully skipped.
   *
   * \return an iterator that points one-past the last element in the string.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto end() noexcept -> iterator
  {
    return m_data.end() - 1;
  }

  /// \copydoc end
  [[nodiscard]] auto end() const noexcept -> const_iterator
  {
    return m_data.end() - 1;
  }

  /**
   * \brief Returns the element at the specified index.
   *
   * \details This function will throw an exception if the supplied index is
   * out-of-bounds.
   *
   * \param index the index of the desired element.
   *
   * \return the element at the specified index.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto at(const size_type index) -> reference
  {
    return m_data.at(index);
  }

  /// \copydoc at
  [[nodiscard]] auto at(const size_type index) const -> const_reference
  {
    return m_data.at(index);
  }

  /**
   * \brief Returns the element at the specified index.
   *
   * \pre `index` **must** be in the range [0, `size()`);
   *
   * \details This function will does *not* perform bounds-checking. However, in
   * debug-mode, an assertion will abort the program if the supplied index is
   * out-of-bounds.
   *
   * \param index the index of the desired element.
   *
   * \return the element at the specified index.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto operator[](const size_type index) noexcept(on_msvc()) -> reference
  {
    assert(index < m_data.size());
    return m_data[index];
  }

  /// \copydoc operator[]
  [[nodiscard]] auto operator[](const size_type index) const noexcept(on_msvc())
      -> const_reference
  {
    assert(index < m_data.size());
    return m_data[index];
  }

  /**
   * \brief Serializes the string.
   *
   * \details This function expects that the archive provides an overloaded `operator()`,
   * used for serializing data. This API is based on the Cereal serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the string.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_data);
  }

 private:
  std::vector<unicode> m_data;
};

/// \name Unicode string comparison operators
/// \{

/**
 * \brief Indicates whether or not two Unicode strings are the same.
 *
 * \param lhs the left-hand side string.
 * \param rhs the right-hand side string.
 *
 * \return `true` if the strings are the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto operator==(const unicode_string& lhs, const unicode_string& rhs)
    -> bool
{
  if (lhs.size() != rhs.size()) {
    return false;
  }

  for (unicode_string::size_type index = 0; index < lhs.size(); ++index) {
    const auto a = lhs.at(index);
    const auto b = rhs.at(index);
    if (a != b) {
      return false;
    }
  }

  return true;
}

/**
 * \brief Indicates whether or not two Unicode strings aren't the same.
 *
 * \param lhs the left-hand side string.
 * \param rhs the right-hand side string.
 *
 * \return `true` if the strings are the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto operator!=(const unicode_string& lhs, const unicode_string& rhs)
    -> bool
{
  return !(lhs == rhs);
}

/// \} End of unicode string comparison operators

namespace literals {

/**
 * \brief Creates a `unicode` value from a `char`.
 *
 * \param c the character used to create the unicode value.
 *
 * \return a `unicode` value.
 *
 * \since 5.0.0
 */
constexpr auto operator""_uni(const char c) noexcept -> unicode
{
  return static_cast<unicode>(c);
}

/**
 * \brief Creates a `unicode` value from a integral value.
 *
 * \param i the integer used to create the unicode value.
 *
 * \return a `unicode` value.
 *
 * \since 5.0.0
 */
constexpr auto operator""_uni(const ulonglong i) noexcept -> unicode
{
  return static_cast<unicode>(i);
}

}  // namespace literals

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_UNICODE_STRING_HEADER


namespace cen {

/// \addtogroup video
/// \{

/**
 * \struct glyph_metrics
 *
 * \brief Provides metrics about a glyph in a font.
 *
 * \since 4.0.0
 */
struct glyph_metrics final
{
  int minX;     ///< The minimum X-offset.
  int minY;     ///< The minimum Y-offset.
  int maxX;     ///< The maximum X-offset.
  int maxY;     ///< The maximum Y-offset.
  int advance;  ///< The advance offset.
};

/**
 * \enum font_hint
 *
 * \brief Provides different possible TrueType font hint values.
 *
 * \since 3.1.0
 */
enum class font_hint : int
{
  normal = TTF_HINTING_NORMAL,
  light = TTF_HINTING_LIGHT,
  mono = TTF_HINTING_MONO,
  none = TTF_HINTING_NONE
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied font hint.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(font_hint::light) == "light"`.
 *
 * \param hint the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const font_hint hint) -> std::string_view
{
  switch (hint) {
    case font_hint::normal:
      return "normal";

    case font_hint::light:
      return "light";

    case font_hint::mono:
      return "mono";

    case font_hint::none:
      return "none";

    default:
      throw cen_error{"Did not recognize font hint!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a font hint enumerator.
 *
 * \param stream the output stream that will be used.
 * \param hint the enumerator that will be printed.
 *
 * \see `to_string(font_hint)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const font_hint hint) -> std::ostream&
{
  return stream << to_string(hint);
}

/// \} End of streaming

/**
 * \class font
 *
 * \brief Represents a TrueType font.
 *
 * \details This class provides information about a TrueType font, but it can also be used
 * for text rendering and obtaining information about the size of rendered strings, etc.
 *
 * \see `TTF_Font`
 *
 * \since 3.0.0
 */
class font final
{
 public:
  /// \name Construction
  /// \{

  /**
   * \brief Creates a font based on the `.ttf`-file at the specified path.
   *
   * \param file the file path of the TrueType font file, mustn't be null.
   * \param size the font size, must be greater than zero.
   *
   * \throws cen_error if the supplied size is not greater than zero.
   * \throws ttf_error if the font cannot be loaded.
   *
   * \since 3.0.0
   */
  font(const not_null<str> file, const int size) : m_size{size}
  {
    assert(file);

    if (size <= 0) {
      throw cen_error{"Bad font size!"};
    }

    m_font.reset(TTF_OpenFont(file, size));
    if (!m_font) {
      throw ttf_error{};
    }
  }

  /**
   * \brief Creates a font based on the `.ttf`-file at the specified path.
   *
   * \param file the file path of the TrueType font file.
   * \param size the font size, must be greater than zero.
   *
   * \throws cen_error if the supplied size is not greater than zero.
   * \throws ttf_error if the font cannot be loaded.
   *
   * \since 5.3.0
   */
  font(const std::string& file, const int size) : font{file.c_str(), size}
  {}

  /// \} End of construction

  /// \name Style functions
  /// \{

  /**
   * \brief Resets the style of the font.
   *
   * \since 3.0.0
   */
  void reset() noexcept
  {
    TTF_SetFontStyle(m_font.get(), TTF_STYLE_NORMAL);
  }

  /**
   * \brief Sets whether the font is bold.
   *
   * \param bold `true` if the font should be bold; `false` otherwise.
   *
   * \since 3.0.0
   */
  void set_bold(const bool bold) noexcept
  {
    if (bold) {
      add_style(TTF_STYLE_BOLD);
    }
    else {
      remove_style(TTF_STYLE_BOLD);
    }
  }

  /**
   * \brief Sets whether the font is italic.
   *
   * \param italic `true` if the font should be italic; `false` otherwise.
   *
   * \since 3.0.0
   */
  void set_italic(const bool italic) noexcept
  {
    if (italic) {
      add_style(TTF_STYLE_ITALIC);
    }
    else {
      remove_style(TTF_STYLE_ITALIC);
    }
  }

  /**
   * \brief Sets whether the font is underlined.
   *
   * \param underlined `true` if the font should be underlined; `false` otherwise.
   *
   * \since 3.0.0
   */
  void set_underlined(const bool underlined) noexcept
  {
    if (underlined) {
      add_style(TTF_STYLE_UNDERLINE);
    }
    else {
      remove_style(TTF_STYLE_UNDERLINE);
    }
  }

  /**
   * \brief Sets whether the font is strikethrough.
   *
   * \param strikethrough `true` if the font should be strikethrough; `false` otherwise.
   *
   * \since 3.0.0
   */
  void set_strikethrough(const bool strikethrough) noexcept
  {
    if (strikethrough) {
      add_style(TTF_STYLE_STRIKETHROUGH);
    }
    else {
      remove_style(TTF_STYLE_STRIKETHROUGH);
    }
  }

  /**
   * \brief Sets the outline size of the font.
   *
   * \param outline the outline size, in pixels; `0` is used to disable outlining.
   *
   * \since 5.0.0
   */
  void set_outline(const int outline) noexcept
  {
    TTF_SetFontOutline(m_font.get(), outline);
  }

  /**
   * \brief Sets the TrueType font hint of the font.
   *
   * \param hint the font hinting that will be used.
   *
   * \since 3.1.0
   */
  void set_font_hinting(const font_hint hint) noexcept
  {
    TTF_SetFontHinting(m_font.get(), to_underlying(hint));
  }

  /**
   * \brief Sets whether or not font kerning is allowed.
   *
   * \details Kerning is the process of adjusting the spacing between certain characters
   * in order to improve the appearance of a font.
   *
   * \param kerning `true` if kerning should be allowed; `false` otherwise.
   *
   * \since 4.0.0
   */
  void set_kerning(const bool kerning) noexcept
  {
    TTF_SetFontKerning(m_font.get(), kerning ? 1 : 0);
  }

  /**
   * \brief Indicates whether or not the font is bold.
   *
   * \return `true` if the font is bold; `false` otherwise.
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto is_bold() const noexcept -> bool
  {
    return TTF_GetFontStyle(m_font.get()) & TTF_STYLE_BOLD;
  }

  /**
   * \brief Indicates whether or not the font is italic.
   *
   * \return `true` if the font is italic; `false` otherwise.
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto is_italic() const noexcept -> bool
  {
    return TTF_GetFontStyle(m_font.get()) & TTF_STYLE_ITALIC;
  }

  /**
   * \brief Indicates whether or not the font is underlined.
   *
   * \return `true` if the font is underlined; `false` otherwise.
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto is_underlined() const noexcept -> bool
  {
    return TTF_GetFontStyle(m_font.get()) & TTF_STYLE_UNDERLINE;
  }

  /**
   * \brief Indicates whether or not the font is a strikethrough font.
   *
   * \return `true` if the font is a strikethrough font; `false` otherwise.
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto is_strikethrough() const noexcept -> bool
  {
    return TTF_GetFontStyle(m_font.get()) & TTF_STYLE_STRIKETHROUGH;
  }

  /**
   * \brief Returns the size of the outline of the font.
   *
   * \return the current outline size, in pixels.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto outline() const noexcept -> int
  {
    return TTF_GetFontOutline(m_font.get());
  }

  /**
   * \brief Returns the TrueType font hinting of the font.
   *
   * \details This property is set to `Normal` by default.
   *
   * \return the TrueType font hinting of the font.
   *
   * \since 3.1.0
   */
  [[nodiscard]] auto font_hinting() const noexcept -> font_hint
  {
    return static_cast<font_hint>(TTF_GetFontHinting(m_font.get()));
  }

  /**
   * \brief Indicates whether or not kerning is being used.
   *
   * \return `true` if kerning is being used by the font; `false` otherwise.
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto has_kerning() const noexcept -> bool
  {
    return TTF_GetFontKerning(m_font.get());
  }

  /// \} End of style functions

  /// \name Queries
  /// \{

  /**
   * \brief Returns the maximum height of a character in this font.
   *
   * \details This is usually the same as the point size.
   *
   * \return the maximum height of a character in this font.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto height() const noexcept -> int
  {
    return TTF_FontHeight(m_font.get());
  }

  /**
   * \brief Returns the offset from the baseline to the bottom of the font characters.
   *
   * \details The returned value is negative, relative to the baseline.
   *
   * \return the offset from the baseline to the bottom of the font characters.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto descent() const noexcept -> int
  {
    return TTF_FontDescent(m_font.get());
  }

  /**
   * \brief Returns the offset from the baseline to the top of the font characters.
   *
   * \details The returned value is positive, relative to the baseline.
   *
   * \return the offset from the baseline to the top of the font characters.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto ascent() const noexcept -> int
  {
    return TTF_FontAscent(m_font.get());
  }

  /**
   * \brief Returns the recommended pixel height of rendered text in the font.
   *
   * \details The returned value is usually larger than the height of the font.
   *
   * \return Returns the recommended pixel height of rendered text in the font.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto line_skip() const noexcept -> int
  {
    return TTF_FontLineSkip(m_font.get());
  }

  /**
   * \brief Returns the number of available font faces in the font.
   *
   * \return the number of available font faces in the font.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto font_faces() const noexcept -> int
  {
    return static_cast<int>(TTF_FontFaces(m_font.get()));
  }

  /**
   * \brief Indicates whether or not the font is outlined.
   *
   * \return `true` if the font is outlined; `false` otherwise.
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto is_outlined() const noexcept -> bool
  {
    return TTF_GetFontOutline(m_font.get()) != 0;
  }

  /**
   * \brief Indicates whether or not the font is fixed width.
   *
   * \return `true` if the font is fixed width; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_fixed_width() const noexcept -> bool
  {
    return TTF_FontFaceIsFixedWidth(m_font.get());
  }

  /**
   * \brief Returns the family name of the font.
   *
   * \return the family name of the font.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto family_name() const noexcept -> str
  {
    return TTF_FontFaceFamilyName(m_font.get());
  }

  /**
   * \brief Returns the font face style name of the font.
   *
   * \note This information may not be available.
   *
   * \return the font face style name of the font; `nullptr` if it isn't available.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto style_name() const noexcept -> str
  {
    return TTF_FontFaceStyleName(m_font.get());
  }

  /**
   * \brief Returns the size of the font.
   *
   * \return the size of the font.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto size() const noexcept -> int
  {
    return m_size;
  }

  /// \} End of queries

  /// \name Glyph information
  /// \{

  /**
   * \brief Returns the kerning amount between two glyphs in the font, if kerning would be
   * enabled.
   *
   * \details In other words, you can use this function to obtain the kerning amount
   * between, for instance, the characters 'a' and 'V' if they were to be rendered next to
   * each other.
   *
   * \param firstGlyph the first glyph.
   * \param secondGlyph the second glyph.
   *
   * \return the kerning amount between to glyphs in the font.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto kerning_amount(const unicode firstGlyph,
                                    const unicode secondGlyph) const noexcept -> int
  {
    return TTF_GetFontKerningSizeGlyphs(m_font.get(), firstGlyph, secondGlyph);
  }

  /**
   * \brief Indicates whether or not the specified glyph is available in the font.
   *
   * \param glyph the unicode glyph that will be checked.
   *
   * \return `true` if the glyph is available in the font; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_glyph_provided(const unicode glyph) const noexcept -> bool
  {
    return TTF_GlyphIsProvided(m_font.get(), glyph);
  }

  /**
   * \brief Returns the metrics of the specified glyph in this font.
   *
   * \param glyph the glyph to obtain the metrics of.
   *
   * \return the metrics of the specified glyph; std::nullopt if the metrics couldn't be
   * obtained.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get_metrics(const unicode glyph) const noexcept
      -> std::optional<glyph_metrics>
  {
    glyph_metrics metrics{};
    if (TTF_GlyphMetrics(m_font.get(),
                         glyph,
                         &metrics.minX,
                         &metrics.maxX,
                         &metrics.minY,
                         &metrics.maxY,
                         &metrics.advance) != -1)
    {
      return metrics;
    }
    else {
      return std::nullopt;
    }
  }

  /// \} End of glyph information

  /// \name Rendered string size functions
  /// \{

  /**
   * \brief Returns the size of the supplied string, if it was rendered using the font.
   *
   * \param str the string to determine the size of, can't be null.
   *
   * \return the size of the string, if it was rendered using the font; `std::nullopt` if
   * something goes wrong.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto string_size(const not_null<str> str) const noexcept
      -> std::optional<iarea>
  {
    assert(str);

    iarea size{};
    if (TTF_SizeText(m_font.get(), str, &size.width, &size.height) != -1) {
      return size;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the size of the supplied string, if it was rendered using the font.
   *
   * \param str the string to determine the size of.
   *
   * \return the size of the string, if it was rendered using the font; `std::nullopt` if
   * something goes wrong.
   *
   * \since 5.3.0
   */
  [[nodiscard]] auto string_size(const std::string& str) const noexcept -> std::optional<iarea>
  {
    return string_size(str.c_str());
  }

  /**
   * \brief Returns the width of the supplied string, if it was rendered using the font.
   *
   * \param str the string to determine the width of, can't be null.
   *
   * \return the width of the supplied string, if it was rendered using the font;
   * `std::nullopt` if something goes wrong.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto string_width(const not_null<str> str) const noexcept -> std::optional<int>
  {
    if (const auto size = string_size(str)) {
      return size->width;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the width of the supplied string, if it was rendered using the font.
   *
   * \param str the string to determine the width of.
   *
   * \return the width of the supplied string, if it was rendered using the font;
   * `std::nullopt` if something goes wrong.
   *
   * \since 5.3.0
   */
  [[nodiscard]] auto string_width(const std::string& str) const noexcept -> std::optional<int>
  {
    return string_width(str.c_str());
  }

  /**
   * \brief Returns the height of the supplied string, if it was rendered using the font.
   *
   * \param str the string to determine the height of, can't be null.
   *
   * \return the height of the supplied string, if it was rendered using the font;
   * `std::nullopt` if something goes wrong.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto string_height(const not_null<str> str) const noexcept
      -> std::optional<int>
  {
    if (const auto size = string_size(str)) {
      return size->height;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the height of the supplied string, if it was rendered using the font.
   *
   * \param str the string to determine the height of.
   *
   * \return the height of the supplied string, if it was rendered using the font;
   * `std::nullopt` if something goes wrong.
   *
   * \since 5.3.0
   */
  [[nodiscard]] auto string_height(const std::string& str) const noexcept -> std::optional<int>
  {
    return string_height(str.c_str());
  }

  /// \} End of rendered string size functions

  /// \name Conversions
  /// \{

  /**
   * \brief Converts to `TTF_Font*`.
   *
   * \return a pointer to the associated `TTF_Font` instance.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit operator TTF_Font*() noexcept
  {
    return m_font.get();
  }

  /**
   * \brief Converts to `const TTF_Font*`.
   *
   * \return a pointer to the associated `TTF_Font` instance.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit operator const TTF_Font*() const noexcept
  {
    return m_font.get();
  }

  /// \} End of conversions

  /**
   * \brief Returns a pointer to the associated `TTF_Font`.
   *
   * \warning Use of this function is not recommended. However, it's useful since many SDL
   * calls use non-const pointers even when no change will be applied.
   *
   * \warning Don't take ownership of the returned pointer!
   *
   * \return a pointer to the associated `TTF_Font`.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get() const noexcept -> TTF_Font*
  {
    return m_font.get();
  }

 private:
  struct deleter final
  {
    void operator()(TTF_Font* font) noexcept
    {
      TTF_CloseFont(font);
    }
  };

  std::unique_ptr<TTF_Font, deleter> m_font;
  int m_size{};

  /**
   * \brief Enables the font style associated with the supplied bit mask.
   *
   * \details The possible values are `TTF_STYLE_BOLD`, `TTF_STYLE_ITALIC`,
   * `TTF_STYLE_UNDERLINE` and `TTF_STYLE_STRIKETHROUGH`.
   *
   * \param mask the bit mask of the font style to enable.
   *
   * \since 3.0.0
   */
  void add_style(const int mask) noexcept
  {
    const auto style = TTF_GetFontStyle(m_font.get());
    TTF_SetFontStyle(m_font.get(), style | mask);
  }

  /**
   * \brief Removes the font style associated with the supplied bit mask.
   *
   * \details The possible values are `TTF_STYLE_BOLD`, `TTF_STYLE_ITALIC`,
   * `TTF_STYLE_UNDERLINE` and `TTF_STYLE_STRIKETHROUGH`.
   *
   * \param mask the bit mask of the font style to disable.
   *
   * \since 3.0.0
   */
  void remove_style(const int mask) noexcept
  {
    const auto style = TTF_GetFontStyle(m_font.get());
    TTF_SetFontStyle(m_font.get(), style & ~mask);
  }
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a font instance.
 *
 * \return a textual representation of the font instance.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto to_string(const font& font) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("font{{data: {}, name: {}, size: {}}}",
                     detail::address_of(font.get()),
                     font.family_name(),
                     font.size());
#else
  return "font{data: " + detail::address_of(font.get()) +
         ", name: " + std::string{font.family_name()} +
         ", size: " + std::to_string(font.size()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a font.
 *
 * \param stream the stream that will be used.
 * \param font the font instance that will be printed.
 *
 * \return the stream that was used.
 *
 * \since 5.0.0
 */
inline auto operator<<(std::ostream& stream, const font& font) -> std::ostream&
{
  return stream << to_string(font);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_NO_SDL_TTF
#endif  // CENTURION_FONT_HEADER
// #include "centurion/video/font_cache.hpp"
#ifndef CENTURION_FONT_CACHE_HEADER
#define CENTURION_FONT_CACHE_HEADER

#ifndef CENTURION_NO_SDL_TTF

#include <SDL_ttf.h>

#include <cassert>        // assert
#include <string>         // string
#include <unordered_map>  // unordered_map
#include <utility>        // move, forward

// #include "../core/not_null.hpp"

// #include "../core/str.hpp"

// #include "font.hpp"
#ifndef CENTURION_FONT_HEADER
#define CENTURION_FONT_HEADER

#ifndef CENTURION_NO_SDL_TTF

#include <SDL_ttf.h>

#include <cassert>      // assert
#include <memory>       // unique_ptr
#include <optional>     // optional
#include <ostream>      // ostream
#include <string>       // string, to_string
#include <string_view>  // string_view

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/not_null.hpp"

// #include "../core/str.hpp"

// #include "../core/to_underlying.hpp"

// #include "../detail/address_of.hpp"

// #include "../math/area.hpp"

// #include "unicode_string.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \struct glyph_metrics
 *
 * \brief Provides metrics about a glyph in a font.
 *
 * \since 4.0.0
 */
struct glyph_metrics final
{
  int minX;     ///< The minimum X-offset.
  int minY;     ///< The minimum Y-offset.
  int maxX;     ///< The maximum X-offset.
  int maxY;     ///< The maximum Y-offset.
  int advance;  ///< The advance offset.
};

/**
 * \enum font_hint
 *
 * \brief Provides different possible TrueType font hint values.
 *
 * \since 3.1.0
 */
enum class font_hint : int
{
  normal = TTF_HINTING_NORMAL,
  light = TTF_HINTING_LIGHT,
  mono = TTF_HINTING_MONO,
  none = TTF_HINTING_NONE
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied font hint.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(font_hint::light) == "light"`.
 *
 * \param hint the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const font_hint hint) -> std::string_view
{
  switch (hint) {
    case font_hint::normal:
      return "normal";

    case font_hint::light:
      return "light";

    case font_hint::mono:
      return "mono";

    case font_hint::none:
      return "none";

    default:
      throw cen_error{"Did not recognize font hint!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a font hint enumerator.
 *
 * \param stream the output stream that will be used.
 * \param hint the enumerator that will be printed.
 *
 * \see `to_string(font_hint)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const font_hint hint) -> std::ostream&
{
  return stream << to_string(hint);
}

/// \} End of streaming

/**
 * \class font
 *
 * \brief Represents a TrueType font.
 *
 * \details This class provides information about a TrueType font, but it can also be used
 * for text rendering and obtaining information about the size of rendered strings, etc.
 *
 * \see `TTF_Font`
 *
 * \since 3.0.0
 */
class font final
{
 public:
  /// \name Construction
  /// \{

  /**
   * \brief Creates a font based on the `.ttf`-file at the specified path.
   *
   * \param file the file path of the TrueType font file, mustn't be null.
   * \param size the font size, must be greater than zero.
   *
   * \throws cen_error if the supplied size is not greater than zero.
   * \throws ttf_error if the font cannot be loaded.
   *
   * \since 3.0.0
   */
  font(const not_null<str> file, const int size) : m_size{size}
  {
    assert(file);

    if (size <= 0) {
      throw cen_error{"Bad font size!"};
    }

    m_font.reset(TTF_OpenFont(file, size));
    if (!m_font) {
      throw ttf_error{};
    }
  }

  /**
   * \brief Creates a font based on the `.ttf`-file at the specified path.
   *
   * \param file the file path of the TrueType font file.
   * \param size the font size, must be greater than zero.
   *
   * \throws cen_error if the supplied size is not greater than zero.
   * \throws ttf_error if the font cannot be loaded.
   *
   * \since 5.3.0
   */
  font(const std::string& file, const int size) : font{file.c_str(), size}
  {}

  /// \} End of construction

  /// \name Style functions
  /// \{

  /**
   * \brief Resets the style of the font.
   *
   * \since 3.0.0
   */
  void reset() noexcept
  {
    TTF_SetFontStyle(m_font.get(), TTF_STYLE_NORMAL);
  }

  /**
   * \brief Sets whether the font is bold.
   *
   * \param bold `true` if the font should be bold; `false` otherwise.
   *
   * \since 3.0.0
   */
  void set_bold(const bool bold) noexcept
  {
    if (bold) {
      add_style(TTF_STYLE_BOLD);
    }
    else {
      remove_style(TTF_STYLE_BOLD);
    }
  }

  /**
   * \brief Sets whether the font is italic.
   *
   * \param italic `true` if the font should be italic; `false` otherwise.
   *
   * \since 3.0.0
   */
  void set_italic(const bool italic) noexcept
  {
    if (italic) {
      add_style(TTF_STYLE_ITALIC);
    }
    else {
      remove_style(TTF_STYLE_ITALIC);
    }
  }

  /**
   * \brief Sets whether the font is underlined.
   *
   * \param underlined `true` if the font should be underlined; `false` otherwise.
   *
   * \since 3.0.0
   */
  void set_underlined(const bool underlined) noexcept
  {
    if (underlined) {
      add_style(TTF_STYLE_UNDERLINE);
    }
    else {
      remove_style(TTF_STYLE_UNDERLINE);
    }
  }

  /**
   * \brief Sets whether the font is strikethrough.
   *
   * \param strikethrough `true` if the font should be strikethrough; `false` otherwise.
   *
   * \since 3.0.0
   */
  void set_strikethrough(const bool strikethrough) noexcept
  {
    if (strikethrough) {
      add_style(TTF_STYLE_STRIKETHROUGH);
    }
    else {
      remove_style(TTF_STYLE_STRIKETHROUGH);
    }
  }

  /**
   * \brief Sets the outline size of the font.
   *
   * \param outline the outline size, in pixels; `0` is used to disable outlining.
   *
   * \since 5.0.0
   */
  void set_outline(const int outline) noexcept
  {
    TTF_SetFontOutline(m_font.get(), outline);
  }

  /**
   * \brief Sets the TrueType font hint of the font.
   *
   * \param hint the font hinting that will be used.
   *
   * \since 3.1.0
   */
  void set_font_hinting(const font_hint hint) noexcept
  {
    TTF_SetFontHinting(m_font.get(), to_underlying(hint));
  }

  /**
   * \brief Sets whether or not font kerning is allowed.
   *
   * \details Kerning is the process of adjusting the spacing between certain characters
   * in order to improve the appearance of a font.
   *
   * \param kerning `true` if kerning should be allowed; `false` otherwise.
   *
   * \since 4.0.0
   */
  void set_kerning(const bool kerning) noexcept
  {
    TTF_SetFontKerning(m_font.get(), kerning ? 1 : 0);
  }

  /**
   * \brief Indicates whether or not the font is bold.
   *
   * \return `true` if the font is bold; `false` otherwise.
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto is_bold() const noexcept -> bool
  {
    return TTF_GetFontStyle(m_font.get()) & TTF_STYLE_BOLD;
  }

  /**
   * \brief Indicates whether or not the font is italic.
   *
   * \return `true` if the font is italic; `false` otherwise.
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto is_italic() const noexcept -> bool
  {
    return TTF_GetFontStyle(m_font.get()) & TTF_STYLE_ITALIC;
  }

  /**
   * \brief Indicates whether or not the font is underlined.
   *
   * \return `true` if the font is underlined; `false` otherwise.
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto is_underlined() const noexcept -> bool
  {
    return TTF_GetFontStyle(m_font.get()) & TTF_STYLE_UNDERLINE;
  }

  /**
   * \brief Indicates whether or not the font is a strikethrough font.
   *
   * \return `true` if the font is a strikethrough font; `false` otherwise.
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto is_strikethrough() const noexcept -> bool
  {
    return TTF_GetFontStyle(m_font.get()) & TTF_STYLE_STRIKETHROUGH;
  }

  /**
   * \brief Returns the size of the outline of the font.
   *
   * \return the current outline size, in pixels.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto outline() const noexcept -> int
  {
    return TTF_GetFontOutline(m_font.get());
  }

  /**
   * \brief Returns the TrueType font hinting of the font.
   *
   * \details This property is set to `Normal` by default.
   *
   * \return the TrueType font hinting of the font.
   *
   * \since 3.1.0
   */
  [[nodiscard]] auto font_hinting() const noexcept -> font_hint
  {
    return static_cast<font_hint>(TTF_GetFontHinting(m_font.get()));
  }

  /**
   * \brief Indicates whether or not kerning is being used.
   *
   * \return `true` if kerning is being used by the font; `false` otherwise.
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto has_kerning() const noexcept -> bool
  {
    return TTF_GetFontKerning(m_font.get());
  }

  /// \} End of style functions

  /// \name Queries
  /// \{

  /**
   * \brief Returns the maximum height of a character in this font.
   *
   * \details This is usually the same as the point size.
   *
   * \return the maximum height of a character in this font.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto height() const noexcept -> int
  {
    return TTF_FontHeight(m_font.get());
  }

  /**
   * \brief Returns the offset from the baseline to the bottom of the font characters.
   *
   * \details The returned value is negative, relative to the baseline.
   *
   * \return the offset from the baseline to the bottom of the font characters.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto descent() const noexcept -> int
  {
    return TTF_FontDescent(m_font.get());
  }

  /**
   * \brief Returns the offset from the baseline to the top of the font characters.
   *
   * \details The returned value is positive, relative to the baseline.
   *
   * \return the offset from the baseline to the top of the font characters.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto ascent() const noexcept -> int
  {
    return TTF_FontAscent(m_font.get());
  }

  /**
   * \brief Returns the recommended pixel height of rendered text in the font.
   *
   * \details The returned value is usually larger than the height of the font.
   *
   * \return Returns the recommended pixel height of rendered text in the font.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto line_skip() const noexcept -> int
  {
    return TTF_FontLineSkip(m_font.get());
  }

  /**
   * \brief Returns the number of available font faces in the font.
   *
   * \return the number of available font faces in the font.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto font_faces() const noexcept -> int
  {
    return static_cast<int>(TTF_FontFaces(m_font.get()));
  }

  /**
   * \brief Indicates whether or not the font is outlined.
   *
   * \return `true` if the font is outlined; `false` otherwise.
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto is_outlined() const noexcept -> bool
  {
    return TTF_GetFontOutline(m_font.get()) != 0;
  }

  /**
   * \brief Indicates whether or not the font is fixed width.
   *
   * \return `true` if the font is fixed width; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_fixed_width() const noexcept -> bool
  {
    return TTF_FontFaceIsFixedWidth(m_font.get());
  }

  /**
   * \brief Returns the family name of the font.
   *
   * \return the family name of the font.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto family_name() const noexcept -> str
  {
    return TTF_FontFaceFamilyName(m_font.get());
  }

  /**
   * \brief Returns the font face style name of the font.
   *
   * \note This information may not be available.
   *
   * \return the font face style name of the font; `nullptr` if it isn't available.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto style_name() const noexcept -> str
  {
    return TTF_FontFaceStyleName(m_font.get());
  }

  /**
   * \brief Returns the size of the font.
   *
   * \return the size of the font.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto size() const noexcept -> int
  {
    return m_size;
  }

  /// \} End of queries

  /// \name Glyph information
  /// \{

  /**
   * \brief Returns the kerning amount between two glyphs in the font, if kerning would be
   * enabled.
   *
   * \details In other words, you can use this function to obtain the kerning amount
   * between, for instance, the characters 'a' and 'V' if they were to be rendered next to
   * each other.
   *
   * \param firstGlyph the first glyph.
   * \param secondGlyph the second glyph.
   *
   * \return the kerning amount between to glyphs in the font.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto kerning_amount(const unicode firstGlyph,
                                    const unicode secondGlyph) const noexcept -> int
  {
    return TTF_GetFontKerningSizeGlyphs(m_font.get(), firstGlyph, secondGlyph);
  }

  /**
   * \brief Indicates whether or not the specified glyph is available in the font.
   *
   * \param glyph the unicode glyph that will be checked.
   *
   * \return `true` if the glyph is available in the font; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_glyph_provided(const unicode glyph) const noexcept -> bool
  {
    return TTF_GlyphIsProvided(m_font.get(), glyph);
  }

  /**
   * \brief Returns the metrics of the specified glyph in this font.
   *
   * \param glyph the glyph to obtain the metrics of.
   *
   * \return the metrics of the specified glyph; std::nullopt if the metrics couldn't be
   * obtained.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get_metrics(const unicode glyph) const noexcept
      -> std::optional<glyph_metrics>
  {
    glyph_metrics metrics{};
    if (TTF_GlyphMetrics(m_font.get(),
                         glyph,
                         &metrics.minX,
                         &metrics.maxX,
                         &metrics.minY,
                         &metrics.maxY,
                         &metrics.advance) != -1)
    {
      return metrics;
    }
    else {
      return std::nullopt;
    }
  }

  /// \} End of glyph information

  /// \name Rendered string size functions
  /// \{

  /**
   * \brief Returns the size of the supplied string, if it was rendered using the font.
   *
   * \param str the string to determine the size of, can't be null.
   *
   * \return the size of the string, if it was rendered using the font; `std::nullopt` if
   * something goes wrong.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto string_size(const not_null<str> str) const noexcept
      -> std::optional<iarea>
  {
    assert(str);

    iarea size{};
    if (TTF_SizeText(m_font.get(), str, &size.width, &size.height) != -1) {
      return size;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the size of the supplied string, if it was rendered using the font.
   *
   * \param str the string to determine the size of.
   *
   * \return the size of the string, if it was rendered using the font; `std::nullopt` if
   * something goes wrong.
   *
   * \since 5.3.0
   */
  [[nodiscard]] auto string_size(const std::string& str) const noexcept -> std::optional<iarea>
  {
    return string_size(str.c_str());
  }

  /**
   * \brief Returns the width of the supplied string, if it was rendered using the font.
   *
   * \param str the string to determine the width of, can't be null.
   *
   * \return the width of the supplied string, if it was rendered using the font;
   * `std::nullopt` if something goes wrong.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto string_width(const not_null<str> str) const noexcept -> std::optional<int>
  {
    if (const auto size = string_size(str)) {
      return size->width;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the width of the supplied string, if it was rendered using the font.
   *
   * \param str the string to determine the width of.
   *
   * \return the width of the supplied string, if it was rendered using the font;
   * `std::nullopt` if something goes wrong.
   *
   * \since 5.3.0
   */
  [[nodiscard]] auto string_width(const std::string& str) const noexcept -> std::optional<int>
  {
    return string_width(str.c_str());
  }

  /**
   * \brief Returns the height of the supplied string, if it was rendered using the font.
   *
   * \param str the string to determine the height of, can't be null.
   *
   * \return the height of the supplied string, if it was rendered using the font;
   * `std::nullopt` if something goes wrong.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto string_height(const not_null<str> str) const noexcept
      -> std::optional<int>
  {
    if (const auto size = string_size(str)) {
      return size->height;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the height of the supplied string, if it was rendered using the font.
   *
   * \param str the string to determine the height of.
   *
   * \return the height of the supplied string, if it was rendered using the font;
   * `std::nullopt` if something goes wrong.
   *
   * \since 5.3.0
   */
  [[nodiscard]] auto string_height(const std::string& str) const noexcept -> std::optional<int>
  {
    return string_height(str.c_str());
  }

  /// \} End of rendered string size functions

  /// \name Conversions
  /// \{

  /**
   * \brief Converts to `TTF_Font*`.
   *
   * \return a pointer to the associated `TTF_Font` instance.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit operator TTF_Font*() noexcept
  {
    return m_font.get();
  }

  /**
   * \brief Converts to `const TTF_Font*`.
   *
   * \return a pointer to the associated `TTF_Font` instance.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit operator const TTF_Font*() const noexcept
  {
    return m_font.get();
  }

  /// \} End of conversions

  /**
   * \brief Returns a pointer to the associated `TTF_Font`.
   *
   * \warning Use of this function is not recommended. However, it's useful since many SDL
   * calls use non-const pointers even when no change will be applied.
   *
   * \warning Don't take ownership of the returned pointer!
   *
   * \return a pointer to the associated `TTF_Font`.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get() const noexcept -> TTF_Font*
  {
    return m_font.get();
  }

 private:
  struct deleter final
  {
    void operator()(TTF_Font* font) noexcept
    {
      TTF_CloseFont(font);
    }
  };

  std::unique_ptr<TTF_Font, deleter> m_font;
  int m_size{};

  /**
   * \brief Enables the font style associated with the supplied bit mask.
   *
   * \details The possible values are `TTF_STYLE_BOLD`, `TTF_STYLE_ITALIC`,
   * `TTF_STYLE_UNDERLINE` and `TTF_STYLE_STRIKETHROUGH`.
   *
   * \param mask the bit mask of the font style to enable.
   *
   * \since 3.0.0
   */
  void add_style(const int mask) noexcept
  {
    const auto style = TTF_GetFontStyle(m_font.get());
    TTF_SetFontStyle(m_font.get(), style | mask);
  }

  /**
   * \brief Removes the font style associated with the supplied bit mask.
   *
   * \details The possible values are `TTF_STYLE_BOLD`, `TTF_STYLE_ITALIC`,
   * `TTF_STYLE_UNDERLINE` and `TTF_STYLE_STRIKETHROUGH`.
   *
   * \param mask the bit mask of the font style to disable.
   *
   * \since 3.0.0
   */
  void remove_style(const int mask) noexcept
  {
    const auto style = TTF_GetFontStyle(m_font.get());
    TTF_SetFontStyle(m_font.get(), style & ~mask);
  }
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a font instance.
 *
 * \return a textual representation of the font instance.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto to_string(const font& font) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("font{{data: {}, name: {}, size: {}}}",
                     detail::address_of(font.get()),
                     font.family_name(),
                     font.size());
#else
  return "font{data: " + detail::address_of(font.get()) +
         ", name: " + std::string{font.family_name()} +
         ", size: " + std::to_string(font.size()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a font.
 *
 * \param stream the stream that will be used.
 * \param font the font instance that will be printed.
 *
 * \return the stream that was used.
 *
 * \since 5.0.0
 */
inline auto operator<<(std::ostream& stream, const font& font) -> std::ostream&
{
  return stream << to_string(font);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_NO_SDL_TTF
#endif  // CENTURION_FONT_HEADER
// #include "surface.hpp"

// #include "texture.hpp"
#ifndef CENTURION_TEXTURE_HEADER
#define CENTURION_TEXTURE_HEADER

#include <SDL.h>

// #include "../compiler/features.hpp"


#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#include <cassert>  // assert
#include <ostream>  // ostream
#include <string>   // string, to_string

#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/not_null.hpp"

// #include "../core/owner.hpp"

// #include "../core/result.hpp"

// #include "../core/str.hpp"

// #include "../detail/address_of.hpp"

// #include "../detail/owner_handle_api.hpp"

// #include "../math/area.hpp"

// #include "../math/point.hpp"

// #include "blend_mode.hpp"

// #include "color.hpp"

// #include "pixel_format_info.hpp"

// #include "scale_mode.hpp"
#ifndef CENTURION_SCALE_MODE_HEADER
#define CENTURION_SCALE_MODE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup video
/// \{

#if SDL_VERSION_ATLEAST(2, 0, 12)

/**
 * \enum scale_mode
 *
 * \brief Represents different texture scale modes.
 *
 * \since 4.0.0
 *
 * \see `SDL_ScaleMode`
 */
enum class scale_mode
{
  nearest = SDL_ScaleModeNearest,  ///< Represents nearest pixel sampling.
  linear = SDL_ScaleModeLinear,    ///< Represents linear filtering.
  best = SDL_ScaleModeBest         ///< Represents anisotropic filtering.
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied scale mode.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(scale_mode::linear) == "linear"`.
 *
 * \param mode the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const scale_mode mode) -> std::string_view
{
  switch (mode) {
    case scale_mode::nearest:
      return "nearest";

    case scale_mode::linear:
      return "linear";

    case scale_mode::best:
      return "best";

    default:
      throw cen_error{"Did not recognize scale mode!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a scale mode enumerator.
 *
 * \param stream the output stream that will be used.
 * \param mode the enumerator that will be printed.
 *
 * \see `to_string(scale_mode)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const scale_mode mode) -> std::ostream&
{
  return stream << to_string(mode);
}

/// \} End of streaming

/// \name Scale mode comparison operators
/// \{

/**
 * \brief Indicates whether or not the two scale mode values are the same.
 *
 * \param lhs the lhs scale mode value.
 * \param rhs the rhs scale mode value.
 *
 * \return `true` if the scale mode values are the same; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator==(const scale_mode lhs, const SDL_ScaleMode rhs) noexcept
    -> bool
{
  return static_cast<SDL_ScaleMode>(lhs) == rhs;
}

/// \copydoc operator==(scale_mode, SDL_ScaleMode)
[[nodiscard]] constexpr auto operator==(const SDL_ScaleMode lhs, const scale_mode rhs) noexcept
    -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the two scale mode values aren't the same.
 *
 * \param lhs the lhs scale mode value.
 * \param rhs the rhs scale mode value.
 *
 * \return `true` if the scale mode values aren't the same; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator!=(const scale_mode lhs, const SDL_ScaleMode rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(scale_mode, SDL_ScaleMode)
[[nodiscard]] constexpr auto operator!=(const SDL_ScaleMode lhs, const scale_mode rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \} End of scale mode comparison operators

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_SCALE_MODE_HEADER

// #include "surface.hpp"

// #include "texture_access.hpp"
#ifndef CENTURION_TEXTURE_ACCESS_HEADER
#define CENTURION_TEXTURE_ACCESS_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum texture_access
 *
 * \brief Represents different texture access modes.
 *
 * \note The `no_lock` enumerator is also referred to as "static" texture access.
 *
 * \since 3.0.0
 *
 * \see `SDL_TextureAccess`
 */
enum class texture_access : int
{
  // clang-format off
  no_lock = SDL_TEXTUREACCESS_STATIC,       ///< Texture changes rarely and isn't lockable.
  streaming = SDL_TEXTUREACCESS_STREAMING,  ///< Texture changes frequently and is lockable.
  target = SDL_TEXTUREACCESS_TARGET         ///< Texture can be used as a render target.
  // clang-format on
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied texture access.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(texture_access::streaming) == "streaming"`.
 *
 * \param access the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const texture_access access) -> std::string_view
{
  switch (access) {
    case texture_access::no_lock:
      return "no_lock";

    case texture_access::streaming:
      return "streaming";

    case texture_access::target:
      return "target";

    default:
      throw cen_error{"Did not recognize texture access!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a texture access enumerator.
 *
 * \param stream the output stream that will be used.
 * \param access the enumerator that will be printed.
 *
 * \see `to_string(texture_access)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const texture_access access) -> std::ostream&
{
  return stream << to_string(access);
}

/// \} End of streaming

/// \name Texture access comparison operators
/// \{

/**
 * \brief Indicates whether or not the two texture access values are the same.
 *
 * \param lhs the lhs texture access value.
 * \param rhs the rhs texture access value.
 *
 * \return `true` if the texture access values are the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const texture_access lhs,
                                        const SDL_TextureAccess rhs) noexcept -> bool
{
  return static_cast<SDL_TextureAccess>(lhs) == rhs;
}

/// \copydoc operator==(texture_access, SDL_TextureAccess)
[[nodiscard]] constexpr auto operator==(const SDL_TextureAccess lhs,
                                        const texture_access rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the two texture access values aren't the same.
 *
 * \param lhs the lhs texture access value.
 * \param rhs the rhs texture access value.
 *
 * \return `true` if the texture access values aren't the same; `false`
 * otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator!=(const texture_access lhs,
                                        const SDL_TextureAccess rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(texture_access, SDL_TextureAccess)
[[nodiscard]] constexpr auto operator!=(const SDL_TextureAccess lhs,
                                        const texture_access rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of texture access comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_TEXTURE_ACCESS_HEADER


namespace cen {

/// \addtogroup video
/// \{

template <typename T>
class basic_texture;

using texture = basic_texture<detail::owning_type>;
using texture_handle = basic_texture<detail::handle_type>;

/**
 * \class basic_texture
 *
 * \brief Represents an hardware-accelerated image, intended to be rendered using the
 * `basic_renderer` class.
 *
 * \ownerhandle `texture`/`texture_handle`
 *
 * \since 3.0.0
 *
 * \see `texture`
 * \see `texture_handle`
 */
template <typename T>
class basic_texture final
{
 public:
  /// \name Construction
  /// \{

  // clang-format off

  /**
   * \brief Creates an texture from a pre-existing SDL texture.
   *
   * \param source a pointer to the associated SDL texture.
   *
   * \throws cen_error if the supplied pointer is null *and* the texture is owning.
   *
   * \since 3.0.0
   */
  explicit basic_texture(maybe_owner<SDL_Texture*> source) noexcept(!detail::is_owning<T>())
      : m_texture{source}
  {
    if constexpr (detail::is_owning<T>())
    {
      if (!m_texture)
      {
        throw cen_error{"Cannot create texture from null pointer!"};
      }
    }
  }

  // clang-format on

  /**
   * \brief Creates a handle to texture instance.
   *
   * \param owner the associated owning texture.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit basic_texture(texture& owner) noexcept : m_texture{owner.get()}
  {}

#ifndef CENTURION_NO_SDL_IMAGE

  /**
   * \brief Creates a texture based the image at the specified path.
   *
   * \tparam Renderer the type of the renderer, e.g. `renderer` or `renderer_handle`.
   *
   * \param renderer the renderer that will be used to create the texture.
   * \param path the file path of the texture, can't be null.
   *
   * \throws img_error if the texture cannot be loaded.
   *
   * \since 4.0.0
   */
  template <typename Renderer, typename TT = T, detail::is_owner<TT> = 0>
  basic_texture(const Renderer& renderer, const not_null<str> path)
      : m_texture{IMG_LoadTexture(renderer.get(), path)}
  {
    if (!m_texture) {
      throw img_error{};
    }
  }

  /**
   * \brief Creates a texture based the image at the specified path.
   *
   * \tparam Renderer the type of the renderer, e.g. `renderer` or `renderer_handle`.
   *
   * \param renderer the renderer that will be used to create the texture.
   * \param path the file path of the texture.
   *
   * \throws img_error if the texture cannot be loaded.
   *
   * \since 5.3.0
   */
  template <typename Renderer, typename TT = T, detail::is_owner<TT> = 0>
  basic_texture(const Renderer& renderer, const std::string& path)
      : basic_texture{renderer, path.c_str()}
  {}

#endif  // CENTURION_NO_SDL_IMAGE

  /**
   * \brief Creates an texture that is a copy of the supplied surface.
   *
   * \tparam Renderer the type of the renderer, e.g. `renderer` or `renderer_handle`.
   *
   * \param renderer the renderer that will be used to create the texture.
   * \param surface the surface that the texture will be based on.
   *
   * \throws sdl_error if the texture cannot be loaded.
   *
   * \since 4.0.0
   */
  template <typename Renderer, typename TT = T, detail::is_owner<TT> = 0>
  basic_texture(const Renderer& renderer, const surface& surface)
      : m_texture{SDL_CreateTextureFromSurface(renderer.get(), surface.get())}
  {
    if (!m_texture) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates an texture with the specified characteristics.
   *
   * \tparam Renderer the type of the renderer, e.g. `renderer` or `renderer_handle`.
   *
   * \param renderer the associated renderer instance.
   * \param format the pixel format of the created texture.
   * \param access the access of the created texture.
   * \param size the size of the texture.
   *
   * \throws sdl_error if the texture cannot be created.
   *
   * \since 4.0.0
   */
  template <typename Renderer, typename TT = T, detail::is_owner<TT> = 0>
  basic_texture(const Renderer& renderer,
                const pixel_format format,
                const texture_access access,
                const iarea size)
      : m_texture{SDL_CreateTexture(renderer.get(),
                                    to_underlying(format),
                                    to_underlying(access),
                                    size.width,
                                    size.height)}
  {
    if (!m_texture) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates and returns a texture with streaming access.
   *
   * \details The created texture is based on the image at the specified path with the
   * `streaming` texture access.
   *
   * \tparam Renderer the type of the renderer, e.g. `renderer` or `renderer_handle`.
   *
   * \param renderer the renderer that will be used to create the texture.
   * \param path the path of the image file to base the texture on, can't be null.
   * \param format the pixel format that will be used by the texture.
   *
   * \throws cen_error if something goes wrong.
   *
   * \return a texture with `streaming` texture access.
   *
   * \since 4.0.0
   */
  template <typename Renderer, typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto streaming(const Renderer& renderer,
                                      const not_null<str> path,
                                      const pixel_format format) -> basic_texture
  {
    assert(path);

    constexpr auto blendMode = blend_mode::blend;
    const auto surface = cen::surface::with_format(path, blendMode, format);

    basic_texture texture{renderer, format, texture_access::streaming, surface.size()};
    texture.set_blend_mode(blendMode);

    u32* pixels{};
    if (!texture.lock(&pixels)) {
      throw sdl_error{};
    }

    const auto maxCount =
        static_cast<usize>(surface.pitch()) * static_cast<usize>(surface.height());
    SDL_memcpy(pixels, surface.pixels(), maxCount);

    texture.unlock();

    return texture;
  }

  /**
   * \see streaming()
   * \since 5.3.0
   */
  template <typename Renderer, typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto streaming(const Renderer& renderer,
                                      const std::string& path,
                                      const pixel_format format) -> basic_texture
  {
    return streaming(renderer, path.c_str(), format);
  }

  /// \} End of construction

  /// \name Setters
  /// \{

  /**
   * \brief Sets the color of the pixel at the specified coordinate.
   *
   * \details This function has no effect if the texture access isn't `streaming` or if
   * the coordinate is out-of-bounds.
   *
   * \param pixel the pixel that will be changed.
   * \param color the new color of the pixel.
   *
   * \since 4.0.0
   */
  void set_pixel(const ipoint pixel, const color& color)
  {
    if (access() != texture_access::streaming || (pixel.x() < 0) || (pixel.y() < 0) ||
        (pixel.x() >= width()) || (pixel.y() >= height()))
    {
      return;
    }

    u32* pixels{};
    int pitch{};
    if (!lock(&pixels, &pitch)) {
      return;
    }

    const int nPixels = (pitch / 4) * height();
    const int index = (pixel.y() * width()) + pixel.x();

    if ((index >= 0) && (index < nPixels)) {
      const pixel_format_info info{format()};
      pixels[index] = info.rgba_to_pixel(color);
    }

    unlock();
  }

  /**
   * \brief Sets the alpha value of the texture.
   *
   * \param alpha the alpha value, in the range [0, 255].
   *
   * \since 3.0.0
   */
  void set_alpha(const u8 alpha) noexcept
  {
    SDL_SetTextureAlphaMod(m_texture, alpha);
  }

  /**
   * \brief Sets the blend mode that will be used by the texture.
   *
   * \param mode the blend mode that will be used.
   *
   * \since 3.0.0
   */
  void set_blend_mode(const blend_mode mode) noexcept
  {
    SDL_SetTextureBlendMode(m_texture, static_cast<SDL_BlendMode>(mode));
  }

  /**
   * \brief Sets the color modulation of the texture.
   *
   * \note The alpha component in the color struct is ignored by this function.
   *
   * \param color the color that will be used to modulate the color of the texture.
   *
   * \since 3.0.0
   */
  void set_color_mod(const color& color) noexcept
  {
    SDL_SetTextureColorMod(m_texture, color.red(), color.green(), color.blue());
  }

#if SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Sets the scale mode that will be used by the texture.
   *
   * \param mode the scale mode that will be used.
   *
   * \since 4.0.0
   */
  void set_scale_mode(const scale_mode mode) noexcept
  {
    SDL_SetTextureScaleMode(m_texture, static_cast<SDL_ScaleMode>(mode));
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

  /// \} End of setters

  /// \name Getters
  /// \{

  /**
   * \brief Returns the pixel format that is used by the texture.
   *
   * \return the pixel format that is used by the texture.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto format() const noexcept -> pixel_format
  {
    u32 format{};
    SDL_QueryTexture(m_texture, &format, nullptr, nullptr, nullptr);
    return static_cast<pixel_format>(format);
  }

  /**
   * \brief Returns the texture access of the texture.
   *
   * \return the texture access of the texture.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto access() const noexcept -> texture_access
  {
    int access{};
    SDL_QueryTexture(m_texture, nullptr, &access, nullptr, nullptr);
    return static_cast<texture_access>(access);
  }

  /**
   * \brief Returns the width of the texture.
   *
   * \return the width of the texture.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto width() const noexcept -> int
  {
    const auto [width, height] = size();
    return width;
  }

  /**
   * \brief Returns the height of the texture.
   *
   * \return the height of the texture.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto height() const noexcept -> int
  {
    const auto [width, height] = size();
    return height;
  }

  /**
   * \brief Returns the size of the texture.
   *
   * \return the size of the texture.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto size() const noexcept -> iarea
  {
    int width{};
    int height{};
    SDL_QueryTexture(m_texture, nullptr, nullptr, &width, &height);
    return {width, height};
  }

  /**
   * \brief Indicates whether or not the texture is a possible render target.
   *
   * \return `true` if the texture is a possible render target; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_target() const noexcept -> bool
  {
    return access() == texture_access::target;
  }

  /**
   * \brief Indicates whether or not the texture has static texture access.
   *
   * \return `true` if the texture has static texture access; `false` otherwise.
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto is_no_lock() const noexcept -> bool
  {
    return access() == texture_access::no_lock;
  }

  /**
   * \brief Indicates whether or not the texture has streaming texture access.
   *
   * \return `true` if the texture has streaming texture access; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_streaming() const noexcept -> bool
  {
    return access() == texture_access::streaming;
  }

  /**
   * \brief Returns the alpha value of the texture.
   *
   * \return the alpha value of the texture.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto alpha() const noexcept -> u8
  {
    u8 alpha{};
    SDL_GetTextureAlphaMod(m_texture, &alpha);
    return alpha;
  }

  /**
   * \brief Returns the blend mode of the texture.
   *
   * \return the blend mode of the texture.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto get_blend_mode() const noexcept -> blend_mode
  {
    SDL_BlendMode mode{};
    SDL_GetTextureBlendMode(m_texture, &mode);
    return static_cast<blend_mode>(mode);
  }

  /**
   * \brief Returns the color modulation of the texture.
   *
   * \return the modulation of the texture.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto color_mod() const noexcept -> color
  {
    u8 red{};
    u8 green{};
    u8 blue{};
    SDL_GetTextureColorMod(m_texture, &red, &green, &blue);
    return {red, green, blue, 0xFF};
  }

#if SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Returns the scale mode that is used by the texture.
   *
   * \return the scale mode that is used by the texture.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get_scale_mode() const noexcept -> scale_mode
  {
    SDL_ScaleMode mode{};
    SDL_GetTextureScaleMode(m_texture, &mode);
    return static_cast<scale_mode>(mode);
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Releases ownership of the associated SDL texture and returns a pointer to it.
   *
   * \warning Usage of this function should be considered dangerous, since you might run
   * into memory leak issues. You **must** call `SDL_DestroyTexture` on the returned
   * pointer to free the associated memory.
   *
   * \return a pointer to the associated SDL texture.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] auto release() noexcept -> owner<SDL_Texture*>
  {
    return m_texture.release();
  }

  /**
   * \brief Returns a pointer to the associated `SDL_Texture`.
   *
   * \return a pointer to the associated `SDL_Texture`.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_Texture*
  {
    return m_texture.get();
  }

  /// \} End of getters

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not a texture handle holds a non-null pointer.
   *
   * \return `true` if the handle holds a non-null pointer; `false` otherwise.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit operator bool() const noexcept
  {
    return m_texture != nullptr;
  }

  /**
   * \brief Converts to `SDL_Texture*`.
   *
   * \return a pointer to the associated `SDL_Texture`.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit operator SDL_Texture*() noexcept
  {
    return m_texture;
  }

  /**
   * \brief Converts to `const SDL_Texture*`.
   *
   * \return a pointer to the associated `SDL_Texture`.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit operator const SDL_Texture*() const noexcept
  {
    return m_texture;
  }

  /// \} End of conversions

 private:
  struct deleter final
  {
    void operator()(SDL_Texture* texture) noexcept
    {
      SDL_DestroyTexture(texture);
    }
  };
  detail::pointer_manager<T, SDL_Texture, deleter> m_texture;

  /**
   * \brief Locks the texture for write-only pixel access.
   *
   * \remarks This function is only applicable if the texture access of the texture is
   * `Streaming`.
   *
   * \param pixels this will be filled with a pointer to the locked pixels.
   * \param pitch This is filled in with the pitch of the locked pixels, can safely be
   * null if it isn't needed.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 4.0.0
   */
  auto lock(u32** pixels, int* pitch = nullptr) noexcept -> result
  {
    if (pitch) {
      return SDL_LockTexture(m_texture, nullptr, reinterpret_cast<void**>(pixels), pitch) == 0;
    }
    else {
      int dummyPitch;
      return SDL_LockTexture(m_texture,
                             nullptr,
                             reinterpret_cast<void**>(pixels),
                             &dummyPitch) == 0;
    }
  }

  /**
   * \brief Unlocks the texture.
   *
   * \since 4.0.0
   */
  void unlock() noexcept
  {
    SDL_UnlockTexture(m_texture);
  }
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a texture.
 *
 * \param texture the texture that will be converted.
 *
 * \return a string that represents the texture.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_texture<T>& texture) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("texture{{data: {}, width: {}, height: {}}}",
                     detail::address_of(texture.get()),
                     texture.width(),
                     texture.height());
#else
  return "texture{data: " + detail::address_of(texture.get()) +
         ", width: " + std::to_string(texture.width()) +
         ", height: " + std::to_string(texture.height()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a texture.
 *
 * \param stream the stream that will be used.
 * \param texture the texture that will be printed
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_texture<T>& texture) -> std::ostream&
{
  return stream << to_string(texture);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_TEXTURE_HEADER
// #include "unicode_string.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \class font_cache
 *
 * \brief Provides an API that enables efficient font rendering.
 *
 * \details This class provides two different optimizations.
 *
 * Firstly, this class can be used to cache glyph textures that can then be used to render
 * strings, by simply looking up the individual glyphs and rendering the existing
 * textures. Note, this will not result in accurate kerning. However, this might not be
 * noticeable and/or worth the performance boost. This approach is *very* efficient for
 * rendering pieces of text that frequently changes, since other approaches would require
 * dynamic allocation and de-allocation for every new rendered string.
 *
 * Secondly, it's possible to cache complete strings and associate them with a
 * user-provided identifier. In contrast with the first approach, this will result in
 * accurate kerning. The only problem is that it's hard to know the exact strings you will
 * render at compile-time. Use this option if you know that you're going to render some
 * specific string a lot.
 *
 * \since 5.0.0
 */
class font_cache final
{
 public:
  using id_type = std::size_t;

  /**
   * \struct glyph_data
   *
   * \brief Simple aggregate that contains a texture and metrics for a glyph.
   *
   * \since 5.0.0
   */
  struct glyph_data final
  {
    texture cached;         ///< The cached texture.
    glyph_metrics metrics;  ///< The metrics of the glyph.
  };

  /// \name Construction
  /// \{

  /**
   * \brief Creates an empty font cache instance.
   *
   * \note You have to explicitly state what glyphs that you want to be cached.
   *
   * \param font the font that will be used.
   *
   * \since 5.0.0
   */
  explicit font_cache(font&& font) noexcept : m_font{std::move(font)}
  {}

  /**
   * \brief Creates an empty font cache, and creates the associated font in-place.
   *
   * \note This constructor throws whatever exceptions that the `font` constructor might
   * throw.
   *
   * \tparam Args the types of the arguments forwarded to the font constructor.
   *
   * \param args the arguments that will be forwarded to the font constructor.
   *
   * \since 5.0.0
   */
  template <typename... Args>
  explicit font_cache(Args&&... args) : m_font{std::forward<Args>(args)...}
  {}

  /// \} End of construction

  /// \name String texture caching
  /// \{

  /**
   * \brief Caches the supplied string by rendering it to a texture.
   *
   * \details This function respects the kerning of the font. Any previous cached string
   * associated with the supplied ID will be overwritten.
   *
   * \tparam Renderer the type of the renderer that will be used.
   *
   * \param id the identifier that will be associated with the texture.
   * \param string the string that will be cached.
   * \param renderer the renderer that will be used to create the string texture.
   *
   * \see `basic_renderer::render_blended_utf8()`
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void store_blended_utf8(const id_type id, const not_null<str> string, Renderer& renderer)
  {
    assert(string);
    store(id, renderer.render_blended_utf8(string, get_font()));
  }

  /**
   * \see store_blended_utf8()
   * \since 5.3.0
   */
  template <typename Renderer>
  void store_blended_utf8(const id_type id, const std::string& string, Renderer& renderer)
  {
    store_blended_utf8(id, string.c_str(), renderer);
  }

  /**
   * \brief Caches the supplied string by rendering it to a texture.
   *
   * \details This function respects the kerning of the font. Any previous cached string
   * associated with the supplied ID will be overwritten.
   *
   * \tparam Renderer the type of the renderer that will be used.
   *
   * \param id the identifier that will be associated with the texture.
   * \param string the string that will be cached.
   * \param renderer the renderer that will be used to create the string texture.
   * \param wrap the width in pixels after which the text will be wrapped.
   *
   * \see `basic_renderer::render_blended_wrapped_utf8()`
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void store_blended_wrapped_utf8(const id_type id,
                                  const not_null<str> string,
                                  Renderer& renderer,
                                  const u32 wrap)
  {
    assert(string);
    store(id, renderer.render_blended_wrapped_utf8(string, get_font(), wrap));
  }

  /**
   * \see store_blended_wrapped_utf8()
   * \since 5.3.0
   */
  template <typename Renderer>
  void store_blended_wrapped_utf8(const id_type id,
                                  const std::string& string,
                                  Renderer& renderer,
                                  const u32 wrap)
  {
    store_blended_wrapped_utf8(id, string.c_str(), renderer, wrap);
  }

  /**
   * \brief Caches the supplied string by rendering it to a texture.
   *
   * \details This function respects the kerning of the font. Any previous cached string
   * associated with the supplied ID will be overwritten.
   *
   * \tparam Renderer the type of the renderer that will be used.
   *
   * \param id the identifier that will be associated with the texture.
   * \param string the string that will be cached.
   * \param renderer the renderer that will be used to create the string texture.
   * \param background the color used for the background box.
   *
   * \see `basic_renderer::render_shaded_utf8()`
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void store_shaded_utf8(const id_type id,
                         const not_null<str> string,
                         Renderer& renderer,
                         const color& background)
  {
    assert(string);
    store(id, renderer.render_shaded_utf8(string, get_font(), background));
  }

  /**
   * \see store_shaded_utf8()
   * \since 5.3.0
   */
  template <typename Renderer>
  void store_shaded_utf8(const id_type id,
                         const std::string& string,
                         Renderer& renderer,
                         const color& background)
  {
    store_shaded_utf8(id, string.c_str(), renderer, background);
  }

  /**
   * \brief Caches the supplied string by rendering it to a texture.
   *
   * \details This function respects the kerning of the font. Any previous cached string
   * associated with the supplied ID will be overwritten.
   *
   * \tparam Renderer the type of the renderer that will be used.
   *
   * \param id the identifier that will be associated with the texture.
   * \param string the string that will be cached.
   * \param renderer the renderer that will be used to create the string texture.
   *
   * \see `basic_renderer::render_solid_utf8()`
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void store_solid_utf8(const id_type id, const not_null<str> string, Renderer& renderer)
  {
    assert(string);
    store(id, renderer.render_solid_utf8(string, get_font()));
  }

  /**
   * \see store_solid_utf8()
   * \since 5.3.0
   */
  template <typename Renderer>
  void store_solid_utf8(const id_type id, const std::string& string, Renderer& renderer)
  {
    store_solid_utf8(id, string.c_str(), renderer);
  }

  /**
   * \brief Caches the supplied string by rendering it to a texture.
   *
   * \details This function respects the kerning of the font. Any previous cached string
   * associated with the supplied ID will be overwritten.
   *
   * \tparam Renderer the type of the renderer that will be used.
   *
   * \param id the identifier that will be associated with the texture.
   * \param string the string that will be cached.
   * \param renderer the renderer that will be used to create the string texture.
   *
   * \see `basic_renderer::render_blended_latin1()`
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void store_blended_latin1(const id_type id, const not_null<str> string, Renderer& renderer)
  {
    assert(string);
    store(id, renderer.render_blended_latin1(string, get_font()));
  }

  /**
   * \see store_blended_latin1()
   * \since 5.3.0
   */
  template <typename Renderer>
  void store_blended_latin1(const id_type id, const std::string& string, Renderer& renderer)
  {
    store_blended_latin1(id, string.c_str(), renderer);
  }

  /**
   * \brief Caches the supplied string by rendering it to a texture.
   *
   * \details This function respects the kerning of the font. Any previous cached string
   * associated with the supplied ID will be overwritten.
   *
   * \tparam Renderer the type of the renderer that will be used.
   *
   * \param id the identifier that will be associated with the texture.
   * \param string the string that will be cached.
   * \param renderer the renderer that will be used to create the string texture.
   * \param wrap the width in pixels after which the text will be wrapped.
   *
   * \see `basic_renderer::render_blended_wrapped_latin1()`
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void store_blended_wrapped_latin1(const id_type id,
                                    const not_null<str> string,
                                    Renderer& renderer,
                                    const u32 wrap)
  {
    assert(string);
    store(id, renderer.render_blended_wrapped_latin1(string, get_font(), wrap));
  }

  /**
   * \see store_blended_wrapped_latin1()
   * \since 5.3.0
   */
  template <typename Renderer>
  void store_blended_wrapped_latin1(const id_type id,
                                    const std::string& string,
                                    Renderer& renderer,
                                    const u32 wrap)
  {
    store_blended_wrapped_latin1(id, string.c_str(), renderer, wrap);
  }

  /**
   * \brief Caches the supplied string by rendering it to a texture.
   *
   * \details This function respects the kerning of the font. Any previous cached string
   * associated with the supplied ID will be overwritten.
   *
   * \tparam Renderer the type of the renderer that will be used.
   *
   * \param id the identifier that will be associated with the texture.
   * \param string the string that will be cached.
   * \param renderer the renderer that will be used to create the string texture.
   * \param background the color used for the background box.
   *
   * \see `basic_renderer::render_shaded_latin1()`
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void store_shaded_latin1(const id_type id,
                           const not_null<str> string,
                           Renderer& renderer,
                           const color& background)
  {
    assert(string);
    store(id, renderer.render_shaded_latin1(string, get_font(), background));
  }

  /**
   * \see store_shaded_latin1()
   * \since 5.3.0
   */
  template <typename Renderer>
  void store_shaded_latin1(const id_type id,
                           const std::string& string,
                           Renderer& renderer,
                           const color& background)
  {
    store_shaded_latin1(id, string.c_str(), renderer, background);
  }

  /**
   * \brief Caches the supplied string by rendering it to a texture.
   *
   * \details This function respects the kerning of the font. Any previous cached string
   * associated with the supplied ID will be overwritten.
   *
   * \tparam Renderer the type of the renderer that will be used.
   *
   * \param id the identifier that will be associated with the texture.
   * \param string the string that will be cached.
   * \param renderer the renderer that will be used to create the string texture.
   *
   * \see `basic_renderer::render_solid_latin1()`
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void store_solid_latin1(const id_type id, const not_null<str> string, Renderer& renderer)
  {
    assert(string);
    store(id, renderer.render_solid_latin1(string, get_font()));
  }

  /**
   * \see store_solid_latin1()
   * \since 5.3.0
   */
  template <typename Renderer>
  void store_solid_latin1(const id_type id, const std::string& string, Renderer& renderer)
  {
    store_solid_latin1(id, string.c_str(), renderer);
  }

  /**
   * \brief Caches the supplied string by rendering it to a texture.
   *
   * \details This function respects the kerning of the font. Any previous cached string
   * associated with the supplied ID will be overwritten.
   *
   * \tparam Renderer the type of the renderer that will be used.
   *
   * \param id the identifier that will be associated with the texture.
   * \param string the string that will be cached.
   * \param renderer the renderer that will be used to create the string texture.
   *
   * \see `basic_renderer::render_blended_unicode()`
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void store_blended_unicode(const id_type id,
                             const unicode_string& string,
                             Renderer& renderer)
  {
    store(id, renderer.render_blended_unicode(string, get_font()));
  }

  /**
   * \brief Caches the supplied string by rendering it to a texture.
   *
   * \details This function respects the kerning of the font. Any previous cached string
   * associated with the supplied ID will be overwritten.
   *
   * \tparam Renderer the type of the renderer that will be used.
   *
   * \param id the identifier that will be associated with the texture.
   * \param string the string that will be cached.
   * \param renderer the renderer that will be used to create the string texture.
   * \param wrap the width in pixels after which the text will be wrapped.
   *
   * \see `basic_renderer::render_blended_wrapped_unicode()`
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void store_blended_wrapped_unicode(const id_type id,
                                     const unicode_string& string,
                                     Renderer& renderer,
                                     const u32 wrap)
  {
    store(id, renderer.render_blended_wrapped_unicode(string, get_font(), wrap));
  }

  /**
   * \brief Caches the supplied string by rendering it to a texture.
   *
   * \details This function respects the kerning of the font. Any previous cached string
   * associated with the supplied ID will be overwritten.
   *
   * \tparam Renderer the type of the renderer that will be used.
   *
   * \param id the identifier that will be associated with the texture.
   * \param string the string that will be cached.
   * \param renderer the renderer that will be used to create the string texture.
   * \param background the color used for the background box.
   *
   * \see `basic_renderer::render_shaded_unicode()`
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void store_shaded_unicode(const id_type id,
                            const unicode_string& string,
                            Renderer& renderer,
                            const color& background)
  {
    store(id, renderer.render_shaded_unicode(string, get_font(), background));
  }

  /**
   * \brief Caches the supplied string by rendering it to a texture.
   *
   * \details This function respects the kerning of the font. Any previous cached string
   * associated with the supplied ID will be overwritten.
   *
   * \tparam Renderer the type of the renderer that will be used.
   *
   * \param id the identifier that will be associated with the texture.
   * \param string the string that will be cached.
   * \param renderer the renderer that will be used to create the string texture.
   *
   * \see `basic_renderer::render_solid_unicode()`
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void store_solid_unicode(const id_type id, const unicode_string& string, Renderer& renderer)
  {
    store(id, renderer.render_solid_unicode(string, get_font()));
  }

  /**
   * \brief Indicates whether or not there is a cached string texture associated with the
   * specified key.
   *
   * \param id the key that will be checked.
   *
   * \return `true` if there is a cached texture associated with the key; `false`
   * otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto has_stored(const id_type id) const noexcept -> bool
  {
    return m_strings.find(id) != m_strings.end();
  }

  /**
   * \brief Returns the cached texture associated with the specified ID.
   *
   * \pre `id` **must** be associated with a cached string texture.
   *
   * \param id the key of the cached texture to obtain.
   *
   * \return the cached texture associated with the key.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get_stored(const id_type id) const -> const texture&
  {
    return m_strings.at(id);
  }

  /**
   * \brief Returns a pointer to the texture associated with the specified key.
   *
   * \note The returned pointer is not suitable for storing for longer than absolutely
   * necessary, as it might get invalidated by modifications of the font cache.
   *
   * \param id the key of the desired texture.
   *
   * \return a pointer to the texture associated with the specified key; `nullptr` if no
   * texture is found.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto try_get_stored(const id_type id) const noexcept -> const texture*
  {
    const auto iterator = m_strings.find(id);
    if (iterator != m_strings.end()) {
      return &iterator->second;
    }
    else {
      return nullptr;
    }
  }

  /// \} End of string texture caching

  /// \name Glyph texture caching
  /// \{

  /**
   * \brief Adds a glyph to the font cache.
   *
   * \details This function has no effect if the supplied glyph isn't provided by the
   * associated font, or if the supplied glyph has already been cached.
   *
   * \tparam Renderer the type of the renderer.
   *
   * \param renderer the renderer that will be used to create the glyph texture.
   * \param glyph the glyph that will be cached.
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void add_glyph(Renderer& renderer, const unicode glyph)
  {
    if (has(glyph) || !m_font.is_glyph_provided(glyph)) {
      return;
    }

    glyph_data data{create_glyph_texture(renderer, glyph), m_font.get_metrics(glyph).value()};
    m_glyphs.try_emplace(glyph, std::move(data));
  }

  /**
   * \brief Caches the glyphs in the specified range.
   *
   * \details The range is interpreted as [min, max), i.e. the the `min` value is
   * included, and `max` is excluded.
   *
   * \remark For an overview of the various Unicode blocks, see <a
   * href="https://unicode-table.com/en/blocks/">this</a>.
   *
   * \tparam Renderer the type of the renderer.
   *
   * \param renderer the renderer that will be used to create the glyph textures.
   * \param begin the first glyph that will be included.
   * \param end the "end" glyph in the range, will not be included.
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void add_range(Renderer& renderer, const unicode begin, const unicode end)
  {
    for (auto ch = begin; ch < end; ++ch) {
      add_glyph(renderer, ch);
    }
  }

  /**
   * \brief Attempts to cache all printable basic latin characters.
   *
   * \details The basic latin set provides the most common characters, such as upper- and
   * lower-case latin letters, numbers and symbols. This function might throw if something
   * goes wrong when creating the textures.
   *
   * \tparam Renderer the type of the renderer.
   *
   * \param renderer the renderer that will be used to create the glyph textures.
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void add_basic_latin(Renderer& renderer)
  {
    // https://unicode-table.com/en/blocks/basic-latin/
    add_range(renderer, 0x20, 0x7F);
  }

  /**
   * \brief Attempts to cache all printable Latin-1 supplement characters.
   *
   * \tparam Renderer the type of the renderer.
   *
   * \param renderer the renderer that will be used to create the glyph textures.
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void add_latin1_supplement(Renderer& renderer)
  {
    // https://unicode-table.com/en/blocks/latin-1-supplement/
    add_range(renderer, 0xA0, 0x100);
  }

  /**
   * \brief Attempts to cache all printable Latin-1 characters.
   *
   * \note This function is effectively equivalent to calling both `add_basic_latin` and
   * `add_latin1_supplement`.
   *
   * \tparam Renderer the type of the renderer.
   *
   * \param renderer the renderer that will be used to create the glyph textures.
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void add_latin1(Renderer& renderer)
  {
    add_basic_latin(renderer);
    add_latin1_supplement(renderer);
  }

  /**
   * \brief Indicates whether or not the specified glyph has been cached.
   *
   * \param glyph the glyph to check.
   *
   * \return `true` if the specified glyph has been cached; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto has(const unicode glyph) const noexcept -> bool
  {
    return m_glyphs.count(glyph);
  }

  /**
   * \brief Returns the data associated with the specified glyph.
   *
   * \pre `glyph` **must** have been previously cached.
   *
   * \param glyph the desired glyph to lookup the data for.
   *
   * \return the cached texture and metrics associated with the glyph.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto at(const unicode glyph) const -> const glyph_data&
  {
    return m_glyphs.at(glyph);
  }

  /**
   * \brief Returns the data associated with the specified glyph.
   *
   * \note This function is equivalent to calling `at`.
   *
   * \pre `glyph` **must** have been previously cached.
   *
   * \param glyph the desired glyph to lookup the data for.
   *
   * \return the cached texture and metrics associated with the glyph.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto operator[](unicode glyph) const -> const glyph_data&
  {
    return at(glyph);
  }

  /**
   * \brief Returns the data associated with the specified glyph, if it exists.
   *
   * \details This function is a non-throwing alternative to the `at()` and `operator[]`
   * functions.
   *
   * \note Do not store the returned pointer for longer than absolutely necessary, it may
   * get invalidated upon modification of the font cache.
   *
   * \param glyph the desired glyph to lookup the data for.
   *
   * \return a pointer to the associated glyph data; a null pointer if no matching data
   * was found.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto try_at(const unicode glyph) const -> const glyph_data*
  {
    if (const auto it = m_glyphs.find(glyph); it != m_glyphs.end()) {
      return &it->second;
    }
    else {
      return nullptr;
    }
  }

  /// \} End of glyph texture caching

  /**
   * \brief Returns the font used by the cache.
   *
   * \return a reference to the internal font.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get_font() noexcept -> font&
  {
    return m_font;
  }

  /**
   * \copydoc get_font
   */
  [[nodiscard]] auto get_font() const noexcept -> const font&
  {
    return m_font;
  }

 private:
  font m_font;
  std::unordered_map<unicode, glyph_data> m_glyphs;
  std::unordered_map<id_type, texture> m_strings;

  /**
   * \brief Creates and returns a texture for the specified glyph.
   *
   * \details The glyph is rendered with `TTF_RenderGlyph_Blended`.
   *
   * \param renderer the renderer that will be used.
   * \param glyph the Unicode glyph that will be rendered.
   *
   * \return a texture that represents the specified glyph.
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  [[nodiscard]] auto create_glyph_texture(Renderer& renderer, const unicode glyph) -> texture
  {
    const auto color = renderer.get_color().get();
    const surface src{TTF_RenderGlyph_Blended(m_font.get(), glyph, color)};
    return texture{renderer, src};
  }

  void store(const id_type id, texture&& texture)
  {
    if (const auto it = m_strings.find(id); it != m_strings.end()) {
      m_strings.erase(it);
    }
    m_strings.try_emplace(id, std::move(texture));
  }
};

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_NO_SDL_TTF
#endif  // CENTURION_FONT_CACHE_HEADER
// #include "centurion/video/graphics_drivers.hpp"
#ifndef CENTURION_GRAPHICS_DRIVERS_HEADER
#define CENTURION_GRAPHICS_DRIVERS_HEADER

#include <SDL.h>

#include <optional>  // optional

namespace cen {

/// \addtogroup video
/// \{

/**
 * \brief Returns the number of available rendering drivers.
 *
 * \note Usually there is only one available rendering driver.
 *
 * \return the number of available rendering drivers.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto render_driver_count() noexcept -> int
{
  return SDL_GetNumRenderDrivers();
}

/**
 * \brief Returns the number of available video drivers compiled into SDL.
 *
 * \return the number of available video drivers compiled into SDL.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto video_driver_count() noexcept -> int
{
  return SDL_GetNumVideoDrivers();
}

/**
 * \brief Returns the information associated with a rendering driver.
 *
 * \param index the index of the rendering driver to query.
 *
 * \return information about the specified rendering driver; `std::nullopt` if something
 * went wrong.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto get_render_driver_info(const int index) noexcept
    -> std::optional<SDL_RendererInfo>
{
  SDL_RendererInfo info{};
  if (SDL_GetRenderDriverInfo(index, &info) == 0) {
    return info;
  }
  else {
    return std::nullopt;
  }
}

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_GRAPHICS_DRIVERS_HEADER

// #include "centurion/video/message_box.hpp"
#ifndef CENTURION_MESSAGE_BOX_HEADER
#define CENTURION_MESSAGE_BOX_HEADER

#include <SDL.h>

#include <algorithm>    // max, any_of
#include <cstddef>      // nullptr_t
#include <optional>     // optional
#include <ostream>      // ostream
#include <string>       // string
#include <string_view>  // string_view
#include <utility>      // move
#include <vector>       // vector

// #include "../compiler/features.hpp"

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/to_underlying.hpp"

// #include "../detail/stack_resource.hpp"
#ifndef CENTURION_DETAIL_STACK_RESOURCE_HEADER
#define CENTURION_DETAIL_STACK_RESOURCE_HEADER

// #include "../compiler/features.hpp"

// #include "../core/integers.hpp"
#ifndef CENTURION_INTEGERS_HEADER
#define CENTURION_INTEGERS_HEADER

#include <SDL.h>

#include <cstddef>  // size_t

namespace cen {

/// \addtogroup core
/// \{

/// \name Integer aliases
/// \{

using usize = std::size_t;

/// Alias for an unsigned integer.
using uint = unsigned int;

/// Alias for the type used for integer literal operators.
using ulonglong = unsigned long long;

/// Alias for a 64-bit unsigned integer.
using u64 = Uint64;

/// Alias for a 32-bit unsigned integer.
using u32 = Uint32;

/// Alias for a 16-bit unsigned integer.
using u16 = Uint16;

/// Alias for an 8-bit unsigned integer.
using u8 = Uint8;

/// Alias for a 64-bit signed integer.
using i64 = Sint64;

/// Alias for a 32-bit signed integer.
using i32 = Sint32;

/// Alias for a 16-bit signed integer.
using i16 = Sint16;

/// Alias for an 8-bit signed integer.
using i8 = Sint8;

/// \} End of integer aliases

// clang-format off

/**
 * \brief Obtains the size of a container as an `int`.
 *
 * \tparam T a "container" that provides a `size()` member function.
 *
 * \param container the container to query the size of.
 *
 * \return the size of the container as an `int` value.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto isize(const T& container) noexcept(noexcept(container.size()))
    -> int
{
  return static_cast<int>(container.size());
}

// clang-format on

namespace literals {

/**
 * \brief Creates an 8-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u8(const ulonglong value) noexcept -> u8
{
  return static_cast<u8>(value);
}

/**
 * \brief Creates a 16-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u16(const ulonglong value) noexcept -> u16
{
  return static_cast<u16>(value);
}

/**
 * \brief Creates a 32-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u32(const ulonglong value) noexcept -> u32
{
  return static_cast<u32>(value);
}

/**
 * \brief Creates a 64-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u64(const ulonglong value) noexcept -> u64
{
  return static_cast<u64>(value);
}

/**
 * \brief Creates an 8-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i8(const ulonglong value) noexcept -> i8
{
  return static_cast<i8>(value);
}

/**
 * \brief Creates a 16-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i16(const ulonglong value) noexcept -> i16
{
  return static_cast<i16>(value);
}

/**
 * \brief Creates a 32-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i32(const ulonglong value) noexcept -> i32
{
  return static_cast<i32>(value);
}

/**
 * \brief Creates a 64-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i64(const ulonglong value) noexcept -> i64
{
  return static_cast<i64>(value);
}

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_INTEGERS_HEADER


#if CENTURION_HAS_FEATURE_MEMORY_RESOURCE

#include <array>            // array
#include <cstddef>          // byte
#include <memory_resource>  // memory_resource, monotonic_buffer_resource

/// \cond FALSE
namespace cen::detail {

template <usize BufferSize>
class stack_resource final
{
 public:
  [[nodiscard]] auto get() noexcept -> std::pmr::memory_resource*
  {
    return &m_pool;
  }

 private:
  std::array<std::byte, BufferSize> m_buffer{};
  std::pmr::monotonic_buffer_resource m_pool{m_buffer.data(), sizeof m_buffer};
};

}  // namespace cen::detail
   /// \endcond

#endif  // CENTURION_HAS_FEATURE_MEMORY_RESOURCE
#endif  // CENTURION_DETAIL_STACK_RESOURCE_HEADER

// #include "button_order.hpp"
#ifndef CENTURION_BUTTON_ORDER_HEADER
#define CENTURION_BUTTON_ORDER_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum button_order
 *
 * \brief Provides hints for how the buttons in a message box should be aligned.
 *
 * \note This enum has no effect and shouldn't be used if you're using SDL 2.0.10!
 *
 * \since 4.0.0
 */
enum class button_order : u32
{
#if SDL_VERSION_ATLEAST(2, 0, 12)
  left_to_right = SDL_MESSAGEBOX_BUTTONS_LEFT_TO_RIGHT,
  right_to_left = SDL_MESSAGEBOX_BUTTONS_RIGHT_TO_LEFT
#else
  left_to_right,
  right_to_left
#endif  // SDL_VERSION_ATLEAST(2, 0, 12)
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied button order.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(button_order::left_to_right) == "left_to_right"`.
 *
 * \param order the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const button_order order) -> std::string_view
{
  switch (order) {
    case button_order::left_to_right:
      return "left_to_right";

    case button_order::right_to_left:
      return "right_to_left";

    default:
      throw cen_error{"Did not recognize button order!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a button order enumerator.
 *
 * \param stream the output stream that will be used.
 * \param order the enumerator that will be printed.
 *
 * \see `to_string(button_order)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const button_order order) -> std::ostream&
{
  return stream << to_string(order);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_BUTTON_ORDER_HEADER

// #include "color.hpp"

// #include "colors.hpp"
#ifndef CENTURION_COLORS_HEADER
#define CENTURION_COLORS_HEADER

// #include "color.hpp"


/**
 * \namespace cen::colors
 *
 * \brief Contains pre-defined `color` constants.
 *
 * \see cen::color
 */
namespace cen::colors {

/// \addtogroup video
/// \{

/**
 * \brief An invisible color. Hex: 000000.
 *
 * \since 3.0.0
 */
inline constexpr color transparent{0, 0, 0, 0};

/**
 * \brief Hex: FFFFFF.
 *
 * \since 3.0.0
 */
inline constexpr color white{0xFF, 0xFF, 0xFF};

/**
 * \brief Hex: 000000.
 *
 * \since 3.0.0
 */
inline constexpr color black{0, 0, 0};

/**
 * \brief Hex: F0F8FF.
 *
 * \since 3.0.0
 */
inline constexpr color alice_blue{0xF0, 0xF8, 0xFF};

/**
 * \brief Hex: FAEBD7.
 *
 * \since 3.0.0
 */
inline constexpr color antique_white{0xFA, 0xEB, 0xD7};

/**
 * \brief Hex: 00FFFF.
 *
 * \since 3.0.0
 */
inline constexpr color aqua{0, 0xFF, 0xFF};

/**
 * \brief Hex: 7FFFD4.
 *
 * \since 3.0.0
 */
inline constexpr color aquamarine{0x7F, 0xFF, 0xD4};

/**
 * \brief Hex: F0FFFF.
 *
 * \since 3.0.0
 */
inline constexpr color azure{0xF0, 0xFF, 0xFF};

/**
 * \brief Hex: F5F5DC.
 *
 * \since 3.0.0
 */
inline constexpr color beige{0xF5, 0xF5, 0xDC};

/**
 * \brief Hex: FFE4C4.
 *
 * \since 3.0.0
 */
inline constexpr color bisque{0xFF, 0xE4, 0xC4};

/**
 * \brief Hex: FFEBCD.
 *
 * \since 3.0.0
 */
inline constexpr color blanched_almond{0xFF, 0xEB, 0xCD};

/**
 * \brief Hex: 0000FF.
 *
 * \since 3.0.0
 */
inline constexpr color blue{0, 0, 0xFF};

/**
 * \brief Hex: 8A2BE2.
 *
 * \since 3.0.0
 */
inline constexpr color blue_violet{0x8A, 0x2B, 0xE2};

/**
 * \brief Hex: A52A2A.
 *
 * \since 3.0.0
 */
inline constexpr color brown{0xA5, 0x2A, 0x2A};

/**
 * \brief Hex: DEB887.
 *
 * \since 3.0.0
 */
inline constexpr color burly_wood{0xDE, 0xB8, 0x87};

/**
 * \brief Hex: 5F9EA0.
 *
 * \since 3.0.0
 */
inline constexpr color cadet_blue{0x5F, 0x9E, 0xA0};

/**
 * \brief Hex: 7FFF00.
 *
 * \since 3.0.0
 */
inline constexpr color chartreuse{0x7F, 0xFF, 0};

/**
 * \brief Hex: D2691E.
 *
 * \since 3.0.0
 */
inline constexpr color chocolate{0xD2, 0x69, 0x1E};

/**
 * \brief Hex: FF7F50.
 *
 * \since 3.0.0
 */
inline constexpr color coral{0xFF, 0x7F, 0x50};

/**
 * \brief Hex: 6495ED.
 *
 * \since 3.0.0
 */
inline constexpr color cornflower_blue{0x64, 0x95, 0xED};

/**
 * \brief Hex: FFF8DC.
 *
 * \since 3.0.0
 */
inline constexpr color cornsilk{0xFF, 0xF8, 0xDC};

/**
 * \brief Hex: DC143C.
 *
 * \since 3.0.0
 */
inline constexpr color crimson{0xDC, 0x14, 0x3C};

/**
 * \brief Hex: 00FFFF.
 *
 * \since 3.0.0
 */
inline constexpr color cyan{0, 0xFF, 0xFF};

/**
 * \brief Hex: 00008B.
 *
 * \since 3.0.0
 */
inline constexpr color dark_blue{0, 0, 0x8B};

/**
 * \brief Hex: 008B8B.
 *
 * \since 3.0.0
 */
inline constexpr color dark_cyan{0, 0x8B, 0x8B};

/**
 * \brief Hex: B8860B.
 *
 * \since 3.0.0
 */
inline constexpr color dark_golden_rod{0xB8, 0x86, 0x0B};

/**
 * \brief Hex: A9A9A9.
 *
 * \since 3.0.0
 */
inline constexpr color dark_gray{0xA9, 0xA9, 0xA9};

/**
 * \brief Hex: A9A9A9.
 *
 * \since 3.0.0
 */
inline constexpr color dark_grey{dark_gray};

/**
 * \brief Hex: 006400.
 *
 * \since 3.0.0
 */
inline constexpr color dark_green{0, 0x64, 0};

/**
 * \brief Hex: BDB76B.
 *
 * \since 3.0.0
 */
inline constexpr color dark_khaki{0xBD, 0xB7, 0x6B};

/**
 * \brief Hex: 8B008B.
 *
 * \since 3.0.0
 */
inline constexpr color dark_magenta{0x8B, 0, 0x8B};

/**
 * \brief Hex: 556B2F.
 *
 * \since 3.0.0
 */
inline constexpr color dark_olive_green{0x55, 0x6B, 0x2F};

/**
 * \brief Hex: FF8C00.
 *
 * \since 3.0.0
 */
inline constexpr color dark_orange{0xFF, 0x8C, 0};

/**
 * \brief Hex: 9932CC.
 *
 * \since 3.0.0
 */
inline constexpr color dark_orchid{0x99, 0x32, 0xCC};

/**
 * \brief Hex: 8B0000.
 *
 * \since 3.0.0
 */
inline constexpr color dark_red{0x8B, 0, 0};

/**
 * \brief Hex: E9967A.
 *
 * \since 3.0.0
 */
inline constexpr color dark_salmon{0xE9, 0x96, 0x7A};

/**
 * \brief Hex: 8FBC8F.
 *
 * \since 3.0.0
 */
inline constexpr color dark_sea_green{0x8F, 0xBC, 0x8F};

/**
 * \brief Hex: 483D8B.
 *
 * \since 3.0.0
 */
inline constexpr color dark_slate_blue{0x48, 0x3D, 0x8B};

/**
 * \brief Hex: 2F4F4F.
 *
 * \since 3.0.0
 */
inline constexpr color dark_slate_gray{0x2F, 0x4F, 0x4F};

/**
 * \brief Hex: 2F4F4F.
 *
 * \since 3.0.0
 */
inline constexpr color dark_slate_grey{dark_slate_gray};

/**
 * \brief Hex: 00CED1.
 *
 * \since 3.0.0
 */
inline constexpr color dark_turquoise{0, 0xCE, 0xD1};

/**
 * \brief Hex: 9400D3.
 *
 * \since 3.0.0
 */
inline constexpr color dark_violet{0x94, 0, 0xD3};

/**
 * \brief Hex: FF1493.
 *
 * \since 3.0.0
 */
inline constexpr color deep_pink{0xFF, 0x14, 0x93};

/**
 * \brief Hex: 00BFFF.
 *
 * \since 3.0.0
 */
inline constexpr color deep_sky_blue{0, 0xBF, 0xFF};

/**
 * \brief Hex: 696969.
 *
 * \since 3.0.0
 */
inline constexpr color dim_gray{0x69, 0x69, 0x69};

/**
 * \brief Hex: 696969.
 *
 * \since 3.0.0
 */
inline constexpr color dim_grey{dim_gray};

/**
 * \brief Hex: 1E90FF.
 *
 * \since 3.0.0
 */
inline constexpr color dodger_blue{0x1E, 0x90, 0xFF};

/**
 * \brief Hex: B22222.
 *
 * \since 3.0.0
 */
inline constexpr color fire_brick{0xB2, 0x22, 0x22};

/**
 * \brief Hex: FFFAF0.
 *
 * \since 3.0.0
 */
inline constexpr color floral_white{0xFF, 0xFA, 0xF0};

/**
 * \brief Hex: 228B22.
 *
 * \since 3.0.0
 */
inline constexpr color forest_green{0x22, 0x8B, 0x22};

/**
 * \brief Hex: FF00FF.
 *
 * \since 3.0.0
 */
inline constexpr color fuchsia{0xFF, 0, 0xFF};

/**
 * \brief Hex: DCDCDC.
 *
 * \since 3.0.0
 */
inline constexpr color gainsboro{0xDC, 0xDC, 0xDC};

/**
 * \brief Hex: F8F8FF.
 *
 * \since 3.0.0
 */
inline constexpr color ghost_white{0xF8, 0xF8, 0xFF};

/**
 * \brief Hex: FFD700.
 *
 * \since 3.0.0
 */
inline constexpr color gold{0xFF, 0xD7, 0};

/**
 * \brief Hex: DAA520.
 *
 * \since 3.0.0
 */
inline constexpr color golden_rod{0xDA, 0xA5, 0x20};

/**
 * \brief Hex: 808080.
 *
 * \since 3.0.0
 */
inline constexpr color gray{0x80, 0x80, 0x80};

/**
 * \brief Hex: 808080.
 *
 * \since 3.0.0
 */
inline constexpr color grey{gray};

/**
 * \brief Hex: 008000.
 *
 * \since 3.0.0
 */
inline constexpr color green{0, 0x80, 0};

/**
 * \brief Hex: ADFF2F.
 *
 * \since 3.0.0
 */
inline constexpr color green_yellow{0xAD, 0xFF, 0x2F};

/**
 * \brief Hex: F0FFF0.
 *
 * \since 3.0.0
 */
inline constexpr color honey_dew{0xF0, 0xFF, 0xF0};

/**
 * \brief Hex: FF69B4.
 *
 * \since 3.0.0
 */
inline constexpr color hot_pink{0xFF, 0x69, 0xB4};

/**
 * \brief Hex: CD5C5C.
 *
 * \since 3.0.0
 */
inline constexpr color indian_red{0xCD, 0x5C, 0x5C};

/**
 * \brief Hex: 4B0082.
 *
 * \since 3.0.0
 */
inline constexpr color indigo{0x4B, 0, 0x82};

/**
 * \brief Hex: FFFFF0.
 *
 * \since 3.0.0
 */
inline constexpr color ivory{0xFF, 0xFF, 0xF0};

/**
 * \brief Hex: F0E68C.
 *
 * \since 3.0.0
 */
inline constexpr color khaki{0xF0, 0xE6, 0x8C};

/**
 * \brief Hex: E6E6FA.
 *
 * \since 3.0.0
 */
inline constexpr color lavender{0xE6, 0xE6, 0xFA};

/**
 * \brief Hex: FFF0F5.
 *
 * \since 3.0.0
 */
inline constexpr color lavender_blush{0xFF, 0xF0, 0xF5};

/**
 * \brief Hex: 7CFC00.
 *
 * \since 3.0.0
 */
inline constexpr color lawn_green{0x7C, 0xFC, 0};

/**
 * \brief Hex: FFFACD.
 *
 * \since 3.0.0
 */
inline constexpr color lemon_chiffon{0xFF, 0xFA, 0xCD};

/**
 * \brief Hex: ADD8E6.
 *
 * \since 3.0.0
 */
inline constexpr color light_blue{0xAD, 0xD8, 0xE6};

/**
 * \brief Hex: F08080.
 *
 * \since 3.0.0
 */
inline constexpr color light_coral{0xF0, 0x80, 0x80};

/**
 * \brief Hex: E0FFFF.
 *
 * \since 3.0.0
 */
inline constexpr color light_cyan{0xE0, 0xFF, 0xFF};

/**
 * \brief Hex: FAFAD2.
 *
 * \since 3.0.0
 */
inline constexpr color light_golden_rod_yellow{0xFA, 0xFA, 0xD2};

/**
 * \brief Hex: D3D3D3.
 *
 * \since 3.0.0
 */
inline constexpr color light_gray{0xD3, 0xD3, 0xD3};

/**
 * \brief Hex: D3D3D3.
 *
 * \since 3.0.0
 */
inline constexpr color light_grey{light_gray};

/**
 * \brief Hex: 90EE90.
 *
 * \since 3.0.0
 */
inline constexpr color light_green{0x90, 0xEE, 0x90};

/**
 * \brief Hex: FFB6C1.
 *
 * \since 3.0.0
 */
inline constexpr color light_pink{0xFF, 0xB6, 0xC1};

/**
 * \brief Hex: FFA07A.
 *
 * \since 3.0.0
 */
inline constexpr color light_salmon{0xFF, 0xA0, 0x7A};

/**
 * \brief Hex: 20B2AA.
 *
 * \since 3.0.0
 */
inline constexpr color light_sea_green{0x20, 0xB2, 0xAA};

/**
 * \brief Hex: 87CEFA.
 *
 * \since 3.0.0
 */
inline constexpr color light_sky_blue{0x87, 0xCE, 0xFA};

/**
 * \brief Hex: 778899.
 *
 * \since 3.0.0
 */
inline constexpr color light_slate_gray{0x77, 0x88, 0x99};

/**
 * \brief Hex: 778899.
 *
 * \since 3.0.0
 */
inline constexpr color light_slate_grey{light_slate_gray};

/**
 * \brief Hex: B0C4DE.
 *
 * \since 3.0.0
 */
inline constexpr color light_steel_blue{0xB0, 0xC4, 0xDE};

/**
 * \brief Hex: FFFFE0.
 *
 * \since 3.0.0
 */
inline constexpr color light_yellow{0xFF, 0xFF, 0xE0};

/**
 * \brief Hex: 00FF00.
 *
 * \since 3.0.0
 */
inline constexpr color lime{0, 0xFF, 0};

/**
 * \brief Hex: 32CD32.
 *
 * \since 3.0.0
 */
inline constexpr color lime_green{0x32, 0xCD, 0x32};

/**
 * \brief Hex: FAF0E6.
 *
 * \since 3.0.0
 */
inline constexpr color linen{0xFA, 0xF0, 0xE6};

/**
 * \brief Hex: FF00FF.
 *
 * \since 3.0.0
 */
inline constexpr color magenta{0xFF, 0, 0xFF};

/**
 * \brief Hex: 800000.
 *
 * \since 3.0.0
 */
inline constexpr color maroon{0x80, 0, 0};

/**
 * \brief Hex: 66CDAA.
 *
 * \since 3.0.0
 */
inline constexpr color medium_aqua_marine{0x66, 0xCD, 0xAA};

/**
 * \brief Hex: 0000CD.
 *
 * \since 3.0.0
 */
inline constexpr color medium_blue{0, 0, 0xCD};

/**
 * \brief Hex: BA55D3.
 *
 * \since 3.0.0
 */
inline constexpr color medium_orchid{0xBA, 0x55, 0xD3};

/**
 * \brief Hex: 9370DB.
 *
 * \since 3.0.0
 */
inline constexpr color medium_purple{0x93, 0x70, 0xDB};

/**
 * \brief Hex: 3CB371.
 *
 * \since 3.0.0
 */
inline constexpr color medium_sea_green{0x3C, 0xB3, 0x71};

/**
 * \brief Hex: 7B68EE.
 *
 * \since 3.0.0
 */
inline constexpr color medium_slate_blue{0x7B, 0x68, 0xEE};

/**
 * \brief Hex: 00FA9A.
 *
 * \since 3.0.0
 */
inline constexpr color medium_spring_green{0, 0xFA, 0x9A};

/**
 * \brief Hex: 48D1CC.
 *
 * \since 3.0.0
 */
inline constexpr color medium_turquoise{0x48, 0xD1, 0xCC};

/**
 * \brief Hex: C71585.
 *
 * \since 3.0.0
 */
inline constexpr color medium_violet_red{0xC7, 0x15, 0x85};

/**
 * \brief Hex: 191970.
 *
 * \since 3.0.0
 */
inline constexpr color midnight_blue{0x19, 0x19, 0x70};

/**
 * \brief Hex: F5FFFA.
 *
 * \since 3.0.0
 */
inline constexpr color mint_cream{0xF5, 0xFF, 0xFA};

/**
 * \brief Hex: FFE4E1.
 *
 * \since 3.0.0
 */
inline constexpr color misty_rose{0xFF, 0xE4, 0xE1};

/**
 * \brief Hex: FFE4B5.
 *
 * \since 3.0.0
 */
inline constexpr color moccasin{0xFF, 0xE4, 0xB5};

/**
 * \brief Hex: FFDEAD.
 *
 * \since 3.0.0
 */
inline constexpr color navajo_white{0xFF, 0xDE, 0xAD};

/**
 * \brief Hex: 000080.
 *
 * \since 3.0.0
 */
inline constexpr color navy{0, 0, 0x80};

/**
 * \brief Hex: FDF5E6.
 *
 * \since 3.0.0
 */
inline constexpr color old_lace{0xFD, 0xF5, 0xE6};

/**
 * \brief Hex: 808000.
 *
 * \since 3.0.0
 */
inline constexpr color olive{0x80, 0x80, 0};

/**
 * \brief Hex: 6B8E23.
 *
 * \since 3.0.0
 */
inline constexpr color olive_drab{0x6B, 0x8E, 0x23};

/**
 * \brief Hex: FFA500.
 *
 * \since 3.0.0
 */
inline constexpr color orange{0xFF, 0xA5, 0};

/**
 * \brief Hex: FF4500.
 *
 * \since 3.0.0
 */
inline constexpr color orange_red{0xFF, 0x45, 0};

/**
 * \brief Hex: DA70D6.
 *
 * \since 3.0.0
 */
inline constexpr color orchid{0xDA, 0x70, 0xD6};

/**
 * \brief Hex: EEE8AA.
 *
 * \since 3.0.0
 */
inline constexpr color pale_golden_rod{0xEE, 0xE8, 0xAA};

/**
 * \brief Hex: 98FB98.
 *
 * \since 3.0.0
 */
inline constexpr color pale_green{0x98, 0xFB, 0x98};

/**
 * \brief Hex: AFEEEE.
 *
 * \since 3.0.0
 */
inline constexpr color pale_turquoise{0xAF, 0xEE, 0xEE};

/**
 * \brief Hex: DB7093.
 *
 * \since 3.0.0
 */
inline constexpr color pale_violet_red{0xDB, 0x70, 0x93};

/**
 * \brief Hex: FFEFD5.
 *
 * \since 3.0.0
 */
inline constexpr color papaya_whip{0xFF, 0xEF, 0xD5};

/**
 * \brief Hex: FFDAB9.
 *
 * \since 3.0.0
 */
inline constexpr color peach_puff{0xFF, 0xDA, 0xB9};

/**
 * \brief Hex: CD853F.
 *
 * \since 3.0.0
 */
inline constexpr color peru{0xCD, 0x85, 0x3F};

/**
 * \brief Hex: FFC0CB.
 *
 * \since 3.0.0
 */
inline constexpr color pink{0xFF, 0xC0, 0xCB};

/**
 * \brief Hex: DDA0DD.
 *
 * \since 3.0.0
 */
inline constexpr color plum{0xDD, 0xA0, 0xDD};

/**
 * \brief Hex: B0E0E6.
 *
 * \since 3.0.0
 */
inline constexpr color powder_blue{0xB0, 0xE0, 0xE6};

/**
 * \brief Hex: 800080.
 *
 * \since 3.0.0
 */
inline constexpr color purple{0x80, 0, 0x80};

/**
 * \brief Hex: 663399.
 *
 * \since 3.0.0
 */
inline constexpr color rebecca_purple{0x66, 0x33, 0x99};

/**
 * \brief Hex: FF0000.
 *
 * \since 3.0.0
 */
inline constexpr color red{0xFF, 0, 0};

/**
 * \brief Hex: BC8F8F.
 *
 * \since 3.0.0
 */
inline constexpr color rosy_brown{0xBC, 0x8F, 0x8F};

/**
 * \brief Hex: 4169E1.
 *
 * \since 3.0.0
 */
inline constexpr color royal_blue{0x41, 0x69, 0xE1};

/**
 * \brief Hex: 8B4513.
 *
 * \since 3.0.0
 */
inline constexpr color saddle_brown{0x8B, 0x45, 0x13};

/**
 * \brief Hex: FA8072.
 *
 * \since 3.0.0
 */
inline constexpr color salmon{0xFA, 0x80, 0x72};

/**
 * \brief Hex: F4A460.
 *
 * \since 3.0.0
 */
inline constexpr color sandy_brown{0xF4, 0xA4, 0x60};

/**
 * \brief Hex: 2E8B57.
 *
 * \since 3.0.0
 */
inline constexpr color sea_green{0x2E, 0x8B, 0x57};

/**
 * \brief Hex: FFF5EE.
 *
 * \since 3.0.0
 */
inline constexpr color sea_shell{0xFF, 0xF5, 0xEE};

/**
 * \brief Hex: A0522D.
 *
 * \since 3.0.0
 */
inline constexpr color sienna{0xA0, 0x52, 0x2D};

/**
 * \brief Hex: C0C0C0.
 *
 * \since 3.0.0
 */
inline constexpr color silver{0xC0, 0xC0, 0xC0};

/**
 * \brief Hex: 87CEEB.
 *
 * \since 3.0.0
 */
inline constexpr color sky_blue{0x87, 0xCE, 0xEB};

/**
 * \brief Hex: 6A5ACD.
 *
 * \since 3.0.0
 */
inline constexpr color slate_blue{0x6A, 0x5A, 0xCD};

/**
 * \brief Hex: 708090.
 *
 * \since 3.0.0
 */
inline constexpr color slate_gray{0x70, 0x80, 0x90};

/**
 * \brief Hex: 708090.
 *
 * \since 3.0.0
 */
inline constexpr color slate_grey{slate_gray};

/**
 * \brief Hex: FFFAFA.
 *
 * \since 3.0.0
 */
inline constexpr color snow{0xFF, 0xFA, 0xFA};

/**
 * \brief Hex: 00FF7F.
 *
 * \since 3.0.0
 */
inline constexpr color spring_green{0, 0xFF, 0x7F};

/**
 * \brief Hex: 4682B4.
 *
 * \since 3.0.0
 */
inline constexpr color steel_blue{0x46, 0x82, 0xB4};

/**
 * \brief Hex: D2B48C.
 *
 * \since 3.0.0
 */
inline constexpr color tan{0xD2, 0xB4, 0x8C};

/**
 * \brief Hex: 008080.
 *
 * \since 3.0.0
 */
inline constexpr color teal{0, 0x80, 0x80};

/**
 * \brief Hex: D8BFD8.
 *
 * \since 3.0.0
 */
inline constexpr color thistle{0xD8, 0xBF, 0xD8};

/**
 * \brief Hex: FF6347.
 *
 * \since 3.0.0
 */
inline constexpr color tomato{0xFF, 0x63, 0x47};

/**
 * \brief Hex: 40E0D0.
 *
 * \since 3.0.0
 */
inline constexpr color turquoise{0x40, 0xE0, 0xD0};

/**
 * \brief Hex: EE82EE.
 *
 * \since 3.0.0
 */
inline constexpr color violet{0xEE, 0x82, 0xEE};

/**
 * \brief Hex: F5DEB3.
 *
 * \since 3.0.0
 */
inline constexpr color wheat{0xF5, 0xDE, 0xB3};

/**
 * \brief Hex: F5F5F5.
 *
 * \since 3.0.0
 */
inline constexpr color white_smoke{0xF5, 0xF5, 0xF5};

/**
 * \brief Hex: FFFF00.
 *
 * \since 3.0.0
 */
inline constexpr color yellow{0xFF, 0xFF, 0};

/**
 * \brief Hex: 9ACD32.
 *
 * \since 3.0.0
 */
inline constexpr color yellow_green{0x9A, 0xCD, 0x32};

/// \} End of group video

}  // namespace cen::colors

#endif  // CENTURION_COLORS_HEADER

// #include "message_box_type.hpp"
#ifndef CENTURION_MESSAGE_BOX_TYPE_HEADER
#define CENTURION_MESSAGE_BOX_TYPE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum message_box_type
 *
 * \brief Serves as a hint of the purpose of a message box.
 *
 * \details Message boxes can indicate errors, warnings and general information.
 *
 * \since 5.0.0
 */
enum class message_box_type : u32
{
  error = SDL_MESSAGEBOX_ERROR,
  warning = SDL_MESSAGEBOX_WARNING,
  information = SDL_MESSAGEBOX_INFORMATION
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied message box type.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(message_box_type::error) == "error"`.
 *
 * \param type the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const message_box_type type) -> std::string_view
{
  switch (type) {
    case message_box_type::error:
      return "error";

    case message_box_type::warning:
      return "warning";

    case message_box_type::information:
      return "information";

    default:
      throw cen_error{"Did not recognize message box type!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a message box type enumerator.
 *
 * \param stream the output stream that will be used.
 * \param type the enumerator that will be printed.
 *
 * \see `to_string(message_box_type)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const message_box_type type) -> std::ostream&
{
  return stream << to_string(type);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_MESSAGE_BOX_TYPE_HEADER

// #include "window.hpp"
#ifndef CENTURION_WINDOW_HEADER
#define CENTURION_WINDOW_HEADER

#include <SDL.h>

#include <cassert>   // assert
#include <optional>  // optional
#include <ostream>   // ostream
#include <string>    // string, to_string

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/not_null.hpp"

// #include "../core/owner.hpp"

// #include "../core/result.hpp"

// #include "../core/str.hpp"

// #include "../detail/address_of.hpp"

// #include "../detail/clamp.hpp"

// #include "../detail/convert_bool.hpp"
#ifndef CENTURION_DETAIL_CONVERT_BOOL_HEADER
#define CENTURION_DETAIL_CONVERT_BOOL_HEADER

#include <SDL.h>

/// \cond FALSE
namespace cen::detail {

/**
 * \brief Returns the corresponding `SDL_bool` value for the supplied boolean value.
 *
 * \param b the boolean value that will be converted.
 *
 * \return `SDL_TRUE` for `true`; `SDL_FALSE` for `false`.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto convert_bool(const bool b) noexcept -> SDL_bool
{
  return b ? SDL_TRUE : SDL_FALSE;
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_CONVERT_BOOL_HEADER

// #include "../detail/max.hpp"
#ifndef CENTURION_DETAIL_MAX_HEADER
#define CENTURION_DETAIL_MAX_HEADER

/// \cond FALSE
namespace cen::detail {

template <typename T>
[[nodiscard]] constexpr auto max(const T& a, const T& b) noexcept(noexcept(a < b)) -> T
{
  return (a < b) ? b : a;
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_MAX_HEADER

// #include "../detail/owner_handle_api.hpp"

// #include "../math/area.hpp"

// #include "../math/rect.hpp"

// #include "flash_op.hpp"
#ifndef CENTURION_FLASH_OP_HEADER
#define CENTURION_FLASH_OP_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


#if SDL_VERSION_ATLEAST(2, 0, 16)

namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum flash_op
 *
 * \brief Represents different window flash operations.
 *
 * \see `basic_window::flash()`
 * \see `to_string(flash_op)`
 *
 * \since 6.2.0
 */
enum class flash_op
{
  cancel = SDL_FLASH_CANCEL,               ///< Cancel any current flashing.
  briefly = SDL_FLASH_BRIEFLY,             ///< Briefly flash the window.
  until_focused = SDL_FLASH_UNTIL_FOCUSED  ///< Flash the window until it's focused.
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied window flash operation.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(flash_op::briefly) == "briefly"`.
 *
 * \param op the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const flash_op op) -> std::string_view
{
  switch (op) {
    case flash_op::cancel:
      return "cancel";

    case flash_op::briefly:
      return "briefly";

    case flash_op::until_focused:
      return "until_focused";

    default:
      throw cen_error{"Did not recognize window flash operation!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a window flash operation enumerator.
 *
 * \param stream the output stream that will be used.
 * \param op the enumerator that will be printed.
 *
 * \see `to_string(flash_op)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const flash_op op) -> std::ostream&
{
  return stream << to_string(op);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // SDL_VERSION_ATLEAST(2, 0, 16)

#endif  // CENTURION_FLASH_OP_HEADER

// #include "pixel_format.hpp"

// #include "surface.hpp"


namespace cen {

/// \addtogroup video
/// \{

template <typename T>
class basic_window;

/**
 * \typedef window
 *
 * \brief Represents an owning window.
 *
 * \since 5.0.0
 */
using window = basic_window<detail::owning_type>;

/**
 * \typedef window_handle
 *
 * \brief Represents a non-owning window.
 *
 * \since 5.0.0
 */
using window_handle = basic_window<detail::handle_type>;

/**
 * \class basic_window
 *
 * \brief Represents an operating system window.
 *
 * \ownerhandle `window`/`window_handle`
 *
 * \since 5.0.0
 *
 * \see `window`
 * \see `window_handle`
 * \see `get_window()`
 * \see `get_grabbed_window()`
 * \see `mouse_focus_window()`
 * \see `keyboard_focus_window()`
 * \see `get_renderer()`
 * \see `make_window_and_renderer()`
 */
template <typename T>
class basic_window final
{
 public:
  /**
   * \enum window_flags
   *
   * \brief Represents different window features and options.
   *
   * \details Values of this enum are intended to be used to create flag bitmasks, that
   * can be used when creating windows and to obtain information from created windows.
   *
   * \see `SDL_WindowFlags`
   *
   * \since 6.0.0
   */
  enum window_flags : u32
  {
    fullscreen = SDL_WINDOW_FULLSCREEN,
    opengl = SDL_WINDOW_OPENGL,
    shown = SDL_WINDOW_SHOWN,
    hidden = SDL_WINDOW_HIDDEN,
    borderless = SDL_WINDOW_BORDERLESS,
    resizable = SDL_WINDOW_RESIZABLE,
    minimized = SDL_WINDOW_MINIMIZED,
    maximized = SDL_WINDOW_MAXIMIZED,
    input_grabbed = SDL_WINDOW_INPUT_GRABBED,
    input_focus = SDL_WINDOW_INPUT_FOCUS,
    mouse_focus = SDL_WINDOW_MOUSE_FOCUS,
    fullscreen_desktop = SDL_WINDOW_FULLSCREEN_DESKTOP,
    foreign = SDL_WINDOW_FOREIGN,
    high_dpi = SDL_WINDOW_ALLOW_HIGHDPI,
    mouse_capture = SDL_WINDOW_MOUSE_CAPTURE,
    always_on_top = SDL_WINDOW_ALWAYS_ON_TOP,
    skip_taskbar = SDL_WINDOW_SKIP_TASKBAR,
    utility = SDL_WINDOW_UTILITY,
    tooltip = SDL_WINDOW_TOOLTIP,
    popup_menu = SDL_WINDOW_POPUP_MENU,
    vulkan = SDL_WINDOW_VULKAN,

#if SDL_VERSION_ATLEAST(2, 0, 14)
    metal = SDL_WINDOW_METAL
#endif  // SDL_VERSION_ATLEAST(2, 0, 14)
  };

  /// \name Construction
  /// \{

  /**
   * \brief Creates a window from a pointer to an SDL window.
   *
   * \note If you're creating a `window` instance, then ownership of the pointer is
   * claimed. Furthermore, if you're creating a `window_handle`, ownership is *not*
   * claimed.
   *
   * \param window a pointer to the associated SDL window. Ownership of this pointer is
   * claimed if the window is owning.
   *
   * \since 5.0.0
   */
  explicit basic_window(maybe_owner<SDL_Window*> window) noexcept(!detail::is_owning<T>())
      : m_window{window}
  {
    if constexpr (detail::is_owning<T>()) {
      if (!m_window) {
        throw cen_error{"Cannot create window from null pointer!"};
      }
    }
  }

  /**
   * \brief Creates an owning window with the specified title and size.
   *
   * \details The window will be hidden by default.
   *
   * \param title the title of the window, can't be null.
   * \param size the size of the window, components must be greater than zero.
   * \param flags the window flags.
   *
   * \throws cen_error if the supplied width or height aren't greater than zero.
   * \throws sdl_error if the window cannot be created.
   *
   * \see `default_size()`
   * \see `default_flags()`
   *
   * \since 3.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_window(const not_null<str> title,
                        const iarea size = default_size(),
                        const u32 flags = default_flags())
  {
    assert(title);

    if (size.width < 1) {
      throw cen_error{"Bad window width!"};
    }
    else if (size.height < 1) {
      throw cen_error{"Bad window height!"};
    }

    m_window.reset(SDL_CreateWindow(title,
                                    SDL_WINDOWPOS_CENTERED,
                                    SDL_WINDOWPOS_CENTERED,
                                    size.width,
                                    size.height,
                                    flags));
    if (!m_window) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates an owning window with the specified title and size.
   *
   * \details The window will be hidden by default.
   *
   * \param title the title of the window.
   * \param size the size of the window, components must be greater than zero.
   * \param flags the window flags, see `window_flags`.
   *
   * \throws cen_error if the supplied width or height aren't greater than zero.
   * \throws sdl_error if the window cannot be created.
   *
   * \see `default_size()`
   * \see `default_flags()`
   *
   * \since 5.3.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_window(const std::string& title,
                        const iarea size = default_size(),
                        const u32 flags = default_flags())
      : basic_window{title.c_str(), size, flags}
  {}

  /**
   * \brief Creates a window.
   *
   * \details The window will use the size obtained from `default_size()` as its initial
   * size.
   *
   * \throws sdl_error if the window cannot be created.
   *
   * \since 3.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  basic_window() : basic_window{"Centurion window"}
  {}

  /**
   * \brief Creates a window handle based on an owning window.
   *
   * \param owner the owning window to base the handle on.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit basic_window(const window& owner) noexcept : m_window{owner.get()}
  {}

  /// \} End of construction

  /// \name Mutators
  /// \{

  /**
   * \brief Makes the window visible.
   *
   * \since 3.0.0
   */
  void show() noexcept
  {
    SDL_ShowWindow(m_window);
  }

  /**
   * \brief Makes the window invisible.
   *
   * \since 3.0.0
   */
  void hide() noexcept
  {
    SDL_HideWindow(m_window);
  }

  /**
   * \brief Raises this window above other windows and requests focus.
   *
   * \since 3.0.0
   */
  void raise() noexcept
  {
    SDL_RaiseWindow(m_window);
  }

  /**
   * \brief Maximizes the window.
   *
   * \since 3.1.0
   */
  void maximize() noexcept
  {
    SDL_MaximizeWindow(m_window);
  }

  /**
   * \brief Minimizes the window.
   *
   * \since 3.1.0
   */
  void minimize() noexcept
  {
    SDL_MinimizeWindow(m_window);
  }

  /**
   * \brief Restores the position and size of the window if it's minimized or maximized.
   *
   * \since 5.3.0
   */
  void restore() noexcept
  {
    SDL_RestoreWindow(m_window);
  }

  /**
   * \brief Updates the window surface.
   *
   * \return `success` if the surface was successfully updated; `failure` otherwise.
   *
   * \since 5.0.0
   */
  auto update_surface() noexcept -> result
  {
    return SDL_UpdateWindowSurface(m_window) == 0;
  }

#if SDL_VERSION_ATLEAST(2, 0, 16)

  /**
   * \brief Modifies the flash state of the window to acquire attention from the user.
   *
   * \param op the flash operation that will be performed.
   *
   * \return `success` if the operation was successful; `failure` otherwise.
   *
   * \since 6.2.0
   */
  auto flash(const flash_op op = flash_op::briefly) noexcept -> result
  {
    return SDL_FlashWindow(m_window, static_cast<SDL_FlashOperation>(op)) == 0;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 16)

  /// \} End of mutators

  /// \name Setters
  /// \{

  /**
   * \brief Sets whether or not the window is in fullscreen mode.
   *
   * \param enabled `true` if the window should be fullscreen; `false` for windowed mode.
   *
   * \return `success` if the display mode was changed; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_fullscreen(const bool enabled) noexcept -> result
  {
    return SDL_SetWindowFullscreen(m_window, enabled ? fullscreen : 0) == 0;
  }

  /**
   * \brief Sets whether or not the window is in fullscreen desktop mode.
   *
   * \details This mode is useful when you want to "fake" fullscreen mode.
   *
   * \param enabled `true` if the window should be fullscreen desktop; `false` for
   * windowed mode.
   *
   * \return `success` if the display mode was changed; `failure` otherwise.
   *
   * \since 4.0.0
   */
  auto set_fullscreen_desktop(const bool enabled) noexcept -> result
  {
    return SDL_SetWindowFullscreen(m_window, enabled ? fullscreen_desktop : 0) == 0;
  }

  /**
   * \brief Sets whether or not the window is decorated.
   *
   * \details This is enabled by default.
   *
   * \param decorated `true` if the window should be decorated; `false` otherwise.
   *
   * \since 3.0.0
   */
  void set_decorated(const bool decorated) noexcept
  {
    SDL_SetWindowBordered(m_window, detail::convert_bool(decorated));
  }

  /**
   * \brief Sets whether or not the window should be resizable.
   *
   * \param resizable `true` if the window should be resizable; `false` otherwise.
   *
   * \since 3.0.0
   */
  void set_resizable(const bool resizable) noexcept
  {
    SDL_SetWindowResizable(m_window, detail::convert_bool(resizable));
  }

  /**
   * \brief Sets the icon that will be used by the window.
   *
   * \param icon the surface that will serve as the icon of the window.
   *
   * \since 3.0.0
   */
  void set_icon(const surface& icon) noexcept
  {
    SDL_SetWindowIcon(m_window, icon.get());
  }

  /**
   * \brief Sets the title of the window.
   *
   * \param title the title of the window, can't be null.
   *
   * \since 3.0.0
   */
  void set_title(const not_null<str> title) noexcept
  {
    assert(title);
    SDL_SetWindowTitle(m_window, title);
  }

  /**
   * \brief Sets the title of the window.
   *
   * \param title the title of the window.
   *
   * \since 5.3.0
   */
  void set_title(const std::string& title) noexcept
  {
    set_title(title.c_str());
  }

  /**
   * \brief Sets the opacity of the window.
   *
   * \details The supplied opacity will be clamped to a value in the legal range.
   *
   * \param opacity the opacity, in the range [0, 1].
   *
   * \return `success` if the opacity was successfully set; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_opacity(const float opacity) noexcept -> result
  {
    return SDL_SetWindowOpacity(m_window, opacity) == 0;
  }

  /**
   * \brief Sets whether or not the mouse should be confined within the window.
   *
   * \brief This property is disabled by default.
   *
   * \param grab `true` if the mouse should be confined within the window; `false`
   * otherwise.
   *
   * \see `set_grab_keyboard()`
   *
   * \since 3.0.0
   */
  void set_grab_mouse(const bool grab) noexcept
  {
    SDL_SetWindowGrab(m_window, detail::convert_bool(grab));
  }

  /**
   * \brief Sets the overall brightness of the window.
   *
   * \note A brightness value outside the legal range will be clamped to the closest valid
   * value.
   *
   * \param brightness the brightness value, in the range [0, 1].
   *
   * \return `success` if the brightness was successfully set; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_brightness(const float brightness) noexcept -> result
  {
    return SDL_SetWindowBrightness(m_window, detail::clamp(brightness, 0.0f, 1.0f)) == 0;
  }

  /**
   * \brief Sets whether or not the mouse should be captured.
   *
   * \note A window might have to be visible in order for the mouse to be captured.
   *
   * \param capture `true` if the mouse should be captured; `false` otherwise.
   *
   * \return `success` on the mouse capture was successfully changed; `failure` otherwise.
   *
   * \since 5.0.0
   */
  static auto set_capturing_mouse(const bool capture) noexcept -> result
  {
    return SDL_CaptureMouse(detail::convert_bool(capture)) == 0;
  }

#if SDL_VERSION_ATLEAST(2, 0, 16)

  /**
   * \brief Sets whether or not the keyboard input should be grabbed by the window.
   *
   * \param grab `true` if the keyboard should be grabbed; `false` otherwise.
   *
   * \see `set_grab_mouse()`
   *
   * \since 6.2.0
   */
  void set_grab_keyboard(const bool grab) noexcept
  {
    SDL_SetWindowKeyboardGrab(m_window, detail::convert_bool(grab));
  }

  /**
   * \brief Sets whether or not a window is always on top of other windows.
   *
   * \param enabled `true` if the window should be on top of all other windows; `false`
   * otherwise.
   *
   * \since 6.2.0
   */
  void set_always_on_top(const bool enabled) noexcept
  {
    SDL_SetWindowAlwaysOnTop(m_window, detail::convert_bool(enabled));
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 16)

  /// \} End of setters

  /// \name Position functions
  /// \{

  /**
   * \brief Centers the window position relative to the screen.
   *
   * \note Windows are centered by default.
   *
   * \since 3.0.0
   */
  void center() noexcept
  {
    set_position({SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED});
  }

  /**
   * \brief Sets the x-coordinate of the window.
   *
   * \param x the new x-coordinate of the window.
   *
   * \since 6.0.0
   */
  void set_x(const int x) noexcept
  {
    set_position({x, y()});
  }

  /**
   * \brief Sets the y-coordinate of the window.
   *
   * \param y the new y-coordinate of the window.
   *
   * \since 6.0.0
   */
  void set_y(const int y) noexcept
  {
    set_position({x(), y});
  }

  /**
   * \brief Sets the position of the window.
   *
   * \note It's possible to use `SDL_WINDOWPOS_CENTERED` or `SDL_WINDOWPOS_UNDEFINED` as
   * any of the components of the point.
   *
   * \param position the new position of the window.
   *
   * \since 5.0.0
   */
  void set_position(const ipoint position) noexcept
  {
    SDL_SetWindowPosition(m_window, position.x(), position.y());
  }

  /**
   * \brief Returns the x-coordinate of the window position.
   *
   * \return the x-coordinate of the window position.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto x() const noexcept -> int
  {
    return position().x();
  }

  /**
   * \brief Returns the y-coordinate of the window position.
   *
   * \return the y-coordinate of the window position.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto y() const noexcept -> int
  {
    return position().y();
  }

  /**
   * \brief Returns the current position of the window.
   *
   * \note Windows are centered by default.
   *
   * \return the current position of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto position() const noexcept -> ipoint
  {
    int x{};
    int y{};
    SDL_GetWindowPosition(m_window, &x, &y);
    return {x, y};
  }

  /// \} End of position functions

  /// \name Size functions
  /// \{

  /**
   * \brief Sets the width of the window.
   *
   * \details The supplied width is capped to always be at least 1.
   *
   * \param width the new width of the window, must be greater than zero.
   *
   * \since 3.0.0
   */
  void set_width(const int width) noexcept
  {
    SDL_SetWindowSize(m_window, detail::max(width, 1), height());
  }

  /**
   * \brief Sets the height of the window.
   *
   * \details The supplied height is capped to always be at least 1.
   *
   * \param height the new height of the window, must be greater than zero.
   *
   * \since 3.0.0
   */
  void set_height(const int height) noexcept
  {
    SDL_SetWindowSize(m_window, width(), detail::max(height, 1));
  }

  /**
   * \brief Sets the size of the window.
   *
   * \pre The supplied width and height must be greater than zero.
   *
   * \param size the new size of the window.
   *
   * \since 5.0.0
   */
  void set_size(const iarea size) noexcept
  {
    assert(size.width > 0);
    assert(size.height > 0);
    SDL_SetWindowSize(m_window, size.width, size.height);
  }

  /**
   * \brief Sets the minimum size of the window.
   *
   * \pre The supplied width and height must be greater than zero.
   *
   * \param size the minimum size of the window.
   *
   * \since 3.0.0
   */
  void set_min_size(const iarea size) noexcept
  {
    assert(size.width > 0);
    assert(size.height > 0);
    SDL_SetWindowMinimumSize(m_window, size.width, size.height);
  }

  /**
   * \brief Sets the maximum size of the window.
   *
   * \pre The supplied width and height must be greater than zero.
   *
   * \param size the maximum size of the window.
   *
   * \since 3.0.0
   */
  void set_max_size(const iarea size) noexcept
  {
    assert(size.width > 0);
    assert(size.height > 0);
    SDL_SetWindowMaximumSize(m_window, size.width, size.height);
  }

  /**
   * \brief Returns the current width of the window.
   *
   * \return the current width of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto width() const noexcept -> int
  {
    return size().width;
  }

  /**
   * \brief Returns the current height of the window.
   *
   * \return the current height of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto height() const noexcept -> int
  {
    return size().height;
  }

  /**
   * \brief Returns the current size of the window.
   *
   * \note Calling this function is slightly faster than calling both `width` and `height`
   * to obtain the window size.
   *
   * \return the size of the window.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto size() const noexcept -> iarea
  {
    iarea size{};
    SDL_GetWindowSize(m_window, &size.width, &size.height);
    return size;
  }

  /**
   * \brief Returns the minimum size of the window.
   *
   * \return the minimum size of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto min_size() const noexcept -> iarea
  {
    iarea size{};
    SDL_GetWindowMinimumSize(m_window, &size.width, &size.height);
    return size;
  }

  /**
   * \brief Returns the maximum size of the window.
   *
   * \return the maximum size of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto max_size() const noexcept -> iarea
  {
    iarea size{};
    SDL_GetWindowMaximumSize(m_window, &size.width, &size.height);
    return size;
  }

  /**
   * \brief Returns the default size of a window.
   *
   * \note This function is only available for owning windows.
   *
   * \return the default size of a window.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] constexpr static auto default_size() noexcept -> iarea
  {
    return {800, 600};
  }

  /// \} End of size functions

  /// \name Flag queries
  /// \{

  /**
   * \brief Returns a mask that represents the flags associated with the window.
   *
   * \details You can check the returned mask using the `SDL_WindowFlags` enum.
   *
   * \return a mask that represents the flags associated with the window.
   *
   * \see `SDL_WindowFlags`
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto flags() const noexcept -> u32
  {
    return SDL_GetWindowFlags(m_window);
  }

  /**
   * \brief Indicates whether or not a flag is set.
   *
   * \details Some of the use cases of this function can be replaced by more explicit
   * functions, e.g. `is_fullscreen()` instead of `check_flag(SDL_WINDOW_FULLSCREEN)`.
   *
   * \param flag the flag that will be tested.
   *
   * \return `true` if the flag is set; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto check_flag(const SDL_WindowFlags flag) const noexcept -> bool
  {
    return static_cast<bool>(flags() & flag);
  }

  /**
   * \brief Indicates whether or not a flag is set.
   *
   * \details Some of the use cases of this function can be replaced by more explicit
   * functions, e.g. `is_fullscreen()` instead of `check_flag(cen::window::fullscreen)`.
   *
   * \param flag the flag that will be tested.
   *
   * \return `true` if the flag is set; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto check_flag(const window_flags flag) const noexcept -> bool
  {
    return static_cast<bool>(flags() & flag);
  }

  /**
   * \brief Indicates whether or not the window has grabbed the input focus.
   *
   * \return `true` if the window has grabbed input focus; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto has_grabbed_input() const noexcept -> bool
  {
    return check_flag(input_grabbed);
  }

  /**
   * \brief Indicates whether or not the window has input focus.
   *
   * \note The window might have to be visible for this to be true.
   *
   * \return `true` if the window has input focus; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto has_input_focus() const noexcept -> bool
  {
    return check_flag(input_focus);
  }

  /**
   * \brief Indicates whether or not the window has mouse focus.
   *
   * \return `true` if the window has mouse focus; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto has_mouse_focus() const noexcept -> bool
  {
    return check_flag(mouse_focus);
  }

  /**
   * \brief Indicates whether or not the window is borderless.
   *
   * \note This check is the opposite of `is_decorated()`.
   *
   * \details Windows are not borderless by default.
   *
   * \return `true` if the window is borderless; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_borderless() const noexcept -> bool
  {
    return check_flag(borderless);
  }

  /**
   * \brief Indicates whether or not the window is decorated.
   *
   * \note This check is the opposite of `is_borderless()`.
   *
   * \details Windows are decorated by default.
   *
   * \return `true` if the window is decorated; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_decorated() const noexcept -> bool
  {
    return !is_borderless();
  }

  /**
   * \brief Indicates whether or not the window is resizable.
   *
   * \details By default, this property is set to false.
   *
   * \return `true` if the window is resizable; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_resizable() const noexcept -> bool
  {
    return check_flag(resizable);
  }

  /**
   * \brief Indicates whether or the window supports high-DPI mode.
   *
   * \return `true` if the window supports high-DPI mode; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_high_dpi() const noexcept -> bool
  {
    return check_flag(high_dpi);
  }

  /**
   * \brief Indicates whether or not the window is in fullscreen mode.
   *
   * \return `true` if the window is in fullscreen mode; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_fullscreen() const noexcept -> bool
  {
    return check_flag(fullscreen);
  }

  /**
   * \brief Indicates whether or not the window is in fullscreen desktop mode.
   *
   * \return `true` if the window is in fullscreen desktop mode; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_fullscreen_desktop() const noexcept -> bool
  {
    return check_flag(fullscreen_desktop);
  }

  /**
   * \brief Indicates whether or not the window is visible.
   *
   * \return `true` if the window is visible; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_visible() const noexcept -> bool
  {
    return check_flag(shown);
  }

  /**
   * \brief Indicates whether or not the window is hidden.
   *
   * \return `true` if the window isn't visible; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_hidden() const noexcept -> bool
  {
    return check_flag(hidden);
  }

  /**
   * \brief Indicates whether or not the window is usable with an OpenGL-context.
   *
   * \return `true` if the window is compatible with an OpenGL-context; false otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_opengl() const noexcept -> bool
  {
    return check_flag(opengl);
  }

  /**
   * \brief Indicates whether or not the window is usable as a Vulkan surface.
   *
   * \return `true` if the window is is usable as a Vulkan surface; false otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_vulkan() const noexcept -> bool
  {
    return check_flag(vulkan);
  }

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Indicates whether or not the window can be used as a Metal view.
   *
   * \return `true` if the window can be used as a Metal view; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_metal() const noexcept -> bool
  {
    return check_flag(metal);
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Indicates whether or not the window wasn't created by SDL.
   *
   * \return `true` if the window wasn't created by SDL; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_foreign() const noexcept -> bool
  {
    return check_flag(foreign);
  }

  /**
   * \brief Indicates whether or not the window is capturing the mouse.
   *
   * \return `true` if the window is capturing the mouse; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_capturing_mouse() const noexcept -> bool
  {
    return check_flag(mouse_capture);
  }

  /**
   * \brief Indicates whether or not the window is minimized.
   *
   * \return `true` if the window is minimized; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_minimized() const noexcept -> bool
  {
    return check_flag(minimized);
  }

  /**
   * \brief Indicates whether or not the window is maximized.
   *
   * \return `true` if the window is maximized; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_maximized() const noexcept -> bool
  {
    return check_flag(maximized);
  }

  /**
   * \brief Indicates whether or not the window is set to be always on top of other
   * windows.
   *
   * \return `true` if the window is always on top of other windows; false otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_always_on_top() const noexcept -> bool
  {
    return check_flag(always_on_top);
  }

  /**
   * \brief Indicates whether or not the window is a "utility" window.
   *
   * \return `true` if window is a "utility" window; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_utility() const noexcept -> bool
  {
    return check_flag(utility);
  }

  /**
   * \brief Indicates whether or not the window is a tooltip.
   *
   * \return `true` if the window is a tooltip; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_tooltip() const noexcept -> bool
  {
    return check_flag(tooltip);
  }

  /**
   * \brief Indicates whether or not the window is a popup menu.
   *
   * \return `true` if the window is a popup menu; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_popup_menu() const noexcept -> bool
  {
    return check_flag(popup_menu);
  }

  /**
   * \brief Indicates whether or not the window is excluded from the taskbar.
   *
   * \return `true` if the window is excluded from the taskbar; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_excluded_from_taskbar() const noexcept -> bool
  {
    return check_flag(skip_taskbar);
  }

  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] constexpr static auto default_flags() noexcept -> u32
  {
    return hidden;
  }

  /// \} End of flag queries

  /// \name Getters
  /// \{

  /**
   * \brief Returns a numerical ID of the window.
   *
   * \return a numerical ID of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto id() const noexcept -> u32
  {
    return SDL_GetWindowID(m_window);
  }

  /**
   * \brief Returns the display index associated with the window.
   *
   * \return the display index associated with the window; `std::nullopt` if the display
   * index cannot be obtained.
   *
   * \since 3.1.0
   */
  [[nodiscard]] auto display_index() const noexcept -> std::optional<int>
  {
    const auto index = SDL_GetWindowDisplayIndex(m_window);
    if (index != -1) {
      return index;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the title of the window.
   *
   * \return the title of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto title() const -> std::string
  {
    return SDL_GetWindowTitle(m_window);
  }

  /**
   * \brief Returns the current brightness value of the window.
   *
   * \details The default value of this property is 1.
   *
   * \return the current brightness of the window, in the range [0, 1].
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto brightness() const noexcept -> float
  {
    return SDL_GetWindowBrightness(m_window);
  }

  /**
   * \brief Returns the opacity of the window.
   *
   * \return the opacity of the window, in the range [0, 1].
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto opacity() const noexcept -> float
  {
    float opacity{1};
    SDL_GetWindowOpacity(m_window, &opacity);
    return opacity;
  }

  /**
   * \brief Returns the pixel format of the window.
   *
   * \return the pixel format used by the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto get_pixel_format() const noexcept -> pixel_format
  {
    return static_cast<pixel_format>(SDL_GetWindowPixelFormat(m_window));
  }

  /**
   * \brief Returns a handle to the window framebuffer surface.
   *
   * \warning It is not possible use the framebuffer surface with the 3D or 2D rendering
   * APIs.
   *
   * \return a handle to the window surface, might not contain a valid surface pointer.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get_surface() noexcept -> surface_handle
  {
    return surface_handle{SDL_GetWindowSurface(m_window)};
  }

  /**
   * \brief Indicates whether or not the window is currently grabbing the mouse input.
   *
   * \return `true` if the window is grabbing the mouse; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto grabbing_mouse() const noexcept -> bool
  {
    return SDL_GetWindowGrab(m_window);
  }

  /**
   * \brief Indicates whether or not the screen keyboard is shown for the window.
   *
   * \return `true` if the screen keyboard is shown for the window; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_screen_keyboard_shown() const noexcept -> bool
  {
    return SDL_IsScreenKeyboardShown(get()) == SDL_TRUE;
  }

  /**
   * \brief Returns a pointer to the associated SDL window.
   *
   * \warning Don't take ownership of the returned pointer!
   *
   * \return a pointer to the associated SDL window.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_Window*
  {
    return m_window.get();
  }

  /// \} End of getters

  /// \name Conversions
  /// \{

  /**
   * \brief Converts to `SDL_Window*`.
   *
   * \return a pointer to the associated SDL window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit operator SDL_Window*() noexcept
  {
    return m_window.get();
  }

  /**
   * \brief Converts to `const SDL_Window*`.
   *
   * \return a pointer to the associated SDL window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit operator const SDL_Window*() const noexcept
  {
    return m_window.get();
  }

  /**
   * \brief Indicates whether or not the handle holds a non-null pointer.
   *
   * \note This function is only available for window handles.
   *
   * \warning It's undefined behaviour to invoke other member functions that use the
   * internal pointer if this function returns `false`.
   *
   * \return `true` if the handle holds a non-null pointer; `false` otherwise.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit operator bool() const noexcept
  {
    return m_window != nullptr;
  }

  /// \} End of conversions

 private:
  struct deleter final
  {
    void operator()(SDL_Window* window) noexcept
    {
      SDL_DestroyWindow(window);
    }
  };
  detail::pointer_manager<T, SDL_Window, deleter> m_window;
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a window.
 *
 * \param window the window that will be converted.
 *
 * \return a textual representation of the window.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_window<T>& window) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("window{{data: {}, width: {}, height: {}}}",
                     detail::address_of(window.get()),
                     window.width(),
                     window.height());
#else
  return "window{data: " + detail::address_of(window.get()) +
         ", width: " + std::to_string(window.width()) +
         ", height: " + std::to_string(window.height()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a window.
 *
 * \param stream the stream that will be used.
 * \param window the window that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_window<T>& window) -> std::ostream&
{
  return stream << to_string(window);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_WINDOW_HEADER


namespace cen {

/// \addtogroup video
/// \{

/**
 * \class message_box
 *
 * \brief Represents a modal message box that can be used display information, warnings
 * and errors.
 *
 * \note The appearance of message boxes varies depending on the platform, and certain
 * styling options are not available on all platforms.
 *
 * \since 3.0.0
 */
class message_box final
{
 public:
  /**
   * \typedef button_id
   *
   * \brief Used for message box button identifiers.
   *
   * \since 5.0.0
   */
  using button_id = int;

  /**
   * \enum default_button
   *
   * \brief Provides identifiers that represent default buttons of message boxes.
   *
   * \see `SDL_MessageBoxButtonFlags`
   *
   * \since 3.0.0
   */
  enum class default_button : u32
  {
    return_key = SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT,
    escape_key = SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT
  };

  /**
   * \enum color_id
   *
   * \brief Represents different message box aspects that can be colored.
   *
   * \see `SDL_MessageBoxColorType`
   *
   * \since 5.0.0
   */
  enum class color_id : int
  {
    background = SDL_MESSAGEBOX_COLOR_BACKGROUND,
    text = SDL_MESSAGEBOX_COLOR_TEXT,
    button_border = SDL_MESSAGEBOX_COLOR_BUTTON_BORDER,
    button_background = SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND,
    button_selected = SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED
  };

  /**
   * \class color_scheme
   *
   * \brief A simple wrapper around a `SDL_MessageBoxColorScheme` instance.
   *
   * \since 5.0.0
   */
  class color_scheme final
  {
   public:
    /**
     * \brief Creates a color scheme that uses `white` for all colors.
     *
     * \since 5.0.0
     */
    color_scheme() noexcept
    {
      set_color(color_id::background, colors::white);
      set_color(color_id::text, colors::white);
      set_color(color_id::button_background, colors::white);
      set_color(color_id::button_border, colors::white);
      set_color(color_id::button_selected, colors::white);
    }

    /**
     * \brief Sets the color associated with the specified ID.
     *
     * \param id the ID of the color that will be set.
     * \param color the color that will be adapted.
     *
     * \since 5.0.0
     */
    void set_color(const color_id id, const color& color) noexcept
    {
      m_scheme.colors[to_underlying(id)] = static_cast<SDL_MessageBoxColor>(color);
    }

    /**
     * \brief Returns a pointer to the internal `SDL_MessageBoxColorScheme`.
     *
     * \return a pointer to the internal `SDL_MessageBoxColorScheme`.
     *
     * \since 5.0.0
     */
    [[nodiscard]] auto get() noexcept -> SDL_MessageBoxColorScheme*
    {
      return &m_scheme;
    }

   private:
    SDL_MessageBoxColorScheme m_scheme{};
  };

  /**
   * \brief Creates a default-initialized message box.
   *
   * \since 5.0.0
   */
  message_box() = default;

  /**
   * \brief Creates a message box with the specified title and message.
   *
   * \param title the title that will be used.
   * \param message the message that will be used.
   *
   * \since 5.0.0
   */
  message_box(std::string title, std::string message)
      : m_title{std::move(title)}
      , m_message{std::move(message)}
  {}

  /**
   * \brief Displays a message box.
   *
   * \param parent the parent window.
   * \param title the title of the message box.
   * \param message the message that will be displayed.
   * \param type the type of the message box, defaults to `information`.
   * \param buttonOrder the button order that will be used, defaults to `left_to_right`.
   *
   * \throws sdl_error if something goes wrong when showing the message box.
   *
   * \since 5.0.0
   */
  template <typename T>
  static void show(const basic_window<T>& parent,
                   const std::string& title,
                   const std::string& message,
                   const message_box_type type = default_type(),
                   const button_order buttonOrder = default_order())
  {
    show(parent.ptr(), title, message, type, buttonOrder);
  }

  /**
   * \brief Displays a message box.
   *
   * \param title the title of the message box.
   * \param message the message that will be displayed.
   * \param type the type of the message box, defaults to `information`.
   * \param buttonOrder the button order that will be used, defaults to `left_to_right`.
   *
   * \throws sdl_error if something goes wrong when showing the message box.
   *
   * \since 5.0.0
   */
  static void show(const std::string& title,
                   const std::string& message,
                   const message_box_type type = default_type(),
                   const button_order buttonOrder = default_order())
  {
    show(nullptr, title, message, type, buttonOrder);
  }

  /**
   * \brief Displays a message box.
   *
   * \param parent the parent window.
   *
   * \return the ID of the pressed button; `std::nullopt` if no button was pressed.
   *
   * \throws sdl_error if something goes wrong when showing the message box.
   *
   * \since 5.0.0
   */
  template <typename T>
  auto show(const basic_window<T>& parent) -> std::optional<button_id>
  {
    return show(parent.get());
  }

  /**
   * \brief Displays a message box.
   *
   * \details If no buttons have been added by the time this function is called, then an
   * "OK" button is automatically added.
   *
   * \return the ID of the pressed button; `std::nullopt` if no button was pressed.
   *
   * \throws sdl_error if something goes wrong when showing the message box.
   *
   * \since 5.0.0
   */
  auto show() -> std::optional<button_id>
  {
    return show(nullptr);
  }

  /**
   * \brief Adds a button to the message box.
   *
   * \param id the ID of the button.
   * \param text the text of the button.
   * \param button the default button hint.
   *
   * \see `button_flags`
   *
   * \since 5.0.0
   */
  void add_button(const button_id id,
                  std::string text,
                  const default_button button = default_button::return_key)
  {
    m_buttons.emplace_back(id, std::move(text), button);
  }

  [[maybe_unused]] void set_title(std::nullptr_t) = delete;

  /**
   * \brief Sets the title of the message box.
   *
   * \param title the title that will be used.
   *
   * \since 5.0.0
   */
  void set_title(std::string title)
  {
    m_title = std::move(title);
  }

  /**
   * \brief Sets the message of the message box.
   *
   * \param message the message that will be used.
   *
   * \since 5.0.0
   */
  void set_message(std::string message)
  {
    m_message = std::move(message);
  }

  [[maybe_unused]] void set_message(std::nullptr_t) = delete;

  /**
   * \brief Sets the color scheme that will be used by the message box.
   *
   * \note This is not supported on all platforms, so this property is simply not set by
   * default.
   *
   * \param scheme the color scheme that will be used.
   *
   * \since 5.0.0
   */
  void set_color_scheme(const color_scheme& scheme) noexcept
  {
    m_colorScheme = scheme;
  }

  /**
   * \brief Sets the type of the message box.
   *
   * \param type the new type of the message box.
   *
   * \since 5.0.0
   */
  void set_type(const message_box_type type) noexcept
  {
    m_type = type;
  }

  /**
   * \brief Sets the button order of the message box.
   *
   * \param order the new button order of the message box.
   *
   * \since 5.0.0
   */
  void set_button_order(const button_order order) noexcept
  {
    m_buttonOrder = order;
  }

  /**
   * \brief Indicates whether or not the message box has a button associated with the
   * specified ID.
   *
   * \param id the ID that will be checked.
   *
   * \return `true` if there is a button associated with the supplied ID; `false`
   * otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto has_button(const button_id id) const -> bool
  {
    return std::any_of(m_buttons.begin(),
                       m_buttons.end(),
                       [id](const button& button) noexcept { return button.id() == id; });
  }

  /**
   * \brief Returns the title of the message box.
   *
   * \details The default title is "Message box".
   *
   * \return the title of the message box.
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto title() const -> std::string_view
  {
    return m_title;
  }

  /**
   * \brief Returns the message of the message box.
   *
   * \details The default message is "n/a".
   *
   * \return the message of the message box.
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto message() const -> std::string_view
  {
    return m_message;
  }

  /**
   * \brief Returns the type of the message box.
   *
   * \details The default type is "information".
   *
   * \return the type of the message box.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto type() const noexcept -> message_box_type
  {
    return m_type;
  }

  /**
   * \brief Returns the button order of the message box.
   *
   * \details The default button order is "left_to_right".
   *
   * \return the button order used by the message box.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get_button_order() const noexcept -> button_order
  {
    return m_buttonOrder;
  }

 private:
  class button final
  {
   public:
    button(const button_id id, std::string text, const default_button defaultButton)
        : m_id{id}
        , m_defaultButton{defaultButton}
        , m_text{std::move(text)}
    {}

    /**
     * \brief Returns the ID associated with the button.
     *
     * \return the ID of the button.
     *
     * \since 5.0.0
     */
    [[nodiscard]] auto id() const noexcept -> button_id
    {
      return m_id;
    }

    /**
     * \brief Returns an `SDL_MessageBoxButtonData` instance that corresponds to the
     * button.
     *
     * \note The returned instance holds a pointer to the string text associated with the
     * button, so it mustn't outlive the lifetime of the button.
     *
     * \return an `SDL_MessageBoxButtonData` instance.
     *
     * \since 5.0.0
     */
    [[nodiscard]] auto convert() const noexcept -> SDL_MessageBoxButtonData
    {
      SDL_MessageBoxButtonData result{};

      result.flags = to_underlying(m_defaultButton);
      result.buttonid = m_id;
      result.text = m_text.c_str();

      return result;
    }

   private:
    button_id m_id;
    default_button m_defaultButton;
    std::string m_text;
  };

  std::vector<button> m_buttons;
  std::string m_title{"Message box"};
  std::string m_message{"n/a"};
  std::optional<color_scheme> m_colorScheme;
  message_box_type m_type{default_type()};
  button_order m_buttonOrder{default_order()};

  [[nodiscard]] constexpr static auto default_type() noexcept -> message_box_type
  {
    return message_box_type::information;
  }

  [[nodiscard]] constexpr static auto default_order() noexcept -> button_order
  {
    return button_order::left_to_right;
  }

  [[nodiscard]] constexpr static auto to_flags(const message_box_type type,
                                               const button_order buttonOrder) noexcept -> u32
  {
    return to_underlying(type) | to_underlying(buttonOrder);
  }

  static void show(SDL_Window* parent,
                   const std::string& title,
                   const std::string& message,
                   const message_box_type type,
                   const button_order buttonOrder)
  {
    if (-1 == SDL_ShowSimpleMessageBox(to_flags(type, buttonOrder),
                                       title.c_str(),
                                       message.c_str(),
                                       parent))
    {
      throw sdl_error{};
    }
  }

  auto show(SDL_Window* parent) -> std::optional<button_id>
  {
    SDL_MessageBoxData data{};

    data.window = parent;
    data.title = m_title.c_str();
    data.message = m_message.c_str();
    data.flags = to_flags(m_type, m_buttonOrder);
    data.colorScheme = m_colorScheme ? m_colorScheme->get() : nullptr;

#if CENTURION_HAS_FEATURE_MEMORY_RESOURCE
    // Realistically 1-3 buttons, stack buffer for 8 buttons, just in case.
    detail::stack_resource<8 * sizeof(SDL_MessageBoxButtonData)> resource;
    std::pmr::vector<SDL_MessageBoxButtonData> buttonData{resource.get()};
#else
    std::vector<SDL_MessageBoxButtonData> buttonData;
    buttonData.reserve(8);
#endif  // CENTURION_HAS_STD_MEMORY_RESOURCE

    if (m_buttons.empty()) {
      add_button(0, "OK", default_button::return_key);
    }

    for (const auto& button : m_buttons) {
      buttonData.emplace_back(button.convert());
    }

    data.buttons = buttonData.data();
    data.numbuttons = isize(buttonData);

    button_id button{-1};
    if (SDL_ShowMessageBox(&data, &button) == -1) {
      throw sdl_error{};
    }

    if (button != -1) {
      return button;
    }
    else {
      return std::nullopt;
    }
  }
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied default button.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(message_box::default_button::return_key) == "return_key"`.
 *
 * \param button the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const message_box::default_button button)
    -> std::string_view
{
  switch (button) {
    case message_box::default_button::return_key:
      return "return_key";

    case message_box::default_button::escape_key:
      return "escape_key";

    default:
      throw cen_error{"Did not recognize message box default button!"};
  }
}

/**
 * \brief Returns a textual version of the supplied color ID
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(message_box::color_id::text) == "text"`.
 *
 * \param id the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const message_box::color_id id) -> std::string_view
{
  switch (id) {
    case message_box::color_id::background:
      return "background";

    case message_box::color_id::text:
      return "text";

    case message_box::color_id::button_border:
      return "button_border";

    case message_box::color_id::button_background:
      return "button_background";

    case message_box::color_id::button_selected:
      return "button_selected";

    default:
      throw cen_error{"Did not recognize message box color ID!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a default button enumerator.
 *
 * \param stream the output stream that will be used.
 * \param button the enumerator that will be printed.
 *
 * \see `to_string(message_box::default_button)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const message_box::default_button button)
    -> std::ostream&
{
  return stream << to_string(button);
}

/**
 * \brief Prints a textual representation of a color ID enumerator.
 *
 * \param stream the output stream that will be used.
 * \param id the enumerator that will be printed.
 *
 * \see `to_string(message_box::color_id)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const message_box::color_id id) -> std::ostream&
{
  return stream << to_string(id);
}

/// \} End of streaming

/// \name Message box default button comparison operators
/// \{

/**
 * \brief Indicates whether or not the flags represent the same value.
 *
 * \param lhs the left-hand side message box button flag.
 * \param rhs the right-hand side message box button flag.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const message_box::default_button lhs,
                                        const SDL_MessageBoxButtonFlags rhs) noexcept -> bool
{
  return static_cast<SDL_MessageBoxButtonFlags>(lhs) == rhs;
}

/// \copydoc operator==(message_box::default_button, SDL_MessageBoxButtonFlags)
[[nodiscard]] constexpr auto operator==(const SDL_MessageBoxButtonFlags lhs,
                                        const message_box::default_button rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the flags represent the same value.
 *
 * \param lhs the left-hand side message box button flag.
 * \param rhs the right-hand side message box button flag.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator!=(const message_box::default_button lhs,
                                        const SDL_MessageBoxButtonFlags rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(message_box::default_button, SDL_MessageBoxButtonFlags)
[[nodiscard]] constexpr auto operator!=(const SDL_MessageBoxButtonFlags lhs,
                                        const message_box::default_button rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of message box default button comparison operators

/// \name Message box color ID comparison operators
/// \{

/**
 * \brief Indicates whether or not two message box are colors the same.
 *
 * \param lhs the left-hand side message box color.
 * \param rhs the right-hand side message box color.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const SDL_MessageBoxColorType lhs,
                                        const message_box::color_id rhs) noexcept -> bool
{
  return lhs == static_cast<SDL_MessageBoxColorType>(rhs);
}

/// \copydoc operator==(SDL_MessageBoxColorType, message_box::color_id)
[[nodiscard]] constexpr auto operator==(const message_box::color_id lhs,
                                        const SDL_MessageBoxColorType rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two message box colors aren't the same.
 *
 * \param lhs the left-hand side message box color.
 * \param rhs the right-hand side message box color.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator!=(const SDL_MessageBoxColorType lhs,
                                        const message_box::color_id rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(SDL_MessageBoxColorType, message_box::color_id)
[[nodiscard]] constexpr auto operator!=(const message_box::color_id lhs,
                                        const SDL_MessageBoxColorType rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of message box color ID comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_MESSAGE_BOX_HEADER

// #include "centurion/video/message_box_type.hpp"
#ifndef CENTURION_MESSAGE_BOX_TYPE_HEADER
#define CENTURION_MESSAGE_BOX_TYPE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum message_box_type
 *
 * \brief Serves as a hint of the purpose of a message box.
 *
 * \details Message boxes can indicate errors, warnings and general information.
 *
 * \since 5.0.0
 */
enum class message_box_type : u32
{
  error = SDL_MESSAGEBOX_ERROR,
  warning = SDL_MESSAGEBOX_WARNING,
  information = SDL_MESSAGEBOX_INFORMATION
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied message box type.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(message_box_type::error) == "error"`.
 *
 * \param type the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const message_box_type type) -> std::string_view
{
  switch (type) {
    case message_box_type::error:
      return "error";

    case message_box_type::warning:
      return "warning";

    case message_box_type::information:
      return "information";

    default:
      throw cen_error{"Did not recognize message box type!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a message box type enumerator.
 *
 * \param stream the output stream that will be used.
 * \param type the enumerator that will be printed.
 *
 * \see `to_string(message_box_type)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const message_box_type type) -> std::ostream&
{
  return stream << to_string(type);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_MESSAGE_BOX_TYPE_HEADER

// #include "centurion/video/opengl/gl_attribute.hpp"
#ifndef CENTURION_GL_ATTRIBUTE_HEADER
#define CENTURION_GL_ATTRIBUTE_HEADER

#ifndef CENTURION_NO_OPENGL

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../../core/exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER


namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum gl_attribute
 *
 * \brief Provides identifiers for different OpenGL attributes.
 *
 * \since 6.0.0
 */
enum class gl_attribute
{
  red_size = SDL_GL_RED_SIZE,
  green_size = SDL_GL_GREEN_SIZE,
  blue_size = SDL_GL_BLUE_SIZE,
  alpha_size = SDL_GL_ALPHA_SIZE,
  buffer_size = SDL_GL_BUFFER_SIZE,
  depth_size = SDL_GL_DEPTH_SIZE,
  stencil_size = SDL_GL_STENCIL_SIZE,

  accum_red_size = SDL_GL_ACCUM_RED_SIZE,
  accum_green_size = SDL_GL_ACCUM_GREEN_SIZE,
  accum_blue_size = SDL_GL_ACCUM_BLUE_SIZE,
  accum_alpha_size = SDL_GL_ACCUM_ALPHA_SIZE,

  stereo = SDL_GL_STEREO,
  egl = SDL_GL_CONTEXT_EGL,
  flags = SDL_GL_CONTEXT_FLAGS,
  double_buffer = SDL_GL_DOUBLEBUFFER,
  accelerated_visual = SDL_GL_ACCELERATED_VISUAL,
  retained_backing = SDL_GL_RETAINED_BACKING,
  share_with_current_context = SDL_GL_SHARE_WITH_CURRENT_CONTEXT,
  framebuffer_srgb_capable = SDL_GL_FRAMEBUFFER_SRGB_CAPABLE,

  multisample_buffers = SDL_GL_MULTISAMPLEBUFFERS,
  multisample_samples = SDL_GL_MULTISAMPLESAMPLES,

  context_major_version = SDL_GL_CONTEXT_MAJOR_VERSION,
  context_minor_version = SDL_GL_CONTEXT_MINOR_VERSION,
  context_profile_mask = SDL_GL_CONTEXT_PROFILE_MASK,
  context_release_behaviour = SDL_GL_CONTEXT_RELEASE_BEHAVIOR,
  context_reset_notification = SDL_GL_CONTEXT_RESET_NOTIFICATION,
  context_no_error = SDL_GL_CONTEXT_NO_ERROR
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied OpenGL attribute.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(gl_attribute::flags) == "flags"`.
 *
 * \param attr the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const gl_attribute attr) -> std::string_view
{
  switch (attr) {
    case gl_attribute::red_size:
      return "red_size";

    case gl_attribute::green_size:
      return "green_size";

    case gl_attribute::blue_size:
      return "blue_size";

    case gl_attribute::alpha_size:
      return "alpha_size";

    case gl_attribute::buffer_size:
      return "buffer_size";

    case gl_attribute::depth_size:
      return "depth_size";

    case gl_attribute::stencil_size:
      return "stencil_size";

    case gl_attribute::accum_red_size:
      return "accum_red_size";

    case gl_attribute::accum_green_size:
      return "accum_green_size";

    case gl_attribute::accum_blue_size:
      return "accum_blue_size";

    case gl_attribute::accum_alpha_size:
      return "accum_alpha_size";

    case gl_attribute::stereo:
      return "stereo";

    case gl_attribute::egl:
      return "egl";

    case gl_attribute::flags:
      return "flags";

    case gl_attribute::double_buffer:
      return "double_buffer";

    case gl_attribute::accelerated_visual:
      return "accelerated_visual";

    case gl_attribute::retained_backing:
      return "retained_backing";

    case gl_attribute::share_with_current_context:
      return "share_with_current_context";

    case gl_attribute::framebuffer_srgb_capable:
      return "framebuffer_srgb_capable";

    case gl_attribute::multisample_buffers:
      return "multisample_buffers";

    case gl_attribute::multisample_samples:
      return "multisample_samples";

    case gl_attribute::context_major_version:
      return "context_major_version";

    case gl_attribute::context_minor_version:
      return "context_minor_version";

    case gl_attribute::context_profile_mask:
      return "context_profile_mask";

    case gl_attribute::context_release_behaviour:
      return "context_release_behaviour";

    case gl_attribute::context_reset_notification:
      return "context_reset_notification";

    case gl_attribute::context_no_error:
      return "context_no_error";

    default:
      throw cen_error{"Did not recognize OpenGL attribute!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of an OpenGL attribute enumerator.
 *
 * \param stream the output stream that will be used.
 * \param attr the enumerator that will be printed.
 *
 * \see `to_string(gl_attribute)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const gl_attribute attr) -> std::ostream&
{
  return stream << to_string(attr);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_NO_OPENGL
#endif  // CENTURION_GL_ATTRIBUTE_HEADER

// #include "centurion/video/opengl/gl_context.hpp"
#ifndef CENTURION_GL_CONTEXT_HEADER
#define CENTURION_GL_CONTEXT_HEADER

#ifndef CENTURION_NO_OPENGL

#include <SDL.h>

#include <cassert>  // assert
#include <memory>   // unique_ptr

// #include "../../core/exception.hpp"

// #include "../../core/owner.hpp"
#ifndef CENTURION_OWNER_HEADER
#define CENTURION_OWNER_HEADER

// #include "sfinae.hpp"
#ifndef CENTURION_SFINAE_HEADER
#define CENTURION_SFINAE_HEADER

#include <type_traits>  // enable_if_t, is_same_v, is_integral_v, is_floating_point_v, ...

namespace cen {

/// \addtogroup core
/// \{

// clang-format off

/// Enables a template if the type is either integral of floating-point, but not a boolean.
template <typename T>
using enable_if_number_t = std::enable_if_t<!std::is_same_v<T, bool> &&
                                            (std::is_integral_v<T> ||
                                             std::is_floating_point_v<T>), int>;

// clang-format on

/// Enables a template if the type is a pointer.
template <typename T>
using enable_if_pointer_v = std::enable_if_t<std::is_pointer_v<T>, int>;

/// Enables a template if T is convertible to any of the specified types.
template <typename T, typename... Args>
using enable_if_convertible_t = std::enable_if_t<(std::is_convertible_v<T, Args> || ...), int>;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_SFINAE_HEADER


namespace cen {

/**
 * \typedef owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote ownership of raw pointers directly in code.
 *
 * \details If a function takes an `owner<T*>` as a parameter, then the function will
 * claim ownership of that pointer. Subsequently, if a function returns an `owner<T*>`,
 * then ownership is transferred to the caller.
 */
template <typename T, enable_if_pointer_v<T> = 0>
using owner = T;

/**
 * \typedef maybe_owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote conditional ownership of raw pointers directly in code.
 *
 * \details This is primarily used in constructors of owner/handle classes, where the
 * owner version will claim ownership of the pointer, whilst the handle does not.
 *
 * \since 6.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using maybe_owner = T;

}  // namespace cen

#endif  // CENTURION_OWNER_HEADER
// #include "../../core/result.hpp"
#ifndef CENTURION_RESULT_HEADER
#define CENTURION_RESULT_HEADER

#include <ostream>  // ostream
#include <string>   // string

namespace cen {

/// \addtogroup core
/// \{

/**
 * \class result
 *
 * \brief A simple indicator for the result of different operations.
 *
 * \details The idea behind this class is to make results of various operations
 * unambiguous. Quite an amount of functions in the library may fail, and earlier versions
 * of Centurion would usually return a `bool` in those cases, where `true` and `false`
 * would indicate success and failure, respectively. This class is a development of that
 * practice. For instance, this class is contextually convertible to `bool`, where a
 * successful result is still converted to `true`, and vice versa. However, this class
 * also enables explicit checks against `success` and `failure` constants, which makes
 * code very easy to read and unambiguous.
 * \code{cpp}
 *   cen::window window;
 *
 *   if (window.set_opacity(0.4f))
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::success)
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::failure)
 *   {
 *     // Failure!
 *   }
 * \endcode
 *
 * \see `success`
 * \see `failure`
 *
 * \since 6.0.0
 */
class result final
{
 public:
  /**
   * \brief Creates a result.
   *
   * \param success `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  constexpr result(const bool success) noexcept  // NOLINT implicit
      : m_success{success}
  {}

  /// \name Comparison operators
  /// \{

  /**
   * \brief Indicates whether or not two results have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results are equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator==(const result other) const noexcept -> bool
  {
    return m_success == other.m_success;
  }

  /**
   * \brief Indicates whether or not two results don't have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results aren't equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator!=(const result other) const noexcept -> bool
  {
    return !(*this == other);
  }

  /// \} End of comparison operators

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not the result is successful.
   *
   * \return `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr explicit operator bool() const noexcept
  {
    return m_success;
  }

  /// \} End of conversions

 private:
  bool m_success{};
};

/// Represents a successful result.
/// \since 6.0.0
inline constexpr result success{true};

/// Represents a failure of some kind.
/// \since 6.0.0
inline constexpr result failure{false};

/// \name String conversions
/// \{

/**
 * \brief Returns a string that represents a result value.
 *
 * \note The returned string is in a slightly different format compared to other Centurion
 * components.
 *
 * \param result the value that will be converted.
 *
 * \return `"success"` for a successful result; `"failure"` otherwise.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto to_string(const result result) -> std::string
{
  return result ? "success" : "failure";
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a result value using a stream.
 *
 * \param stream the stream that will be used.
 * \param result the result value that will be printed.
 *
 * \return the used stream.
 *
 * \since 6.0.0
 */
inline auto operator<<(std::ostream& stream, const result result) -> std::ostream&
{
  return stream << to_string(result);
}

/// \} End of streaming

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_RESULT_HEADER

// #include "../../detail/owner_handle_api.hpp"
#ifndef CENTURION_DETAIL_OWNER_HANDLE_API_HEADER
#define CENTURION_DETAIL_OWNER_HANDLE_API_HEADER

#include <cassert>      // assert
#include <memory>       // unique_ptr
#include <type_traits>  // enable_if_t, is_same_v, true_type, false_type

// #include "../core/exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER


/// \cond FALSE
namespace cen::detail {

using owning_type = std::true_type;
using handle_type = std::false_type;

template <typename T>
using is_owner = std::enable_if_t<std::is_same_v<T, owning_type>, int>;

template <typename T>
using is_handle = std::enable_if_t<std::is_same_v<T, handle_type>, int>;

template <typename T>
[[nodiscard]] constexpr auto is_owning() noexcept -> bool
{
  return std::is_same_v<T, owning_type>;
}

template <typename B, typename Type, typename Deleter>
class pointer_manager final
{
  using managed_ptr = std::unique_ptr<Type, Deleter>;
  using raw_ptr = Type*;
  using pointer_type = std::conditional_t<B::value, managed_ptr, raw_ptr>;

 public:
  pointer_manager() noexcept = default;

  explicit pointer_manager(Type* ptr) noexcept : m_ptr{ptr}
  {}

  template <typename BB = B, is_owner<BB> = 0>
  void reset(Type* ptr) noexcept
  {
    m_ptr.reset(ptr);
  }

  auto operator->() noexcept -> Type*
  {
    return get();
  }

  auto operator->() const noexcept -> const Type*
  {
    return get();
  }

  auto operator*() noexcept -> Type&
  {
    assert(m_ptr);
    return *m_ptr;
  }

  auto operator*() const noexcept -> const Type&
  {
    assert(m_ptr);
    return *m_ptr;
  }

  explicit operator bool() const noexcept
  {
    return m_ptr != nullptr;
  }

  /*implicit*/ operator Type*() const noexcept
  {
    return get();
  }

  template <typename BB = B, is_owner<BB> = 0>
  [[nodiscard]] auto release() noexcept -> Type*
  {
    return m_ptr.release();
  }

  [[nodiscard]] auto get() const noexcept -> Type*
  {
    if constexpr (B::value) {
      return m_ptr.get();
    }
    else {
      return m_ptr;
    }
  }

 private:
  pointer_type m_ptr{};
};

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_OWNER_HANDLE_API_HEADER

// #include "../window.hpp"
#ifndef CENTURION_WINDOW_HEADER
#define CENTURION_WINDOW_HEADER

#include <SDL.h>

#include <cassert>   // assert
#include <optional>  // optional
#include <ostream>   // ostream
#include <string>    // string, to_string

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER

// #include "../core/integers.hpp"
#ifndef CENTURION_INTEGERS_HEADER
#define CENTURION_INTEGERS_HEADER

#include <SDL.h>

#include <cstddef>  // size_t

namespace cen {

/// \addtogroup core
/// \{

/// \name Integer aliases
/// \{

using usize = std::size_t;

/// Alias for an unsigned integer.
using uint = unsigned int;

/// Alias for the type used for integer literal operators.
using ulonglong = unsigned long long;

/// Alias for a 64-bit unsigned integer.
using u64 = Uint64;

/// Alias for a 32-bit unsigned integer.
using u32 = Uint32;

/// Alias for a 16-bit unsigned integer.
using u16 = Uint16;

/// Alias for an 8-bit unsigned integer.
using u8 = Uint8;

/// Alias for a 64-bit signed integer.
using i64 = Sint64;

/// Alias for a 32-bit signed integer.
using i32 = Sint32;

/// Alias for a 16-bit signed integer.
using i16 = Sint16;

/// Alias for an 8-bit signed integer.
using i8 = Sint8;

/// \} End of integer aliases

// clang-format off

/**
 * \brief Obtains the size of a container as an `int`.
 *
 * \tparam T a "container" that provides a `size()` member function.
 *
 * \param container the container to query the size of.
 *
 * \return the size of the container as an `int` value.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto isize(const T& container) noexcept(noexcept(container.size()))
    -> int
{
  return static_cast<int>(container.size());
}

// clang-format on

namespace literals {

/**
 * \brief Creates an 8-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u8(const ulonglong value) noexcept -> u8
{
  return static_cast<u8>(value);
}

/**
 * \brief Creates a 16-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u16(const ulonglong value) noexcept -> u16
{
  return static_cast<u16>(value);
}

/**
 * \brief Creates a 32-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u32(const ulonglong value) noexcept -> u32
{
  return static_cast<u32>(value);
}

/**
 * \brief Creates a 64-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u64(const ulonglong value) noexcept -> u64
{
  return static_cast<u64>(value);
}

/**
 * \brief Creates an 8-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i8(const ulonglong value) noexcept -> i8
{
  return static_cast<i8>(value);
}

/**
 * \brief Creates a 16-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i16(const ulonglong value) noexcept -> i16
{
  return static_cast<i16>(value);
}

/**
 * \brief Creates a 32-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i32(const ulonglong value) noexcept -> i32
{
  return static_cast<i32>(value);
}

/**
 * \brief Creates a 64-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i64(const ulonglong value) noexcept -> i64
{
  return static_cast<i64>(value);
}

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_INTEGERS_HEADER

// #include "../core/not_null.hpp"
#ifndef CENTURION_NOT_NULL_HEADER
#define CENTURION_NOT_NULL_HEADER

// #include "sfinae.hpp"
#ifndef CENTURION_SFINAE_HEADER
#define CENTURION_SFINAE_HEADER

#include <type_traits>  // enable_if_t, is_same_v, is_integral_v, is_floating_point_v, ...

namespace cen {

/// \addtogroup core
/// \{

// clang-format off

/// Enables a template if the type is either integral of floating-point, but not a boolean.
template <typename T>
using enable_if_number_t = std::enable_if_t<!std::is_same_v<T, bool> &&
                                            (std::is_integral_v<T> ||
                                             std::is_floating_point_v<T>), int>;

// clang-format on

/// Enables a template if the type is a pointer.
template <typename T>
using enable_if_pointer_v = std::enable_if_t<std::is_pointer_v<T>, int>;

/// Enables a template if T is convertible to any of the specified types.
template <typename T, typename... Args>
using enable_if_convertible_t = std::enable_if_t<(std::is_convertible_v<T, Args> || ...), int>;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_SFINAE_HEADER


namespace cen {

/**
 * \typedef not_null
 *
 * \ingroup core
 *
 * \brief Tag used to indicate that a pointer cannot be null.
 *
 * \note This alias is equivalent to `T`, it is a no-op.
 *
 * \since 5.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using not_null = T;

}  // namespace cen

#endif  // CENTURION_NOT_NULL_HEADER

// #include "../core/owner.hpp"
#ifndef CENTURION_OWNER_HEADER
#define CENTURION_OWNER_HEADER

// #include "sfinae.hpp"


namespace cen {

/**
 * \typedef owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote ownership of raw pointers directly in code.
 *
 * \details If a function takes an `owner<T*>` as a parameter, then the function will
 * claim ownership of that pointer. Subsequently, if a function returns an `owner<T*>`,
 * then ownership is transferred to the caller.
 */
template <typename T, enable_if_pointer_v<T> = 0>
using owner = T;

/**
 * \typedef maybe_owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote conditional ownership of raw pointers directly in code.
 *
 * \details This is primarily used in constructors of owner/handle classes, where the
 * owner version will claim ownership of the pointer, whilst the handle does not.
 *
 * \since 6.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using maybe_owner = T;

}  // namespace cen

#endif  // CENTURION_OWNER_HEADER
// #include "../core/result.hpp"
#ifndef CENTURION_RESULT_HEADER
#define CENTURION_RESULT_HEADER

#include <ostream>  // ostream
#include <string>   // string

namespace cen {

/// \addtogroup core
/// \{

/**
 * \class result
 *
 * \brief A simple indicator for the result of different operations.
 *
 * \details The idea behind this class is to make results of various operations
 * unambiguous. Quite an amount of functions in the library may fail, and earlier versions
 * of Centurion would usually return a `bool` in those cases, where `true` and `false`
 * would indicate success and failure, respectively. This class is a development of that
 * practice. For instance, this class is contextually convertible to `bool`, where a
 * successful result is still converted to `true`, and vice versa. However, this class
 * also enables explicit checks against `success` and `failure` constants, which makes
 * code very easy to read and unambiguous.
 * \code{cpp}
 *   cen::window window;
 *
 *   if (window.set_opacity(0.4f))
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::success)
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::failure)
 *   {
 *     // Failure!
 *   }
 * \endcode
 *
 * \see `success`
 * \see `failure`
 *
 * \since 6.0.0
 */
class result final
{
 public:
  /**
   * \brief Creates a result.
   *
   * \param success `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  constexpr result(const bool success) noexcept  // NOLINT implicit
      : m_success{success}
  {}

  /// \name Comparison operators
  /// \{

  /**
   * \brief Indicates whether or not two results have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results are equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator==(const result other) const noexcept -> bool
  {
    return m_success == other.m_success;
  }

  /**
   * \brief Indicates whether or not two results don't have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results aren't equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator!=(const result other) const noexcept -> bool
  {
    return !(*this == other);
  }

  /// \} End of comparison operators

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not the result is successful.
   *
   * \return `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr explicit operator bool() const noexcept
  {
    return m_success;
  }

  /// \} End of conversions

 private:
  bool m_success{};
};

/// Represents a successful result.
/// \since 6.0.0
inline constexpr result success{true};

/// Represents a failure of some kind.
/// \since 6.0.0
inline constexpr result failure{false};

/// \name String conversions
/// \{

/**
 * \brief Returns a string that represents a result value.
 *
 * \note The returned string is in a slightly different format compared to other Centurion
 * components.
 *
 * \param result the value that will be converted.
 *
 * \return `"success"` for a successful result; `"failure"` otherwise.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto to_string(const result result) -> std::string
{
  return result ? "success" : "failure";
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a result value using a stream.
 *
 * \param stream the stream that will be used.
 * \param result the result value that will be printed.
 *
 * \return the used stream.
 *
 * \since 6.0.0
 */
inline auto operator<<(std::ostream& stream, const result result) -> std::ostream&
{
  return stream << to_string(result);
}

/// \} End of streaming

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_RESULT_HEADER

// #include "../core/str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER

// #include "../detail/address_of.hpp"
#ifndef CENTURION_DETAIL_ADDRESS_OF_HEADER
#define CENTURION_DETAIL_ADDRESS_OF_HEADER

#include <sstream>  // stringstream
#include <string>   // string

// #include "../compiler/compiler.hpp"
#ifndef CENTURION_COMPILER_HEADER
#define CENTURION_COMPILER_HEADER

#include <SDL.h>

namespace cen {

/// \addtogroup compiler
/// \{

/**
 * \brief Indicates whether or not a "debug" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a debug build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_debug_build() noexcept -> bool
{
#ifndef NDEBUG
  return true;
#else
  return false;
#endif  // NDEBUG
}

/**
 * \brief Indicates whether or not a "release" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a release build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_release_build() noexcept -> bool
{
  return !is_debug_build();
}

/**
 * \brief Indicates whether or not the compiler is MSVC.
 *
 * \return `true` if MSVC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_msvc() noexcept -> bool
{
#ifdef _MSC_VER
  return true;
#else
  return false;
#endif  // _MSC_VER
}

/**
 * \brief Indicates whether or not the compiler is GCC.
 *
 * \return `true` if GCC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_gcc() noexcept -> bool
{
#ifdef __GNUC__
  return true;
#else
  return false;
#endif  // __GNUC__
}

/**
 * \brief Indicates whether or not the compiler is Clang.
 *
 * \return `true` if Clang is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_clang() noexcept -> bool
{
#ifdef __clang__
  return true;
#else
  return false;
#endif  // __clang__
}

/**
 * \brief Indicates whether or not the compiler is Emscripten.
 *
 * \return `true` if Emscripten is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_emscripten() noexcept -> bool
{
#ifdef __EMSCRIPTEN__
  return true;
#else
  return false;
#endif  // __EMSCRIPTEN__
}

/**
 * \brief Indicates whether or not the compiler is Intel C++.
 *
 * \return `true` if Intel C++ is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_intel_cpp() noexcept -> bool
{
#ifdef __INTEL_COMPILER
  return true;
#else
  return false;
#endif  // __INTEL_COMPILER
}

/// \} End of compiler group

}  // namespace cen

#endif  // CENTURION_COMPILER_HEADER


/// \cond FALSE
namespace cen::detail {

/**
 * \brief Returns a string that represents the memory address of the supplied pointer.
 *
 * \details The empty string is returned if the supplied pointer is null.
 *
 * \tparam T the type of the pointer.
 * \param ptr the pointer that will be converted.
 *
 * \return a string that represents the memory address of the supplied pointer.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto address_of(const void* ptr) -> std::string
{
  if (ptr) {
    std::stringstream stream;

    if constexpr (on_msvc()) {
      stream << "0x";  // Only MSVC seems to omit this, add it for consistency
    }

    stream << ptr;
    return stream.str();
  }
  else {
    return std::string{};
  }
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_ADDRESS_OF_HEADER

// #include "../detail/clamp.hpp"
#ifndef CENTURION_DETAIL_CLAMP_HEADER
#define CENTURION_DETAIL_CLAMP_HEADER

#include <cassert>  // assert

/// \cond FALSE
namespace cen::detail {

// clang-format off

/**
 * \brief Clamps a value to be within the range [min, max].
 *
 * \pre `min` must be less than or equal to `max`.
 *
 * \note The standard library provides `std::clamp`, but it isn't mandated to be
 * `noexcept` (although MSVC does mark it as `noexcept`), which is the reason this
 * function exists.
 *
 * \tparam T the type of the values.
 *
 * \param value the value that will be clamped.
 * \param min the minimum value (inclusive).
 * \param max the maximum value (inclusive).
 *
 * \return the clamped value.
 *
 * \since 5.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto clamp(const T& value,
                                   const T& min,
                                   const T& max)
    noexcept(noexcept(value < min) && noexcept(value > max)) -> T
{
  assert(min <= max);
  if (value < min)
  {
    return min;
  }
  else if (value > max)
  {
    return max;
  }
  else
  {
    return value;
  }
}

// clang-format on

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_CLAMP_HEADER

// #include "../detail/convert_bool.hpp"
#ifndef CENTURION_DETAIL_CONVERT_BOOL_HEADER
#define CENTURION_DETAIL_CONVERT_BOOL_HEADER

#include <SDL.h>

/// \cond FALSE
namespace cen::detail {

/**
 * \brief Returns the corresponding `SDL_bool` value for the supplied boolean value.
 *
 * \param b the boolean value that will be converted.
 *
 * \return `SDL_TRUE` for `true`; `SDL_FALSE` for `false`.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto convert_bool(const bool b) noexcept -> SDL_bool
{
  return b ? SDL_TRUE : SDL_FALSE;
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_CONVERT_BOOL_HEADER

// #include "../detail/max.hpp"
#ifndef CENTURION_DETAIL_MAX_HEADER
#define CENTURION_DETAIL_MAX_HEADER

/// \cond FALSE
namespace cen::detail {

template <typename T>
[[nodiscard]] constexpr auto max(const T& a, const T& b) noexcept(noexcept(a < b)) -> T
{
  return (a < b) ? b : a;
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_MAX_HEADER

// #include "../detail/owner_handle_api.hpp"
#ifndef CENTURION_DETAIL_OWNER_HANDLE_API_HEADER
#define CENTURION_DETAIL_OWNER_HANDLE_API_HEADER

#include <cassert>      // assert
#include <memory>       // unique_ptr
#include <type_traits>  // enable_if_t, is_same_v, true_type, false_type

// #include "../core/exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER


/// \cond FALSE
namespace cen::detail {

using owning_type = std::true_type;
using handle_type = std::false_type;

template <typename T>
using is_owner = std::enable_if_t<std::is_same_v<T, owning_type>, int>;

template <typename T>
using is_handle = std::enable_if_t<std::is_same_v<T, handle_type>, int>;

template <typename T>
[[nodiscard]] constexpr auto is_owning() noexcept -> bool
{
  return std::is_same_v<T, owning_type>;
}

template <typename B, typename Type, typename Deleter>
class pointer_manager final
{
  using managed_ptr = std::unique_ptr<Type, Deleter>;
  using raw_ptr = Type*;
  using pointer_type = std::conditional_t<B::value, managed_ptr, raw_ptr>;

 public:
  pointer_manager() noexcept = default;

  explicit pointer_manager(Type* ptr) noexcept : m_ptr{ptr}
  {}

  template <typename BB = B, is_owner<BB> = 0>
  void reset(Type* ptr) noexcept
  {
    m_ptr.reset(ptr);
  }

  auto operator->() noexcept -> Type*
  {
    return get();
  }

  auto operator->() const noexcept -> const Type*
  {
    return get();
  }

  auto operator*() noexcept -> Type&
  {
    assert(m_ptr);
    return *m_ptr;
  }

  auto operator*() const noexcept -> const Type&
  {
    assert(m_ptr);
    return *m_ptr;
  }

  explicit operator bool() const noexcept
  {
    return m_ptr != nullptr;
  }

  /*implicit*/ operator Type*() const noexcept
  {
    return get();
  }

  template <typename BB = B, is_owner<BB> = 0>
  [[nodiscard]] auto release() noexcept -> Type*
  {
    return m_ptr.release();
  }

  [[nodiscard]] auto get() const noexcept -> Type*
  {
    if constexpr (B::value) {
      return m_ptr.get();
    }
    else {
      return m_ptr;
    }
  }

 private:
  pointer_type m_ptr{};
};

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_OWNER_HANDLE_API_HEADER

// #include "../math/area.hpp"
#ifndef CENTURION_AREA_HEADER
#define CENTURION_AREA_HEADER

#include <ostream>      // ostream
#include <string>       // string, to_string
#include <type_traits>  // is_integral_v, is_floating_point_v, is_same_v

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/cast.hpp"
#ifndef CENTURION_CAST_HEADER
#define CENTURION_CAST_HEADER

namespace cen {

/**
 * \brief Casts a value to a value of another type.
 *
 * \ingroup core
 *
 * \details This is the default implementation, which simply attempts to use
 * `static_cast`. The idea is that this function will be specialized for various Centurion
 * and SDL types. This is useful because it isn't always possible to implement conversion
 * operators as members.
 *
 * \tparam To the type of the value that will be converted.
 * \tparam From the type that the value will be casted to.
 *
 * \param from the value that will be converted.
 *
 * \return the result of casting the supplied value to the specified type.
 *
 * \since 5.0.0
 */
template <typename To, typename From>
[[nodiscard]] constexpr auto cast(const From& from) noexcept -> To
{
  return static_cast<To>(from);
}

}  // namespace cen

#endif  // CENTURION_CAST_HEADER


namespace cen {

/// \addtogroup math
/// \{

template <typename T>
struct basic_area;

/**
 * \typedef iarea
 *
 * \brief An alias for `int` areas.
 *
 * \since 4.1.0
 */
using iarea = basic_area<int>;

/**
 * \typedef farea
 *
 * \brief An alias for `float` areas.
 *
 * \since 4.1.0
 */
using farea = basic_area<float>;

/**
 * \typedef darea
 *
 * \brief An alias for `double` areas.
 *
 * \since 4.1.0
 */
using darea = basic_area<double>;

/**
 * \struct basic_area
 *
 * \brief Simply represents an area with a width and height.
 *
 * \serializable
 *
 * \tparam T the type of the components of the area. Must be either an integral or
 * floating-point type. Can't be `bool`.
 *
 * \since 4.0.0
 *
 * \see `iarea`
 * \see `farea`
 * \see `darea`
 */
template <typename T>
struct basic_area final
{
  static_assert(std::is_integral_v<T> || std::is_floating_point_v<T>);
  static_assert(!std::is_same_v<T, bool>);

  using value_type = T;

  T width{0};   ///< The width of the area.
  T height{0};  ///< The height of the area.

#if CENTURION_HAS_FEATURE_SPACESHIP

  [[nodiscard]] constexpr auto operator==(const basic_area&) const noexcept -> bool = default;

#endif  // CENTURION_HAS_FEATURE_SPACESHIP
};

/// \name Area-related functions
/// \{

/**
 * \brief Creates an area instance with automatically deduced precision.
 *
 * \tparam T the deduced type of the width and height values.
 *
 * \param width the width of the area.
 * \param height the height of the area.
 *
 * \return an area instance with the specified width and height.
 *
 * \since 6.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto area(const T width, const T height) noexcept -> basic_area<T>
{
  return {width, height};
}

/**
 * \brief Returns the size (width x height) of an area.
 *
 * \tparam T the representation type.
 *
 * \param area the area instance that will be calculated.
 *
 * \return the size of the area.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto area_of(const basic_area<T> area) noexcept -> T
{
  return area.width * area.height;
}

/// \} End of area-related functions

/**
 * \brief Serializes an area instance.
 *
 * \details This function expects that the archive provides an overloaded `operator()`,
 * used for serializing data. This API is based on the Cereal serialization library.
 *
 * \tparam Archive the type of the archive.
 * \tparam T the type of the area components.
 *
 * \param archive the archive used to serialize the area.
 * \param area the area that will be serialized.
 *
 * \since 5.3.0
 */
template <typename Archive, typename T>
void serialize(Archive& archive, basic_area<T>& area)
{
  archive(area.width, area.height);
}

/// \name Area cast specializations
/// \{

template <>
[[nodiscard]] constexpr auto cast(const iarea& from) noexcept -> darea
{
  return {static_cast<double>(from.width), static_cast<double>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const iarea& from) noexcept -> farea
{
  return {static_cast<float>(from.width), static_cast<float>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const farea& from) noexcept -> darea
{
  return {static_cast<double>(from.width), static_cast<double>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const farea& from) noexcept -> iarea
{
  return {static_cast<int>(from.width), static_cast<int>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const darea& from) noexcept -> farea
{
  return {static_cast<float>(from.width), static_cast<float>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const darea& from) noexcept -> iarea
{
  return {static_cast<int>(from.width), static_cast<int>(from.height)};
}

/// \} End of area cast specializations

/// \name Area comparison operators
/// \{

#if !CENTURION_HAS_FEATURE_SPACESHIP

/**
 * \brief Indicates whether or not two areas are considered to be equal.
 *
 * \param lhs the left-hand side area.
 * \param rhs the right-hand side area.
 *
 * \return `true` if the areas are equal; `false` otherwise.
 *
 * \since 4.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator==(const basic_area<T>& lhs,
                                        const basic_area<T>& rhs) noexcept -> bool
{
  return (lhs.width == rhs.width) && (lhs.height == rhs.height);
}

/**
 * \brief Indicates whether or not two areas aren't considered to be equal.
 *
 * \param lhs the left-hand side area.
 * \param rhs the right-hand side area.
 *
 * \return `true` if the areas aren't equal; `false` otherwise.
 *
 * \since 4.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator!=(const basic_area<T>& lhs,
                                        const basic_area<T>& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

#endif  // CENTURION_HAS_FEATURE_SPACESHIP

/// \} End of area comparison operators

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of an area.
 *
 * \tparam T the type of the area components.
 *
 * \param area the area that will be converted.
 *
 * \return a string that represents the area.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_area<T>& area) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("area{{width: {}, height: {}}}", area.width, area.height);
#else
  return "area{width: " + std::to_string(area.width) +
         ", height: " + std::to_string(area.height) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of an area using a stream.
 *
 * \tparam T the type of the area components.
 *
 * \param stream the stream that will be used.
 * \param area the are that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_area<T>& area) -> std::ostream&
{
  return stream << to_string(area);
}

/// \} End of streaming

/// \} End of group math

}  // namespace cen

#endif  // CENTURION_AREA_HEADER
// #include "../math/rect.hpp"
#ifndef CENTURION_RECTANGLE_HEADER
#define CENTURION_RECTANGLE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string>       // string, to_string
#include <type_traits>  // conditional_t, is_integral_v, is_floating_point_v, ...

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/cast.hpp"

// #include "../core/sfinae.hpp"
#ifndef CENTURION_SFINAE_HEADER
#define CENTURION_SFINAE_HEADER

#include <type_traits>  // enable_if_t, is_same_v, is_integral_v, is_floating_point_v, ...

namespace cen {

/// \addtogroup core
/// \{

// clang-format off

/// Enables a template if the type is either integral of floating-point, but not a boolean.
template <typename T>
using enable_if_number_t = std::enable_if_t<!std::is_same_v<T, bool> &&
                                            (std::is_integral_v<T> ||
                                             std::is_floating_point_v<T>), int>;

// clang-format on

/// Enables a template if the type is a pointer.
template <typename T>
using enable_if_pointer_v = std::enable_if_t<std::is_pointer_v<T>, int>;

/// Enables a template if T is convertible to any of the specified types.
template <typename T, typename... Args>
using enable_if_convertible_t = std::enable_if_t<(std::is_convertible_v<T, Args> || ...), int>;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_SFINAE_HEADER

// #include "../detail/max.hpp"
#ifndef CENTURION_DETAIL_MAX_HEADER
#define CENTURION_DETAIL_MAX_HEADER

/// \cond FALSE
namespace cen::detail {

template <typename T>
[[nodiscard]] constexpr auto max(const T& a, const T& b) noexcept(noexcept(a < b)) -> T
{
  return (a < b) ? b : a;
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_MAX_HEADER

// #include "../detail/min.hpp"
#ifndef CENTURION_DETAIL_MIN_HEADER
#define CENTURION_DETAIL_MIN_HEADER

/// \cond FALSE
namespace cen::detail {

template <typename T>
[[nodiscard]] constexpr auto min(const T& a, const T& b) noexcept(noexcept(a < b)) -> T
{
  return (a < b) ? a : b;
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_MIN_HEADER

// #include "area.hpp"
#ifndef CENTURION_AREA_HEADER
#define CENTURION_AREA_HEADER

#include <ostream>      // ostream
#include <string>       // string, to_string
#include <type_traits>  // is_integral_v, is_floating_point_v, is_same_v

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/cast.hpp"


namespace cen {

/// \addtogroup math
/// \{

template <typename T>
struct basic_area;

/**
 * \typedef iarea
 *
 * \brief An alias for `int` areas.
 *
 * \since 4.1.0
 */
using iarea = basic_area<int>;

/**
 * \typedef farea
 *
 * \brief An alias for `float` areas.
 *
 * \since 4.1.0
 */
using farea = basic_area<float>;

/**
 * \typedef darea
 *
 * \brief An alias for `double` areas.
 *
 * \since 4.1.0
 */
using darea = basic_area<double>;

/**
 * \struct basic_area
 *
 * \brief Simply represents an area with a width and height.
 *
 * \serializable
 *
 * \tparam T the type of the components of the area. Must be either an integral or
 * floating-point type. Can't be `bool`.
 *
 * \since 4.0.0
 *
 * \see `iarea`
 * \see `farea`
 * \see `darea`
 */
template <typename T>
struct basic_area final
{
  static_assert(std::is_integral_v<T> || std::is_floating_point_v<T>);
  static_assert(!std::is_same_v<T, bool>);

  using value_type = T;

  T width{0};   ///< The width of the area.
  T height{0};  ///< The height of the area.

#if CENTURION_HAS_FEATURE_SPACESHIP

  [[nodiscard]] constexpr auto operator==(const basic_area&) const noexcept -> bool = default;

#endif  // CENTURION_HAS_FEATURE_SPACESHIP
};

/// \name Area-related functions
/// \{

/**
 * \brief Creates an area instance with automatically deduced precision.
 *
 * \tparam T the deduced type of the width and height values.
 *
 * \param width the width of the area.
 * \param height the height of the area.
 *
 * \return an area instance with the specified width and height.
 *
 * \since 6.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto area(const T width, const T height) noexcept -> basic_area<T>
{
  return {width, height};
}

/**
 * \brief Returns the size (width x height) of an area.
 *
 * \tparam T the representation type.
 *
 * \param area the area instance that will be calculated.
 *
 * \return the size of the area.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto area_of(const basic_area<T> area) noexcept -> T
{
  return area.width * area.height;
}

/// \} End of area-related functions

/**
 * \brief Serializes an area instance.
 *
 * \details This function expects that the archive provides an overloaded `operator()`,
 * used for serializing data. This API is based on the Cereal serialization library.
 *
 * \tparam Archive the type of the archive.
 * \tparam T the type of the area components.
 *
 * \param archive the archive used to serialize the area.
 * \param area the area that will be serialized.
 *
 * \since 5.3.0
 */
template <typename Archive, typename T>
void serialize(Archive& archive, basic_area<T>& area)
{
  archive(area.width, area.height);
}

/// \name Area cast specializations
/// \{

template <>
[[nodiscard]] constexpr auto cast(const iarea& from) noexcept -> darea
{
  return {static_cast<double>(from.width), static_cast<double>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const iarea& from) noexcept -> farea
{
  return {static_cast<float>(from.width), static_cast<float>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const farea& from) noexcept -> darea
{
  return {static_cast<double>(from.width), static_cast<double>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const farea& from) noexcept -> iarea
{
  return {static_cast<int>(from.width), static_cast<int>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const darea& from) noexcept -> farea
{
  return {static_cast<float>(from.width), static_cast<float>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const darea& from) noexcept -> iarea
{
  return {static_cast<int>(from.width), static_cast<int>(from.height)};
}

/// \} End of area cast specializations

/// \name Area comparison operators
/// \{

#if !CENTURION_HAS_FEATURE_SPACESHIP

/**
 * \brief Indicates whether or not two areas are considered to be equal.
 *
 * \param lhs the left-hand side area.
 * \param rhs the right-hand side area.
 *
 * \return `true` if the areas are equal; `false` otherwise.
 *
 * \since 4.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator==(const basic_area<T>& lhs,
                                        const basic_area<T>& rhs) noexcept -> bool
{
  return (lhs.width == rhs.width) && (lhs.height == rhs.height);
}

/**
 * \brief Indicates whether or not two areas aren't considered to be equal.
 *
 * \param lhs the left-hand side area.
 * \param rhs the right-hand side area.
 *
 * \return `true` if the areas aren't equal; `false` otherwise.
 *
 * \since 4.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator!=(const basic_area<T>& lhs,
                                        const basic_area<T>& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

#endif  // CENTURION_HAS_FEATURE_SPACESHIP

/// \} End of area comparison operators

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of an area.
 *
 * \tparam T the type of the area components.
 *
 * \param area the area that will be converted.
 *
 * \return a string that represents the area.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_area<T>& area) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("area{{width: {}, height: {}}}", area.width, area.height);
#else
  return "area{width: " + std::to_string(area.width) +
         ", height: " + std::to_string(area.height) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of an area using a stream.
 *
 * \tparam T the type of the area components.
 *
 * \param stream the stream that will be used.
 * \param area the are that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_area<T>& area) -> std::ostream&
{
  return stream << to_string(area);
}

/// \} End of streaming

/// \} End of group math

}  // namespace cen

#endif  // CENTURION_AREA_HEADER
// #include "point.hpp"
#ifndef CENTURION_POINT_HEADER
#define CENTURION_POINT_HEADER

#include <SDL.h>

#include <cmath>        // sqrt, abs, round
#include <ostream>      // ostream
#include <string>       // string, to_string
#include <type_traits>  // conditional_t, is_integral_v, is_floating_point_v, ...

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/cast.hpp"

// #include "../core/sfinae.hpp"


namespace cen {

/// \addtogroup math
/// \{

/**
 * \brief Provides traits used by the `basic_point` class.
 *
 * \tparam T the representation type. Must be convertible to `int` or `float`.
 *
 * \since 5.0.0
 *
 * \see `basic_point`
 * \see `ipoint`
 * \see `fpoint`
 */
template <typename T, enable_if_convertible_t<T, int, float> = 0>
class point_traits final
{
 public:
  /**
   * \var isIntegral
   *
   * \brief Indicates whether or not the point is based on an integral type.
   *
   * \since 5.0.0
   */
  inline constexpr static bool isIntegral = std::is_integral_v<T>;

  /**
   * \var isFloating
   *
   * \brief Indicates whether or not the point is based on a floating-point
   * type.
   *
   * \since 5.0.0
   */
  inline constexpr static bool isFloating = std::is_floating_point_v<T>;

  /**
   * \typedef value_type
   *
   * \brief The actual representation type, i.e. `int` or `float`.
   *
   * \since 5.0.0
   */
  using value_type = std::conditional_t<isIntegral, int, float>;

  /**
   * \typedef point_type
   *
   * \brief The SDL point type, i.e. `SDL_Point` or `SDL_FPoint`.
   *
   * \since 5.0.0
   */
  using point_type = std::conditional_t<isIntegral, SDL_Point, SDL_FPoint>;
};

template <typename T>
class basic_point;

/**
 * \typedef ipoint
 *
 * \brief Alias for an `int`-based point.
 *
 * \details This type corresponds to `SDL_Point`.
 *
 * \since 5.0.0
 */
using ipoint = basic_point<int>;

/**
 * \typedef fpoint
 *
 * \brief Alias for a `float`-based point.
 *
 * \details This type corresponds to `SDL_FPoint`.
 *
 * \since 5.0.0
 */
using fpoint = basic_point<float>;

/**
 * \class basic_point
 *
 * \brief Represents a two-dimensional point.
 *
 * \serializable
 *
 * \details This class is designed as a wrapper for `SDL_Point` and `SDL_FPoint`. The
 * representation is specified by the type parameter.
 *
 * \note This point class will only use `int` or `float` as the actual internal
 * representation.
 *
 * \tparam T the representation type. Must be convertible to `int` or `float`.
 *
 * \since 5.0.0
 *
 * \see `ipoint`
 * \see `fpoint`
 * \see `point()`
 * \see `distance()`
 */
template <typename T>
class basic_point final
{
 public:
  /// \copydoc point_traits::isIntegral
  inline constexpr static bool isIntegral = point_traits<T>::isIntegral;

  /// \copydoc point_traits::isFloating
  inline constexpr static bool isFloating = point_traits<T>::isFloating;

  /// \copydoc point_traits::value_type
  using value_type = typename point_traits<T>::value_type;

  /// \copydoc point_traits::point_type
  using point_type = typename point_traits<T>::point_type;

  /// \name Construction
  /// \{

  /**
   * \brief Creates a zero-initialized point.
   *
   * \since 5.0.0
   */
  constexpr basic_point() noexcept = default;

  /**
   * \brief Creates a point with the specified coordinates.
   *
   * \param x the x-coordinate that will be used.
   * \param y the y-coordinate that will be used.
   *
   * \since 5.0.0
   */
  constexpr basic_point(const value_type x, const value_type y) noexcept
  {
    m_point.x = x;
    m_point.y = y;
  };

  /// \} End of construction

  /// \name Setters
  /// \{

  /**
   * \brief Sets the x-coordinate of the point.
   *
   * \param x the new x-coordinate.
   *
   * \since 5.0.0
   */
  constexpr void set_x(const value_type x) noexcept
  {
    m_point.x = x;
  }

  /**
   * \brief Sets the y-coordinate of the point.
   *
   * \param y the new y-coordinate.
   *
   * \since 5.0.0
   */
  constexpr void set_y(const value_type y) noexcept
  {
    m_point.y = y;
  }

  /// \} End of setters

  /// \name Getters
  /// \{

  /**
   * \brief Returns the x-coordinate of the point.
   *
   * \return the x-coordinate.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto x() const noexcept -> value_type
  {
    return m_point.x;
  }

  /**
   * \brief Returns the y-coordinate of the point.
   *
   * \return the y-coordinate.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto y() const noexcept -> value_type
  {
    return m_point.y;
  }

  /**
   * \brief Returns the internal point representation.
   *
   * \return a reference to the internal representation.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto get() noexcept -> point_type&
  {
    return m_point;
  }

  /// \copydoc get
  [[nodiscard]] constexpr auto get() const noexcept -> const point_type&
  {
    return m_point;
  }

  /**
   * \brief Returns a pointer to the internal point representation.
   *
   * \note Don't cache the returned pointer.
   *
   * \return a pointer to the point representation.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto data() noexcept -> point_type*
  {
    return &m_point;
  }

  /// \copydoc data
  [[nodiscard]] auto data() const noexcept -> const point_type*
  {
    return &m_point;
  }

  /// \} End of getters

  /// \name Conversions
  /// \{

  /**
   * \brief Converts to the internal representation.
   *
   * \return a copy of the internal point.
   *
   * \see `cen::cast`
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr explicit operator point_type() const noexcept
  {
    return m_point;
  }

  /// \copydoc data()
  [[nodiscard]] explicit operator point_type*() noexcept
  {
    return data();
  }

  /// \copydoc data()
  [[nodiscard]] explicit operator const point_type*() const noexcept
  {
    return data();
  }

  /// \} End of conversions

  /**
   * \brief Serializes the point.
   *
   * \details This function expects that the archive provides an overloaded `operator()`,
   * used for serializing data. This API is based on the Cereal serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the point.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_point.x, m_point.y);
  }

 private:
  point_type m_point{0, 0};
};

/// \name Point-related functions
/// \{

/**
 * \brief Creates a point instance with automatically deduced precision.
 *
 * \note The only supported precisions for points are `int` and `float`, so this function
 * will cast the supplied values to the corresponding type. For example, if you supply two
 * doubles to this function, the returned point will use float as the precision.
 *
 * \tparam T the deduced precision type, must be a numerical type other than `bool`.
 *
 * \param x the x-coordinate of the point.
 * \param y the y-coordinate of the point.
 *
 * \return the created point.
 *
 * \since 6.0.0
 */
template <typename T, enable_if_number_t<T> = 0>
[[nodiscard]] constexpr auto point(const T x, const T y) noexcept
    -> basic_point<typename point_traits<T>::value_type>
{
  using value_type = typename point_traits<T>::value_type;
  return basic_point<value_type>{static_cast<value_type>(x), static_cast<value_type>(y)};
}

/**
 * \brief Returns the distance between two points.
 *
 * \tparam T the representation type used by the points.
 *
 * \param from the first point.
 * \param to the second point.
 *
 * \return the distance between the two points.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto distance(const basic_point<T> from, const basic_point<T> to) noexcept ->
    typename point_traits<T>::value_type
{
  if constexpr (basic_point<T>::isIntegral) {
    const auto xDiff = std::pow(from.x() - to.x(), 2);
    const auto yDiff = std::pow(from.y() - to.y(), 2);
    const auto dist = std::sqrt(xDiff + yDiff);
    return static_cast<int>(std::round(dist));
  }
  else {
    return std::sqrt(std::pow(from.x() - to.x(), 2) + std::pow(from.y() - to.y(), 2));
  }
}

/// \} End of point-related functions

/// \name String conversions
/// \{

[[nodiscard]] inline auto to_string(const ipoint point) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("ipoint{{x: {}, y: {}}}", point.x(), point.y());
#else
  return "ipoint{x: " + std::to_string(point.x()) + ", y: " + std::to_string(point.y()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

[[nodiscard]] inline auto to_string(const fpoint point) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("fpoint{{x: {}, y: {}}}", point.x(), point.y());
#else
  return "fpoint{x: " + std::to_string(point.x()) + ", y: " + std::to_string(point.y()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

template <typename T>
auto operator<<(std::ostream& stream, const basic_point<T>& point) -> std::ostream&
{
  return stream << to_string(point);
}

/// \} End of streaming

/// \name Point cast specializations
/// \{

/**
 * \brief Converts an `fpoint` instance to the corresponding `ipoint`.
 *
 * \details This function casts the coordinates of the supplied point to `int`, and uses
 * the obtained values to create an `ipoint` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `ipoint` instance that corresponds to the supplied `fpoint`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const fpoint& from) noexcept -> ipoint
{
  const auto x = static_cast<int>(from.x());
  const auto y = static_cast<int>(from.y());
  return ipoint{x, y};
}

/**
 * \brief Converts an `ipoint` instance to the corresponding `fpoint`.
 *
 * \details This function casts the coordinates of the supplied point to `float`, and uses
 * the obtained values to create an `fpoint` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `fpoint` instance that corresponds to the supplied `ipoint`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const ipoint& from) noexcept -> fpoint
{
  const auto x = static_cast<float>(from.x());
  const auto y = static_cast<float>(from.y());
  return fpoint{x, y};
}

/**
 * \brief Converts an `SDL_FPoint` instance to the corresponding `SDL_Point`.
 *
 * \details This function casts the coordinates of the supplied point to `int`, and uses
 * the obtained values to create an `SDL_Point` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `SDL_Point` instance that corresponds to the supplied `SDL_FPoint`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const SDL_FPoint& from) noexcept -> SDL_Point
{
  const auto x = static_cast<int>(from.x);
  const auto y = static_cast<int>(from.y);
  return SDL_Point{x, y};
}

/**
 * \brief Converts an `SDL_Point` instance to the corresponding `SDL_FPoint`.
 *
 * \details This function casts the coordinates of the supplied point to `float`, and uses
 * the obtained values to create an `SDL_FPoint` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `SDL_FPoint` instance that corresponds to the supplied `SDL_Point`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const SDL_Point& from) noexcept -> SDL_FPoint
{
  const auto x = static_cast<float>(from.x);
  const auto y = static_cast<float>(from.y);
  return SDL_FPoint{x, y};
}

/// \} End of point cast specializations

/// \name Point addition and subtraction operators
/// \{

template <typename T>
[[nodiscard]] constexpr auto operator+(const basic_point<T>& lhs,
                                       const basic_point<T>& rhs) noexcept -> basic_point<T>
{
  return {lhs.x() + rhs.x(), lhs.y() + rhs.y()};
}

template <typename T>
[[nodiscard]] constexpr auto operator-(const basic_point<T>& lhs,
                                       const basic_point<T>& rhs) noexcept -> basic_point<T>
{
  return {lhs.x() - rhs.x(), lhs.y() - rhs.y()};
}

/// \} End of point addition and subtraction operators

/// \name Point comparison operators
/// \{

template <typename T>
[[nodiscard]] constexpr auto operator==(const basic_point<T> lhs,
                                        const basic_point<T> rhs) noexcept -> bool
{
  return (lhs.x() == rhs.x()) && (lhs.y() == rhs.y());
}

template <typename T>
[[nodiscard]] constexpr auto operator!=(const basic_point<T> lhs,
                                        const basic_point<T> rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of point comparison operators

/// \} End of group math

}  // namespace cen

#endif  // CENTURION_POINT_HEADER

namespace cen {

/// \addtogroup math
/// \{

/**
 * \class rect_traits
 *
 * \brief Provides rectangle traits used by `basic_rect`.
 *
 * \note Whilst it is possible to supply a type that isn't `int` or `float`, rectangles
 * will always use one of them as the representation type.
 *
 * \tparam T the representation type, must be convertible to `int` or `float`.
 *
 * \see `basic_rect`
 * \see `irect`
 * \see `frect`
 *
 * \since 5.0.0
 */
template <typename T, enable_if_convertible_t<T, int, float> = 0>
class rect_traits final
{
 public:
  inline constexpr static bool isIntegral = std::is_integral_v<T>;
  inline constexpr static bool isFloating = std::is_floating_point_v<T>;

  using value_type = std::conditional_t<isIntegral, int, float>;
  using point_type = std::conditional_t<isIntegral, ipoint, fpoint>;
  using area_type = std::conditional_t<isIntegral, iarea, farea>;
  using rect_type = std::conditional_t<isIntegral, SDL_Rect, SDL_FRect>;
};

template <typename T>
class basic_rect;

/**
 * \typedef irect
 *
 * \brief Alias for an `int`-based rectangle.
 *
 * \since 5.0.0
 */
using irect = basic_rect<int>;

/**
 * \typedef frect
 *
 * \brief Alias for a `float`-based rectangle.
 *
 * \since 5.0.0
 */
using frect = basic_rect<float>;

/**
 * \class basic_rect
 *
 * \brief A simple rectangle implementation, based on either `SDL_Rect` or `SDL_FRect`.
 *
 * \serializable
 *
 * \tparam T the representation type. Must be convertible to either `int` or `float`.
 *
 * \see `irect`
 * \see `frect`
 * \see `rect()`
 * \see `intersects()`
 * \see `collides()`
 * \see `get_union()`
 *
 * \since 4.0.0
 */
template <typename T>
class basic_rect final
{
 public:
  /**
   * \brief Indicates whether or not the rectangle is based on an integral type.
   *
   * \since 5.0.0
   */
  inline constexpr static bool isIntegral = rect_traits<T>::isIntegral;

  /**
   * \brief Indicates whether or not the rectangle is based on a floating-point
   * type.
   *
   * \since 5.0.0
   */
  inline constexpr static bool isFloating = rect_traits<T>::isFloating;

  /**
   * \typedef value_type
   *
   * \brief The representation type, i.e. `int` or `float`.
   *
   * \since 5.0.0
   */
  using value_type = typename rect_traits<T>::value_type;

  /**
   * \typedef point_type
   *
   * \brief The point type used, i.e. `ipoint` or `fpoint`.
   *
   * \since 5.0.0
   */
  using point_type = typename rect_traits<T>::point_type;

  /**
   * \typedef area_type
   *
   * \brief The area type used, i.e. `iarea` or `farea`.
   *
   * \since 5.0.0
   */
  using area_type = typename rect_traits<T>::area_type;

  /**
   * \typedef rect_type
   *
   * \brief The underlying SDL rectangle type, i.e. `SDL_Rect` or `SDL_FRect`.
   *
   * \since 5.0.0
   */
  using rect_type = typename rect_traits<T>::rect_type;

  /// \name Construction
  /// \{

  /**
   * \brief Creates a rectangle with the components (0, 0, 0, 0).
   *
   * \since 4.0.0
   */
  constexpr basic_rect() noexcept = default;

  /**
   * \brief Creates a rectangle based on an SDL rectangle.
   *
   * \param rect the rectangle that will be copied.
   *
   * \since 5.3.0
   */
  constexpr explicit basic_rect(const rect_type& rect) noexcept : m_rect{rect}
  {}

  /**
   * \brief Creates a rectangle with the supplied position and size.
   *
   * \param position the position of the rectangle.
   * \param size the size of the rectangle.
   *
   * \since 4.1.0
   */
  constexpr basic_rect(const point_type& position, const area_type& size) noexcept
      : m_rect{position.x(), position.y(), size.width, size.height}
  {}

  /**
   * \brief Creates a rectangle with the supplied position and size.
   *
   * \param x the x-coordinate of the rectangle.
   * \param y the y-coordinate of the rectangle.
   * \param width the width of the rectangle.
   * \param height the height of the rectangle.
   *
   * \since 5.3.0
   */
  constexpr basic_rect(const value_type x,
                       const value_type y,
                       const value_type width,
                       const value_type height) noexcept
      : m_rect{x, y, width, height}
  {}

  /// \} End of construction

  /// \name Setters
  /// \{

  /**
   * \brief Sets the x-coordinate of the rectangle.
   *
   * \param x the new x-coordinate of the rectangle.
   *
   * \since 4.0.0
   */
  constexpr void set_x(const value_type x) noexcept
  {
    m_rect.x = x;
  }

  /**
   * \brief Sets the y-coordinate of the rectangle.
   *
   * \param y the new y-coordinate of the rectangle.
   *
   * \since 4.0.0
   */
  constexpr void set_y(const value_type y) noexcept
  {
    m_rect.y = y;
  }

  /**
   * \brief Sets the maximum x-coordinate of the rectangle.
   *
   * \note This function preserves the width of the rectangle.
   *
   * \param maxX the new maximum x-coordinate of the rectangle.
   *
   * \since 5.1.0
   */
  constexpr void set_max_x(const value_type maxX) noexcept
  {
    m_rect.x = maxX - m_rect.w;
  }

  /**
   * \brief Sets the maximum y-coordinate of the rectangle.
   *
   * \note This function preserves the height of the rectangle.
   *
   * \param maxY the new maximum y-coordinate of the rectangle.
   *
   * \since 5.1.0
   */
  constexpr void set_max_y(const value_type maxY) noexcept
  {
    m_rect.y = maxY - m_rect.h;
  }

  /**
   * \brief Offsets the x-coordinate of the rectangle by the specified amount.
   *
   * \details This function is effectively equivalent to calling `set_x()` with the sum of
   * `x()` and `offset`.
   *
   * \param offset the offset to the x-coordinate of the rectangle.
   *
   * \since 6.0.0
   */
  constexpr void offset_x(const value_type offset) noexcept
  {
    m_rect.x += offset;
  }

  /**
   * \brief Offsets the y-coordinate of the rectangle by the specified amount.
   *
   * \details This function is effectively equivalent to calling `set_y()` with the sum of
   * `y()` and `offset`.
   *
   * \param offset the offset to the y-coordinate of the rectangle.
   *
   * \since 6.0.0
   */
  constexpr void offset_y(const value_type offset) noexcept
  {
    m_rect.y += offset;
  }

  /**
   * \brief Tweaks the width of the rectangle by the specified amount.
   *
   * \details This function is effectively equivalent to calling `set_width()` with the
   * sum of `width()` and `offset`.
   *
   * \param offset the offset to the width of the rectangle.
   *
   * \since 6.0.0
   */
  constexpr void offset_width(const value_type offset) noexcept
  {
    m_rect.w += offset;
  }

  /**
   * \brief Tweaks the height of the rectangle by the specified amount.
   *
   * \details This function is effectively equivalent to calling `set_height()` with the
   * sum of `height()` and `offset`.
   *
   * \param offset the offset to the height of the rectangle.
   *
   * \since 6.0.0
   */
  constexpr void offset_height(const value_type offset) noexcept
  {
    m_rect.h += offset;
  }

  /**
   * \brief Sets the position of the rectangle.
   *
   * \note Some frameworks have this kind of function change the size of the rectangle.
   * However, this function does *not* change the size of the rectangle.
   *
   * \param pos the new position of the rectangle.
   *
   * \since 5.1.0
   */
  constexpr void set_position(const point_type& pos) noexcept
  {
    m_rect.x = pos.x();
    m_rect.y = pos.y();
  }

  /**
   * \brief Sets the width of the rectangle.
   *
   * \param width the new width of the rectangle.
   *
   * \since 4.0.0
   */
  constexpr void set_width(const value_type width) noexcept
  {
    m_rect.w = width;
  }

  /**
   * \brief Sets the height of the rectangle.
   *
   * \param height the new height of the rectangle.
   *
   * \since 4.0.0
   */
  constexpr void set_height(const value_type height) noexcept
  {
    m_rect.h = height;
  }

  /**
   * \brief Sets the size of the rectangle.
   *
   * \param size the new size of the rectangle.
   *
   * \since 5.1.0
   */
  constexpr void set_size(const area_type& size) noexcept
  {
    m_rect.w = size.width;
    m_rect.h = size.height;
  };

  /// \} End of setters

  /// \name Queries
  /// \{

  /**
   * \brief Returns the x-coordinate of the rectangle.
   *
   * \return the x-coordinate of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto x() const noexcept -> value_type
  {
    return m_rect.x;
  }

  /**
   * \brief Returns the y-coordinate of the rectangle.
   *
   * \return the y-coordinate of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto y() const noexcept -> value_type
  {
    return m_rect.y;
  }

  /**
   * \brief Returns the position of the rectangle.
   *
   * \return the position of the rectangle.
   *
   * \since 4.1.0
   */
  [[nodiscard]] constexpr auto position() const noexcept -> point_type
  {
    return point_type{m_rect.x, m_rect.y};
  }

  /**
   * \brief Returns the width of the rectangle.
   *
   * \return the width of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto width() const noexcept -> value_type
  {
    return m_rect.w;
  }

  /**
   * \brief Returns the height of the rectangle.
   *
   * \return the height of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto height() const noexcept -> value_type
  {
    return m_rect.h;
  }

  /**
   * \brief Returns the size of the rectangle.
   *
   * \return the size of the rectangle.
   *
   * \since 4.1.0
   */
  [[nodiscard]] constexpr auto size() const noexcept -> area_type
  {
    return area_type{m_rect.w, m_rect.h};
  }

  /**
   * \brief Returns the maximum x-coordinate of the rectangle.
   *
   * \return the maximum x-coordinate of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto max_x() const noexcept -> value_type
  {
    return x() + width();
  }

  /**
   * \brief Returns the maximum y-coordinate of the rectangle.
   *
   * \return the maximum y-coordinate of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto max_y() const noexcept -> value_type
  {
    return y() + height();
  }

  /**
   * \brief Returns the x-coordinate of the center point of the rectangle.
   *
   * \return the x-coordinate of the center point of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto center_x() const noexcept -> value_type
  {
    return x() + (width() / static_cast<value_type>(2));
  }

  /**
   * \brief Returns the y-coordinate of the center point of the rectangle.
   *
   * \return the y-coordinate of the center point of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto center_y() const noexcept -> value_type
  {
    return y() + (height() / static_cast<value_type>(2));
  }

  /**
   * \brief Returns the center point of the rectangle.
   *
   * \return the center point of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto center() const noexcept -> point_type
  {
    return {center_x(), center_y()};
  }

  /**
   * \brief Returns the total area of the rectangle.
   *
   * \return the area of the rectangle.
   *
   * \since 4.2.0
   */
  [[nodiscard]] constexpr auto area() const noexcept -> value_type
  {
    return width() * height();
  }

  /**
   * \brief Indicates whether or not the rectangle contains the point.
   *
   * \param point the point that will be checked.
   *
   * \return `true` if the rectangle contains the point; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto contains(const point_type& point) const noexcept -> bool
  {
    const auto px = point.x();
    const auto py = point.y();
    return !(px < x() || py < y() || px > max_x() || py > max_y());
  }

  /**
   * \brief Indicates whether or not the rectangle has an area.
   *
   * \details The rectangle has an area if both the width and height are
   * greater than zero.
   *
   * \return `true` if the rectangle has an area; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto has_area() const noexcept -> bool
  {
    return (width() > 0) && (height() > 0);
  }

  /**
   * \brief Returns a pointer to the internal rectangle representation.
   *
   * \note Don't cache the returned pointer.
   *
   * \return a pointer to the rectangle representation.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto data() noexcept -> rect_type*
  {
    return &m_rect;
  }

  /**
   * \copydoc data()
   */
  [[nodiscard]] auto data() const noexcept -> const rect_type*
  {
    return &m_rect;
  }

  /**
   * \brief Returns the internal rectangle.
   *
   * \return a reference to the internal rectangle.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto get() noexcept -> rect_type&
  {
    return m_rect;
  }

  /**
   * \brief Returns the internal rectangle.
   *
   * \return a reference to the internal rectangle.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto get() const noexcept -> const rect_type&
  {
    return m_rect;
  }

  /// \} End of queries

  /// \name Conversions
  /// \{

  /**
   * \brief Returns a pointer to the internal rectangle.
   *
   * \return a pointer to the internal rectangle.
   *
   * \since 5.0.0
   */
  [[nodiscard]] explicit operator rect_type*() noexcept
  {
    return &m_rect;
  }

  /**
   * \brief Returns a pointer to the internal rectangle.
   *
   * \return a pointer to the internal rectangle.
   *
   * \since 5.0.0
   */
  [[nodiscard]] explicit operator const rect_type*() const noexcept
  {
    return &m_rect;
  }

  /// \} End of conversions

  /**
   * \brief Serializes the rectangle.
   *
   * \details This function expects that the archive provides an overloaded `operator()`,
   * used for serializing data. This API is based on the Cereal serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the rectangle.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_rect.x, m_rect.y, m_rect.w, m_rect.h);
  }

 private:
  rect_type m_rect{0, 0, 0, 0};
};

/// \name Rectangle functions
/// \{

/**
 * \brief Creates a rectangle with automatically deduced precision.
 *
 * \note The only supported precisions for rectangles are `int` and `float`, so this
 * function will cast the supplied values to the corresponding type. For example, if you
 * supply doubles to this function, the returned point will use float as the precision.
 *
 * \tparam T the deduced precision type.
 *
 * \param x the x-coordinate of the rectangle.
 * \param y the y-coordinate of the rectangle.
 * \param width the width of the rectangle.
 * \param height the height of the rectangle.
 *
 * \return a rectangle with the specified position and size.
 *
 * \since 6.0.0
 */
template <typename T, enable_if_number_t<T> = 0>
[[nodiscard]] constexpr auto rect(const T x, const T y, const T width, const T height) noexcept
    -> basic_rect<typename rect_traits<T>::value_type>
{
  using value_type = typename rect_traits<T>::value_type;
  return basic_rect<value_type>{static_cast<value_type>(x),
                                static_cast<value_type>(y),
                                static_cast<value_type>(width),
                                static_cast<value_type>(height)};
}

/**
 * \brief Indicates whether or not the two rectangles intersect.
 *
 * \details This function does *not* consider rectangles with overlapping borders as
 * intersecting. If you want such behaviour, see the `collides` function.
 *
 * \tparam T the representation type used by the rectangles.
 *
 * \param fst the first rectangle.
 * \param snd the second rectangle.
 *
 * \return `true` if the rectangles intersect; `false` otherwise.
 *
 * \see `collides`
 *
 * \since 4.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto intersects(const basic_rect<T>& fst,
                                        const basic_rect<T>& snd) noexcept -> bool
{
  return !(fst.x() >= snd.max_x() || fst.max_x() <= snd.x() || fst.y() >= snd.max_y() ||
           fst.max_y() <= snd.y());
}

/**
 * \brief Indicates whether or not two rectangles are colliding.
 *
 * \details This function considers rectangles with overlapping borders as colliding.
 *
 * \tparam T the representation type used by the rectangles.
 *
 * \param fst the first rectangle.
 * \param snd the second rectangle.
 *
 * \return `true` if the rectangles collide; `false` otherwise.
 *
 * \see `intersects`
 *
 * \since 4.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto collides(const basic_rect<T>& fst,
                                      const basic_rect<T>& snd) noexcept -> bool
{
  return !(fst.x() > snd.max_x() || fst.max_x() < snd.x() || fst.y() > snd.max_y() ||
           fst.max_y() < snd.y());
}

/**
 * \brief Returns the union of two rectangles.
 *
 * \details Returns a rectangle that represents the union of two rectangles.
 *
 * \tparam T the representation type used by the rectangles.
 *
 * \param fst the first rectangle.
 * \param snd the second rectangle.
 *
 * \return a rectangle that represents the union of the rectangles.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto get_union(const basic_rect<T>& fst,
                                       const basic_rect<T>& snd) noexcept -> basic_rect<T>
{
  const auto fstHasArea = fst.has_area();
  const auto sndHasArea = snd.has_area();

  if (!fstHasArea && !sndHasArea) {
    return {};
  }
  else if (!fstHasArea) {
    return snd;
  }
  else if (!sndHasArea) {
    return fst;
  }

  const auto x = detail::min(fst.x(), snd.x());
  const auto y = detail::min(fst.y(), snd.y());
  const auto maxX = detail::max(fst.max_x(), snd.max_x());
  const auto maxY = detail::max(fst.max_y(), snd.max_y());

  return {{x, y}, {maxX - x, maxY - y}};
}

/// \} End of rectangle functions

/// \name Rectangle comparison operators
/// \{

/**
 * \brief Indicates whether or not two rectangles are equal.
 *
 * \tparam T the representation type used by the rectangles.
 *
 * \param lhs the left-hand side rectangle.
 * \param rhs the right-hand side rectangle.
 *
 * \return `true` if the rectangles are equal; `false` otherwise.
 *
 * \since 4.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator==(const basic_rect<T>& lhs,
                                        const basic_rect<T>& rhs) noexcept -> bool
{
  return (lhs.x() == rhs.x()) && (lhs.y() == rhs.y()) && (lhs.width() == rhs.width()) &&
         (lhs.height() == rhs.height());
}

/**
 * \brief Indicates whether or not two rectangles aren't equal.
 *
 * \tparam T the representation type used by the rectangles.
 *
 * \param lhs the left-hand side rectangle.
 * \param rhs the right-hand side rectangle.
 *
 * \return `true` if the rectangles aren't equal; `false` otherwise.
 *
 * \since 4.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator!=(const basic_rect<T>& lhs,
                                        const basic_rect<T>& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of rectangle comparison operators

/// \name Rectangle cast specializations
/// \{

template <>
[[nodiscard]] constexpr auto cast(const irect& from) noexcept -> frect
{
  const frect::point_type pos{static_cast<float>(from.x()), static_cast<float>(from.y())};
  const frect::area_type size{static_cast<float>(from.width()),
                              static_cast<float>(from.height())};
  return frect{pos, size};
}

template <>
[[nodiscard]] constexpr auto cast(const frect& from) noexcept -> irect
{
  const irect::point_type pos{static_cast<int>(from.x()), static_cast<int>(from.y())};
  const irect::area_type size{static_cast<int>(from.width()), static_cast<int>(from.height())};
  return irect{pos, size};
}

/// \} End of rectangle cast specializations

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a rectangle.
 *
 * \tparam T the representation type used by the rectangle.
 *
 * \param rect the rectangle that will be converted to a string.
 *
 * \return a textual representation of the rectangle.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_rect<T>& rect) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("rect{{x: {}, y: {}, width: {}, height: {}}}",
                     rect.x(),
                     rect.y(),
                     rect.width(),
                     rect.height());
#else
  return "rect{x: " + std::to_string(rect.x()) + ", y: " + std::to_string(rect.y()) +
         ", width: " + std::to_string(rect.width()) +
         ", height: " + std::to_string(rect.height()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a rectangle using a stream.
 *
 * \tparam T the representation type used by the rectangle.
 *
 * \param stream the stream that will be used.
 * \param rect the rectangle that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_rect<T>& rect) -> std::ostream&
{
  return stream << to_string(rect);
}

/// \} End of streaming

/// \} End of group math

}  // namespace cen

#endif  // CENTURION_RECTANGLE_HEADER
// #include "flash_op.hpp"
#ifndef CENTURION_FLASH_OP_HEADER
#define CENTURION_FLASH_OP_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


#if SDL_VERSION_ATLEAST(2, 0, 16)

namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum flash_op
 *
 * \brief Represents different window flash operations.
 *
 * \see `basic_window::flash()`
 * \see `to_string(flash_op)`
 *
 * \since 6.2.0
 */
enum class flash_op
{
  cancel = SDL_FLASH_CANCEL,               ///< Cancel any current flashing.
  briefly = SDL_FLASH_BRIEFLY,             ///< Briefly flash the window.
  until_focused = SDL_FLASH_UNTIL_FOCUSED  ///< Flash the window until it's focused.
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied window flash operation.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(flash_op::briefly) == "briefly"`.
 *
 * \param op the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const flash_op op) -> std::string_view
{
  switch (op) {
    case flash_op::cancel:
      return "cancel";

    case flash_op::briefly:
      return "briefly";

    case flash_op::until_focused:
      return "until_focused";

    default:
      throw cen_error{"Did not recognize window flash operation!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a window flash operation enumerator.
 *
 * \param stream the output stream that will be used.
 * \param op the enumerator that will be printed.
 *
 * \see `to_string(flash_op)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const flash_op op) -> std::ostream&
{
  return stream << to_string(op);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // SDL_VERSION_ATLEAST(2, 0, 16)

#endif  // CENTURION_FLASH_OP_HEADER

// #include "pixel_format.hpp"
#ifndef CENTURION_PIXEL_FORMAT_HEADER
#define CENTURION_PIXEL_FORMAT_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum pixel_format
 *
 * \brief Represents different pixel formats.
 *
 * \see `SDL_PixelFormatEnum`
 *
 * \since 3.1.0
 */
enum class pixel_format : u32
{
  unknown = SDL_PIXELFORMAT_UNKNOWN,

  index1lsb = SDL_PIXELFORMAT_INDEX1LSB,
  index1msb = SDL_PIXELFORMAT_INDEX1MSB,
  index4lsb = SDL_PIXELFORMAT_INDEX4LSB,
  index4msb = SDL_PIXELFORMAT_INDEX4MSB,
  index8 = SDL_PIXELFORMAT_INDEX8,

#if SDL_VERSION_ATLEAST(2, 0, 14)
  xrgb4444 = SDL_PIXELFORMAT_XRGB4444,
  xbgr4444 = SDL_PIXELFORMAT_XBGR4444,

  xrgb1555 = SDL_PIXELFORMAT_XRGB1555,
  xbgr1555 = SDL_PIXELFORMAT_XBGR1555,

  xrgb8888 = SDL_PIXELFORMAT_XRGB8888,
  xbgr8888 = SDL_PIXELFORMAT_XBGR8888,
#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  rgb332 = SDL_PIXELFORMAT_RGB332,
  rgb444 = SDL_PIXELFORMAT_RGB444,

#if SDL_VERSION_ATLEAST(2, 0, 12)
  bgr444 = SDL_PIXELFORMAT_BGR444,
#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

  rgb555 = SDL_PIXELFORMAT_RGB555,
  bgr555 = SDL_PIXELFORMAT_BGR555,

  argb4444 = SDL_PIXELFORMAT_ARGB4444,
  rgba4444 = SDL_PIXELFORMAT_RGBA4444,
  abgr4444 = SDL_PIXELFORMAT_ABGR4444,
  bgra4444 = SDL_PIXELFORMAT_BGRA4444,

  argb1555 = SDL_PIXELFORMAT_ARGB1555,
  rgba5551 = SDL_PIXELFORMAT_RGBA5551,
  abgr1555 = SDL_PIXELFORMAT_ABGR1555,
  bgra5551 = SDL_PIXELFORMAT_BGRA5551,

  rgb565 = SDL_PIXELFORMAT_RGB565,
  bgr565 = SDL_PIXELFORMAT_BGR565,

  rgb24 = SDL_PIXELFORMAT_RGB24,
  bgr24 = SDL_PIXELFORMAT_BGR24,

  rgb888 = SDL_PIXELFORMAT_RGB888,
  rgbx8888 = SDL_PIXELFORMAT_RGBX8888,
  bgr888 = SDL_PIXELFORMAT_BGR888,
  bgrx8888 = SDL_PIXELFORMAT_BGRX8888,

  argb8888 = SDL_PIXELFORMAT_ARGB8888,
  rgba8888 = SDL_PIXELFORMAT_RGBA8888,
  abgr8888 = SDL_PIXELFORMAT_ABGR8888,
  bgra8888 = SDL_PIXELFORMAT_BGRA8888,

  argb2101010 = SDL_PIXELFORMAT_ARGB2101010,

#if SDL_BYTEORDER == SDL_BIG_ENDIAN
  rgba32 = SDL_PIXELFORMAT_RGBA8888,
  argb32 = SDL_PIXELFORMAT_ARGB8888,
  bgra32 = SDL_PIXELFORMAT_BGRA8888,
  abgr32 = SDL_PIXELFORMAT_ABGR8888,
#else
  rgba32 = SDL_PIXELFORMAT_ABGR8888,
  argb32 = SDL_PIXELFORMAT_BGRA8888,
  bgra32 = SDL_PIXELFORMAT_ARGB8888,
  abgr32 = SDL_PIXELFORMAT_RGBA8888,
#endif

  yv12 = SDL_PIXELFORMAT_YV12,
  iyuv = SDL_PIXELFORMAT_IYUV,
  yuy2 = SDL_PIXELFORMAT_YUY2,
  uyvy = SDL_PIXELFORMAT_UYVY,
  yvyu = SDL_PIXELFORMAT_YVYU,
  nv12 = SDL_PIXELFORMAT_NV12,
  nv21 = SDL_PIXELFORMAT_NV21,
  external_oes = SDL_PIXELFORMAT_EXTERNAL_OES
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied pixel format.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(pixel_format::rgba8888) == "rgba8888"`.
 *
 * \param format the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const pixel_format format) -> std::string_view
{
  switch (format) {
    case pixel_format::unknown:
      return "unknown";

    case pixel_format::index1lsb:
      return "index1lsb";

    case pixel_format::index1msb:
      return "index1msb";

    case pixel_format::index4lsb:
      return "index4lsb";

    case pixel_format::index4msb:
      return "index4msb";

    case pixel_format::index8:
      return "index8";

    case pixel_format::rgb332:
      return "rgb332";

    case pixel_format::argb4444:
      return "argb4444";

    case pixel_format::rgba4444:
      return "rgba4444";

    case pixel_format::abgr4444:
      return "abgr4444";

    case pixel_format::bgra4444:
      return "bgra4444";

    case pixel_format::argb1555:
      return "argb1555";

    case pixel_format::rgba5551:
      return "rgba5551";

    case pixel_format::abgr1555:
      return "abgr1555";

    case pixel_format::bgra5551:
      return "bgra5551";

    case pixel_format::rgb565:
      return "rgb565";

    case pixel_format::bgr565:
      return "bgr565";

    case pixel_format::rgb24:
      return "rgb24";

    case pixel_format::bgr24:
      return "bgr24";

    case pixel_format::rgbx8888:
      return "rgbx8888";

    case pixel_format::bgrx8888:
      return "bgrx8888";

    case pixel_format::argb8888:
      return "argb8888";

    case pixel_format::rgba8888:
      return "rgba8888";

    case pixel_format::abgr8888:
      return "abgr8888";

    case pixel_format::bgra8888:
      return "bgra8888";

    case pixel_format::argb2101010:
      return "argb2101010";

    case pixel_format::yv12:
      return "yv12";

    case pixel_format::iyuv:
      return "iyuv";

    case pixel_format::yuy2:
      return "yuy2";

    case pixel_format::uyvy:
      return "uyvy";

    case pixel_format::yvyu:
      return "yvyu";

    case pixel_format::nv12:
      return "nv12";

    case pixel_format::nv21:
      return "nv21";

    case pixel_format::external_oes:
      return "external_oes";

#if SDL_VERSION_ATLEAST(2, 0, 14)

    case pixel_format::xrgb4444:
      return "xrgb4444";

    case pixel_format::xbgr4444:
      return "xbgr4444";

    case pixel_format::xrgb1555:
      return "xrgb1555";

    case pixel_format::xbgr1555:
      return "xbgr1555";

    case pixel_format::xrgb8888:
      return "xrgb8888";

    case pixel_format::xbgr8888:
      return "xbgr8888";

#elif SDL_VERSION_ATLEAST(2, 0, 12)

    case pixel_format::bgr444:  // Equal to xbgr4444
      return "bgr444";

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

    default:
      throw cen_error{"Did not recognize pixel format mode!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a pixel format enumerator.
 *
 * \param stream the output stream that will be used.
 * \param format the enumerator that will be printed.
 *
 * \see `to_string(pixel_format)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const pixel_format format) -> std::ostream&
{
  return stream << to_string(format);
}

/// \} End of streaming

/// \name Pixel format comparison operators
/// \{

/**
 * \brief Indicates whether or not the two pixel format values are the same.
 *
 * \param lhs the left-hand side pixel format value.
 * \param rhs the right-hand side pixel format value.
 *
 * \return `true` if the pixel format values are the same; `false` otherwise.
 *
 * \since 3.1.0
 */
[[nodiscard]] constexpr auto operator==(const pixel_format lhs,
                                        const SDL_PixelFormatEnum rhs) noexcept -> bool
{
  return static_cast<SDL_PixelFormatEnum>(lhs) == rhs;
}

/// \copydoc operator==(pixel_format, SDL_PixelFormatEnum)
[[nodiscard]] constexpr auto operator==(const SDL_PixelFormatEnum lhs,
                                        const pixel_format rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the two pixel format values aren't the same.
 *
 * \param lhs the left-hand side pixel format value.
 * \param rhs the right-hand side pixel format value.
 *
 * \return `true` if the pixel format values aren't the same; `false` otherwise.
 *
 * \since 3.1.0
 */
[[nodiscard]] constexpr auto operator!=(const pixel_format lhs,
                                        const SDL_PixelFormatEnum rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(pixel_format, SDL_PixelFormatEnum)
[[nodiscard]] constexpr auto operator!=(const SDL_PixelFormatEnum lhs,
                                        const pixel_format rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of pixel format comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_PIXEL_FORMAT_HEADER

// #include "surface.hpp"
#ifndef CENTURION_SURFACE_HEADER
#define CENTURION_SURFACE_HEADER

#include <SDL.h>

// #include "../compiler/features.hpp"


#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#include <cassert>  // assert
#include <ostream>  // ostream
#include <string>   // string, to_string

#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/not_null.hpp"

// #include "../core/owner.hpp"

// #include "../core/result.hpp"

// #include "../core/str.hpp"

// #include "../core/to_underlying.hpp"
#ifndef CENTURION_TO_UNDERLYING_HEADER
#define CENTURION_TO_UNDERLYING_HEADER

#include <type_traits>  // underlying_type_t, enable_if_t, is_enum_v

namespace cen {

/**
 * \brief Converts an enum value to an integral value using the underlying type.
 *
 * \ingroup core
 *
 * \note If you're using C++23, see `std::to_underlying()`.
 *
 * \tparam Enum the enum type.
 *
 * \param value the enum value that will be converted.
 *
 * \return the value of the enum, in the underlying type.
 *
 * \since 6.0.0
 */
template <typename Enum, std::enable_if_t<std::is_enum_v<Enum>, int> = 0>
[[nodiscard]] constexpr auto to_underlying(const Enum value) noexcept
    -> std::underlying_type_t<Enum>
{
  return static_cast<std::underlying_type_t<Enum>>(value);
}

}  // namespace cen

#endif  // CENTURION_TO_UNDERLYING_HEADER

// #include "../detail/address_of.hpp"

// #include "../detail/owner_handle_api.hpp"

// #include "../math/area.hpp"

// #include "../math/rect.hpp"

// #include "blend_mode.hpp"
#ifndef CENTURION_BLEND_MODE_HEADER
#define CENTURION_BLEND_MODE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "blend_factor.hpp"
#ifndef CENTURION_BLEND_FACTOR_HEADER
#define CENTURION_BLEND_FACTOR_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum blend_factor
 *
 * \brief Represents normalized factors used when multiplying pixel components.
 *
 * \see `blend_op`
 * \see `compose_blend_mode()`
 *
 * \since 6.3.0
 */
enum class blend_factor
{
  zero = SDL_BLENDFACTOR_ZERO,
  one = SDL_BLENDFACTOR_ONE,

  src_color = SDL_BLENDFACTOR_SRC_COLOR,
  one_minus_src_color = SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR,

  src_alpha = SDL_BLENDFACTOR_SRC_ALPHA,
  one_minus_src_alpha = SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA,

  dst_color = SDL_BLENDFACTOR_DST_COLOR,
  one_minus_dst_color = SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR,

  dst_alpha = SDL_BLENDFACTOR_DST_ALPHA,
  one_minus_dst_alpha = SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied blend factor.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(blend_factor::zero) == "zero"`.
 *
 * \param factor the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto to_string(const blend_factor factor) -> std::string_view
{
  switch (factor) {
    case blend_factor::zero:
      return "zero";

    case blend_factor::one:
      return "one";

    case blend_factor::src_color:
      return "src_color";

    case blend_factor::one_minus_src_color:
      return "one_minus_src_color";

    case blend_factor::src_alpha:
      return "src_alpha";

    case blend_factor::one_minus_src_alpha:
      return "one_minus_src_alpha";

    case blend_factor::dst_color:
      return "dst_color";

    case blend_factor::one_minus_dst_color:
      return "one_minus_dst_color";

    case blend_factor::dst_alpha:
      return "dst_alpha";

    case blend_factor::one_minus_dst_alpha:
      return "one_minus_dst_alpha";

    default:
      throw cen_error{"Did not recognize blend factor!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a blend factor enumerator.
 *
 * \param stream the output stream that will be used.
 * \param factor the enumerator that will be printed.
 *
 * \see `to_string(blend_factor)`
 *
 * \return the used stream.
 *
 * \since 6.3.0
 */
inline auto operator<<(std::ostream& stream, const blend_factor factor) -> std::ostream&
{
  return stream << to_string(factor);
}

/// \} End of streaming

/// \name Blend factor comparison operators
/// \{

/**
 * \brief Indicates whether or not two blend factor values are the same;
 *
 * \param lhs the left-hand side blend factor value.
 * \param rhs the right-hand side blend factor value.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto operator==(const blend_factor lhs,
                                        const SDL_BlendFactor rhs) noexcept -> bool
{
  return static_cast<SDL_BlendFactor>(lhs) == rhs;
}

/// \copydoc operator==(blend_factor, SDL_BlendFactor)
[[nodiscard]] constexpr auto operator==(const SDL_BlendFactor lhs,
                                        const blend_factor rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two blend factor values aren't the same;
 *
 * \param lhs the left-hand side blend factor value.
 * \param rhs the right-hand side blend factor value.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto operator!=(const blend_factor lhs,
                                        const SDL_BlendFactor rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(blend_factor, SDL_BlendFactor)
[[nodiscard]] constexpr auto operator!=(const SDL_BlendFactor lhs,
                                        const blend_factor rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of blend factor comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_BLEND_FACTOR_HEADER

// #include "blend_op.hpp"
#ifndef CENTURION_BLEND_OP_HEADER
#define CENTURION_BLEND_OP_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum blend_op
 *
 * \brief Represents different strategies used when combining pixel components.
 *
 * \see `blend_factor`
 * \see `compose_blend_mode()`
 *
 * \since 6.3.0
 */
enum class blend_op
{
  add = SDL_BLENDOPERATION_ADD,
  sub = SDL_BLENDOPERATION_SUBTRACT,
  reverse_sub = SDL_BLENDOPERATION_REV_SUBTRACT,
  min = SDL_BLENDOPERATION_MINIMUM,
  max = SDL_BLENDOPERATION_MAXIMUM
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied blend operation.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(blend_op::add) == "add"`.
 *
 * \param op the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto to_string(const blend_op op) -> std::string_view
{
  switch (op) {
    case blend_op::add:
      return "add";

    case blend_op::sub:
      return "sub";

    case blend_op::reverse_sub:
      return "reverse_sub";

    case blend_op::min:
      return "min";

    case blend_op::max:
      return "max";

    default:
      throw cen_error{"Did not recognize blend operation!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a blend operation enumerator.
 *
 * \param stream the output stream that will be used.
 * \param op the enumerator that will be printed.
 *
 * \see `to_string(blend_op)`
 *
 * \return the used stream.
 *
 * \since 6.3.0
 */
inline auto operator<<(std::ostream& stream, const blend_op op) -> std::ostream&
{
  return stream << to_string(op);
}

/// \} End of streaming

/// \name Blend operation comparison operators
/// \{

/**
 * \brief Indicates whether or not two blend operation values are the same;
 *
 * \param lhs the left-hand side blend operation value.
 * \param rhs the right-hand side blend operation value.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto operator==(const blend_op lhs,
                                        const SDL_BlendOperation rhs) noexcept -> bool
{
  return static_cast<SDL_BlendOperation>(lhs) == rhs;
}

/// \copydoc operator==(blend_op, SDL_BlendOperation)
[[nodiscard]] constexpr auto operator==(const SDL_BlendOperation lhs,
                                        const blend_op rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two blend operation values aren't the same;
 *
 * \param lhs the left-hand side blend operation value.
 * \param rhs the right-hand side blend operation value.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto operator!=(const blend_op lhs,
                                        const SDL_BlendOperation rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(blend_op, SDL_BlendOperation)
[[nodiscard]] constexpr auto operator!=(const SDL_BlendOperation lhs,
                                        const blend_op rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of blend operation comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_BLEND_OP_HEADER

namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum blend_mode
 *
 * \brief Provides values that represent various rendering blend modes.
 *
 * \since 3.0.0
 *
 * \see `SDL_BlendMode`
 */
enum class blend_mode
{
  none = SDL_BLENDMODE_NONE,    ///< Represents no blending.
  blend = SDL_BLENDMODE_BLEND,  ///< Represents alpha blending.
  add = SDL_BLENDMODE_ADD,      ///< Represents additive blending.
  mod = SDL_BLENDMODE_MOD,      ///< Represents color modulation.

#if SDL_VERSION_ATLEAST(2, 0, 12)

  mul = SDL_BLENDMODE_MUL,  ///< Represents color multiplication.

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

  invalid = SDL_BLENDMODE_INVALID  ///< Represents an invalid blend mode.
};

/**
 * \struct blend_task
 *
 * \brief Describes how a pair of blend mode factors will be combined.
 *
 * \see `compose_blend_mode()`
 *
 * \since 6.3.0
 */
struct blend_task final
{
  blend_factor src;  ///< The blend factor applied to the source pixels.
  blend_factor dst;  ///< The blend factor applied to the destination pixels.
  blend_op op;       ///< The operation used to combine the source and destination pixels.
};

/**
 * \brief Composes a custom blend mode.
 *
 * \param color the blend task descriptor used for RGB components.
 * \param alpha the blend task descriptor used for alpha components.
 *
 * \return the composed blend mode.
 *
 * \see `blend_task`
 * \see `blend_factor`
 * \see `blend_op`
 *
 * \see `SDL_ComposeCustomBlendMode()`
 * \see `basic_renderer::set_blend_mode()`
 * \see `basic_texture::set_blend_mode()`
 *
 * \since 6.3.0
 */
[[nodiscard]] inline auto compose_blend_mode(const blend_task& color,
                                             const blend_task& alpha) noexcept -> blend_mode
{
  const auto res = SDL_ComposeCustomBlendMode(static_cast<SDL_BlendFactor>(color.src),
                                              static_cast<SDL_BlendFactor>(color.dst),
                                              static_cast<SDL_BlendOperation>(color.op),
                                              static_cast<SDL_BlendFactor>(alpha.src),
                                              static_cast<SDL_BlendFactor>(alpha.dst),
                                              static_cast<SDL_BlendOperation>(alpha.op));
  return static_cast<blend_mode>(res);
}

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied blend mode.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(blend_mode::blend) == "blend"`.
 *
 * \param mode the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const blend_mode mode) -> std::string_view
{
  switch (mode) {
    case blend_mode::none:
      return "none";

    case blend_mode::blend:
      return "blend";

    case blend_mode::add:
      return "add";

    case blend_mode::mod:
      return "mod";

    case blend_mode::invalid:
      return "invalid";

#if SDL_VERSION_ATLEAST(2, 0, 12)

    case blend_mode::mul:
      return "mul";

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

    default:
      throw cen_error{"Did not recognize blend mode!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a blend mode enumerator.
 *
 * \param stream the output stream that will be used.
 * \param mode the enumerator that will be printed.
 *
 * \see `to_string(blend_mode)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const blend_mode mode) -> std::ostream&
{
  return stream << to_string(mode);
}

/// \} End of streaming

/// \name Blend mode comparison operators
/// \{

/**
 * \brief Indicates whether or not two blend mode values are the same;
 *
 * \param lhs the left-hand side blend mode value.
 * \param rhs the right-hand side blend mode value.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const blend_mode lhs, const SDL_BlendMode rhs) noexcept
    -> bool
{
  return static_cast<SDL_BlendMode>(lhs) == rhs;
}

/// \copydoc operator==(blend_mode, SDL_BlendMode)
[[nodiscard]] constexpr auto operator==(const SDL_BlendMode lhs, const blend_mode rhs) noexcept
    -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two blend mode values aren't the same;
 *
 * \param lhs the left-hand side blend mode value.
 * \param rhs the right-hand side blend mode value.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator!=(const blend_mode lhs, const SDL_BlendMode rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(blend_mode, SDL_BlendMode)
[[nodiscard]] constexpr auto operator!=(const SDL_BlendMode lhs, const blend_mode rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \} End of blend mode comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_BLEND_MODE_HEADER

// #include "color.hpp"
#ifndef CENTURION_COLOR_HEADER
#define CENTURION_COLOR_HEADER

#include <SDL.h>

#include <cassert>      // assert
#include <cmath>        // round, abs, fmod, lerp
#include <iomanip>      // setfill, setw
#include <ios>          // uppercase, hex
#include <optional>     // optional
#include <ostream>      // ostream
#include <sstream>      // stringstream
#include <string>       // string, to_string
#include <string_view>  // string_view

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../compiler/compiler.hpp"
#ifndef CENTURION_COMPILER_HEADER
#define CENTURION_COMPILER_HEADER

#include <SDL.h>

namespace cen {

/// \addtogroup compiler
/// \{

/**
 * \brief Indicates whether or not a "debug" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a debug build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_debug_build() noexcept -> bool
{
#ifndef NDEBUG
  return true;
#else
  return false;
#endif  // NDEBUG
}

/**
 * \brief Indicates whether or not a "release" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a release build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_release_build() noexcept -> bool
{
  return !is_debug_build();
}

/**
 * \brief Indicates whether or not the compiler is MSVC.
 *
 * \return `true` if MSVC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_msvc() noexcept -> bool
{
#ifdef _MSC_VER
  return true;
#else
  return false;
#endif  // _MSC_VER
}

/**
 * \brief Indicates whether or not the compiler is GCC.
 *
 * \return `true` if GCC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_gcc() noexcept -> bool
{
#ifdef __GNUC__
  return true;
#else
  return false;
#endif  // __GNUC__
}

/**
 * \brief Indicates whether or not the compiler is Clang.
 *
 * \return `true` if Clang is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_clang() noexcept -> bool
{
#ifdef __clang__
  return true;
#else
  return false;
#endif  // __clang__
}

/**
 * \brief Indicates whether or not the compiler is Emscripten.
 *
 * \return `true` if Emscripten is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_emscripten() noexcept -> bool
{
#ifdef __EMSCRIPTEN__
  return true;
#else
  return false;
#endif  // __EMSCRIPTEN__
}

/**
 * \brief Indicates whether or not the compiler is Intel C++.
 *
 * \return `true` if Intel C++ is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_intel_cpp() noexcept -> bool
{
#ifdef __INTEL_COMPILER
  return true;
#else
  return false;
#endif  // __INTEL_COMPILER
}

/// \} End of compiler group

}  // namespace cen

#endif  // CENTURION_COMPILER_HEADER

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../detail/clamp.hpp"

// #include "../detail/from_string.hpp"
#ifndef CENTURION_DETAIL_FROM_STRING_HEADER
#define CENTURION_DETAIL_FROM_STRING_HEADER

#include <charconv>      // from_chars
#include <optional>      // optional
#include <string>        // string, stof
#include <string_view>   // string_view
#include <system_error>  // errc
#include <type_traits>   // is_floating_point_v

// #include "../compiler/compiler.hpp"


/// \cond FALSE
namespace cen::detail {

template <typename T>
[[nodiscard]] auto from_string(const std::string_view str,
                               const int base = 10) noexcept(on_msvc()) -> std::optional<T>
{
  T value{};

  const auto begin = str.data();
  const auto end = str.data() + str.size();

  const char* mismatch = end;
  std::errc error{};

  if constexpr (std::is_floating_point_v<T>) {
    if constexpr (on_gcc() || on_clang()) {
      try {
        value = std::stof(std::string{str});
      }
      catch (...) {
        return std::nullopt;
      }
    }
    else {
      const auto [ptr, err] = std::from_chars(begin, end, value);
      mismatch = ptr;
      error = err;
    }
  }
  else {
    const auto [ptr, err] = std::from_chars(begin, end, value, base);
    mismatch = ptr;
    error = err;
  }

  if (mismatch == end && error == std::errc{}) {
    return value;
  }
  else {
    return std::nullopt;
  }
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_FROM_STRING_HEADER

// #include "../detail/lerp.hpp"
#ifndef CENTURION_DETAIL_LERP_HEADER
#define CENTURION_DETAIL_LERP_HEADER

#include <cmath>  // lerp

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER


/// \cond FALSE

namespace cen::detail {

[[nodiscard]] constexpr auto lerp(const float a, const float b, const float bias) noexcept
    -> float
{
#if CENTURION_HAS_FEATURE_LERP
  return std::lerp(a, b, bias);
#else
  return (a * (1.0f - bias)) + (b * bias);
#endif  // CENTURION_HAS_FEATURE_LERP
}

}  // namespace cen::detail

/// \endcond

#endif  // CENTURION_DETAIL_LERP_HEADER


namespace cen {

/// \addtogroup video
/// \{

/**
 * \class color
 *
 * \brief An 8-bit accuracy RGBA color.
 *
 * \serializable
 *
 * \details This class is designed to interact with the SDL colors, i.e. `SDL_Color` and
 * `SDL_MessageBoxColor`. For convenience, there are approximately 140 color constants
 * provided in the `colors` namespace,
 *
 * \since 3.0.0
 */
class color final
{
 public:
  /// \name Construction
  /// \{

  /**
   * \brief Creates a color. The created color will be equal to #000000FF.
   *
   * \since 3.0.0
   */
  constexpr color() noexcept = default;

  /**
   * \brief Creates a color.
   *
   * \param red the red component value, in the range [0, 255].
   * \param green the green component value, in the range [0, 255].
   * \param blue the blue component value, in the range [0, 255].
   * \param alpha the alpha component value, in the rage [0, 255]. Defaults to 255.
   *
   * \since 3.0.0
   */
  constexpr color(const u8 red, const u8 green, const u8 blue, const u8 alpha = max()) noexcept
      : m_color{red, green, blue, alpha}
  {}

  /**
   * \brief Creates a color that is a copy of the supplied `SDL_Color`.
   *
   * \param color the `SDL_Color` that will be copied.
   *
   * \since 3.0.0
   */
  constexpr explicit color(const SDL_Color& color) noexcept : m_color{color}
  {}

  /**
   * \brief Creates a color that is a copy of the supplied SDL_MessageBoxColor.
   *
   * \details Message box colors don't have an alpha component so the created color will
   * feature an alpha value of 255.
   *
   * \param color the message box color that will be copied.
   *
   * \since 3.0.0
   */
  constexpr explicit color(const SDL_MessageBoxColor& color) noexcept
      : m_color{color.r, color.g, color.b, max()}
  {}

  /**
   * \brief Creates a color from HSV-encoded values.
   *
   * \note The values will be clamped to be within their respective ranges.
   *
   * \param hue the hue of the color, in the range [0, 360].
   * \param saturation the saturation of the color, in the range [0, 100].
   * \param value the value of the color, in the range [0, 100].
   *
   * \return an RGBA color converted from the HSV values.
   *
   * \since 5.3.0
   */
  [[nodiscard]] static auto from_hsv(float hue, float saturation, float value) -> color
  {
    hue = detail::clamp(hue, 0.0f, 360.0f);
    saturation = detail::clamp(saturation, 0.0f, 100.0f);
    value = detail::clamp(value, 0.0f, 100.0f);

    const auto v = (value / 100.0f);
    const auto chroma = v * (saturation / 100.0f);
    const auto hp = hue / 60.0f;

    const auto x = chroma * (1.0f - std::abs(std::fmod(hp, 2.0f) - 1.0f));

    float red{};
    float green{};
    float blue{};

    if (0 <= hp && hp <= 1) {
      red = chroma;
      green = x;
      blue = 0;
    }
    else if (1 < hp && hp <= 2) {
      red = x;
      green = chroma;
      blue = 0;
    }
    else if (2 < hp && hp <= 3) {
      red = 0;
      green = chroma;
      blue = x;
    }
    else if (3 < hp && hp <= 4) {
      red = 0;
      green = x;
      blue = chroma;
    }
    else if (4 < hp && hp <= 5) {
      red = x;
      green = 0;
      blue = chroma;
    }
    else if (5 < hp && hp <= 6) {
      red = chroma;
      green = 0;
      blue = x;
    }

    const auto m = v - chroma;

    const auto r = static_cast<u8>(std::round((red + m) * 255.0f));
    const auto g = static_cast<u8>(std::round((green + m) * 255.0f));
    const auto b = static_cast<u8>(std::round((blue + m) * 255.0f));

    return color{r, g, b};
  }

  /**
   * \brief Creates a color from HSL-encoded values.
   *
   * \note The values will be clamped to be within their respective ranges.
   *
   * \param hue the hue of the color, in the range [0, 360].
   * \param saturation the saturation of the color, in the range [0, 100].
   * \param lightness the lightness of the color, in the range [0, 100].
   *
   * \return an RGBA color converted from the HSL values.
   *
   * \since 5.3.0
   */
  [[nodiscard]] static auto from_hsl(float hue, float saturation, float lightness) -> color
  {
    hue = detail::clamp(hue, 0.0f, 360.0f);
    saturation = detail::clamp(saturation, 0.0f, 100.0f);
    lightness = detail::clamp(lightness, 0.0f, 100.0f);

    const auto s = saturation / 100.0f;
    const auto l = lightness / 100.0f;

    const auto chroma = (1.0f - std::abs(2.0f * l - 1.0f)) * s;
    const auto hp = hue / 60.0f;

    const auto x = chroma * (1.0f - std::abs(std::fmod(hp, 2.0f) - 1.0f));

    float red{};
    float green{};
    float blue{};

    if (0 <= hp && hp < 1) {
      red = chroma;
      green = x;
      blue = 0;
    }
    else if (1 <= hp && hp < 2) {
      red = x;
      green = chroma;
      blue = 0;
    }
    else if (2 <= hp && hp < 3) {
      red = 0;
      green = chroma;
      blue = x;
    }
    else if (3 <= hp && hp < 4) {
      red = 0;
      green = x;
      blue = chroma;
    }
    else if (4 <= hp && hp < 5) {
      red = x;
      green = 0;
      blue = chroma;
    }
    else if (5 <= hp && hp < 6) {
      red = chroma;
      green = 0;
      blue = x;
    }

    const auto m = l - (chroma / 2.0f);

    const auto r = static_cast<u8>(std::round((red + m) * 255.0f));
    const auto g = static_cast<u8>(std::round((green + m) * 255.0f));
    const auto b = static_cast<u8>(std::round((blue + m) * 255.0f));

    return color{r, g, b};
  }

  /**
   * \brief Creates a color from a hexadecimal RGB color string.
   *
   * \details The supplied string must feature a leading '#' character, and be 7
   * characters long.
   *
   * \param rgb the hexadecimal RGB color string, using the format "#RRGGBB".
   *
   * \return a corresponding color; `std::nullopt` if something goes wrong.
   *
   * \see `from_rgba()`
   * \see `from_argb()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] static auto from_rgb(const std::string_view rgb) -> std::optional<color>
  {
    if (rgb.length() != 7 || rgb.at(0) != '#') {
      return std::nullopt;
    }

    const auto noHash = rgb.substr(1);

    const auto rr = noHash.substr(0, 2);
    const auto gg = noHash.substr(2, 2);
    const auto bb = noHash.substr(4, 2);

    const auto red = detail::from_string<u8>(rr, 16);
    const auto green = detail::from_string<u8>(gg, 16);
    const auto blue = detail::from_string<u8>(bb, 16);

    if (red && green && blue) {
      return cen::color{*red, *green, *blue};
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Creates a color from a hexadecimal RGBA color string.
   *
   * \details The supplied string must feature a leading '#' character, and be 9
   * characters long.
   *
   * \param rgba the hexadecimal RGBA color string, using the format "#RRGGBBAA".
   *
   * \return a corresponding color; `std::nullopt` if something goes wrong.
   *
   * \see `from_rgb()`
   * \see `from_argb()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] static auto from_rgba(const std::string_view rgba) -> std::optional<color>
  {
    if (rgba.length() != 9 || rgba.at(0) != '#') {
      return std::nullopt;
    }

    const auto noHash = rgba.substr(1);

    const auto rr = noHash.substr(0, 2);
    const auto gg = noHash.substr(2, 2);
    const auto bb = noHash.substr(4, 2);
    const auto aa = noHash.substr(6, 2);

    const auto red = detail::from_string<u8>(rr, 16);
    const auto green = detail::from_string<u8>(gg, 16);
    const auto blue = detail::from_string<u8>(bb, 16);
    const auto alpha = detail::from_string<u8>(aa, 16);

    if (red && green && blue && alpha) {
      return cen::color{*red, *green, *blue, *alpha};
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Creates a color from a hexadecimal ARGB color string.
   *
   * \details The supplied string must feature a leading '#' character, and be 9
   * characters long.
   *
   * \param argb the hexadecimal ARGB color string, using the format "#AARRGGBB".
   *
   * \return a corresponding color; `std::nullopt` if something goes wrong.
   *
   * \see `from_rgb()`
   * \see `from_rgba()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] static auto from_argb(const std::string_view argb) -> std::optional<color>
  {
    if (argb.length() != 9 || argb.at(0) != '#') {
      return std::nullopt;
    }

    const auto noHash = argb.substr(1);

    const auto aa = noHash.substr(0, 2);
    const auto rr = noHash.substr(2, 2);
    const auto gg = noHash.substr(4, 2);
    const auto bb = noHash.substr(6, 2);

    const auto alpha = detail::from_string<u8>(aa, 16);
    const auto red = detail::from_string<u8>(rr, 16);
    const auto green = detail::from_string<u8>(gg, 16);
    const auto blue = detail::from_string<u8>(bb, 16);

    if (alpha && red && green && blue) {
      return cen::color{*red, *green, *blue, *alpha};
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Creates a color from normalized color component values.
   *
   * \note The color components will be clamped to the range [0, 1].
   *
   * \param red the red component value, in the range [0, 1].
   * \param green the green component value, in the range [0, 1].
   * \param blue the blue component value, in the range [0, 1].
   * \param alpha the alpha component value, in the range [0, 1].
   *
   * \return a color with the supplied color components.
   *
   * \since 6.1.0
   */
  [[nodiscard]] static auto from_norm(float red,
                                      float green,
                                      float blue,
                                      float alpha = 1.0f) noexcept(on_msvc()) -> color
  {
    red = detail::clamp(red, 0.0f, 1.0f);
    green = detail::clamp(green, 0.0f, 1.0f);
    blue = detail::clamp(blue, 0.0f, 1.0f);
    alpha = detail::clamp(alpha, 0.0f, 1.0f);

    const auto r = static_cast<u8>(std::round(red * 255.0f));
    const auto g = static_cast<u8>(std::round(green * 255.0f));
    const auto b = static_cast<u8>(std::round(blue * 255.0f));
    const auto a = static_cast<u8>(std::round(alpha * 255.0f));

    return color{r, g, b, a};
  }

  /// \} End of construction

  /// \name Setters
  /// \{

  /**
   * \brief Sets the value of the red component.
   *
   * \param red the new value of the red component.
   *
   * \since 3.0.0
   */
  constexpr void set_red(const u8 red) noexcept
  {
    m_color.r = red;
  }

  /**
   * \brief Sets the value of the green component.
   *
   * \param green the new value of the green component.
   *
   * \since 3.0.0
   */
  constexpr void set_green(const u8 green) noexcept
  {
    m_color.g = green;
  }

  /**
   * \brief Sets the value of the blue component.
   *
   * \param blue the new value of the blue component.
   *
   * \since 3.0.0
   */
  constexpr void set_blue(const u8 blue) noexcept
  {
    m_color.b = blue;
  }

  /**
   * \brief Sets the value of the alpha component.
   *
   * \param alpha the new value of the alpha component.
   *
   * \since 3.0.0
   */
  constexpr void set_alpha(const u8 alpha) noexcept
  {
    m_color.a = alpha;
  }

  /// \} End of setters

  /// \name Getters
  /// \{

  /**
   * \brief Returns the value of the red component.
   *
   * \return the value of the red component, in the range [0, 255].
   *
   * \since 3.0.0
   */
  [[nodiscard]] constexpr auto red() const noexcept -> u8
  {
    return m_color.r;
  }

  /**
   * \brief Returns the value of the green component.
   *
   * \return the value of the green component, in the range [0, 255].
   *
   * \since 3.0.0
   */
  [[nodiscard]] constexpr auto green() const noexcept -> u8
  {
    return m_color.g;
  }

  /**
   * \brief Returns the value of the blue component.
   *
   * \return the value of the blue component, in the range [0, 255].
   *
   * \since 3.0.0
   */
  [[nodiscard]] constexpr auto blue() const noexcept -> u8
  {
    return m_color.b;
  }

  /**
   * \brief Returns the value of the alpha component.
   *
   * \return the value of the alpha component, in the range [0, 255].
   *
   * \since 3.0.0
   */
  [[nodiscard]] constexpr auto alpha() const noexcept -> u8
  {
    return m_color.a;
  }

  /**
   * \brief Returns the normalized red component of the color.
   *
   * \return the red component value, in the range [0, 1].
   *
   * \since 6.1.0
   */
  [[nodiscard]] constexpr auto red_norm() const noexcept -> float
  {
    return static_cast<float>(m_color.r) / 255.0f;
  }

  /**
   * \brief Returns the normalized green component of the color.
   *
   * \return the green component value, in the range [0, 1].
   *
   * \since 6.1.0
   */
  [[nodiscard]] constexpr auto green_norm() const noexcept -> float
  {
    return static_cast<float>(m_color.g) / 255.0f;
  }

  /**
   * \brief Returns the normalized blue component of the color.
   *
   * \return the blue component value, in the range [0, 1].
   *
   * \since 6.1.0
   */
  [[nodiscard]] constexpr auto blue_norm() const noexcept -> float
  {
    return static_cast<float>(m_color.b) / 255.0f;
  }

  /**
   * \brief Returns the normalized alpha component of the color.
   *
   * \return the alpha component value, in the range [0, 1].
   *
   * \since 6.1.0
   */
  [[nodiscard]] constexpr auto alpha_norm() const noexcept -> float
  {
    return static_cast<float>(m_color.a) / 255.0f;
  }

  /**
   * \brief Returns a pointer to the internal SDL color.
   *
   * \warning Do not cache the returned pointer!
   *
   * \return a pointer to the internal color instance.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto data() noexcept -> SDL_Color*
  {
    return &m_color;
  }

  /// \copydoc data()
  [[nodiscard]] auto data() const noexcept -> const SDL_Color*
  {
    return &m_color;
  }

  /**
   * \brief Returns the internal color instance.
   *
   * \return a reference to the internal color.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get() const noexcept -> const SDL_Color&
  {
    return m_color;
  }

  /// \} End of getters

  /// \name Color string conversions
  /// \{

  /**
   * \brief Returns a hexadecimal RGB color string that represents the color.
   *
   * \details The returned string is guaranteed to use uppercase hexadecimal digits (A-F).
   *
   * \return a hexadecimal color string representation, on the format "#RRGGBB".
   *
   * \see `as_rgba()`
   * \see `as_argb()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto as_rgb() const -> std::string
  {
    std::stringstream stream;
    stream << std::setfill('0') << std::hex << std::uppercase;

    stream << '#';
    stream << std::setw(2) << +m_color.r;
    stream << std::setw(2) << +m_color.g;
    stream << std::setw(2) << +m_color.b;

    return stream.str();
  }

  /**
   * \brief Returns a hexadecimal RGBA color string that represents the color.
   *
   * \details The returned string is guaranteed to use uppercase hexadecimal digits (A-F).
   *
   * \return a hexadecimal color string representation, on the format "#RRGGBBAA".
   *
   * \see `as_rgb()`
   * \see `as_argb()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto as_rgba() const -> std::string
  {
    std::stringstream stream;
    stream << std::setfill('0') << std::hex << std::uppercase;

    stream << '#';
    stream << std::setw(2) << +m_color.r;
    stream << std::setw(2) << +m_color.g;
    stream << std::setw(2) << +m_color.b;
    stream << std::setw(2) << +m_color.a;

    return stream.str();
  }

  /**
   * \brief Returns a hexadecimal ARGB color string that represents the color.
   *
   * \details The returned string is guaranteed to use uppercase hexadecimal digits (A-F).
   *
   * \return a hexadecimal color string representation, on the format "#AARRGGBB".
   *
   * \see `as_rgb()`
   * \see `as_rgba()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto as_argb() const -> std::string
  {
    std::stringstream stream;
    stream << std::setfill('0') << std::hex << std::uppercase;

    stream << '#';
    stream << std::setw(2) << +m_color.a;
    stream << std::setw(2) << +m_color.r;
    stream << std::setw(2) << +m_color.g;
    stream << std::setw(2) << +m_color.b;

    return stream.str();
  }

  /// \} End of color string conversions

  /// \name Conversions
  /// \{

  /**
   * \brief Converts the the color into an `SDL_Color`.
   *
   * \return an `SDL_Color` that is equivalent to this color.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit constexpr operator SDL_Color() const noexcept
  {
    return {red(), green(), blue(), alpha()};
  }

  /**
   * \brief Converts the the color into an `SDL_MessageBoxColor`.
   *
   * \note Message box colors don't feature an alpha value!
   *
   * \return an `SDL_MessageBoxColor` that is equivalent to this color.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit constexpr operator SDL_MessageBoxColor() const noexcept
  {
    return {red(), green(), blue()};
  }

  /**
   * \brief Converts the color to `SDL_Color*`.
   *
   * \warning The returned pointer is not to be freed or stored away!
   *
   * \return a pointer to the internal color instance.
   *
   * \since 4.0,0
   */
  [[nodiscard]] explicit operator SDL_Color*() noexcept
  {
    return &m_color;
  }

  /**
   * \brief Converts the color to `const SDL_Color*`.
   *
   * \warning The returned pointer is not to be freed or stored away!
   *
   * \return a pointer to the internal color instance.
   *
   * \since 4.0,0
   */
  [[nodiscard]] explicit operator const SDL_Color*() const noexcept
  {
    return &m_color;
  }

  /// \} End of conversions

  /**
   * \brief Serializes the color.
   *
   * \details This function expects that the archive provides an overloaded `operator()`,
   * used for serializing data. This API is based on the Cereal serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the color.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_color.r, m_color.g, m_color.b, m_color.a);
  }

  /**
   * \brief Returns a copy of the color with the specified alpha value.
   *
   * \param alpha the alpha component value that will be used by the new color.
   *
   * \return a color that is identical to the color except for the alpha component.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto with_alpha(const u8 alpha) const noexcept -> color
  {
    return {red(), green(), blue(), alpha};
  }

  /**
   * \brief Returns the maximum possible value of a color component.
   *
   * \return the maximum possible value of a color component.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr static auto max() noexcept -> u8
  {
    return 0xFF;
  }

 private:
  SDL_Color m_color{0, 0, 0, max()};
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of the color.
 *
 * \param color the color that will be converted.
 *
 * \return a textual representation of the color.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto to_string(const color& color) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("color{{r: {}, g: {}, b: {}: a: {}}}",
                     +color.red(),
                     +color.green(),
                     +color.blue(),
                     +color.alpha());
#else
  return "color{r: " + std::to_string(color.red()) + ", g: " + std::to_string(color.green()) +
         ", b: " + std::to_string(color.blue()) + ", a: " + std::to_string(color.alpha()) +
         "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a color.
 *
 * \param stream the stream that will be used.
 * \param color the color that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
inline auto operator<<(std::ostream& stream, const color& color) -> std::ostream&
{
  return stream << to_string(color);
}

/// \} End of streaming

/**
 * \brief Blends two colors according to the specified bias.
 *
 * \pre `bias` should be in the range [0, 1].
 *
 * \details This function applies a linear interpolation for each color component to
 * obtain the blended color. The bias parameter is the "alpha" for the interpolation,
 * which determines how the input colors are blended. For example, a bias of 0 or 1 will
 * simply result in the first or second color being returned, respectively.
 * Subsequently, a bias of 0.5 will blend the two colors evenly.
 *
 * \param a the first color.
 * \param b the second color.
 * \param bias the bias that determines how the colors are blended, in the range [0, 1].
 *
 * \return a color obtained by blending the two supplied colors.
 *
 * \todo Default the bias to 0.5 when the `double` overload has been removed.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto blend(const color& a, const color& b, const float bias) -> color
{
  assert(bias >= 0);
  assert(bias <= 1.0f);

  const auto red = detail::lerp(a.red_norm(), b.red_norm(), bias);
  const auto green = detail::lerp(a.green_norm(), b.green_norm(), bias);
  const auto blue = detail::lerp(a.blue_norm(), b.blue_norm(), bias);
  const auto alpha = detail::lerp(a.alpha_norm(), b.alpha_norm(), bias);

  return color::from_norm(red, green, blue, alpha);
}

/// \copydoc blend()
/// \deprecated Since 6.2.0, use the overload using a `float` bias parameter instead.
[[nodiscard, deprecated]] inline auto blend(const color& a,
                                            const color& b,
                                            const double bias = 0.5) -> color
{
  return blend(a, b, static_cast<float>(bias));
}

/// \name Color comparison operators
/// \{

/**
 * \brief Indicates whether or not the two colors are equal.
 *
 * \param lhs the left-hand side color.
 * \param rhs the right-hand side color.
 *
 * \return `true` if the colors are equal; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const color& lhs, const color& rhs) noexcept -> bool
{
  return (lhs.red() == rhs.red()) && (lhs.green() == rhs.green()) &&
         (lhs.blue() == rhs.blue()) && (lhs.alpha() == rhs.alpha());
}

/// \copydoc operator==(const color&, const color&)
[[nodiscard]] constexpr auto operator==(const color& lhs, const SDL_Color& rhs) noexcept
    -> bool
{
  return (lhs.red() == rhs.r) && (lhs.green() == rhs.g) && (lhs.blue() == rhs.b) &&
         (lhs.alpha() == rhs.a);
}

/// \copydoc operator==(const color&, const color&)
[[nodiscard]] constexpr auto operator==(const SDL_Color& lhs, const color& rhs) noexcept
    -> bool
{
  return rhs == lhs;
}

/**
 * \copybrief operator==(const color&, const color&)
 *
 * \note The alpha components are not taken into account.
 *
 * \param lhs the left-hand side color.
 * \param rhs the right-hand side color.
 *
 * \return `true` if the colors are equal; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const color& lhs,
                                        const SDL_MessageBoxColor& rhs) noexcept -> bool
{
  return (lhs.red() == rhs.r) && (lhs.green() == rhs.g) && (lhs.blue() == rhs.b);
}

/// \copydoc operator==(const color&, const SDL_MessageBoxColor&)
[[nodiscard]] constexpr auto operator==(const SDL_MessageBoxColor& lhs,
                                        const color& rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the two colors aren't equal.
 *
 * \param lhs the left-hand side color.
 * \param rhs the right-hand side color.
 *
 * \return `true` if the colors aren't equal; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator!=(const color& lhs, const color& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const color&, const color&)
[[nodiscard]] constexpr auto operator!=(const color& lhs, const SDL_Color& rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const color&, const color&)
[[nodiscard]] constexpr auto operator!=(const SDL_Color& lhs, const color& rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/**
 * \copybrief operator!=(const color&, const color&)
 *
 * \note The alpha components are not taken into account.
 *
 * \param lhs the left-hand side color.
 * \param rhs the right-hand side color.
 *
 * \return `true` if the colors aren't equal; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator!=(const color& lhs,
                                        const SDL_MessageBoxColor& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const color&, const SDL_MessageBoxColor&)
[[nodiscard]] constexpr auto operator!=(const SDL_MessageBoxColor& lhs,
                                        const color& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of color comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_COLOR_HEADER

// #include "pixel_format_info.hpp"
#ifndef CENTURION_PIXEL_FORMAT_INFO_HEADER
#define CENTURION_PIXEL_FORMAT_INFO_HEADER

#include <SDL.h>

#include <ostream>  // ostream
#include <string>   // string, to_string

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/not_null.hpp"

// #include "../core/owner.hpp"

// #include "../core/str.hpp"

// #include "../core/to_underlying.hpp"

// #include "../detail/address_of.hpp"

// #include "../detail/owner_handle_api.hpp"

// #include "color.hpp"

// #include "pixel_format.hpp"


namespace cen {

/// \addtogroup video
/// \{

template <typename B>
class basic_pixel_format_info;

/**
 * \typedef pixel_format_info
 *
 * \brief Represents an owning pixel format info instance.
 *
 * \since 5.2.0
 */
using pixel_format_info = basic_pixel_format_info<detail::owning_type>;

/**
 * \typedef pixel_format_info_handle
 *
 * \brief Represents a non-owning pixel format info instance.
 *
 * \since 5.2.0
 */
using pixel_format_info_handle = basic_pixel_format_info<detail::handle_type>;

/**
 * \class basic_pixel_format_info
 *
 * \brief Provides information about a pixel format.
 *
 * \ownerhandle `pixel_format_info`/ `pixel_format_info_handle`
 *
 * \see `pixel_format`
 * \see `pixel_format_info`
 * \see `pixel_format_info_handle`
 * \see `SDL_PixelFormat`
 * \see `SDL_PixelFormatEnum`
 *
 * \since 5.2.0
 */
template <typename B>
class basic_pixel_format_info final
{
 public:
  /// \name Construction
  /// \{

  // clang-format off

  /**
   * \brief Creates a pixel format info instance based on an existing pointer.
   *
   * \note Ownership of the supplied pointer might be claimed, depending on the
   * ownership semantics of the class.
   *
   * \param format a pointer to the associated pixel format.
   *
   * \throws cen_error if the supplied pointer is null *and* the class has owning semantics.
   *
   * \since 5.2.0
   */
  explicit basic_pixel_format_info(maybe_owner<SDL_PixelFormat*> format) noexcept(!detail::is_owning<B>())
      : m_format{format}
  {
    if constexpr (detail::is_owning<B>())
    {
      if (!m_format)
      {
        throw cen_error{"Null pixel format!"};
      }
    }
  }

  // clang-format on

  /**
   * \brief Creates an owning instance based on a pixel format.
   *
   * \tparam BB dummy template parameter for SFINAE.
   *
   * \param format the associated pixel format.
   *
   * \throws sdl_error if the pixel format info could not be obtained.
   *
   * \since 5.2.0
   */
  template <typename BB = B, detail::is_owner<BB> = 0>
  explicit basic_pixel_format_info(const pixel_format format)
      : m_format{SDL_AllocFormat(to_underlying(format))}
  {
    if (!m_format) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates a handle based on an owning pixel format info instance.
   *
   * \param info the associated pixel format info instance.
   *
   * \since 5.2.0
   */
  template <typename BB = B, detail::is_handle<BB> = 0>
  explicit basic_pixel_format_info(const pixel_format_info& info) noexcept
      : m_format{info.get()}
  {}

  /// \} End of construction

  /// \name Pixel/RGB/RGBA conversions
  /// \{

  /**
   * \brief Returns a color that corresponds to a masked pixel value.
   *
   * \param pixel the masked pixel value.
   *
   * \return a color that corresponds to a pixel value, according to the format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto pixel_to_rgb(const u32 pixel) const noexcept -> color
  {
    u8 red{};
    u8 green{};
    u8 blue{};
    SDL_GetRGB(pixel, m_format, &red, &green, &blue);
    return color{red, green, blue};
  }

  /**
   * \brief Returns a color that corresponds to a masked pixel value.
   *
   * \param pixel the masked pixel value.
   *
   * \return a color that corresponds to a pixel value, according to the format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto pixel_to_rgba(const u32 pixel) const noexcept -> color
  {
    u8 red{};
    u8 green{};
    u8 blue{};
    u8 alpha{};
    SDL_GetRGBA(pixel, m_format, &red, &green, &blue, &alpha);
    return color{red, green, blue, alpha};
  }

  /**
   * \brief Returns a pixel color value based on the RGB values of a color.
   *
   * \note The alpha component is assumed to be `0xFF`, i.e. fully opaque.
   *
   * \param color the color that will be converted.
   *
   * \return a masked pixel color value, based on the pixel format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto rgb_to_pixel(const color& color) const noexcept -> u32
  {
    return SDL_MapRGB(m_format, color.red(), color.green(), color.blue());
  }

  /**
   * \brief Returns a pixel color value based on the RGBA values of a color.
   *
   * \param color the color that will be converted.
   *
   * \return a masked pixel color value, based on the pixel format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto rgba_to_pixel(const color& color) const noexcept -> u32
  {
    return SDL_MapRGBA(m_format, color.red(), color.green(), color.blue(), color.alpha());
  }

  /// \} End of pixel/RGB/RGBA conversions

  /// \name Queries
  /// \{

  /**
   * \brief Returns the associated pixel format.
   *
   * \return the associated pixel format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto format() const noexcept -> pixel_format
  {
    return static_cast<pixel_format>(m_format->format);
  }

  /**
   * \brief Returns a human-readable name associated with the format.
   *
   * \details This function never returns a null-pointer, instead it returns
   * "SDL_PIXELFORMAT_UNKNOWN" if the format is ill-formed.
   *
   * \return a human-readable name associated with the format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto name() const noexcept -> not_null<str>
  {
    return SDL_GetPixelFormatName(m_format->format);
  }

  /**
   * \brief Returns a pointer to the associated pixel format instance.
   *
   * \warning Do not claim ownership of the returned pointer.
   *
   * \return a pointer to the internal pixel format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_PixelFormat*
  {
    return m_format.get();
  }

  /// \} End of queries

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not a handle holds a non-null pointer.
   *
   * \return `true` if the handle holds a non-null pointer; `false` otherwise.
   *
   * \since 5.2.0
   */
  template <typename BB = B, detail::is_handle<BB> = 0>
  [[nodiscard]] explicit operator bool() const noexcept
  {
    return m_format;
  }

  /// \} End of conversions

 private:
  struct deleter final
  {
    void operator()(SDL_PixelFormat* format) noexcept
    {
      SDL_FreeFormat(format);
    }
  };
  detail::pointer_manager<B, SDL_PixelFormat, deleter> m_format;
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a pixel format info instance.
 *
 * \tparam T the ownership semantics tag.
 *
 * \param info the pixel format info instance that will be converted.
 *
 * \return a string that represents the pixel format info.
 *
 * \since 6.2.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_pixel_format_info<T>& info) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("pixel_format_info{{data: {}, name: {}}}",
                     detail::address_of(info.get()),
                     info.name());
#else
  return "pixel_format_info{data: " + detail::address_of(info.get()) +
         ", name: " + info.name() + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a pixel format info instance.
 *
 * \tparam T the ownership semantics tag.
 *
 * \param stream the output stream that will be used.
 * \param info the pixel format info that will be printed.
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_pixel_format_info<T>& info) -> std::ostream&
{
  return stream << to_string(info);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_PIXEL_FORMAT_INFO_HEADER


namespace cen {

/// \addtogroup video
/// \{

template <typename T>
class basic_surface;

/**
 * \typedef surface
 *
 * \brief Represents an owning surface.
 *
 * \since 5.0.0
 */
using surface = basic_surface<detail::owning_type>;

/**
 * \typedef surface_handle
 *
 * \brief Represents a non-owning surface.
 *
 * \since 5.0.0
 */
using surface_handle = basic_surface<detail::handle_type>;

/**
 * \class basic_surface
 *
 * \brief Represents a non-accelerated image.
 *
 * \ownerhandle `surface`/`surface_handle`
 *
 * \details Surfaces are often used for icons and snapshots, or as an "intermediate"
 * representation that can be manipulated, unlike textures. There is no support
 * for directly rendering surfaces. However, surfaces can be converted to textures, which
 * in turn can be rendered.
 *
 * \note Unlike most other Centurion components, surfaces can be copied.
 *
 * \since 4.0.0
 *
 * \see `surface`
 * \see `surface_handle`
 */
template <typename T>
class basic_surface final
{
 public:
  /// \name Construction
  /// \{

  // clang-format off

  /**
   * \brief Creates a surface from a pointer to an SDL surface.
   *
   * \note Depending on the type of the surface, ownership of the supplied SDL
   * surface might be claimed.
   *
   * \param surface a pointer to the associated surface.
   *
   * \since 4.0.0
   */
  explicit basic_surface(maybe_owner<SDL_Surface*> surface) noexcept(!detail::is_owning<T>())
      : m_surface{surface}
  {
    if constexpr (detail::is_owning<T>())
    {
      if (!m_surface)
      {
        throw cen_error{"Cannot create surface from null pointer!"};
      }
    }
  }

  // clang-format on

#ifndef CENTURION_NO_SDL_IMAGE

  /**
   * \brief Creates a surface based on the image at the specified path.
   *
   * \tparam BB dummy parameter for SFINAE.
   *
   * \param file the file path of the image file that will be loaded, can't
   * be null.
   *
   * \throws img_error if the surface cannot be created.
   *
   * \since 4.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_surface(const not_null<str> file) : m_surface{IMG_Load(file)}
  {
    if (!m_surface) {
      throw img_error{};
    }
  }

  /**
   * \brief Creates a surface based on the image at the specified path.
   *
   * \tparam BB dummy parameter for SFINAE.
   *
   * \param file the file path of the image file that will be loaded.
   *
   * \throws img_error if the surface cannot be created.
   *
   * \since 5.3.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_surface(const std::string& file) : basic_surface{file.c_str()}
  {}

#endif  // CENTURION_NO_SDL_IMAGE

  /**
   * \brief Creates a surface with the specified dimensions and pixel format.
   *
   * \tparam BB dummy parameter for SFINAE.
   *
   * \param size the size of the surface.
   * \param pixelFormat the pixel format that will be used by the surface.
   *
   * \throws sdl_error if the surface cannot be created.
   *
   * \since 5.3.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  basic_surface(const iarea size, const pixel_format pixelFormat)
      : m_surface{SDL_CreateRGBSurfaceWithFormat(0,
                                                 size.width,
                                                 size.height,
                                                 0,
                                                 to_underlying(pixelFormat))}
  {
    if (!m_surface) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates and returns a surface with the specified characteristics.
   *
   * \tparam BB dummy parameter for SFINAE.
   *
   * \param file the file path of the image that the surface will be based on.
   * \param blendMode the blend mode that will be used.
   * \param pixelFormat the pixel format that will be used.
   *
   * \return an owning surface, with the specified blend mode and pixel format.
   *
   * \since 5.2.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto with_format(const not_null<str> file,
                                        const blend_mode blendMode,
                                        const pixel_format pixelFormat) -> basic_surface
  {
    assert(file);

    basic_surface source{file};
    source.set_blend_mode(blendMode);

    return source.convert(pixelFormat);
  }

  /**
   * \see with_format()
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto with_format(const std::string& file,
                                        const blend_mode blendMode,
                                        const pixel_format pixelFormat) -> basic_surface
  {
    return with_format(file.c_str(), blendMode, pixelFormat);
  }

  /**
   * \brief Creates and returns a surface based on a BMP file.
   *
   * \tparam BB dummy parameter for SFINAE.
   *
   * \param file the path to the BMP file that contains the surface data.
   *
   * \return the created surface.
   *
   * \throws sdl_error if the surface couldn't be loaded.
   *
   * \since 5.3.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto from_bmp(const not_null<str> file) -> basic_surface
  {
    assert(file);
    return basic_surface{SDL_LoadBMP(file)};
  }

  /**
   * \see from_bmp()
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto from_bmp(const std::string& file) -> basic_surface
  {
    return from_bmp(file.c_str());
  }

  /**
   * \brief Creates a copy of the supplied surface.
   *
   * \param other the surface that will be copied.
   *
   * \since 4.0.0
   */
  basic_surface(const basic_surface& other) noexcept(!detail::is_owning<T>())
  {
    if constexpr (detail::is_owning<T>()) {
      copy(other);
    }
    else {
      m_surface = other.get();
    }
  }

  /**
   * \brief Creates a surface by moving the supplied surface.
   *
   * \param other the surface that will be moved.
   *
   * \since 4.0.0
   */
  basic_surface(basic_surface&& other) noexcept = default;

  /// \} End of construction

  /**
   * \brief Copies the supplied surface.
   *
   * \param other the surface that will be copied.
   *
   * \throws sdl_error if the supplied surface couldn't be copied.
   *
   * \since 4.0.0
   */
  auto operator=(const basic_surface& other) noexcept(!detail::is_owning<T>())
      -> basic_surface&
  {
    if (this != &other) {
      if constexpr (detail::is_owning<T>()) {
        copy(other);
      }
      else {
        m_surface = other.get();
      }
    }
    return *this;
  }

  /**
   * \brief Moves the supplied surface into this surface.
   *
   * \param other the surface that will be moved.
   *
   * \return the surface that claimed the supplied surface.
   *
   * \since 4.0.0
   */
  auto operator=(basic_surface&& other) noexcept -> basic_surface& = default;

  /// \name Save functions
  /// \{

  /**
   * \brief Saves the surface as a BMP image.
   *
   * \param file the file path that the surface data will be saved at.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.3.0
   */
  auto save_as_bmp(const not_null<str> file) const noexcept -> result
  {
    assert(file);
    return SDL_SaveBMP(get(), file) != -1;
  }

  /**
   * \see save_as_bmp()
   * \since 6.0.0
   */
  auto save_as_bmp(const std::string& file) const noexcept -> result  // NOLINT
  {
    return save_as_bmp(file.c_str());
  }

#ifndef CENTURION_NO_SDL_IMAGE

  /**
   * \brief Saves the surface as a PNG image.
   *
   * \param file the file path that the surface data will be saved at.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 6.0.0
   */
  auto save_as_png(const not_null<str> file) const noexcept -> result
  {
    assert(file);
    return IMG_SavePNG(get(), file) != -1;
  }

  /**
   * \see save_as_png()
   * \since 6.0.0
   */
  auto save_as_png(const std::string& file) const noexcept -> result  // NOLINT
  {
    return save_as_png(file.c_str());
  }

  /**
   * \brief Saves the surface as a JPG image.
   *
   * \note The quality parameter is supplied to libjpeg in the SDL
   * implementation, but the limitations on its values are unknown at the time
   * of writing.
   *
   * \param file the file path that the surface data will be saved at.
   * \param quality the quality of the JPG image.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 6.0.0
   */
  auto save_as_jpg(const not_null<str> file, const int quality) const noexcept -> result
  {
    assert(file);
    return IMG_SaveJPG(get(), file, quality) != -1;
  }

  /**
   * \see save_as_jpg()
   * \since 6.0.0
   */
  auto save_as_jpg(const std::string& file, const int quality) const noexcept -> result
  {
    return save_as_jpg(file.c_str(), quality);
  }

#endif  // CENTURION_NO_SDL_IMAGE

  /// \} End of save functions

  /// \name Locking
  /// \{

  /**
   * \brief Attempts to lock the surface, so that the associated pixel data can
   * be modified.
   *
   * \details This function has no effect if `must_lock()` returns `false`.
   *
   * \return `success` if the locking of the surface was successful or if
   * locking isn't required for modifying the surface; `failure` if something
   * went wrong.
   *
   * \since 4.0.0
   */
  auto lock() noexcept -> result
  {
    if (must_lock()) {
      return SDL_LockSurface(m_surface) == 0;
    }
    else {
      return true;
    }
  }

  /**
   * \brief Unlocks the surface.
   *
   * \details This function has no effect if `must_lock()` returns `false`.
   *
   * \since 4.0.0
   */
  void unlock() noexcept
  {
    if (must_lock()) {
      SDL_UnlockSurface(m_surface);
    }
  }

  /**
   * \brief Indicates whether or not the surface must be locked before modifying
   * the pixel data associated with the surface.
   *
   * \return `true` if the surface must be locked before modification; `false`
   * otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto must_lock() const noexcept -> bool
  {
    return SDL_MUSTLOCK(m_surface);
  }

  /// \} End of locking

  /// \name Setters
  /// \{

  /**
   * \brief Sets the color of the pixel at the specified coordinate.
   *
   * \details This function has no effect if the coordinate is out-of-bounds or if
   * something goes wrong when attempting to modify the pixel data.
   *
   * \param pixel the pixel that will be changed.
   * \param color the new color of the pixel.
   *
   * \since 4.0.0
   */
  void set_pixel(const ipoint pixel, const color& color) noexcept
  {
    if (!in_bounds(pixel) || !lock()) {
      return;
    }

    const int nPixels = (m_surface->pitch / 4) * height();
    const int index = (pixel.y() * width()) + pixel.x();

    if ((index >= 0) && (index < nPixels)) {
      const auto info = format_info();
      auto* pixels = reinterpret_cast<u32*>(m_surface->pixels);
      pixels[index] = info.rgba_to_pixel(color);
    }

    unlock();
  }

  /**
   * \brief Sets the alpha component modulation value.
   *
   * \param alpha the new alpha component value, in the range [0, 255].
   *
   * \since 4.0.0
   */
  void set_alpha(const u8 alpha) noexcept
  {
    SDL_SetSurfaceAlphaMod(m_surface, alpha);
  }

  /**
   * \brief Sets the color modulation that will be used by the surface.
   *
   * \param color the color that represents the color modulation that will be
   * used.
   *
   * \since 4.0.0
   */
  void set_color_mod(const color& color) noexcept
  {
    SDL_SetSurfaceColorMod(m_surface, color.red(), color.green(), color.blue());
  }

  /**
   * \brief Sets the blend mode that will be used by the surface.
   *
   * \param mode the blend mode that will be used.
   *
   * \since 4.0.0
   */
  void set_blend_mode(const blend_mode mode) noexcept
  {
    SDL_SetSurfaceBlendMode(m_surface, static_cast<SDL_BlendMode>(mode));
  }

  /**
   * \brief Sets the value of the RLE acceleration hint.
   *
   * \param enabled `true` if the RLE optimization hint should be enabled;
   * `false` otherwise.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \see is_rle_enabled()
   *
   * \since 5.2.0
   */
  auto set_rle_hint(const bool enabled) noexcept -> result
  {
    return SDL_SetSurfaceRLE(m_surface, enabled ? 1 : 0) == 0;
  }

  /// \} End of setters

  /// \name Getters
  /// \{

  /**
   * \brief Returns the alpha component modulation of the surface.
   *
   * \return the alpha modulation value, in the range [0, 255].
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto alpha() const noexcept -> u8
  {
    u8 alpha{0xFF};
    SDL_GetSurfaceAlphaMod(m_surface, &alpha);
    return alpha;
  }

  /**
   * \brief Returns the color modulation of the surface.
   *
   * \return a color that represents the color modulation of the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto color_mod() const noexcept -> color
  {
    u8 red{};
    u8 green{};
    u8 blue{};
    SDL_GetSurfaceColorMod(m_surface, &red, &green, &blue);
    return color{red, green, blue};
  }

  /**
   * \brief Returns the blend mode that is being used by the surface.
   *
   * \return the blend mode that the surface uses.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get_blend_mode() const noexcept -> blend_mode
  {
    SDL_BlendMode mode{};
    SDL_GetSurfaceBlendMode(m_surface, &mode);
    return static_cast<blend_mode>(mode);
  }

  /**
   * \brief Creates and returns a surface based on this surface with the
   * specified pixel format.
   *
   * \param format the pixel format that will be used by the new surface.
   *
   * \return a surface based on this surface with the specified
   * pixel format.
   *
   * \throws sdl_error if the surface cannot be created.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto convert(const pixel_format format) const -> basic_surface
  {
    if (auto* converted = SDL_ConvertSurfaceFormat(m_surface, to_underlying(format), 0)) {
      basic_surface result{converted};
      result.set_blend_mode(get_blend_mode());
      return result;
    }
    else {
      throw sdl_error{};
    }
  }

  /**
   * \brief Returns the width of the surface.
   *
   * \return the width of the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto width() const noexcept -> int
  {
    return m_surface->w;
  }

  /**
   * \brief Returns the height of the surface.
   *
   * \return the height of the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto height() const noexcept -> int
  {
    return m_surface->h;
  }

  /**
   * \brief Returns the size of the surface.
   *
   * \return the size of the surface.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto size() const noexcept -> iarea
  {
    return iarea{width(), height()};
  }

  /**
   * \brief Returns the pitch (the length of a row of pixels in bytes) of the
   * surface.
   *
   * \return the pitch of the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto pitch() const noexcept -> int
  {
    return m_surface->pitch;
  }

  /**
   * \brief Returns a pointer to the pixel data of the surface.
   *
   * \details It's possible to modify the surface through the returned pointer.
   *
   * \return a pointer to the pixel data of the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto pixels() noexcept -> void*
  {
    return m_surface->pixels;
  }

  /**
   * \brief Returns a pointer to the pixel data of the surface.
   *
   * \return a pointer to the pixel data of the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto pixels() const noexcept -> const void*
  {
    return m_surface->pixels;
  }

  /**
   * \brief Returns a pointer to the pixel data of the surface.
   *
   * \return a pointer to the pixel data of the surface.
   *
   * \since 5.3.0
   */
  [[nodiscard]] auto data() noexcept -> void*
  {
    return pixels();
  }

  /**
   * \copydoc data()
   */
  [[nodiscard]] auto data() const noexcept -> const void*
  {
    return pixels();
  }

  /**
   * \brief Returns the pixel format info associated with the surface.
   *
   * \return the associated pixel format info.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto format_info() const noexcept -> pixel_format_info_handle
  {
    return pixel_format_info_handle{m_surface->format};
  }

  /**
   * \brief Returns the clipping information associated with the surface.
   *
   * \return the clipping information associated with the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto clip() const noexcept -> irect
  {
    const auto rect = m_surface->clip_rect;
    return {{rect.x, rect.y}, {rect.w, rect.h}};
  }

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Indicates whether or not the surface is RLE-enabled.
   *
   * \return `true` if the surface is RLE-enabled; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto is_rle_enabled() const noexcept -> bool
  {
    return SDL_HasSurfaceRLE(m_surface) == SDL_TRUE;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Returns a pointer to the associated `SDL_Surface`.
   *
   * \warning Don't take ownership of the returned pointer!
   *
   * \return a pointer to the associated `SDL_Surface`.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_Surface*
  {
    return m_surface.get();
  }

  /// \} End of getters

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not a surface handle holds a non-null pointer.
   *
   * \tparam BB dummy parameter for SFINAE.
   *
   * \return `true` if the surface handle holds a non-null pointer; `false`
   * otherwise.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit operator bool() const noexcept
  {
    return m_surface != nullptr;
  }

  /**
   * \brief Converts to `SDL_Surface*`.
   *
   * \return a pointer to the associated `SDL_Surface`.
   *
   * \since 4.0.0
   */
  [[nodiscard]] explicit operator SDL_Surface*() noexcept
  {
    return get();
  }

  /**
   * \brief Converts to `const SDL_Surface*`.
   *
   * \return a pointer to the associated `SDL_Surface`.
   *
   * \since 4.0.0
   */
  [[nodiscard]] explicit operator const SDL_Surface*() const noexcept
  {
    return get();
  }

  /// \} End of conversions

 private:
  struct deleter final
  {
    void operator()(SDL_Surface* surface) noexcept
    {
      SDL_FreeSurface(surface);
    }
  };
  detail::pointer_manager<T, SDL_Surface, deleter> m_surface;

  /**
   * \brief Copies the contents of the supplied surface instance into this
   * instance.
   *
   * \param other the instance that will be copied.
   *
   * \throws sdl_error if the surface cannot be copied.
   *
   * \since 4.0.0
   */
  void copy(const basic_surface& other)
  {
    m_surface.reset(other.copy_surface());
  }

  /**
   * \brief Indicates whether or not the supplied point is within the bounds of
   * the surface.
   *
   * \param point the point that will be checked.
   *
   * \return `true` if the point is within the bounds of the surface; `false`
   * otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto in_bounds(const ipoint point) const noexcept -> bool
  {
    return !(point.x() < 0 || point.y() < 0 || point.x() >= width() || point.y() >= height());
  }

  /**
   * \brief Creates and returns copy of the associated `SDL_Surface`.
   *
   * \return a copy of the associated `SDL_Surface`, the returned pointer won't
   * be null.
   *
   * \throws sdl_error if the copy couldn't be created.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto copy_surface() const -> owner<SDL_Surface*>
  {
    if (auto* copy = SDL_DuplicateSurface(m_surface)) {
      return copy;
    }
    else {
      throw sdl_error{};
    }
  }

#ifdef CENTURION_MOCK_FRIENDLY_MODE

 public:
  basic_surface() = default;
#endif  // CENTURION_MOCK_FRIENDLY_MODE
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a surface.
 *
 * \param surface the surface that will be converted.
 *
 * \return a textual representation of the surface.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_surface<T>& surface) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("surface{{data: {}, width: {}, height: {}}}",
                     detail::address_of(surface.get()),
                     surface.width(),
                     surface.height());
#else
  return "surface{data: " + detail::address_of(surface.get()) +
         ", width: " + std::to_string(surface.width()) +
         ", height: " + std::to_string(surface.height()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a surface.
 *
 * \param stream the stream that will be used.
 * \param surface the surface that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_surface<T>& surface) -> std::ostream&
{
  return stream << to_string(surface);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_SURFACE_HEADER


namespace cen {

/// \addtogroup video
/// \{

template <typename T>
class basic_window;

/**
 * \typedef window
 *
 * \brief Represents an owning window.
 *
 * \since 5.0.0
 */
using window = basic_window<detail::owning_type>;

/**
 * \typedef window_handle
 *
 * \brief Represents a non-owning window.
 *
 * \since 5.0.0
 */
using window_handle = basic_window<detail::handle_type>;

/**
 * \class basic_window
 *
 * \brief Represents an operating system window.
 *
 * \ownerhandle `window`/`window_handle`
 *
 * \since 5.0.0
 *
 * \see `window`
 * \see `window_handle`
 * \see `get_window()`
 * \see `get_grabbed_window()`
 * \see `mouse_focus_window()`
 * \see `keyboard_focus_window()`
 * \see `get_renderer()`
 * \see `make_window_and_renderer()`
 */
template <typename T>
class basic_window final
{
 public:
  /**
   * \enum window_flags
   *
   * \brief Represents different window features and options.
   *
   * \details Values of this enum are intended to be used to create flag bitmasks, that
   * can be used when creating windows and to obtain information from created windows.
   *
   * \see `SDL_WindowFlags`
   *
   * \since 6.0.0
   */
  enum window_flags : u32
  {
    fullscreen = SDL_WINDOW_FULLSCREEN,
    opengl = SDL_WINDOW_OPENGL,
    shown = SDL_WINDOW_SHOWN,
    hidden = SDL_WINDOW_HIDDEN,
    borderless = SDL_WINDOW_BORDERLESS,
    resizable = SDL_WINDOW_RESIZABLE,
    minimized = SDL_WINDOW_MINIMIZED,
    maximized = SDL_WINDOW_MAXIMIZED,
    input_grabbed = SDL_WINDOW_INPUT_GRABBED,
    input_focus = SDL_WINDOW_INPUT_FOCUS,
    mouse_focus = SDL_WINDOW_MOUSE_FOCUS,
    fullscreen_desktop = SDL_WINDOW_FULLSCREEN_DESKTOP,
    foreign = SDL_WINDOW_FOREIGN,
    high_dpi = SDL_WINDOW_ALLOW_HIGHDPI,
    mouse_capture = SDL_WINDOW_MOUSE_CAPTURE,
    always_on_top = SDL_WINDOW_ALWAYS_ON_TOP,
    skip_taskbar = SDL_WINDOW_SKIP_TASKBAR,
    utility = SDL_WINDOW_UTILITY,
    tooltip = SDL_WINDOW_TOOLTIP,
    popup_menu = SDL_WINDOW_POPUP_MENU,
    vulkan = SDL_WINDOW_VULKAN,

#if SDL_VERSION_ATLEAST(2, 0, 14)
    metal = SDL_WINDOW_METAL
#endif  // SDL_VERSION_ATLEAST(2, 0, 14)
  };

  /// \name Construction
  /// \{

  /**
   * \brief Creates a window from a pointer to an SDL window.
   *
   * \note If you're creating a `window` instance, then ownership of the pointer is
   * claimed. Furthermore, if you're creating a `window_handle`, ownership is *not*
   * claimed.
   *
   * \param window a pointer to the associated SDL window. Ownership of this pointer is
   * claimed if the window is owning.
   *
   * \since 5.0.0
   */
  explicit basic_window(maybe_owner<SDL_Window*> window) noexcept(!detail::is_owning<T>())
      : m_window{window}
  {
    if constexpr (detail::is_owning<T>()) {
      if (!m_window) {
        throw cen_error{"Cannot create window from null pointer!"};
      }
    }
  }

  /**
   * \brief Creates an owning window with the specified title and size.
   *
   * \details The window will be hidden by default.
   *
   * \param title the title of the window, can't be null.
   * \param size the size of the window, components must be greater than zero.
   * \param flags the window flags.
   *
   * \throws cen_error if the supplied width or height aren't greater than zero.
   * \throws sdl_error if the window cannot be created.
   *
   * \see `default_size()`
   * \see `default_flags()`
   *
   * \since 3.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_window(const not_null<str> title,
                        const iarea size = default_size(),
                        const u32 flags = default_flags())
  {
    assert(title);

    if (size.width < 1) {
      throw cen_error{"Bad window width!"};
    }
    else if (size.height < 1) {
      throw cen_error{"Bad window height!"};
    }

    m_window.reset(SDL_CreateWindow(title,
                                    SDL_WINDOWPOS_CENTERED,
                                    SDL_WINDOWPOS_CENTERED,
                                    size.width,
                                    size.height,
                                    flags));
    if (!m_window) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates an owning window with the specified title and size.
   *
   * \details The window will be hidden by default.
   *
   * \param title the title of the window.
   * \param size the size of the window, components must be greater than zero.
   * \param flags the window flags, see `window_flags`.
   *
   * \throws cen_error if the supplied width or height aren't greater than zero.
   * \throws sdl_error if the window cannot be created.
   *
   * \see `default_size()`
   * \see `default_flags()`
   *
   * \since 5.3.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_window(const std::string& title,
                        const iarea size = default_size(),
                        const u32 flags = default_flags())
      : basic_window{title.c_str(), size, flags}
  {}

  /**
   * \brief Creates a window.
   *
   * \details The window will use the size obtained from `default_size()` as its initial
   * size.
   *
   * \throws sdl_error if the window cannot be created.
   *
   * \since 3.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  basic_window() : basic_window{"Centurion window"}
  {}

  /**
   * \brief Creates a window handle based on an owning window.
   *
   * \param owner the owning window to base the handle on.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit basic_window(const window& owner) noexcept : m_window{owner.get()}
  {}

  /// \} End of construction

  /// \name Mutators
  /// \{

  /**
   * \brief Makes the window visible.
   *
   * \since 3.0.0
   */
  void show() noexcept
  {
    SDL_ShowWindow(m_window);
  }

  /**
   * \brief Makes the window invisible.
   *
   * \since 3.0.0
   */
  void hide() noexcept
  {
    SDL_HideWindow(m_window);
  }

  /**
   * \brief Raises this window above other windows and requests focus.
   *
   * \since 3.0.0
   */
  void raise() noexcept
  {
    SDL_RaiseWindow(m_window);
  }

  /**
   * \brief Maximizes the window.
   *
   * \since 3.1.0
   */
  void maximize() noexcept
  {
    SDL_MaximizeWindow(m_window);
  }

  /**
   * \brief Minimizes the window.
   *
   * \since 3.1.0
   */
  void minimize() noexcept
  {
    SDL_MinimizeWindow(m_window);
  }

  /**
   * \brief Restores the position and size of the window if it's minimized or maximized.
   *
   * \since 5.3.0
   */
  void restore() noexcept
  {
    SDL_RestoreWindow(m_window);
  }

  /**
   * \brief Updates the window surface.
   *
   * \return `success` if the surface was successfully updated; `failure` otherwise.
   *
   * \since 5.0.0
   */
  auto update_surface() noexcept -> result
  {
    return SDL_UpdateWindowSurface(m_window) == 0;
  }

#if SDL_VERSION_ATLEAST(2, 0, 16)

  /**
   * \brief Modifies the flash state of the window to acquire attention from the user.
   *
   * \param op the flash operation that will be performed.
   *
   * \return `success` if the operation was successful; `failure` otherwise.
   *
   * \since 6.2.0
   */
  auto flash(const flash_op op = flash_op::briefly) noexcept -> result
  {
    return SDL_FlashWindow(m_window, static_cast<SDL_FlashOperation>(op)) == 0;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 16)

  /// \} End of mutators

  /// \name Setters
  /// \{

  /**
   * \brief Sets whether or not the window is in fullscreen mode.
   *
   * \param enabled `true` if the window should be fullscreen; `false` for windowed mode.
   *
   * \return `success` if the display mode was changed; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_fullscreen(const bool enabled) noexcept -> result
  {
    return SDL_SetWindowFullscreen(m_window, enabled ? fullscreen : 0) == 0;
  }

  /**
   * \brief Sets whether or not the window is in fullscreen desktop mode.
   *
   * \details This mode is useful when you want to "fake" fullscreen mode.
   *
   * \param enabled `true` if the window should be fullscreen desktop; `false` for
   * windowed mode.
   *
   * \return `success` if the display mode was changed; `failure` otherwise.
   *
   * \since 4.0.0
   */
  auto set_fullscreen_desktop(const bool enabled) noexcept -> result
  {
    return SDL_SetWindowFullscreen(m_window, enabled ? fullscreen_desktop : 0) == 0;
  }

  /**
   * \brief Sets whether or not the window is decorated.
   *
   * \details This is enabled by default.
   *
   * \param decorated `true` if the window should be decorated; `false` otherwise.
   *
   * \since 3.0.0
   */
  void set_decorated(const bool decorated) noexcept
  {
    SDL_SetWindowBordered(m_window, detail::convert_bool(decorated));
  }

  /**
   * \brief Sets whether or not the window should be resizable.
   *
   * \param resizable `true` if the window should be resizable; `false` otherwise.
   *
   * \since 3.0.0
   */
  void set_resizable(const bool resizable) noexcept
  {
    SDL_SetWindowResizable(m_window, detail::convert_bool(resizable));
  }

  /**
   * \brief Sets the icon that will be used by the window.
   *
   * \param icon the surface that will serve as the icon of the window.
   *
   * \since 3.0.0
   */
  void set_icon(const surface& icon) noexcept
  {
    SDL_SetWindowIcon(m_window, icon.get());
  }

  /**
   * \brief Sets the title of the window.
   *
   * \param title the title of the window, can't be null.
   *
   * \since 3.0.0
   */
  void set_title(const not_null<str> title) noexcept
  {
    assert(title);
    SDL_SetWindowTitle(m_window, title);
  }

  /**
   * \brief Sets the title of the window.
   *
   * \param title the title of the window.
   *
   * \since 5.3.0
   */
  void set_title(const std::string& title) noexcept
  {
    set_title(title.c_str());
  }

  /**
   * \brief Sets the opacity of the window.
   *
   * \details The supplied opacity will be clamped to a value in the legal range.
   *
   * \param opacity the opacity, in the range [0, 1].
   *
   * \return `success` if the opacity was successfully set; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_opacity(const float opacity) noexcept -> result
  {
    return SDL_SetWindowOpacity(m_window, opacity) == 0;
  }

  /**
   * \brief Sets whether or not the mouse should be confined within the window.
   *
   * \brief This property is disabled by default.
   *
   * \param grab `true` if the mouse should be confined within the window; `false`
   * otherwise.
   *
   * \see `set_grab_keyboard()`
   *
   * \since 3.0.0
   */
  void set_grab_mouse(const bool grab) noexcept
  {
    SDL_SetWindowGrab(m_window, detail::convert_bool(grab));
  }

  /**
   * \brief Sets the overall brightness of the window.
   *
   * \note A brightness value outside the legal range will be clamped to the closest valid
   * value.
   *
   * \param brightness the brightness value, in the range [0, 1].
   *
   * \return `success` if the brightness was successfully set; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_brightness(const float brightness) noexcept -> result
  {
    return SDL_SetWindowBrightness(m_window, detail::clamp(brightness, 0.0f, 1.0f)) == 0;
  }

  /**
   * \brief Sets whether or not the mouse should be captured.
   *
   * \note A window might have to be visible in order for the mouse to be captured.
   *
   * \param capture `true` if the mouse should be captured; `false` otherwise.
   *
   * \return `success` on the mouse capture was successfully changed; `failure` otherwise.
   *
   * \since 5.0.0
   */
  static auto set_capturing_mouse(const bool capture) noexcept -> result
  {
    return SDL_CaptureMouse(detail::convert_bool(capture)) == 0;
  }

#if SDL_VERSION_ATLEAST(2, 0, 16)

  /**
   * \brief Sets whether or not the keyboard input should be grabbed by the window.
   *
   * \param grab `true` if the keyboard should be grabbed; `false` otherwise.
   *
   * \see `set_grab_mouse()`
   *
   * \since 6.2.0
   */
  void set_grab_keyboard(const bool grab) noexcept
  {
    SDL_SetWindowKeyboardGrab(m_window, detail::convert_bool(grab));
  }

  /**
   * \brief Sets whether or not a window is always on top of other windows.
   *
   * \param enabled `true` if the window should be on top of all other windows; `false`
   * otherwise.
   *
   * \since 6.2.0
   */
  void set_always_on_top(const bool enabled) noexcept
  {
    SDL_SetWindowAlwaysOnTop(m_window, detail::convert_bool(enabled));
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 16)

  /// \} End of setters

  /// \name Position functions
  /// \{

  /**
   * \brief Centers the window position relative to the screen.
   *
   * \note Windows are centered by default.
   *
   * \since 3.0.0
   */
  void center() noexcept
  {
    set_position({SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED});
  }

  /**
   * \brief Sets the x-coordinate of the window.
   *
   * \param x the new x-coordinate of the window.
   *
   * \since 6.0.0
   */
  void set_x(const int x) noexcept
  {
    set_position({x, y()});
  }

  /**
   * \brief Sets the y-coordinate of the window.
   *
   * \param y the new y-coordinate of the window.
   *
   * \since 6.0.0
   */
  void set_y(const int y) noexcept
  {
    set_position({x(), y});
  }

  /**
   * \brief Sets the position of the window.
   *
   * \note It's possible to use `SDL_WINDOWPOS_CENTERED` or `SDL_WINDOWPOS_UNDEFINED` as
   * any of the components of the point.
   *
   * \param position the new position of the window.
   *
   * \since 5.0.0
   */
  void set_position(const ipoint position) noexcept
  {
    SDL_SetWindowPosition(m_window, position.x(), position.y());
  }

  /**
   * \brief Returns the x-coordinate of the window position.
   *
   * \return the x-coordinate of the window position.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto x() const noexcept -> int
  {
    return position().x();
  }

  /**
   * \brief Returns the y-coordinate of the window position.
   *
   * \return the y-coordinate of the window position.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto y() const noexcept -> int
  {
    return position().y();
  }

  /**
   * \brief Returns the current position of the window.
   *
   * \note Windows are centered by default.
   *
   * \return the current position of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto position() const noexcept -> ipoint
  {
    int x{};
    int y{};
    SDL_GetWindowPosition(m_window, &x, &y);
    return {x, y};
  }

  /// \} End of position functions

  /// \name Size functions
  /// \{

  /**
   * \brief Sets the width of the window.
   *
   * \details The supplied width is capped to always be at least 1.
   *
   * \param width the new width of the window, must be greater than zero.
   *
   * \since 3.0.0
   */
  void set_width(const int width) noexcept
  {
    SDL_SetWindowSize(m_window, detail::max(width, 1), height());
  }

  /**
   * \brief Sets the height of the window.
   *
   * \details The supplied height is capped to always be at least 1.
   *
   * \param height the new height of the window, must be greater than zero.
   *
   * \since 3.0.0
   */
  void set_height(const int height) noexcept
  {
    SDL_SetWindowSize(m_window, width(), detail::max(height, 1));
  }

  /**
   * \brief Sets the size of the window.
   *
   * \pre The supplied width and height must be greater than zero.
   *
   * \param size the new size of the window.
   *
   * \since 5.0.0
   */
  void set_size(const iarea size) noexcept
  {
    assert(size.width > 0);
    assert(size.height > 0);
    SDL_SetWindowSize(m_window, size.width, size.height);
  }

  /**
   * \brief Sets the minimum size of the window.
   *
   * \pre The supplied width and height must be greater than zero.
   *
   * \param size the minimum size of the window.
   *
   * \since 3.0.0
   */
  void set_min_size(const iarea size) noexcept
  {
    assert(size.width > 0);
    assert(size.height > 0);
    SDL_SetWindowMinimumSize(m_window, size.width, size.height);
  }

  /**
   * \brief Sets the maximum size of the window.
   *
   * \pre The supplied width and height must be greater than zero.
   *
   * \param size the maximum size of the window.
   *
   * \since 3.0.0
   */
  void set_max_size(const iarea size) noexcept
  {
    assert(size.width > 0);
    assert(size.height > 0);
    SDL_SetWindowMaximumSize(m_window, size.width, size.height);
  }

  /**
   * \brief Returns the current width of the window.
   *
   * \return the current width of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto width() const noexcept -> int
  {
    return size().width;
  }

  /**
   * \brief Returns the current height of the window.
   *
   * \return the current height of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto height() const noexcept -> int
  {
    return size().height;
  }

  /**
   * \brief Returns the current size of the window.
   *
   * \note Calling this function is slightly faster than calling both `width` and `height`
   * to obtain the window size.
   *
   * \return the size of the window.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto size() const noexcept -> iarea
  {
    iarea size{};
    SDL_GetWindowSize(m_window, &size.width, &size.height);
    return size;
  }

  /**
   * \brief Returns the minimum size of the window.
   *
   * \return the minimum size of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto min_size() const noexcept -> iarea
  {
    iarea size{};
    SDL_GetWindowMinimumSize(m_window, &size.width, &size.height);
    return size;
  }

  /**
   * \brief Returns the maximum size of the window.
   *
   * \return the maximum size of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto max_size() const noexcept -> iarea
  {
    iarea size{};
    SDL_GetWindowMaximumSize(m_window, &size.width, &size.height);
    return size;
  }

  /**
   * \brief Returns the default size of a window.
   *
   * \note This function is only available for owning windows.
   *
   * \return the default size of a window.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] constexpr static auto default_size() noexcept -> iarea
  {
    return {800, 600};
  }

  /// \} End of size functions

  /// \name Flag queries
  /// \{

  /**
   * \brief Returns a mask that represents the flags associated with the window.
   *
   * \details You can check the returned mask using the `SDL_WindowFlags` enum.
   *
   * \return a mask that represents the flags associated with the window.
   *
   * \see `SDL_WindowFlags`
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto flags() const noexcept -> u32
  {
    return SDL_GetWindowFlags(m_window);
  }

  /**
   * \brief Indicates whether or not a flag is set.
   *
   * \details Some of the use cases of this function can be replaced by more explicit
   * functions, e.g. `is_fullscreen()` instead of `check_flag(SDL_WINDOW_FULLSCREEN)`.
   *
   * \param flag the flag that will be tested.
   *
   * \return `true` if the flag is set; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto check_flag(const SDL_WindowFlags flag) const noexcept -> bool
  {
    return static_cast<bool>(flags() & flag);
  }

  /**
   * \brief Indicates whether or not a flag is set.
   *
   * \details Some of the use cases of this function can be replaced by more explicit
   * functions, e.g. `is_fullscreen()` instead of `check_flag(cen::window::fullscreen)`.
   *
   * \param flag the flag that will be tested.
   *
   * \return `true` if the flag is set; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto check_flag(const window_flags flag) const noexcept -> bool
  {
    return static_cast<bool>(flags() & flag);
  }

  /**
   * \brief Indicates whether or not the window has grabbed the input focus.
   *
   * \return `true` if the window has grabbed input focus; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto has_grabbed_input() const noexcept -> bool
  {
    return check_flag(input_grabbed);
  }

  /**
   * \brief Indicates whether or not the window has input focus.
   *
   * \note The window might have to be visible for this to be true.
   *
   * \return `true` if the window has input focus; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto has_input_focus() const noexcept -> bool
  {
    return check_flag(input_focus);
  }

  /**
   * \brief Indicates whether or not the window has mouse focus.
   *
   * \return `true` if the window has mouse focus; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto has_mouse_focus() const noexcept -> bool
  {
    return check_flag(mouse_focus);
  }

  /**
   * \brief Indicates whether or not the window is borderless.
   *
   * \note This check is the opposite of `is_decorated()`.
   *
   * \details Windows are not borderless by default.
   *
   * \return `true` if the window is borderless; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_borderless() const noexcept -> bool
  {
    return check_flag(borderless);
  }

  /**
   * \brief Indicates whether or not the window is decorated.
   *
   * \note This check is the opposite of `is_borderless()`.
   *
   * \details Windows are decorated by default.
   *
   * \return `true` if the window is decorated; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_decorated() const noexcept -> bool
  {
    return !is_borderless();
  }

  /**
   * \brief Indicates whether or not the window is resizable.
   *
   * \details By default, this property is set to false.
   *
   * \return `true` if the window is resizable; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_resizable() const noexcept -> bool
  {
    return check_flag(resizable);
  }

  /**
   * \brief Indicates whether or the window supports high-DPI mode.
   *
   * \return `true` if the window supports high-DPI mode; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_high_dpi() const noexcept -> bool
  {
    return check_flag(high_dpi);
  }

  /**
   * \brief Indicates whether or not the window is in fullscreen mode.
   *
   * \return `true` if the window is in fullscreen mode; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_fullscreen() const noexcept -> bool
  {
    return check_flag(fullscreen);
  }

  /**
   * \brief Indicates whether or not the window is in fullscreen desktop mode.
   *
   * \return `true` if the window is in fullscreen desktop mode; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_fullscreen_desktop() const noexcept -> bool
  {
    return check_flag(fullscreen_desktop);
  }

  /**
   * \brief Indicates whether or not the window is visible.
   *
   * \return `true` if the window is visible; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_visible() const noexcept -> bool
  {
    return check_flag(shown);
  }

  /**
   * \brief Indicates whether or not the window is hidden.
   *
   * \return `true` if the window isn't visible; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_hidden() const noexcept -> bool
  {
    return check_flag(hidden);
  }

  /**
   * \brief Indicates whether or not the window is usable with an OpenGL-context.
   *
   * \return `true` if the window is compatible with an OpenGL-context; false otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_opengl() const noexcept -> bool
  {
    return check_flag(opengl);
  }

  /**
   * \brief Indicates whether or not the window is usable as a Vulkan surface.
   *
   * \return `true` if the window is is usable as a Vulkan surface; false otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_vulkan() const noexcept -> bool
  {
    return check_flag(vulkan);
  }

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Indicates whether or not the window can be used as a Metal view.
   *
   * \return `true` if the window can be used as a Metal view; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_metal() const noexcept -> bool
  {
    return check_flag(metal);
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Indicates whether or not the window wasn't created by SDL.
   *
   * \return `true` if the window wasn't created by SDL; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_foreign() const noexcept -> bool
  {
    return check_flag(foreign);
  }

  /**
   * \brief Indicates whether or not the window is capturing the mouse.
   *
   * \return `true` if the window is capturing the mouse; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_capturing_mouse() const noexcept -> bool
  {
    return check_flag(mouse_capture);
  }

  /**
   * \brief Indicates whether or not the window is minimized.
   *
   * \return `true` if the window is minimized; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_minimized() const noexcept -> bool
  {
    return check_flag(minimized);
  }

  /**
   * \brief Indicates whether or not the window is maximized.
   *
   * \return `true` if the window is maximized; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_maximized() const noexcept -> bool
  {
    return check_flag(maximized);
  }

  /**
   * \brief Indicates whether or not the window is set to be always on top of other
   * windows.
   *
   * \return `true` if the window is always on top of other windows; false otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_always_on_top() const noexcept -> bool
  {
    return check_flag(always_on_top);
  }

  /**
   * \brief Indicates whether or not the window is a "utility" window.
   *
   * \return `true` if window is a "utility" window; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_utility() const noexcept -> bool
  {
    return check_flag(utility);
  }

  /**
   * \brief Indicates whether or not the window is a tooltip.
   *
   * \return `true` if the window is a tooltip; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_tooltip() const noexcept -> bool
  {
    return check_flag(tooltip);
  }

  /**
   * \brief Indicates whether or not the window is a popup menu.
   *
   * \return `true` if the window is a popup menu; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_popup_menu() const noexcept -> bool
  {
    return check_flag(popup_menu);
  }

  /**
   * \brief Indicates whether or not the window is excluded from the taskbar.
   *
   * \return `true` if the window is excluded from the taskbar; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_excluded_from_taskbar() const noexcept -> bool
  {
    return check_flag(skip_taskbar);
  }

  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] constexpr static auto default_flags() noexcept -> u32
  {
    return hidden;
  }

  /// \} End of flag queries

  /// \name Getters
  /// \{

  /**
   * \brief Returns a numerical ID of the window.
   *
   * \return a numerical ID of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto id() const noexcept -> u32
  {
    return SDL_GetWindowID(m_window);
  }

  /**
   * \brief Returns the display index associated with the window.
   *
   * \return the display index associated with the window; `std::nullopt` if the display
   * index cannot be obtained.
   *
   * \since 3.1.0
   */
  [[nodiscard]] auto display_index() const noexcept -> std::optional<int>
  {
    const auto index = SDL_GetWindowDisplayIndex(m_window);
    if (index != -1) {
      return index;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the title of the window.
   *
   * \return the title of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto title() const -> std::string
  {
    return SDL_GetWindowTitle(m_window);
  }

  /**
   * \brief Returns the current brightness value of the window.
   *
   * \details The default value of this property is 1.
   *
   * \return the current brightness of the window, in the range [0, 1].
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto brightness() const noexcept -> float
  {
    return SDL_GetWindowBrightness(m_window);
  }

  /**
   * \brief Returns the opacity of the window.
   *
   * \return the opacity of the window, in the range [0, 1].
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto opacity() const noexcept -> float
  {
    float opacity{1};
    SDL_GetWindowOpacity(m_window, &opacity);
    return opacity;
  }

  /**
   * \brief Returns the pixel format of the window.
   *
   * \return the pixel format used by the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto get_pixel_format() const noexcept -> pixel_format
  {
    return static_cast<pixel_format>(SDL_GetWindowPixelFormat(m_window));
  }

  /**
   * \brief Returns a handle to the window framebuffer surface.
   *
   * \warning It is not possible use the framebuffer surface with the 3D or 2D rendering
   * APIs.
   *
   * \return a handle to the window surface, might not contain a valid surface pointer.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get_surface() noexcept -> surface_handle
  {
    return surface_handle{SDL_GetWindowSurface(m_window)};
  }

  /**
   * \brief Indicates whether or not the window is currently grabbing the mouse input.
   *
   * \return `true` if the window is grabbing the mouse; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto grabbing_mouse() const noexcept -> bool
  {
    return SDL_GetWindowGrab(m_window);
  }

  /**
   * \brief Indicates whether or not the screen keyboard is shown for the window.
   *
   * \return `true` if the screen keyboard is shown for the window; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_screen_keyboard_shown() const noexcept -> bool
  {
    return SDL_IsScreenKeyboardShown(get()) == SDL_TRUE;
  }

  /**
   * \brief Returns a pointer to the associated SDL window.
   *
   * \warning Don't take ownership of the returned pointer!
   *
   * \return a pointer to the associated SDL window.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_Window*
  {
    return m_window.get();
  }

  /// \} End of getters

  /// \name Conversions
  /// \{

  /**
   * \brief Converts to `SDL_Window*`.
   *
   * \return a pointer to the associated SDL window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit operator SDL_Window*() noexcept
  {
    return m_window.get();
  }

  /**
   * \brief Converts to `const SDL_Window*`.
   *
   * \return a pointer to the associated SDL window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit operator const SDL_Window*() const noexcept
  {
    return m_window.get();
  }

  /**
   * \brief Indicates whether or not the handle holds a non-null pointer.
   *
   * \note This function is only available for window handles.
   *
   * \warning It's undefined behaviour to invoke other member functions that use the
   * internal pointer if this function returns `false`.
   *
   * \return `true` if the handle holds a non-null pointer; `false` otherwise.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit operator bool() const noexcept
  {
    return m_window != nullptr;
  }

  /// \} End of conversions

 private:
  struct deleter final
  {
    void operator()(SDL_Window* window) noexcept
    {
      SDL_DestroyWindow(window);
    }
  };
  detail::pointer_manager<T, SDL_Window, deleter> m_window;
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a window.
 *
 * \param window the window that will be converted.
 *
 * \return a textual representation of the window.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_window<T>& window) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("window{{data: {}, width: {}, height: {}}}",
                     detail::address_of(window.get()),
                     window.width(),
                     window.height());
#else
  return "window{data: " + detail::address_of(window.get()) +
         ", width: " + std::to_string(window.width()) +
         ", height: " + std::to_string(window.height()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a window.
 *
 * \param stream the stream that will be used.
 * \param window the window that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_window<T>& window) -> std::ostream&
{
  return stream << to_string(window);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_WINDOW_HEADER


namespace cen::gl {

/// \addtogroup video
/// \{

template <typename T>
class basic_context;

///< An owning OpenGL context.
using context = basic_context<detail::owning_type>;

///< A non-owning OpenGL context.
using context_handle = basic_context<detail::handle_type>;

/**
 * \class basic_context
 *
 * \brief Represents an OpenGL context.
 *
 * \ownerhandle `context`/`context_handle`
 *
 * \since 6.0.0
 */
template <typename T>
class basic_context final
{
 public:
  /// \name Construction
  /// \{

  // clang-format off

  /**
   * \brief Creates a context instance from an existing OpenGL context.
   *
   * \param context the existing OpenGL context.
   *
   * \throws cen_error if the context is owning and the supplied pointer is null.
   *
   * \since 6.0.0
   */
  explicit basic_context(maybe_owner<SDL_GLContext> context) noexcept(!detail::is_owning<T>())
      : m_context{context}
  {
    if constexpr (detail::is_owning<T>())
    {
      if (!m_context)
      {
        throw cen_error{"Can't create OpenGL context from null pointer!"};
      }
    }
  }

  // clang-format on

  /**
   * \brief Creates an OpenGL context based on the supplied window.
   *
   * \tparam U the ownership semantics of the window.
   *
   * \param window the OpenGL window.
   *
   * \throws sdl_error if the context has owning semantics and the OpenGL context couldn't
   * be initialized.
   *
   * \since 6.0.0
   */
  template <typename U>
  explicit basic_context(basic_window<U>& window) noexcept(!detail::is_owning<T>())
      : m_context{SDL_GL_CreateContext(window.get())}
  {
    if constexpr (detail::is_owning<T>()) {
      if (!m_context) {
        throw sdl_error{};
      }
    }
  }

  /// \} End of construction

  /**
   * \brief Makes the context the current OpenGL context for an OpenGL window.
   *
   * \pre `window` must be an OpenGL window.
   *
   * \tparam U the ownership semantics of the window.
   *
   * \param window the OpenGL window.
   *
   * \return `success` if the was operation was successful; `failure` otherwise.
   *
   * \since 6.0.0
   */
  template <typename U>
  auto make_current(basic_window<U>& window) -> result
  {
    assert(window.is_opengl());
    return SDL_GL_MakeCurrent(window.get(), m_context.get()) == 0;
  }

  /**
   * \brief Returns the associated OpenGL context.
   *
   * \return the handle to the associated OpenGL context.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_GLContext
  {
    return m_context.get();
  }

 private:
  struct deleter final
  {
    void operator()(SDL_GLContext context) noexcept
    {
      SDL_GL_DeleteContext(context);
    }
  };

  std::unique_ptr<void, deleter> m_context;
};

/// \} End of group video

}  // namespace cen::gl

namespace cen {

/// \addtogroup video
/// \{

/// Workaround for slight inconsistency where other OpenGL components feature "gl_"-prefix
using gl_context = gl::context;
using gl_context_handle = gl::context_handle;

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_NO_OPENGL
#endif  // CENTURION_GL_CONTEXT_HEADER

// #include "centurion/video/opengl/gl_core.hpp"
#ifndef CENTURION_GL_CORE_HEADER
#define CENTURION_GL_CORE_HEADER

#ifndef CENTURION_NO_OPENGL

#include <SDL.h>

#include <cassert>      // assert
#include <optional>     // optional
#include <ostream>      // ostream
#include <string>       // string
#include <string_view>  // string_view

// #include "../../core/exception.hpp"

// #include "../../core/not_null.hpp"
#ifndef CENTURION_NOT_NULL_HEADER
#define CENTURION_NOT_NULL_HEADER

// #include "sfinae.hpp"


namespace cen {

/**
 * \typedef not_null
 *
 * \ingroup core
 *
 * \brief Tag used to indicate that a pointer cannot be null.
 *
 * \note This alias is equivalent to `T`, it is a no-op.
 *
 * \since 5.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using not_null = T;

}  // namespace cen

#endif  // CENTURION_NOT_NULL_HEADER

// #include "../../core/result.hpp"

// #include "../../core/str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER

// #include "../../core/to_underlying.hpp"
#ifndef CENTURION_TO_UNDERLYING_HEADER
#define CENTURION_TO_UNDERLYING_HEADER

#include <type_traits>  // underlying_type_t, enable_if_t, is_enum_v

namespace cen {

/**
 * \brief Converts an enum value to an integral value using the underlying type.
 *
 * \ingroup core
 *
 * \note If you're using C++23, see `std::to_underlying()`.
 *
 * \tparam Enum the enum type.
 *
 * \param value the enum value that will be converted.
 *
 * \return the value of the enum, in the underlying type.
 *
 * \since 6.0.0
 */
template <typename Enum, std::enable_if_t<std::is_enum_v<Enum>, int> = 0>
[[nodiscard]] constexpr auto to_underlying(const Enum value) noexcept
    -> std::underlying_type_t<Enum>
{
  return static_cast<std::underlying_type_t<Enum>>(value);
}

}  // namespace cen

#endif  // CENTURION_TO_UNDERLYING_HEADER

// #include "../../math/area.hpp"
#ifndef CENTURION_AREA_HEADER
#define CENTURION_AREA_HEADER

#include <ostream>      // ostream
#include <string>       // string, to_string
#include <type_traits>  // is_integral_v, is_floating_point_v, is_same_v

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/cast.hpp"
#ifndef CENTURION_CAST_HEADER
#define CENTURION_CAST_HEADER

namespace cen {

/**
 * \brief Casts a value to a value of another type.
 *
 * \ingroup core
 *
 * \details This is the default implementation, which simply attempts to use
 * `static_cast`. The idea is that this function will be specialized for various Centurion
 * and SDL types. This is useful because it isn't always possible to implement conversion
 * operators as members.
 *
 * \tparam To the type of the value that will be converted.
 * \tparam From the type that the value will be casted to.
 *
 * \param from the value that will be converted.
 *
 * \return the result of casting the supplied value to the specified type.
 *
 * \since 5.0.0
 */
template <typename To, typename From>
[[nodiscard]] constexpr auto cast(const From& from) noexcept -> To
{
  return static_cast<To>(from);
}

}  // namespace cen

#endif  // CENTURION_CAST_HEADER


namespace cen {

/// \addtogroup math
/// \{

template <typename T>
struct basic_area;

/**
 * \typedef iarea
 *
 * \brief An alias for `int` areas.
 *
 * \since 4.1.0
 */
using iarea = basic_area<int>;

/**
 * \typedef farea
 *
 * \brief An alias for `float` areas.
 *
 * \since 4.1.0
 */
using farea = basic_area<float>;

/**
 * \typedef darea
 *
 * \brief An alias for `double` areas.
 *
 * \since 4.1.0
 */
using darea = basic_area<double>;

/**
 * \struct basic_area
 *
 * \brief Simply represents an area with a width and height.
 *
 * \serializable
 *
 * \tparam T the type of the components of the area. Must be either an integral or
 * floating-point type. Can't be `bool`.
 *
 * \since 4.0.0
 *
 * \see `iarea`
 * \see `farea`
 * \see `darea`
 */
template <typename T>
struct basic_area final
{
  static_assert(std::is_integral_v<T> || std::is_floating_point_v<T>);
  static_assert(!std::is_same_v<T, bool>);

  using value_type = T;

  T width{0};   ///< The width of the area.
  T height{0};  ///< The height of the area.

#if CENTURION_HAS_FEATURE_SPACESHIP

  [[nodiscard]] constexpr auto operator==(const basic_area&) const noexcept -> bool = default;

#endif  // CENTURION_HAS_FEATURE_SPACESHIP
};

/// \name Area-related functions
/// \{

/**
 * \brief Creates an area instance with automatically deduced precision.
 *
 * \tparam T the deduced type of the width and height values.
 *
 * \param width the width of the area.
 * \param height the height of the area.
 *
 * \return an area instance with the specified width and height.
 *
 * \since 6.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto area(const T width, const T height) noexcept -> basic_area<T>
{
  return {width, height};
}

/**
 * \brief Returns the size (width x height) of an area.
 *
 * \tparam T the representation type.
 *
 * \param area the area instance that will be calculated.
 *
 * \return the size of the area.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto area_of(const basic_area<T> area) noexcept -> T
{
  return area.width * area.height;
}

/// \} End of area-related functions

/**
 * \brief Serializes an area instance.
 *
 * \details This function expects that the archive provides an overloaded `operator()`,
 * used for serializing data. This API is based on the Cereal serialization library.
 *
 * \tparam Archive the type of the archive.
 * \tparam T the type of the area components.
 *
 * \param archive the archive used to serialize the area.
 * \param area the area that will be serialized.
 *
 * \since 5.3.0
 */
template <typename Archive, typename T>
void serialize(Archive& archive, basic_area<T>& area)
{
  archive(area.width, area.height);
}

/// \name Area cast specializations
/// \{

template <>
[[nodiscard]] constexpr auto cast(const iarea& from) noexcept -> darea
{
  return {static_cast<double>(from.width), static_cast<double>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const iarea& from) noexcept -> farea
{
  return {static_cast<float>(from.width), static_cast<float>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const farea& from) noexcept -> darea
{
  return {static_cast<double>(from.width), static_cast<double>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const farea& from) noexcept -> iarea
{
  return {static_cast<int>(from.width), static_cast<int>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const darea& from) noexcept -> farea
{
  return {static_cast<float>(from.width), static_cast<float>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const darea& from) noexcept -> iarea
{
  return {static_cast<int>(from.width), static_cast<int>(from.height)};
}

/// \} End of area cast specializations

/// \name Area comparison operators
/// \{

#if !CENTURION_HAS_FEATURE_SPACESHIP

/**
 * \brief Indicates whether or not two areas are considered to be equal.
 *
 * \param lhs the left-hand side area.
 * \param rhs the right-hand side area.
 *
 * \return `true` if the areas are equal; `false` otherwise.
 *
 * \since 4.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator==(const basic_area<T>& lhs,
                                        const basic_area<T>& rhs) noexcept -> bool
{
  return (lhs.width == rhs.width) && (lhs.height == rhs.height);
}

/**
 * \brief Indicates whether or not two areas aren't considered to be equal.
 *
 * \param lhs the left-hand side area.
 * \param rhs the right-hand side area.
 *
 * \return `true` if the areas aren't equal; `false` otherwise.
 *
 * \since 4.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator!=(const basic_area<T>& lhs,
                                        const basic_area<T>& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

#endif  // CENTURION_HAS_FEATURE_SPACESHIP

/// \} End of area comparison operators

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of an area.
 *
 * \tparam T the type of the area components.
 *
 * \param area the area that will be converted.
 *
 * \return a string that represents the area.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_area<T>& area) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("area{{width: {}, height: {}}}", area.width, area.height);
#else
  return "area{width: " + std::to_string(area.width) +
         ", height: " + std::to_string(area.height) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of an area using a stream.
 *
 * \tparam T the type of the area components.
 *
 * \param stream the stream that will be used.
 * \param area the are that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_area<T>& area) -> std::ostream&
{
  return stream << to_string(area);
}

/// \} End of streaming

/// \} End of group math

}  // namespace cen

#endif  // CENTURION_AREA_HEADER
// #include "../texture.hpp"
#ifndef CENTURION_TEXTURE_HEADER
#define CENTURION_TEXTURE_HEADER

#include <SDL.h>

// #include "../compiler/features.hpp"


#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#include <cassert>  // assert
#include <ostream>  // ostream
#include <string>   // string, to_string

#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/not_null.hpp"

// #include "../core/owner.hpp"

// #include "../core/result.hpp"

// #include "../core/str.hpp"

// #include "../detail/address_of.hpp"

// #include "../detail/owner_handle_api.hpp"

// #include "../math/area.hpp"

// #include "../math/point.hpp"
#ifndef CENTURION_POINT_HEADER
#define CENTURION_POINT_HEADER

#include <SDL.h>

#include <cmath>        // sqrt, abs, round
#include <ostream>      // ostream
#include <string>       // string, to_string
#include <type_traits>  // conditional_t, is_integral_v, is_floating_point_v, ...

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/cast.hpp"

// #include "../core/sfinae.hpp"


namespace cen {

/// \addtogroup math
/// \{

/**
 * \brief Provides traits used by the `basic_point` class.
 *
 * \tparam T the representation type. Must be convertible to `int` or `float`.
 *
 * \since 5.0.0
 *
 * \see `basic_point`
 * \see `ipoint`
 * \see `fpoint`
 */
template <typename T, enable_if_convertible_t<T, int, float> = 0>
class point_traits final
{
 public:
  /**
   * \var isIntegral
   *
   * \brief Indicates whether or not the point is based on an integral type.
   *
   * \since 5.0.0
   */
  inline constexpr static bool isIntegral = std::is_integral_v<T>;

  /**
   * \var isFloating
   *
   * \brief Indicates whether or not the point is based on a floating-point
   * type.
   *
   * \since 5.0.0
   */
  inline constexpr static bool isFloating = std::is_floating_point_v<T>;

  /**
   * \typedef value_type
   *
   * \brief The actual representation type, i.e. `int` or `float`.
   *
   * \since 5.0.0
   */
  using value_type = std::conditional_t<isIntegral, int, float>;

  /**
   * \typedef point_type
   *
   * \brief The SDL point type, i.e. `SDL_Point` or `SDL_FPoint`.
   *
   * \since 5.0.0
   */
  using point_type = std::conditional_t<isIntegral, SDL_Point, SDL_FPoint>;
};

template <typename T>
class basic_point;

/**
 * \typedef ipoint
 *
 * \brief Alias for an `int`-based point.
 *
 * \details This type corresponds to `SDL_Point`.
 *
 * \since 5.0.0
 */
using ipoint = basic_point<int>;

/**
 * \typedef fpoint
 *
 * \brief Alias for a `float`-based point.
 *
 * \details This type corresponds to `SDL_FPoint`.
 *
 * \since 5.0.0
 */
using fpoint = basic_point<float>;

/**
 * \class basic_point
 *
 * \brief Represents a two-dimensional point.
 *
 * \serializable
 *
 * \details This class is designed as a wrapper for `SDL_Point` and `SDL_FPoint`. The
 * representation is specified by the type parameter.
 *
 * \note This point class will only use `int` or `float` as the actual internal
 * representation.
 *
 * \tparam T the representation type. Must be convertible to `int` or `float`.
 *
 * \since 5.0.0
 *
 * \see `ipoint`
 * \see `fpoint`
 * \see `point()`
 * \see `distance()`
 */
template <typename T>
class basic_point final
{
 public:
  /// \copydoc point_traits::isIntegral
  inline constexpr static bool isIntegral = point_traits<T>::isIntegral;

  /// \copydoc point_traits::isFloating
  inline constexpr static bool isFloating = point_traits<T>::isFloating;

  /// \copydoc point_traits::value_type
  using value_type = typename point_traits<T>::value_type;

  /// \copydoc point_traits::point_type
  using point_type = typename point_traits<T>::point_type;

  /// \name Construction
  /// \{

  /**
   * \brief Creates a zero-initialized point.
   *
   * \since 5.0.0
   */
  constexpr basic_point() noexcept = default;

  /**
   * \brief Creates a point with the specified coordinates.
   *
   * \param x the x-coordinate that will be used.
   * \param y the y-coordinate that will be used.
   *
   * \since 5.0.0
   */
  constexpr basic_point(const value_type x, const value_type y) noexcept
  {
    m_point.x = x;
    m_point.y = y;
  };

  /// \} End of construction

  /// \name Setters
  /// \{

  /**
   * \brief Sets the x-coordinate of the point.
   *
   * \param x the new x-coordinate.
   *
   * \since 5.0.0
   */
  constexpr void set_x(const value_type x) noexcept
  {
    m_point.x = x;
  }

  /**
   * \brief Sets the y-coordinate of the point.
   *
   * \param y the new y-coordinate.
   *
   * \since 5.0.0
   */
  constexpr void set_y(const value_type y) noexcept
  {
    m_point.y = y;
  }

  /// \} End of setters

  /// \name Getters
  /// \{

  /**
   * \brief Returns the x-coordinate of the point.
   *
   * \return the x-coordinate.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto x() const noexcept -> value_type
  {
    return m_point.x;
  }

  /**
   * \brief Returns the y-coordinate of the point.
   *
   * \return the y-coordinate.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto y() const noexcept -> value_type
  {
    return m_point.y;
  }

  /**
   * \brief Returns the internal point representation.
   *
   * \return a reference to the internal representation.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto get() noexcept -> point_type&
  {
    return m_point;
  }

  /// \copydoc get
  [[nodiscard]] constexpr auto get() const noexcept -> const point_type&
  {
    return m_point;
  }

  /**
   * \brief Returns a pointer to the internal point representation.
   *
   * \note Don't cache the returned pointer.
   *
   * \return a pointer to the point representation.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto data() noexcept -> point_type*
  {
    return &m_point;
  }

  /// \copydoc data
  [[nodiscard]] auto data() const noexcept -> const point_type*
  {
    return &m_point;
  }

  /// \} End of getters

  /// \name Conversions
  /// \{

  /**
   * \brief Converts to the internal representation.
   *
   * \return a copy of the internal point.
   *
   * \see `cen::cast`
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr explicit operator point_type() const noexcept
  {
    return m_point;
  }

  /// \copydoc data()
  [[nodiscard]] explicit operator point_type*() noexcept
  {
    return data();
  }

  /// \copydoc data()
  [[nodiscard]] explicit operator const point_type*() const noexcept
  {
    return data();
  }

  /// \} End of conversions

  /**
   * \brief Serializes the point.
   *
   * \details This function expects that the archive provides an overloaded `operator()`,
   * used for serializing data. This API is based on the Cereal serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the point.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_point.x, m_point.y);
  }

 private:
  point_type m_point{0, 0};
};

/// \name Point-related functions
/// \{

/**
 * \brief Creates a point instance with automatically deduced precision.
 *
 * \note The only supported precisions for points are `int` and `float`, so this function
 * will cast the supplied values to the corresponding type. For example, if you supply two
 * doubles to this function, the returned point will use float as the precision.
 *
 * \tparam T the deduced precision type, must be a numerical type other than `bool`.
 *
 * \param x the x-coordinate of the point.
 * \param y the y-coordinate of the point.
 *
 * \return the created point.
 *
 * \since 6.0.0
 */
template <typename T, enable_if_number_t<T> = 0>
[[nodiscard]] constexpr auto point(const T x, const T y) noexcept
    -> basic_point<typename point_traits<T>::value_type>
{
  using value_type = typename point_traits<T>::value_type;
  return basic_point<value_type>{static_cast<value_type>(x), static_cast<value_type>(y)};
}

/**
 * \brief Returns the distance between two points.
 *
 * \tparam T the representation type used by the points.
 *
 * \param from the first point.
 * \param to the second point.
 *
 * \return the distance between the two points.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto distance(const basic_point<T> from, const basic_point<T> to) noexcept ->
    typename point_traits<T>::value_type
{
  if constexpr (basic_point<T>::isIntegral) {
    const auto xDiff = std::pow(from.x() - to.x(), 2);
    const auto yDiff = std::pow(from.y() - to.y(), 2);
    const auto dist = std::sqrt(xDiff + yDiff);
    return static_cast<int>(std::round(dist));
  }
  else {
    return std::sqrt(std::pow(from.x() - to.x(), 2) + std::pow(from.y() - to.y(), 2));
  }
}

/// \} End of point-related functions

/// \name String conversions
/// \{

[[nodiscard]] inline auto to_string(const ipoint point) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("ipoint{{x: {}, y: {}}}", point.x(), point.y());
#else
  return "ipoint{x: " + std::to_string(point.x()) + ", y: " + std::to_string(point.y()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

[[nodiscard]] inline auto to_string(const fpoint point) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("fpoint{{x: {}, y: {}}}", point.x(), point.y());
#else
  return "fpoint{x: " + std::to_string(point.x()) + ", y: " + std::to_string(point.y()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

template <typename T>
auto operator<<(std::ostream& stream, const basic_point<T>& point) -> std::ostream&
{
  return stream << to_string(point);
}

/// \} End of streaming

/// \name Point cast specializations
/// \{

/**
 * \brief Converts an `fpoint` instance to the corresponding `ipoint`.
 *
 * \details This function casts the coordinates of the supplied point to `int`, and uses
 * the obtained values to create an `ipoint` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `ipoint` instance that corresponds to the supplied `fpoint`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const fpoint& from) noexcept -> ipoint
{
  const auto x = static_cast<int>(from.x());
  const auto y = static_cast<int>(from.y());
  return ipoint{x, y};
}

/**
 * \brief Converts an `ipoint` instance to the corresponding `fpoint`.
 *
 * \details This function casts the coordinates of the supplied point to `float`, and uses
 * the obtained values to create an `fpoint` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `fpoint` instance that corresponds to the supplied `ipoint`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const ipoint& from) noexcept -> fpoint
{
  const auto x = static_cast<float>(from.x());
  const auto y = static_cast<float>(from.y());
  return fpoint{x, y};
}

/**
 * \brief Converts an `SDL_FPoint` instance to the corresponding `SDL_Point`.
 *
 * \details This function casts the coordinates of the supplied point to `int`, and uses
 * the obtained values to create an `SDL_Point` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `SDL_Point` instance that corresponds to the supplied `SDL_FPoint`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const SDL_FPoint& from) noexcept -> SDL_Point
{
  const auto x = static_cast<int>(from.x);
  const auto y = static_cast<int>(from.y);
  return SDL_Point{x, y};
}

/**
 * \brief Converts an `SDL_Point` instance to the corresponding `SDL_FPoint`.
 *
 * \details This function casts the coordinates of the supplied point to `float`, and uses
 * the obtained values to create an `SDL_FPoint` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `SDL_FPoint` instance that corresponds to the supplied `SDL_Point`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const SDL_Point& from) noexcept -> SDL_FPoint
{
  const auto x = static_cast<float>(from.x);
  const auto y = static_cast<float>(from.y);
  return SDL_FPoint{x, y};
}

/// \} End of point cast specializations

/// \name Point addition and subtraction operators
/// \{

template <typename T>
[[nodiscard]] constexpr auto operator+(const basic_point<T>& lhs,
                                       const basic_point<T>& rhs) noexcept -> basic_point<T>
{
  return {lhs.x() + rhs.x(), lhs.y() + rhs.y()};
}

template <typename T>
[[nodiscard]] constexpr auto operator-(const basic_point<T>& lhs,
                                       const basic_point<T>& rhs) noexcept -> basic_point<T>
{
  return {lhs.x() - rhs.x(), lhs.y() - rhs.y()};
}

/// \} End of point addition and subtraction operators

/// \name Point comparison operators
/// \{

template <typename T>
[[nodiscard]] constexpr auto operator==(const basic_point<T> lhs,
                                        const basic_point<T> rhs) noexcept -> bool
{
  return (lhs.x() == rhs.x()) && (lhs.y() == rhs.y());
}

template <typename T>
[[nodiscard]] constexpr auto operator!=(const basic_point<T> lhs,
                                        const basic_point<T> rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of point comparison operators

/// \} End of group math

}  // namespace cen

#endif  // CENTURION_POINT_HEADER
// #include "blend_mode.hpp"

// #include "color.hpp"

// #include "pixel_format_info.hpp"

// #include "scale_mode.hpp"
#ifndef CENTURION_SCALE_MODE_HEADER
#define CENTURION_SCALE_MODE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup video
/// \{

#if SDL_VERSION_ATLEAST(2, 0, 12)

/**
 * \enum scale_mode
 *
 * \brief Represents different texture scale modes.
 *
 * \since 4.0.0
 *
 * \see `SDL_ScaleMode`
 */
enum class scale_mode
{
  nearest = SDL_ScaleModeNearest,  ///< Represents nearest pixel sampling.
  linear = SDL_ScaleModeLinear,    ///< Represents linear filtering.
  best = SDL_ScaleModeBest         ///< Represents anisotropic filtering.
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied scale mode.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(scale_mode::linear) == "linear"`.
 *
 * \param mode the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const scale_mode mode) -> std::string_view
{
  switch (mode) {
    case scale_mode::nearest:
      return "nearest";

    case scale_mode::linear:
      return "linear";

    case scale_mode::best:
      return "best";

    default:
      throw cen_error{"Did not recognize scale mode!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a scale mode enumerator.
 *
 * \param stream the output stream that will be used.
 * \param mode the enumerator that will be printed.
 *
 * \see `to_string(scale_mode)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const scale_mode mode) -> std::ostream&
{
  return stream << to_string(mode);
}

/// \} End of streaming

/// \name Scale mode comparison operators
/// \{

/**
 * \brief Indicates whether or not the two scale mode values are the same.
 *
 * \param lhs the lhs scale mode value.
 * \param rhs the rhs scale mode value.
 *
 * \return `true` if the scale mode values are the same; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator==(const scale_mode lhs, const SDL_ScaleMode rhs) noexcept
    -> bool
{
  return static_cast<SDL_ScaleMode>(lhs) == rhs;
}

/// \copydoc operator==(scale_mode, SDL_ScaleMode)
[[nodiscard]] constexpr auto operator==(const SDL_ScaleMode lhs, const scale_mode rhs) noexcept
    -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the two scale mode values aren't the same.
 *
 * \param lhs the lhs scale mode value.
 * \param rhs the rhs scale mode value.
 *
 * \return `true` if the scale mode values aren't the same; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator!=(const scale_mode lhs, const SDL_ScaleMode rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(scale_mode, SDL_ScaleMode)
[[nodiscard]] constexpr auto operator!=(const SDL_ScaleMode lhs, const scale_mode rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \} End of scale mode comparison operators

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_SCALE_MODE_HEADER

// #include "surface.hpp"

// #include "texture_access.hpp"
#ifndef CENTURION_TEXTURE_ACCESS_HEADER
#define CENTURION_TEXTURE_ACCESS_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum texture_access
 *
 * \brief Represents different texture access modes.
 *
 * \note The `no_lock` enumerator is also referred to as "static" texture access.
 *
 * \since 3.0.0
 *
 * \see `SDL_TextureAccess`
 */
enum class texture_access : int
{
  // clang-format off
  no_lock = SDL_TEXTUREACCESS_STATIC,       ///< Texture changes rarely and isn't lockable.
  streaming = SDL_TEXTUREACCESS_STREAMING,  ///< Texture changes frequently and is lockable.
  target = SDL_TEXTUREACCESS_TARGET         ///< Texture can be used as a render target.
  // clang-format on
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied texture access.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(texture_access::streaming) == "streaming"`.
 *
 * \param access the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const texture_access access) -> std::string_view
{
  switch (access) {
    case texture_access::no_lock:
      return "no_lock";

    case texture_access::streaming:
      return "streaming";

    case texture_access::target:
      return "target";

    default:
      throw cen_error{"Did not recognize texture access!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a texture access enumerator.
 *
 * \param stream the output stream that will be used.
 * \param access the enumerator that will be printed.
 *
 * \see `to_string(texture_access)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const texture_access access) -> std::ostream&
{
  return stream << to_string(access);
}

/// \} End of streaming

/// \name Texture access comparison operators
/// \{

/**
 * \brief Indicates whether or not the two texture access values are the same.
 *
 * \param lhs the lhs texture access value.
 * \param rhs the rhs texture access value.
 *
 * \return `true` if the texture access values are the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const texture_access lhs,
                                        const SDL_TextureAccess rhs) noexcept -> bool
{
  return static_cast<SDL_TextureAccess>(lhs) == rhs;
}

/// \copydoc operator==(texture_access, SDL_TextureAccess)
[[nodiscard]] constexpr auto operator==(const SDL_TextureAccess lhs,
                                        const texture_access rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the two texture access values aren't the same.
 *
 * \param lhs the lhs texture access value.
 * \param rhs the rhs texture access value.
 *
 * \return `true` if the texture access values aren't the same; `false`
 * otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator!=(const texture_access lhs,
                                        const SDL_TextureAccess rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(texture_access, SDL_TextureAccess)
[[nodiscard]] constexpr auto operator!=(const SDL_TextureAccess lhs,
                                        const texture_access rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of texture access comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_TEXTURE_ACCESS_HEADER


namespace cen {

/// \addtogroup video
/// \{

template <typename T>
class basic_texture;

using texture = basic_texture<detail::owning_type>;
using texture_handle = basic_texture<detail::handle_type>;

/**
 * \class basic_texture
 *
 * \brief Represents an hardware-accelerated image, intended to be rendered using the
 * `basic_renderer` class.
 *
 * \ownerhandle `texture`/`texture_handle`
 *
 * \since 3.0.0
 *
 * \see `texture`
 * \see `texture_handle`
 */
template <typename T>
class basic_texture final
{
 public:
  /// \name Construction
  /// \{

  // clang-format off

  /**
   * \brief Creates an texture from a pre-existing SDL texture.
   *
   * \param source a pointer to the associated SDL texture.
   *
   * \throws cen_error if the supplied pointer is null *and* the texture is owning.
   *
   * \since 3.0.0
   */
  explicit basic_texture(maybe_owner<SDL_Texture*> source) noexcept(!detail::is_owning<T>())
      : m_texture{source}
  {
    if constexpr (detail::is_owning<T>())
    {
      if (!m_texture)
      {
        throw cen_error{"Cannot create texture from null pointer!"};
      }
    }
  }

  // clang-format on

  /**
   * \brief Creates a handle to texture instance.
   *
   * \param owner the associated owning texture.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit basic_texture(texture& owner) noexcept : m_texture{owner.get()}
  {}

#ifndef CENTURION_NO_SDL_IMAGE

  /**
   * \brief Creates a texture based the image at the specified path.
   *
   * \tparam Renderer the type of the renderer, e.g. `renderer` or `renderer_handle`.
   *
   * \param renderer the renderer that will be used to create the texture.
   * \param path the file path of the texture, can't be null.
   *
   * \throws img_error if the texture cannot be loaded.
   *
   * \since 4.0.0
   */
  template <typename Renderer, typename TT = T, detail::is_owner<TT> = 0>
  basic_texture(const Renderer& renderer, const not_null<str> path)
      : m_texture{IMG_LoadTexture(renderer.get(), path)}
  {
    if (!m_texture) {
      throw img_error{};
    }
  }

  /**
   * \brief Creates a texture based the image at the specified path.
   *
   * \tparam Renderer the type of the renderer, e.g. `renderer` or `renderer_handle`.
   *
   * \param renderer the renderer that will be used to create the texture.
   * \param path the file path of the texture.
   *
   * \throws img_error if the texture cannot be loaded.
   *
   * \since 5.3.0
   */
  template <typename Renderer, typename TT = T, detail::is_owner<TT> = 0>
  basic_texture(const Renderer& renderer, const std::string& path)
      : basic_texture{renderer, path.c_str()}
  {}

#endif  // CENTURION_NO_SDL_IMAGE

  /**
   * \brief Creates an texture that is a copy of the supplied surface.
   *
   * \tparam Renderer the type of the renderer, e.g. `renderer` or `renderer_handle`.
   *
   * \param renderer the renderer that will be used to create the texture.
   * \param surface the surface that the texture will be based on.
   *
   * \throws sdl_error if the texture cannot be loaded.
   *
   * \since 4.0.0
   */
  template <typename Renderer, typename TT = T, detail::is_owner<TT> = 0>
  basic_texture(const Renderer& renderer, const surface& surface)
      : m_texture{SDL_CreateTextureFromSurface(renderer.get(), surface.get())}
  {
    if (!m_texture) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates an texture with the specified characteristics.
   *
   * \tparam Renderer the type of the renderer, e.g. `renderer` or `renderer_handle`.
   *
   * \param renderer the associated renderer instance.
   * \param format the pixel format of the created texture.
   * \param access the access of the created texture.
   * \param size the size of the texture.
   *
   * \throws sdl_error if the texture cannot be created.
   *
   * \since 4.0.0
   */
  template <typename Renderer, typename TT = T, detail::is_owner<TT> = 0>
  basic_texture(const Renderer& renderer,
                const pixel_format format,
                const texture_access access,
                const iarea size)
      : m_texture{SDL_CreateTexture(renderer.get(),
                                    to_underlying(format),
                                    to_underlying(access),
                                    size.width,
                                    size.height)}
  {
    if (!m_texture) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates and returns a texture with streaming access.
   *
   * \details The created texture is based on the image at the specified path with the
   * `streaming` texture access.
   *
   * \tparam Renderer the type of the renderer, e.g. `renderer` or `renderer_handle`.
   *
   * \param renderer the renderer that will be used to create the texture.
   * \param path the path of the image file to base the texture on, can't be null.
   * \param format the pixel format that will be used by the texture.
   *
   * \throws cen_error if something goes wrong.
   *
   * \return a texture with `streaming` texture access.
   *
   * \since 4.0.0
   */
  template <typename Renderer, typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto streaming(const Renderer& renderer,
                                      const not_null<str> path,
                                      const pixel_format format) -> basic_texture
  {
    assert(path);

    constexpr auto blendMode = blend_mode::blend;
    const auto surface = cen::surface::with_format(path, blendMode, format);

    basic_texture texture{renderer, format, texture_access::streaming, surface.size()};
    texture.set_blend_mode(blendMode);

    u32* pixels{};
    if (!texture.lock(&pixels)) {
      throw sdl_error{};
    }

    const auto maxCount =
        static_cast<usize>(surface.pitch()) * static_cast<usize>(surface.height());
    SDL_memcpy(pixels, surface.pixels(), maxCount);

    texture.unlock();

    return texture;
  }

  /**
   * \see streaming()
   * \since 5.3.0
   */
  template <typename Renderer, typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto streaming(const Renderer& renderer,
                                      const std::string& path,
                                      const pixel_format format) -> basic_texture
  {
    return streaming(renderer, path.c_str(), format);
  }

  /// \} End of construction

  /// \name Setters
  /// \{

  /**
   * \brief Sets the color of the pixel at the specified coordinate.
   *
   * \details This function has no effect if the texture access isn't `streaming` or if
   * the coordinate is out-of-bounds.
   *
   * \param pixel the pixel that will be changed.
   * \param color the new color of the pixel.
   *
   * \since 4.0.0
   */
  void set_pixel(const ipoint pixel, const color& color)
  {
    if (access() != texture_access::streaming || (pixel.x() < 0) || (pixel.y() < 0) ||
        (pixel.x() >= width()) || (pixel.y() >= height()))
    {
      return;
    }

    u32* pixels{};
    int pitch{};
    if (!lock(&pixels, &pitch)) {
      return;
    }

    const int nPixels = (pitch / 4) * height();
    const int index = (pixel.y() * width()) + pixel.x();

    if ((index >= 0) && (index < nPixels)) {
      const pixel_format_info info{format()};
      pixels[index] = info.rgba_to_pixel(color);
    }

    unlock();
  }

  /**
   * \brief Sets the alpha value of the texture.
   *
   * \param alpha the alpha value, in the range [0, 255].
   *
   * \since 3.0.0
   */
  void set_alpha(const u8 alpha) noexcept
  {
    SDL_SetTextureAlphaMod(m_texture, alpha);
  }

  /**
   * \brief Sets the blend mode that will be used by the texture.
   *
   * \param mode the blend mode that will be used.
   *
   * \since 3.0.0
   */
  void set_blend_mode(const blend_mode mode) noexcept
  {
    SDL_SetTextureBlendMode(m_texture, static_cast<SDL_BlendMode>(mode));
  }

  /**
   * \brief Sets the color modulation of the texture.
   *
   * \note The alpha component in the color struct is ignored by this function.
   *
   * \param color the color that will be used to modulate the color of the texture.
   *
   * \since 3.0.0
   */
  void set_color_mod(const color& color) noexcept
  {
    SDL_SetTextureColorMod(m_texture, color.red(), color.green(), color.blue());
  }

#if SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Sets the scale mode that will be used by the texture.
   *
   * \param mode the scale mode that will be used.
   *
   * \since 4.0.0
   */
  void set_scale_mode(const scale_mode mode) noexcept
  {
    SDL_SetTextureScaleMode(m_texture, static_cast<SDL_ScaleMode>(mode));
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

  /// \} End of setters

  /// \name Getters
  /// \{

  /**
   * \brief Returns the pixel format that is used by the texture.
   *
   * \return the pixel format that is used by the texture.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto format() const noexcept -> pixel_format
  {
    u32 format{};
    SDL_QueryTexture(m_texture, &format, nullptr, nullptr, nullptr);
    return static_cast<pixel_format>(format);
  }

  /**
   * \brief Returns the texture access of the texture.
   *
   * \return the texture access of the texture.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto access() const noexcept -> texture_access
  {
    int access{};
    SDL_QueryTexture(m_texture, nullptr, &access, nullptr, nullptr);
    return static_cast<texture_access>(access);
  }

  /**
   * \brief Returns the width of the texture.
   *
   * \return the width of the texture.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto width() const noexcept -> int
  {
    const auto [width, height] = size();
    return width;
  }

  /**
   * \brief Returns the height of the texture.
   *
   * \return the height of the texture.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto height() const noexcept -> int
  {
    const auto [width, height] = size();
    return height;
  }

  /**
   * \brief Returns the size of the texture.
   *
   * \return the size of the texture.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto size() const noexcept -> iarea
  {
    int width{};
    int height{};
    SDL_QueryTexture(m_texture, nullptr, nullptr, &width, &height);
    return {width, height};
  }

  /**
   * \brief Indicates whether or not the texture is a possible render target.
   *
   * \return `true` if the texture is a possible render target; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_target() const noexcept -> bool
  {
    return access() == texture_access::target;
  }

  /**
   * \brief Indicates whether or not the texture has static texture access.
   *
   * \return `true` if the texture has static texture access; `false` otherwise.
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto is_no_lock() const noexcept -> bool
  {
    return access() == texture_access::no_lock;
  }

  /**
   * \brief Indicates whether or not the texture has streaming texture access.
   *
   * \return `true` if the texture has streaming texture access; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_streaming() const noexcept -> bool
  {
    return access() == texture_access::streaming;
  }

  /**
   * \brief Returns the alpha value of the texture.
   *
   * \return the alpha value of the texture.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto alpha() const noexcept -> u8
  {
    u8 alpha{};
    SDL_GetTextureAlphaMod(m_texture, &alpha);
    return alpha;
  }

  /**
   * \brief Returns the blend mode of the texture.
   *
   * \return the blend mode of the texture.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto get_blend_mode() const noexcept -> blend_mode
  {
    SDL_BlendMode mode{};
    SDL_GetTextureBlendMode(m_texture, &mode);
    return static_cast<blend_mode>(mode);
  }

  /**
   * \brief Returns the color modulation of the texture.
   *
   * \return the modulation of the texture.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto color_mod() const noexcept -> color
  {
    u8 red{};
    u8 green{};
    u8 blue{};
    SDL_GetTextureColorMod(m_texture, &red, &green, &blue);
    return {red, green, blue, 0xFF};
  }

#if SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Returns the scale mode that is used by the texture.
   *
   * \return the scale mode that is used by the texture.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get_scale_mode() const noexcept -> scale_mode
  {
    SDL_ScaleMode mode{};
    SDL_GetTextureScaleMode(m_texture, &mode);
    return static_cast<scale_mode>(mode);
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Releases ownership of the associated SDL texture and returns a pointer to it.
   *
   * \warning Usage of this function should be considered dangerous, since you might run
   * into memory leak issues. You **must** call `SDL_DestroyTexture` on the returned
   * pointer to free the associated memory.
   *
   * \return a pointer to the associated SDL texture.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] auto release() noexcept -> owner<SDL_Texture*>
  {
    return m_texture.release();
  }

  /**
   * \brief Returns a pointer to the associated `SDL_Texture`.
   *
   * \return a pointer to the associated `SDL_Texture`.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_Texture*
  {
    return m_texture.get();
  }

  /// \} End of getters

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not a texture handle holds a non-null pointer.
   *
   * \return `true` if the handle holds a non-null pointer; `false` otherwise.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit operator bool() const noexcept
  {
    return m_texture != nullptr;
  }

  /**
   * \brief Converts to `SDL_Texture*`.
   *
   * \return a pointer to the associated `SDL_Texture`.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit operator SDL_Texture*() noexcept
  {
    return m_texture;
  }

  /**
   * \brief Converts to `const SDL_Texture*`.
   *
   * \return a pointer to the associated `SDL_Texture`.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit operator const SDL_Texture*() const noexcept
  {
    return m_texture;
  }

  /// \} End of conversions

 private:
  struct deleter final
  {
    void operator()(SDL_Texture* texture) noexcept
    {
      SDL_DestroyTexture(texture);
    }
  };
  detail::pointer_manager<T, SDL_Texture, deleter> m_texture;

  /**
   * \brief Locks the texture for write-only pixel access.
   *
   * \remarks This function is only applicable if the texture access of the texture is
   * `Streaming`.
   *
   * \param pixels this will be filled with a pointer to the locked pixels.
   * \param pitch This is filled in with the pitch of the locked pixels, can safely be
   * null if it isn't needed.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 4.0.0
   */
  auto lock(u32** pixels, int* pitch = nullptr) noexcept -> result
  {
    if (pitch) {
      return SDL_LockTexture(m_texture, nullptr, reinterpret_cast<void**>(pixels), pitch) == 0;
    }
    else {
      int dummyPitch;
      return SDL_LockTexture(m_texture,
                             nullptr,
                             reinterpret_cast<void**>(pixels),
                             &dummyPitch) == 0;
    }
  }

  /**
   * \brief Unlocks the texture.
   *
   * \since 4.0.0
   */
  void unlock() noexcept
  {
    SDL_UnlockTexture(m_texture);
  }
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a texture.
 *
 * \param texture the texture that will be converted.
 *
 * \return a string that represents the texture.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_texture<T>& texture) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("texture{{data: {}, width: {}, height: {}}}",
                     detail::address_of(texture.get()),
                     texture.width(),
                     texture.height());
#else
  return "texture{data: " + detail::address_of(texture.get()) +
         ", width: " + std::to_string(texture.width()) +
         ", height: " + std::to_string(texture.height()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a texture.
 *
 * \param stream the stream that will be used.
 * \param texture the texture that will be printed
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_texture<T>& texture) -> std::ostream&
{
  return stream << to_string(texture);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_TEXTURE_HEADER
// #include "../window.hpp"

// #include "gl_attribute.hpp"
#ifndef CENTURION_GL_ATTRIBUTE_HEADER
#define CENTURION_GL_ATTRIBUTE_HEADER

#ifndef CENTURION_NO_OPENGL

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../../core/exception.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum gl_attribute
 *
 * \brief Provides identifiers for different OpenGL attributes.
 *
 * \since 6.0.0
 */
enum class gl_attribute
{
  red_size = SDL_GL_RED_SIZE,
  green_size = SDL_GL_GREEN_SIZE,
  blue_size = SDL_GL_BLUE_SIZE,
  alpha_size = SDL_GL_ALPHA_SIZE,
  buffer_size = SDL_GL_BUFFER_SIZE,
  depth_size = SDL_GL_DEPTH_SIZE,
  stencil_size = SDL_GL_STENCIL_SIZE,

  accum_red_size = SDL_GL_ACCUM_RED_SIZE,
  accum_green_size = SDL_GL_ACCUM_GREEN_SIZE,
  accum_blue_size = SDL_GL_ACCUM_BLUE_SIZE,
  accum_alpha_size = SDL_GL_ACCUM_ALPHA_SIZE,

  stereo = SDL_GL_STEREO,
  egl = SDL_GL_CONTEXT_EGL,
  flags = SDL_GL_CONTEXT_FLAGS,
  double_buffer = SDL_GL_DOUBLEBUFFER,
  accelerated_visual = SDL_GL_ACCELERATED_VISUAL,
  retained_backing = SDL_GL_RETAINED_BACKING,
  share_with_current_context = SDL_GL_SHARE_WITH_CURRENT_CONTEXT,
  framebuffer_srgb_capable = SDL_GL_FRAMEBUFFER_SRGB_CAPABLE,

  multisample_buffers = SDL_GL_MULTISAMPLEBUFFERS,
  multisample_samples = SDL_GL_MULTISAMPLESAMPLES,

  context_major_version = SDL_GL_CONTEXT_MAJOR_VERSION,
  context_minor_version = SDL_GL_CONTEXT_MINOR_VERSION,
  context_profile_mask = SDL_GL_CONTEXT_PROFILE_MASK,
  context_release_behaviour = SDL_GL_CONTEXT_RELEASE_BEHAVIOR,
  context_reset_notification = SDL_GL_CONTEXT_RESET_NOTIFICATION,
  context_no_error = SDL_GL_CONTEXT_NO_ERROR
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied OpenGL attribute.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(gl_attribute::flags) == "flags"`.
 *
 * \param attr the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const gl_attribute attr) -> std::string_view
{
  switch (attr) {
    case gl_attribute::red_size:
      return "red_size";

    case gl_attribute::green_size:
      return "green_size";

    case gl_attribute::blue_size:
      return "blue_size";

    case gl_attribute::alpha_size:
      return "alpha_size";

    case gl_attribute::buffer_size:
      return "buffer_size";

    case gl_attribute::depth_size:
      return "depth_size";

    case gl_attribute::stencil_size:
      return "stencil_size";

    case gl_attribute::accum_red_size:
      return "accum_red_size";

    case gl_attribute::accum_green_size:
      return "accum_green_size";

    case gl_attribute::accum_blue_size:
      return "accum_blue_size";

    case gl_attribute::accum_alpha_size:
      return "accum_alpha_size";

    case gl_attribute::stereo:
      return "stereo";

    case gl_attribute::egl:
      return "egl";

    case gl_attribute::flags:
      return "flags";

    case gl_attribute::double_buffer:
      return "double_buffer";

    case gl_attribute::accelerated_visual:
      return "accelerated_visual";

    case gl_attribute::retained_backing:
      return "retained_backing";

    case gl_attribute::share_with_current_context:
      return "share_with_current_context";

    case gl_attribute::framebuffer_srgb_capable:
      return "framebuffer_srgb_capable";

    case gl_attribute::multisample_buffers:
      return "multisample_buffers";

    case gl_attribute::multisample_samples:
      return "multisample_samples";

    case gl_attribute::context_major_version:
      return "context_major_version";

    case gl_attribute::context_minor_version:
      return "context_minor_version";

    case gl_attribute::context_profile_mask:
      return "context_profile_mask";

    case gl_attribute::context_release_behaviour:
      return "context_release_behaviour";

    case gl_attribute::context_reset_notification:
      return "context_reset_notification";

    case gl_attribute::context_no_error:
      return "context_no_error";

    default:
      throw cen_error{"Did not recognize OpenGL attribute!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of an OpenGL attribute enumerator.
 *
 * \param stream the output stream that will be used.
 * \param attr the enumerator that will be printed.
 *
 * \see `to_string(gl_attribute)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const gl_attribute attr) -> std::ostream&
{
  return stream << to_string(attr);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_NO_OPENGL
#endif  // CENTURION_GL_ATTRIBUTE_HEADER

// #include "gl_context.hpp"
#ifndef CENTURION_GL_CONTEXT_HEADER
#define CENTURION_GL_CONTEXT_HEADER

#ifndef CENTURION_NO_OPENGL

#include <SDL.h>

#include <cassert>  // assert
#include <memory>   // unique_ptr

// #include "../../core/exception.hpp"

// #include "../../core/owner.hpp"

// #include "../../core/result.hpp"

// #include "../../detail/owner_handle_api.hpp"

// #include "../window.hpp"


namespace cen::gl {

/// \addtogroup video
/// \{

template <typename T>
class basic_context;

///< An owning OpenGL context.
using context = basic_context<detail::owning_type>;

///< A non-owning OpenGL context.
using context_handle = basic_context<detail::handle_type>;

/**
 * \class basic_context
 *
 * \brief Represents an OpenGL context.
 *
 * \ownerhandle `context`/`context_handle`
 *
 * \since 6.0.0
 */
template <typename T>
class basic_context final
{
 public:
  /// \name Construction
  /// \{

  // clang-format off

  /**
   * \brief Creates a context instance from an existing OpenGL context.
   *
   * \param context the existing OpenGL context.
   *
   * \throws cen_error if the context is owning and the supplied pointer is null.
   *
   * \since 6.0.0
   */
  explicit basic_context(maybe_owner<SDL_GLContext> context) noexcept(!detail::is_owning<T>())
      : m_context{context}
  {
    if constexpr (detail::is_owning<T>())
    {
      if (!m_context)
      {
        throw cen_error{"Can't create OpenGL context from null pointer!"};
      }
    }
  }

  // clang-format on

  /**
   * \brief Creates an OpenGL context based on the supplied window.
   *
   * \tparam U the ownership semantics of the window.
   *
   * \param window the OpenGL window.
   *
   * \throws sdl_error if the context has owning semantics and the OpenGL context couldn't
   * be initialized.
   *
   * \since 6.0.0
   */
  template <typename U>
  explicit basic_context(basic_window<U>& window) noexcept(!detail::is_owning<T>())
      : m_context{SDL_GL_CreateContext(window.get())}
  {
    if constexpr (detail::is_owning<T>()) {
      if (!m_context) {
        throw sdl_error{};
      }
    }
  }

  /// \} End of construction

  /**
   * \brief Makes the context the current OpenGL context for an OpenGL window.
   *
   * \pre `window` must be an OpenGL window.
   *
   * \tparam U the ownership semantics of the window.
   *
   * \param window the OpenGL window.
   *
   * \return `success` if the was operation was successful; `failure` otherwise.
   *
   * \since 6.0.0
   */
  template <typename U>
  auto make_current(basic_window<U>& window) -> result
  {
    assert(window.is_opengl());
    return SDL_GL_MakeCurrent(window.get(), m_context.get()) == 0;
  }

  /**
   * \brief Returns the associated OpenGL context.
   *
   * \return the handle to the associated OpenGL context.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_GLContext
  {
    return m_context.get();
  }

 private:
  struct deleter final
  {
    void operator()(SDL_GLContext context) noexcept
    {
      SDL_GL_DeleteContext(context);
    }
  };

  std::unique_ptr<void, deleter> m_context;
};

/// \} End of group video

}  // namespace cen::gl

namespace cen {

/// \addtogroup video
/// \{

/// Workaround for slight inconsistency where other OpenGL components feature "gl_"-prefix
using gl_context = gl::context;
using gl_context_handle = gl::context_handle;

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_NO_OPENGL
#endif  // CENTURION_GL_CONTEXT_HEADER


namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum gl_swap_interval
 *
 * \brief Provides identifiers that represent different swap interval modes.
 *
 * \ingroup video
 *
 * \since 6.0.0
 */
enum class gl_swap_interval : int
{
  immediate = 0,       ///< Immediate updates.
  synchronized = 1,    ///< Updates synchronized with vertical retrace (VSync).
  late_immediate = -1  ///< Allow immediate late swaps, instead of waiting for retrace.
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied swap interval attribute.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(gl_swap_interval::synchronized) == "synchronized"`.
 *
 * \param interval the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const gl_swap_interval interval) -> std::string_view
{
  switch (interval) {
    case gl_swap_interval::immediate:
      return "immediate";

    case gl_swap_interval::synchronized:
      return "synchronized";

    case gl_swap_interval::late_immediate:
      return "late_immediate";

    default:
      throw cen_error{"Did not recognize swap interval!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a swap interval enumerator.
 *
 * \param stream the output stream that will be used.
 * \param interval the enumerator that will be printed.
 *
 * \see `to_string(gl_swap_interval)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const gl_swap_interval interval) -> std::ostream&
{
  return stream << to_string(interval);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

/**
 * \namespace cen::gl
 *
 * \brief Contains OpenGL-related components.
 *
 * \ingroup video
 *
 * \since 6.0.0
 */
namespace cen::gl {

/// \addtogroup video
/// \{

/// \name OpenGL functions
/// \{

/**
 * \brief Swaps the buffers for an OpenGL window.
 *
 * \pre The window must be usable within an OpenGL context.
 *
 * \note This requires that double-buffering is supported.
 *
 * \param window the OpenGL window to swap the buffers for.
 *
 * \since 6.0.0
 */
template <typename T>
void swap(basic_window<T>& window) noexcept
{
  assert(window.is_opengl());
  SDL_GL_SwapWindow(window.get());
}

/**
 * \brief Returns the drawable size of an OpenGL window.
 *
 * \pre `window` must be an OpenGL window.
 *
 * \tparam T the ownership semantics of the window.
 *
 * \param window the OpenGL window that will be queried.
 *
 * \return the drawable size of the window.
 *
 * \since 6.0.0
 */
template <typename T>
[[nodiscard]] auto drawable_size(const basic_window<T>& window) noexcept -> iarea
{
  assert(window.is_opengl());

  int width{};
  int height{};
  SDL_GL_GetDrawableSize(window.get(), &width, &height);

  return {width, height};
}

/**
 * \brief Resets all OpenGL context attributes to their default values.
 *
 * \since 6.0.0
 */
inline void reset_attributes() noexcept
{
  SDL_GL_ResetAttributes();
}

/**
 * \brief Sets the value of an OpenGL context attribute.
 *
 * \param attr the attribute that will be set.
 * \param value the new value of the attribute.
 *
 * \return `success` if the attribute was successfully set; `failure` otherwise.
 *
 * \since 6.0.0
 */
inline auto set(const gl_attribute attr, const int value) noexcept -> result
{
  return SDL_GL_SetAttribute(static_cast<SDL_GLattr>(attr), value) == 0;
}

/**
 * \brief Returns the current value of an OpenGL context attribute.
 *
 * \param attr the OpenGL context attribute to check.
 *
 * \return the value of the specified attribute; `std::nullopt` if the value could not be
 * obtained.
 *
 * \since 6.0.0
 */
inline auto get(const gl_attribute attr) noexcept -> std::optional<int>
{
  int value{};
  if (SDL_GL_GetAttribute(static_cast<SDL_GLattr>(attr), &value) == 0) {
    return value;
  }
  else {
    return std::nullopt;
  }
}

/**
 * \brief Sets the swap interval strategy that will be used.
 *
 * \param interval the swap interval that will be used.
 *
 * \return `success` if the swap interval successfully set; `failure` if it isn't
 * supported.
 *
 * \since 6.0.0
 */
inline auto set_swap_interval(const gl_swap_interval interval) noexcept -> result
{
  return SDL_GL_SetSwapInterval(to_underlying(interval)) == 0;
}

/**
 * \brief Returns the swap interval used by the current OpenGL context.
 *
 * \note `gl_swap_interval::immediate` is returned if the swap interval couldn't be
 * determined.
 *
 * \return the current swap interval.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto swap_interval() noexcept -> gl_swap_interval
{
  return gl_swap_interval{SDL_GL_GetSwapInterval()};
}

/**
 * \brief Returns a handle to the currently active OpenGL window.
 *
 * \return a potentially invalid handle to the current OpenGL window.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto get_window() noexcept -> window_handle
{
  return window_handle{SDL_GL_GetCurrentWindow()};
}

/**
 * \brief Returns a handle to the currently active OpenGL context.
 *
 * \return a potentially invalid handle to the current OpenGL context.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto get_context() noexcept -> context_handle
{
  return context_handle{SDL_GL_GetCurrentContext()};
}

/**
 * \brief Indicates whether or not the specified extension is supported.
 *
 * \param extension the extension that will be checked.
 *
 * \return `true` if the specified extension is supported; `false` otherwise.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto is_extension_supported(const not_null<str> extension) noexcept
    -> bool
{
  assert(extension);
  return SDL_GL_ExtensionSupported(extension) == SDL_TRUE;
}

/// \copydoc is_extension_supported()
[[nodiscard]] inline auto is_extension_supported(const std::string& extension) noexcept -> bool
{
  return is_extension_supported(extension.c_str());
}

/**
 * \brief Binds a texture to the current OpenGL context.
 *
 * \tparam T the ownership semantics tag.
 *
 * \param texture the texture to bind.
 *
 * \return the size of the texture if it was successfully bound; `std::nullopt` if
 * something goes wrong.
 *
 * \since 6.1.0
 */
template <typename T>
auto bind(basic_texture<T>& texture) noexcept -> std::optional<farea>
{
  float width{};
  float height{};
  if (SDL_GL_BindTexture(texture.get(), &width, &height) == 0) {
    return farea{width, height};
  }
  else {
    return std::nullopt;
  }
}

/**
 * \brief Unbinds a texture from the OpenGL context.
 *
 * \tparam T the ownership semantics tag.
 *
 * \param texture the texture to unbind.
 *
 * \return `success` if the texture was unbound; `failure` otherwise.
 *
 * \since 6.1.0
 */
template <typename T>
auto unbind(basic_texture<T>& texture) noexcept -> result
{
  return SDL_GL_UnbindTexture(texture.get()) == 0;
}

/// \} End of OpenGL functions

/// \} End of group video

}  // namespace cen::gl

#endif  // CENTURION_NO_OPENGL
#endif  // CENTURION_GL_CORE_HEADER

// #include "centurion/video/opengl/gl_library.hpp"
#ifndef CENTURION_GL_LIBRARY_HEADER
#define CENTURION_GL_LIBRARY_HEADER

#ifndef CENTURION_NO_OPENGL

#include <SDL.h>

#include <cassert>  // assert

// #include "../../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER

// #include "../../core/exception.hpp"

// #include "../../core/not_null.hpp"

// #include "../../core/str.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \class gl_library
 *
 * \brief Manages the initialization and de-initialization of an OpenGL library.
 *
 * \since 6.0.0
 */
class gl_library final
{
 public:
  /**
   * \brief Loads an OpenGL library.
   *
   * \param path the file path to the OpenGL library that will be used; a null path
   * indicates that the default library will be used.
   *
   * \throws sdl_error if the OpenGL library can't be loaded.
   *
   * \since 6.0.0
   */
  CENTURION_NODISCARD_CTOR explicit gl_library(const str path = nullptr)
  {
    if (SDL_GL_LoadLibrary(path) == -1) {
      throw sdl_error{};
    }
  }

  gl_library(const gl_library&) = delete;
  gl_library(gl_library&&) = delete;

  auto operator=(const gl_library&) -> gl_library& = delete;
  auto operator=(gl_library&&) -> gl_library& = delete;

  ~gl_library() noexcept
  {
    SDL_GL_UnloadLibrary();
  }

  // clang-format off

  /**
   * \brief Returns the address of an OpenGL function.
   *
   * \details This function must be used to retrieve OpenGL functions after
   * loading the library at runtime.
   *
   * \note Be sure to declare your function pointers with `APIENTRY` to ensure
   * the correct calling convention on different platforms, which avoids stack
   * corruption.
   *
   * \param function the name of the function to obtain the address of.
   *
   * \return the address of the specified function; null if something went
   * wrong.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto address_of(const not_null<str> function) const noexcept // NOLINT
      -> void*
  {
    assert(function);
    return SDL_GL_GetProcAddress(function);
  }

  // clang-format on
};

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_NO_OPENGL
#endif  // CENTURION_GL_LIBRARY_HEADER

// #include "centurion/video/palette.hpp"
#ifndef CENTURION_PALETTE_HEADER
#define CENTURION_PALETTE_HEADER

#include <SDL.h>

#include <cassert>  // assert
#include <memory>   // unique_ptr
#include <ostream>  // ostream
#include <string>   // string, to_string

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/result.hpp"

// #include "../detail/address_of.hpp"

// #include "color.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \class palette
 *
 * \brief Represents a palette of colors.
 *
 * \details This class features an interface similar to a container type, with support for
 * the subscript operator and iteration.
 *
 * \see `SDL_Palette`
 *
 * \since 6.0.0
 */
class palette final
{
 public:
  using iterator = SDL_Color*;
  using const_iterator = const SDL_Color*;

  /// \name Construction
  /// \{

  /**
   * \brief Creates a palette with the specified amount of colors.
   *
   * \param nColors the number of colors in the palette.
   *
   * \throws sdl_error if the palette couldn't be created.
   *
   * \since 6.0.0
   */
  explicit palette(const int nColors) : m_palette{SDL_AllocPalette(nColors)}
  {
    if (!m_palette) {
      throw sdl_error{};
    }
  }

  /// \} End of construction

  /**
   * \brief Sets a color in the palette.
   *
   * \pre `index` must not be negative.
   * \pre `index` must be less than the size of the palette.
   *
   * \param index the index of the color slot that will be changed.
   * \param color the new color that will be used.
   *
   * \since 6.0.0
   */
  auto set_color(const int index, const cen::color& color) noexcept -> result
  {
    assert(index >= 0);
    assert(index < size());
    return SDL_SetPaletteColors(m_palette.get(), color.data(), index, 1) == 0;
  }

  /**
   * \brief Returns the color in the palette at the specified index.
   *
   * \note This function returns a copy of the color, not a reference!
   *
   * \param index the index of color in the palette.
   *
   * \throws cen_error if the supplied index is out of bounds.
   *
   * \return a copy of the color at the specified index in the palette.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto at(const int index) const -> cen::color
  {
    if (index >= 0 && index < size()) {
      return cen::color{m_palette->colors[index]};
    }
    else {
      throw cen_error{"Palette index out of bounds!"};
    }
  }

  /**
   * \brief Returns the color in the palette at the specified index.
   *
   * \warning This function performs no bounds checking, see `at()` for a bounds checked
   * version of this function.
   *
   * \pre `index` must not be negative.
   * \pre `index` must be less than the size of the palette.
   *
   * \note This function returns a copy of the color, not a reference!
   *
   * \param index the index of color in the palette.
   *
   * \return a copy of the color at the specified index in the palette.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto operator[](const int index) const noexcept -> cen::color
  {
    assert(index >= 0);
    assert(index < size());
    return cen::color{m_palette->colors[index]};
  }

  /**
   * \brief Returns the amount of colors in the palette.
   *
   * \return the amount of colors in the palette.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto size() const noexcept -> int
  {
    return m_palette->ncolors;
  }

  /**
   * \brief Returns the version of the palette.
   *
   * \note This value can be incremented by `set_color()`.
   *
   * \return the current version of the palette.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto version() const noexcept -> u32
  {
    return m_palette->version;
  }

  /**
   * \brief Returns a pointer to the associated SDL palette.
   *
   * \warning Do not claim ownership of the returned pointer!
   *
   * \return a pointer to the associated SDL palette
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_Palette*
  {
    return m_palette.get();
  }

  /// \name Iteration
  /// \{

  [[nodiscard]] auto begin() noexcept -> iterator
  {
    return m_palette->colors;
  }

  [[nodiscard]] auto begin() const noexcept -> const_iterator
  {
    return m_palette->colors;
  }

  [[nodiscard]] auto end() noexcept -> iterator
  {
    return m_palette->colors + size();
  }

  [[nodiscard]] auto end() const noexcept -> const_iterator
  {
    return m_palette->colors + size();
  }

  /// \} End of iteration

 private:
  struct deleter final
  {
    void operator()(SDL_Palette* palette) noexcept
    {
      SDL_FreePalette(palette);
    }
  };

  std::unique_ptr<SDL_Palette, deleter> m_palette;
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a palette.
 *
 * \param palette the palette that will be converted.
 *
 * \return a textual representation of the palette.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto to_string(const palette& palette) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("palette{{data: {}, size: {}}}",
                     detail::address_of(palette.get()),
                     palette.size());
#else
  return "palette{data: " + detail::address_of(palette.get()) +
         ", size: " + std::to_string(palette.size()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a palette using a stream.
 *
 * \param stream the stream that will be used.
 * \param palette the palette that will be printed.
 *
 * \return the used stream.
 *
 * \since 6.0.0
 */
inline auto operator<<(std::ostream& stream, const palette& palette) -> std::ostream&
{
  return stream << to_string(palette);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_PALETTE_HEADER

// #include "centurion/video/pixel_format.hpp"
#ifndef CENTURION_PIXEL_FORMAT_HEADER
#define CENTURION_PIXEL_FORMAT_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum pixel_format
 *
 * \brief Represents different pixel formats.
 *
 * \see `SDL_PixelFormatEnum`
 *
 * \since 3.1.0
 */
enum class pixel_format : u32
{
  unknown = SDL_PIXELFORMAT_UNKNOWN,

  index1lsb = SDL_PIXELFORMAT_INDEX1LSB,
  index1msb = SDL_PIXELFORMAT_INDEX1MSB,
  index4lsb = SDL_PIXELFORMAT_INDEX4LSB,
  index4msb = SDL_PIXELFORMAT_INDEX4MSB,
  index8 = SDL_PIXELFORMAT_INDEX8,

#if SDL_VERSION_ATLEAST(2, 0, 14)
  xrgb4444 = SDL_PIXELFORMAT_XRGB4444,
  xbgr4444 = SDL_PIXELFORMAT_XBGR4444,

  xrgb1555 = SDL_PIXELFORMAT_XRGB1555,
  xbgr1555 = SDL_PIXELFORMAT_XBGR1555,

  xrgb8888 = SDL_PIXELFORMAT_XRGB8888,
  xbgr8888 = SDL_PIXELFORMAT_XBGR8888,
#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  rgb332 = SDL_PIXELFORMAT_RGB332,
  rgb444 = SDL_PIXELFORMAT_RGB444,

#if SDL_VERSION_ATLEAST(2, 0, 12)
  bgr444 = SDL_PIXELFORMAT_BGR444,
#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

  rgb555 = SDL_PIXELFORMAT_RGB555,
  bgr555 = SDL_PIXELFORMAT_BGR555,

  argb4444 = SDL_PIXELFORMAT_ARGB4444,
  rgba4444 = SDL_PIXELFORMAT_RGBA4444,
  abgr4444 = SDL_PIXELFORMAT_ABGR4444,
  bgra4444 = SDL_PIXELFORMAT_BGRA4444,

  argb1555 = SDL_PIXELFORMAT_ARGB1555,
  rgba5551 = SDL_PIXELFORMAT_RGBA5551,
  abgr1555 = SDL_PIXELFORMAT_ABGR1555,
  bgra5551 = SDL_PIXELFORMAT_BGRA5551,

  rgb565 = SDL_PIXELFORMAT_RGB565,
  bgr565 = SDL_PIXELFORMAT_BGR565,

  rgb24 = SDL_PIXELFORMAT_RGB24,
  bgr24 = SDL_PIXELFORMAT_BGR24,

  rgb888 = SDL_PIXELFORMAT_RGB888,
  rgbx8888 = SDL_PIXELFORMAT_RGBX8888,
  bgr888 = SDL_PIXELFORMAT_BGR888,
  bgrx8888 = SDL_PIXELFORMAT_BGRX8888,

  argb8888 = SDL_PIXELFORMAT_ARGB8888,
  rgba8888 = SDL_PIXELFORMAT_RGBA8888,
  abgr8888 = SDL_PIXELFORMAT_ABGR8888,
  bgra8888 = SDL_PIXELFORMAT_BGRA8888,

  argb2101010 = SDL_PIXELFORMAT_ARGB2101010,

#if SDL_BYTEORDER == SDL_BIG_ENDIAN
  rgba32 = SDL_PIXELFORMAT_RGBA8888,
  argb32 = SDL_PIXELFORMAT_ARGB8888,
  bgra32 = SDL_PIXELFORMAT_BGRA8888,
  abgr32 = SDL_PIXELFORMAT_ABGR8888,
#else
  rgba32 = SDL_PIXELFORMAT_ABGR8888,
  argb32 = SDL_PIXELFORMAT_BGRA8888,
  bgra32 = SDL_PIXELFORMAT_ARGB8888,
  abgr32 = SDL_PIXELFORMAT_RGBA8888,
#endif

  yv12 = SDL_PIXELFORMAT_YV12,
  iyuv = SDL_PIXELFORMAT_IYUV,
  yuy2 = SDL_PIXELFORMAT_YUY2,
  uyvy = SDL_PIXELFORMAT_UYVY,
  yvyu = SDL_PIXELFORMAT_YVYU,
  nv12 = SDL_PIXELFORMAT_NV12,
  nv21 = SDL_PIXELFORMAT_NV21,
  external_oes = SDL_PIXELFORMAT_EXTERNAL_OES
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied pixel format.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(pixel_format::rgba8888) == "rgba8888"`.
 *
 * \param format the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const pixel_format format) -> std::string_view
{
  switch (format) {
    case pixel_format::unknown:
      return "unknown";

    case pixel_format::index1lsb:
      return "index1lsb";

    case pixel_format::index1msb:
      return "index1msb";

    case pixel_format::index4lsb:
      return "index4lsb";

    case pixel_format::index4msb:
      return "index4msb";

    case pixel_format::index8:
      return "index8";

    case pixel_format::rgb332:
      return "rgb332";

    case pixel_format::argb4444:
      return "argb4444";

    case pixel_format::rgba4444:
      return "rgba4444";

    case pixel_format::abgr4444:
      return "abgr4444";

    case pixel_format::bgra4444:
      return "bgra4444";

    case pixel_format::argb1555:
      return "argb1555";

    case pixel_format::rgba5551:
      return "rgba5551";

    case pixel_format::abgr1555:
      return "abgr1555";

    case pixel_format::bgra5551:
      return "bgra5551";

    case pixel_format::rgb565:
      return "rgb565";

    case pixel_format::bgr565:
      return "bgr565";

    case pixel_format::rgb24:
      return "rgb24";

    case pixel_format::bgr24:
      return "bgr24";

    case pixel_format::rgbx8888:
      return "rgbx8888";

    case pixel_format::bgrx8888:
      return "bgrx8888";

    case pixel_format::argb8888:
      return "argb8888";

    case pixel_format::rgba8888:
      return "rgba8888";

    case pixel_format::abgr8888:
      return "abgr8888";

    case pixel_format::bgra8888:
      return "bgra8888";

    case pixel_format::argb2101010:
      return "argb2101010";

    case pixel_format::yv12:
      return "yv12";

    case pixel_format::iyuv:
      return "iyuv";

    case pixel_format::yuy2:
      return "yuy2";

    case pixel_format::uyvy:
      return "uyvy";

    case pixel_format::yvyu:
      return "yvyu";

    case pixel_format::nv12:
      return "nv12";

    case pixel_format::nv21:
      return "nv21";

    case pixel_format::external_oes:
      return "external_oes";

#if SDL_VERSION_ATLEAST(2, 0, 14)

    case pixel_format::xrgb4444:
      return "xrgb4444";

    case pixel_format::xbgr4444:
      return "xbgr4444";

    case pixel_format::xrgb1555:
      return "xrgb1555";

    case pixel_format::xbgr1555:
      return "xbgr1555";

    case pixel_format::xrgb8888:
      return "xrgb8888";

    case pixel_format::xbgr8888:
      return "xbgr8888";

#elif SDL_VERSION_ATLEAST(2, 0, 12)

    case pixel_format::bgr444:  // Equal to xbgr4444
      return "bgr444";

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

    default:
      throw cen_error{"Did not recognize pixel format mode!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a pixel format enumerator.
 *
 * \param stream the output stream that will be used.
 * \param format the enumerator that will be printed.
 *
 * \see `to_string(pixel_format)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const pixel_format format) -> std::ostream&
{
  return stream << to_string(format);
}

/// \} End of streaming

/// \name Pixel format comparison operators
/// \{

/**
 * \brief Indicates whether or not the two pixel format values are the same.
 *
 * \param lhs the left-hand side pixel format value.
 * \param rhs the right-hand side pixel format value.
 *
 * \return `true` if the pixel format values are the same; `false` otherwise.
 *
 * \since 3.1.0
 */
[[nodiscard]] constexpr auto operator==(const pixel_format lhs,
                                        const SDL_PixelFormatEnum rhs) noexcept -> bool
{
  return static_cast<SDL_PixelFormatEnum>(lhs) == rhs;
}

/// \copydoc operator==(pixel_format, SDL_PixelFormatEnum)
[[nodiscard]] constexpr auto operator==(const SDL_PixelFormatEnum lhs,
                                        const pixel_format rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the two pixel format values aren't the same.
 *
 * \param lhs the left-hand side pixel format value.
 * \param rhs the right-hand side pixel format value.
 *
 * \return `true` if the pixel format values aren't the same; `false` otherwise.
 *
 * \since 3.1.0
 */
[[nodiscard]] constexpr auto operator!=(const pixel_format lhs,
                                        const SDL_PixelFormatEnum rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(pixel_format, SDL_PixelFormatEnum)
[[nodiscard]] constexpr auto operator!=(const SDL_PixelFormatEnum lhs,
                                        const pixel_format rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of pixel format comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_PIXEL_FORMAT_HEADER

// #include "centurion/video/pixel_format_info.hpp"
#ifndef CENTURION_PIXEL_FORMAT_INFO_HEADER
#define CENTURION_PIXEL_FORMAT_INFO_HEADER

#include <SDL.h>

#include <ostream>  // ostream
#include <string>   // string, to_string

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/not_null.hpp"

// #include "../core/owner.hpp"

// #include "../core/str.hpp"

// #include "../core/to_underlying.hpp"

// #include "../detail/address_of.hpp"

// #include "../detail/owner_handle_api.hpp"

// #include "color.hpp"

// #include "pixel_format.hpp"


namespace cen {

/// \addtogroup video
/// \{

template <typename B>
class basic_pixel_format_info;

/**
 * \typedef pixel_format_info
 *
 * \brief Represents an owning pixel format info instance.
 *
 * \since 5.2.0
 */
using pixel_format_info = basic_pixel_format_info<detail::owning_type>;

/**
 * \typedef pixel_format_info_handle
 *
 * \brief Represents a non-owning pixel format info instance.
 *
 * \since 5.2.0
 */
using pixel_format_info_handle = basic_pixel_format_info<detail::handle_type>;

/**
 * \class basic_pixel_format_info
 *
 * \brief Provides information about a pixel format.
 *
 * \ownerhandle `pixel_format_info`/ `pixel_format_info_handle`
 *
 * \see `pixel_format`
 * \see `pixel_format_info`
 * \see `pixel_format_info_handle`
 * \see `SDL_PixelFormat`
 * \see `SDL_PixelFormatEnum`
 *
 * \since 5.2.0
 */
template <typename B>
class basic_pixel_format_info final
{
 public:
  /// \name Construction
  /// \{

  // clang-format off

  /**
   * \brief Creates a pixel format info instance based on an existing pointer.
   *
   * \note Ownership of the supplied pointer might be claimed, depending on the
   * ownership semantics of the class.
   *
   * \param format a pointer to the associated pixel format.
   *
   * \throws cen_error if the supplied pointer is null *and* the class has owning semantics.
   *
   * \since 5.2.0
   */
  explicit basic_pixel_format_info(maybe_owner<SDL_PixelFormat*> format) noexcept(!detail::is_owning<B>())
      : m_format{format}
  {
    if constexpr (detail::is_owning<B>())
    {
      if (!m_format)
      {
        throw cen_error{"Null pixel format!"};
      }
    }
  }

  // clang-format on

  /**
   * \brief Creates an owning instance based on a pixel format.
   *
   * \tparam BB dummy template parameter for SFINAE.
   *
   * \param format the associated pixel format.
   *
   * \throws sdl_error if the pixel format info could not be obtained.
   *
   * \since 5.2.0
   */
  template <typename BB = B, detail::is_owner<BB> = 0>
  explicit basic_pixel_format_info(const pixel_format format)
      : m_format{SDL_AllocFormat(to_underlying(format))}
  {
    if (!m_format) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates a handle based on an owning pixel format info instance.
   *
   * \param info the associated pixel format info instance.
   *
   * \since 5.2.0
   */
  template <typename BB = B, detail::is_handle<BB> = 0>
  explicit basic_pixel_format_info(const pixel_format_info& info) noexcept
      : m_format{info.get()}
  {}

  /// \} End of construction

  /// \name Pixel/RGB/RGBA conversions
  /// \{

  /**
   * \brief Returns a color that corresponds to a masked pixel value.
   *
   * \param pixel the masked pixel value.
   *
   * \return a color that corresponds to a pixel value, according to the format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto pixel_to_rgb(const u32 pixel) const noexcept -> color
  {
    u8 red{};
    u8 green{};
    u8 blue{};
    SDL_GetRGB(pixel, m_format, &red, &green, &blue);
    return color{red, green, blue};
  }

  /**
   * \brief Returns a color that corresponds to a masked pixel value.
   *
   * \param pixel the masked pixel value.
   *
   * \return a color that corresponds to a pixel value, according to the format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto pixel_to_rgba(const u32 pixel) const noexcept -> color
  {
    u8 red{};
    u8 green{};
    u8 blue{};
    u8 alpha{};
    SDL_GetRGBA(pixel, m_format, &red, &green, &blue, &alpha);
    return color{red, green, blue, alpha};
  }

  /**
   * \brief Returns a pixel color value based on the RGB values of a color.
   *
   * \note The alpha component is assumed to be `0xFF`, i.e. fully opaque.
   *
   * \param color the color that will be converted.
   *
   * \return a masked pixel color value, based on the pixel format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto rgb_to_pixel(const color& color) const noexcept -> u32
  {
    return SDL_MapRGB(m_format, color.red(), color.green(), color.blue());
  }

  /**
   * \brief Returns a pixel color value based on the RGBA values of a color.
   *
   * \param color the color that will be converted.
   *
   * \return a masked pixel color value, based on the pixel format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto rgba_to_pixel(const color& color) const noexcept -> u32
  {
    return SDL_MapRGBA(m_format, color.red(), color.green(), color.blue(), color.alpha());
  }

  /// \} End of pixel/RGB/RGBA conversions

  /// \name Queries
  /// \{

  /**
   * \brief Returns the associated pixel format.
   *
   * \return the associated pixel format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto format() const noexcept -> pixel_format
  {
    return static_cast<pixel_format>(m_format->format);
  }

  /**
   * \brief Returns a human-readable name associated with the format.
   *
   * \details This function never returns a null-pointer, instead it returns
   * "SDL_PIXELFORMAT_UNKNOWN" if the format is ill-formed.
   *
   * \return a human-readable name associated with the format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto name() const noexcept -> not_null<str>
  {
    return SDL_GetPixelFormatName(m_format->format);
  }

  /**
   * \brief Returns a pointer to the associated pixel format instance.
   *
   * \warning Do not claim ownership of the returned pointer.
   *
   * \return a pointer to the internal pixel format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_PixelFormat*
  {
    return m_format.get();
  }

  /// \} End of queries

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not a handle holds a non-null pointer.
   *
   * \return `true` if the handle holds a non-null pointer; `false` otherwise.
   *
   * \since 5.2.0
   */
  template <typename BB = B, detail::is_handle<BB> = 0>
  [[nodiscard]] explicit operator bool() const noexcept
  {
    return m_format;
  }

  /// \} End of conversions

 private:
  struct deleter final
  {
    void operator()(SDL_PixelFormat* format) noexcept
    {
      SDL_FreeFormat(format);
    }
  };
  detail::pointer_manager<B, SDL_PixelFormat, deleter> m_format;
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a pixel format info instance.
 *
 * \tparam T the ownership semantics tag.
 *
 * \param info the pixel format info instance that will be converted.
 *
 * \return a string that represents the pixel format info.
 *
 * \since 6.2.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_pixel_format_info<T>& info) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("pixel_format_info{{data: {}, name: {}}}",
                     detail::address_of(info.get()),
                     info.name());
#else
  return "pixel_format_info{data: " + detail::address_of(info.get()) +
         ", name: " + info.name() + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a pixel format info instance.
 *
 * \tparam T the ownership semantics tag.
 *
 * \param stream the output stream that will be used.
 * \param info the pixel format info that will be printed.
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_pixel_format_info<T>& info) -> std::ostream&
{
  return stream << to_string(info);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_PIXEL_FORMAT_INFO_HEADER

// #include "centurion/video/renderer.hpp"
#ifndef CENTURION_RENDERER_HEADER
#define CENTURION_RENDERER_HEADER

#include <SDL.h>

#include <cassert>        // assert
#include <cmath>          // floor, sqrt
#include <memory>         // unique_ptr
#include <optional>       // optional
#include <ostream>        // ostream
#include <string>         // string
#include <type_traits>    // conditional_t
#include <unordered_map>  // unordered_map
#include <utility>        // move, forward, pair

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/integers.hpp"

// #include "../core/not_null.hpp"

// #include "../core/owner.hpp"

// #include "../core/result.hpp"

// #include "../core/str.hpp"

// #include "../detail/address_of.hpp"

// #include "../detail/convert_bool.hpp"

// #include "../detail/owner_handle_api.hpp"

// #include "../math/rect.hpp"

// #include "blend_mode.hpp"

// #include "color.hpp"

// #include "colors.hpp"

// #include "font.hpp"

// #include "font_cache.hpp"
#ifndef CENTURION_FONT_CACHE_HEADER
#define CENTURION_FONT_CACHE_HEADER

#ifndef CENTURION_NO_SDL_TTF

#include <SDL_ttf.h>

#include <cassert>        // assert
#include <string>         // string
#include <unordered_map>  // unordered_map
#include <utility>        // move, forward

// #include "../core/not_null.hpp"

// #include "../core/str.hpp"

// #include "font.hpp"

// #include "surface.hpp"

// #include "texture.hpp"

// #include "unicode_string.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \class font_cache
 *
 * \brief Provides an API that enables efficient font rendering.
 *
 * \details This class provides two different optimizations.
 *
 * Firstly, this class can be used to cache glyph textures that can then be used to render
 * strings, by simply looking up the individual glyphs and rendering the existing
 * textures. Note, this will not result in accurate kerning. However, this might not be
 * noticeable and/or worth the performance boost. This approach is *very* efficient for
 * rendering pieces of text that frequently changes, since other approaches would require
 * dynamic allocation and de-allocation for every new rendered string.
 *
 * Secondly, it's possible to cache complete strings and associate them with a
 * user-provided identifier. In contrast with the first approach, this will result in
 * accurate kerning. The only problem is that it's hard to know the exact strings you will
 * render at compile-time. Use this option if you know that you're going to render some
 * specific string a lot.
 *
 * \since 5.0.0
 */
class font_cache final
{
 public:
  using id_type = std::size_t;

  /**
   * \struct glyph_data
   *
   * \brief Simple aggregate that contains a texture and metrics for a glyph.
   *
   * \since 5.0.0
   */
  struct glyph_data final
  {
    texture cached;         ///< The cached texture.
    glyph_metrics metrics;  ///< The metrics of the glyph.
  };

  /// \name Construction
  /// \{

  /**
   * \brief Creates an empty font cache instance.
   *
   * \note You have to explicitly state what glyphs that you want to be cached.
   *
   * \param font the font that will be used.
   *
   * \since 5.0.0
   */
  explicit font_cache(font&& font) noexcept : m_font{std::move(font)}
  {}

  /**
   * \brief Creates an empty font cache, and creates the associated font in-place.
   *
   * \note This constructor throws whatever exceptions that the `font` constructor might
   * throw.
   *
   * \tparam Args the types of the arguments forwarded to the font constructor.
   *
   * \param args the arguments that will be forwarded to the font constructor.
   *
   * \since 5.0.0
   */
  template <typename... Args>
  explicit font_cache(Args&&... args) : m_font{std::forward<Args>(args)...}
  {}

  /// \} End of construction

  /// \name String texture caching
  /// \{

  /**
   * \brief Caches the supplied string by rendering it to a texture.
   *
   * \details This function respects the kerning of the font. Any previous cached string
   * associated with the supplied ID will be overwritten.
   *
   * \tparam Renderer the type of the renderer that will be used.
   *
   * \param id the identifier that will be associated with the texture.
   * \param string the string that will be cached.
   * \param renderer the renderer that will be used to create the string texture.
   *
   * \see `basic_renderer::render_blended_utf8()`
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void store_blended_utf8(const id_type id, const not_null<str> string, Renderer& renderer)
  {
    assert(string);
    store(id, renderer.render_blended_utf8(string, get_font()));
  }

  /**
   * \see store_blended_utf8()
   * \since 5.3.0
   */
  template <typename Renderer>
  void store_blended_utf8(const id_type id, const std::string& string, Renderer& renderer)
  {
    store_blended_utf8(id, string.c_str(), renderer);
  }

  /**
   * \brief Caches the supplied string by rendering it to a texture.
   *
   * \details This function respects the kerning of the font. Any previous cached string
   * associated with the supplied ID will be overwritten.
   *
   * \tparam Renderer the type of the renderer that will be used.
   *
   * \param id the identifier that will be associated with the texture.
   * \param string the string that will be cached.
   * \param renderer the renderer that will be used to create the string texture.
   * \param wrap the width in pixels after which the text will be wrapped.
   *
   * \see `basic_renderer::render_blended_wrapped_utf8()`
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void store_blended_wrapped_utf8(const id_type id,
                                  const not_null<str> string,
                                  Renderer& renderer,
                                  const u32 wrap)
  {
    assert(string);
    store(id, renderer.render_blended_wrapped_utf8(string, get_font(), wrap));
  }

  /**
   * \see store_blended_wrapped_utf8()
   * \since 5.3.0
   */
  template <typename Renderer>
  void store_blended_wrapped_utf8(const id_type id,
                                  const std::string& string,
                                  Renderer& renderer,
                                  const u32 wrap)
  {
    store_blended_wrapped_utf8(id, string.c_str(), renderer, wrap);
  }

  /**
   * \brief Caches the supplied string by rendering it to a texture.
   *
   * \details This function respects the kerning of the font. Any previous cached string
   * associated with the supplied ID will be overwritten.
   *
   * \tparam Renderer the type of the renderer that will be used.
   *
   * \param id the identifier that will be associated with the texture.
   * \param string the string that will be cached.
   * \param renderer the renderer that will be used to create the string texture.
   * \param background the color used for the background box.
   *
   * \see `basic_renderer::render_shaded_utf8()`
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void store_shaded_utf8(const id_type id,
                         const not_null<str> string,
                         Renderer& renderer,
                         const color& background)
  {
    assert(string);
    store(id, renderer.render_shaded_utf8(string, get_font(), background));
  }

  /**
   * \see store_shaded_utf8()
   * \since 5.3.0
   */
  template <typename Renderer>
  void store_shaded_utf8(const id_type id,
                         const std::string& string,
                         Renderer& renderer,
                         const color& background)
  {
    store_shaded_utf8(id, string.c_str(), renderer, background);
  }

  /**
   * \brief Caches the supplied string by rendering it to a texture.
   *
   * \details This function respects the kerning of the font. Any previous cached string
   * associated with the supplied ID will be overwritten.
   *
   * \tparam Renderer the type of the renderer that will be used.
   *
   * \param id the identifier that will be associated with the texture.
   * \param string the string that will be cached.
   * \param renderer the renderer that will be used to create the string texture.
   *
   * \see `basic_renderer::render_solid_utf8()`
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void store_solid_utf8(const id_type id, const not_null<str> string, Renderer& renderer)
  {
    assert(string);
    store(id, renderer.render_solid_utf8(string, get_font()));
  }

  /**
   * \see store_solid_utf8()
   * \since 5.3.0
   */
  template <typename Renderer>
  void store_solid_utf8(const id_type id, const std::string& string, Renderer& renderer)
  {
    store_solid_utf8(id, string.c_str(), renderer);
  }

  /**
   * \brief Caches the supplied string by rendering it to a texture.
   *
   * \details This function respects the kerning of the font. Any previous cached string
   * associated with the supplied ID will be overwritten.
   *
   * \tparam Renderer the type of the renderer that will be used.
   *
   * \param id the identifier that will be associated with the texture.
   * \param string the string that will be cached.
   * \param renderer the renderer that will be used to create the string texture.
   *
   * \see `basic_renderer::render_blended_latin1()`
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void store_blended_latin1(const id_type id, const not_null<str> string, Renderer& renderer)
  {
    assert(string);
    store(id, renderer.render_blended_latin1(string, get_font()));
  }

  /**
   * \see store_blended_latin1()
   * \since 5.3.0
   */
  template <typename Renderer>
  void store_blended_latin1(const id_type id, const std::string& string, Renderer& renderer)
  {
    store_blended_latin1(id, string.c_str(), renderer);
  }

  /**
   * \brief Caches the supplied string by rendering it to a texture.
   *
   * \details This function respects the kerning of the font. Any previous cached string
   * associated with the supplied ID will be overwritten.
   *
   * \tparam Renderer the type of the renderer that will be used.
   *
   * \param id the identifier that will be associated with the texture.
   * \param string the string that will be cached.
   * \param renderer the renderer that will be used to create the string texture.
   * \param wrap the width in pixels after which the text will be wrapped.
   *
   * \see `basic_renderer::render_blended_wrapped_latin1()`
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void store_blended_wrapped_latin1(const id_type id,
                                    const not_null<str> string,
                                    Renderer& renderer,
                                    const u32 wrap)
  {
    assert(string);
    store(id, renderer.render_blended_wrapped_latin1(string, get_font(), wrap));
  }

  /**
   * \see store_blended_wrapped_latin1()
   * \since 5.3.0
   */
  template <typename Renderer>
  void store_blended_wrapped_latin1(const id_type id,
                                    const std::string& string,
                                    Renderer& renderer,
                                    const u32 wrap)
  {
    store_blended_wrapped_latin1(id, string.c_str(), renderer, wrap);
  }

  /**
   * \brief Caches the supplied string by rendering it to a texture.
   *
   * \details This function respects the kerning of the font. Any previous cached string
   * associated with the supplied ID will be overwritten.
   *
   * \tparam Renderer the type of the renderer that will be used.
   *
   * \param id the identifier that will be associated with the texture.
   * \param string the string that will be cached.
   * \param renderer the renderer that will be used to create the string texture.
   * \param background the color used for the background box.
   *
   * \see `basic_renderer::render_shaded_latin1()`
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void store_shaded_latin1(const id_type id,
                           const not_null<str> string,
                           Renderer& renderer,
                           const color& background)
  {
    assert(string);
    store(id, renderer.render_shaded_latin1(string, get_font(), background));
  }

  /**
   * \see store_shaded_latin1()
   * \since 5.3.0
   */
  template <typename Renderer>
  void store_shaded_latin1(const id_type id,
                           const std::string& string,
                           Renderer& renderer,
                           const color& background)
  {
    store_shaded_latin1(id, string.c_str(), renderer, background);
  }

  /**
   * \brief Caches the supplied string by rendering it to a texture.
   *
   * \details This function respects the kerning of the font. Any previous cached string
   * associated with the supplied ID will be overwritten.
   *
   * \tparam Renderer the type of the renderer that will be used.
   *
   * \param id the identifier that will be associated with the texture.
   * \param string the string that will be cached.
   * \param renderer the renderer that will be used to create the string texture.
   *
   * \see `basic_renderer::render_solid_latin1()`
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void store_solid_latin1(const id_type id, const not_null<str> string, Renderer& renderer)
  {
    assert(string);
    store(id, renderer.render_solid_latin1(string, get_font()));
  }

  /**
   * \see store_solid_latin1()
   * \since 5.3.0
   */
  template <typename Renderer>
  void store_solid_latin1(const id_type id, const std::string& string, Renderer& renderer)
  {
    store_solid_latin1(id, string.c_str(), renderer);
  }

  /**
   * \brief Caches the supplied string by rendering it to a texture.
   *
   * \details This function respects the kerning of the font. Any previous cached string
   * associated with the supplied ID will be overwritten.
   *
   * \tparam Renderer the type of the renderer that will be used.
   *
   * \param id the identifier that will be associated with the texture.
   * \param string the string that will be cached.
   * \param renderer the renderer that will be used to create the string texture.
   *
   * \see `basic_renderer::render_blended_unicode()`
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void store_blended_unicode(const id_type id,
                             const unicode_string& string,
                             Renderer& renderer)
  {
    store(id, renderer.render_blended_unicode(string, get_font()));
  }

  /**
   * \brief Caches the supplied string by rendering it to a texture.
   *
   * \details This function respects the kerning of the font. Any previous cached string
   * associated with the supplied ID will be overwritten.
   *
   * \tparam Renderer the type of the renderer that will be used.
   *
   * \param id the identifier that will be associated with the texture.
   * \param string the string that will be cached.
   * \param renderer the renderer that will be used to create the string texture.
   * \param wrap the width in pixels after which the text will be wrapped.
   *
   * \see `basic_renderer::render_blended_wrapped_unicode()`
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void store_blended_wrapped_unicode(const id_type id,
                                     const unicode_string& string,
                                     Renderer& renderer,
                                     const u32 wrap)
  {
    store(id, renderer.render_blended_wrapped_unicode(string, get_font(), wrap));
  }

  /**
   * \brief Caches the supplied string by rendering it to a texture.
   *
   * \details This function respects the kerning of the font. Any previous cached string
   * associated with the supplied ID will be overwritten.
   *
   * \tparam Renderer the type of the renderer that will be used.
   *
   * \param id the identifier that will be associated with the texture.
   * \param string the string that will be cached.
   * \param renderer the renderer that will be used to create the string texture.
   * \param background the color used for the background box.
   *
   * \see `basic_renderer::render_shaded_unicode()`
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void store_shaded_unicode(const id_type id,
                            const unicode_string& string,
                            Renderer& renderer,
                            const color& background)
  {
    store(id, renderer.render_shaded_unicode(string, get_font(), background));
  }

  /**
   * \brief Caches the supplied string by rendering it to a texture.
   *
   * \details This function respects the kerning of the font. Any previous cached string
   * associated with the supplied ID will be overwritten.
   *
   * \tparam Renderer the type of the renderer that will be used.
   *
   * \param id the identifier that will be associated with the texture.
   * \param string the string that will be cached.
   * \param renderer the renderer that will be used to create the string texture.
   *
   * \see `basic_renderer::render_solid_unicode()`
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void store_solid_unicode(const id_type id, const unicode_string& string, Renderer& renderer)
  {
    store(id, renderer.render_solid_unicode(string, get_font()));
  }

  /**
   * \brief Indicates whether or not there is a cached string texture associated with the
   * specified key.
   *
   * \param id the key that will be checked.
   *
   * \return `true` if there is a cached texture associated with the key; `false`
   * otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto has_stored(const id_type id) const noexcept -> bool
  {
    return m_strings.find(id) != m_strings.end();
  }

  /**
   * \brief Returns the cached texture associated with the specified ID.
   *
   * \pre `id` **must** be associated with a cached string texture.
   *
   * \param id the key of the cached texture to obtain.
   *
   * \return the cached texture associated with the key.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get_stored(const id_type id) const -> const texture&
  {
    return m_strings.at(id);
  }

  /**
   * \brief Returns a pointer to the texture associated with the specified key.
   *
   * \note The returned pointer is not suitable for storing for longer than absolutely
   * necessary, as it might get invalidated by modifications of the font cache.
   *
   * \param id the key of the desired texture.
   *
   * \return a pointer to the texture associated with the specified key; `nullptr` if no
   * texture is found.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto try_get_stored(const id_type id) const noexcept -> const texture*
  {
    const auto iterator = m_strings.find(id);
    if (iterator != m_strings.end()) {
      return &iterator->second;
    }
    else {
      return nullptr;
    }
  }

  /// \} End of string texture caching

  /// \name Glyph texture caching
  /// \{

  /**
   * \brief Adds a glyph to the font cache.
   *
   * \details This function has no effect if the supplied glyph isn't provided by the
   * associated font, or if the supplied glyph has already been cached.
   *
   * \tparam Renderer the type of the renderer.
   *
   * \param renderer the renderer that will be used to create the glyph texture.
   * \param glyph the glyph that will be cached.
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void add_glyph(Renderer& renderer, const unicode glyph)
  {
    if (has(glyph) || !m_font.is_glyph_provided(glyph)) {
      return;
    }

    glyph_data data{create_glyph_texture(renderer, glyph), m_font.get_metrics(glyph).value()};
    m_glyphs.try_emplace(glyph, std::move(data));
  }

  /**
   * \brief Caches the glyphs in the specified range.
   *
   * \details The range is interpreted as [min, max), i.e. the the `min` value is
   * included, and `max` is excluded.
   *
   * \remark For an overview of the various Unicode blocks, see <a
   * href="https://unicode-table.com/en/blocks/">this</a>.
   *
   * \tparam Renderer the type of the renderer.
   *
   * \param renderer the renderer that will be used to create the glyph textures.
   * \param begin the first glyph that will be included.
   * \param end the "end" glyph in the range, will not be included.
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void add_range(Renderer& renderer, const unicode begin, const unicode end)
  {
    for (auto ch = begin; ch < end; ++ch) {
      add_glyph(renderer, ch);
    }
  }

  /**
   * \brief Attempts to cache all printable basic latin characters.
   *
   * \details The basic latin set provides the most common characters, such as upper- and
   * lower-case latin letters, numbers and symbols. This function might throw if something
   * goes wrong when creating the textures.
   *
   * \tparam Renderer the type of the renderer.
   *
   * \param renderer the renderer that will be used to create the glyph textures.
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void add_basic_latin(Renderer& renderer)
  {
    // https://unicode-table.com/en/blocks/basic-latin/
    add_range(renderer, 0x20, 0x7F);
  }

  /**
   * \brief Attempts to cache all printable Latin-1 supplement characters.
   *
   * \tparam Renderer the type of the renderer.
   *
   * \param renderer the renderer that will be used to create the glyph textures.
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void add_latin1_supplement(Renderer& renderer)
  {
    // https://unicode-table.com/en/blocks/latin-1-supplement/
    add_range(renderer, 0xA0, 0x100);
  }

  /**
   * \brief Attempts to cache all printable Latin-1 characters.
   *
   * \note This function is effectively equivalent to calling both `add_basic_latin` and
   * `add_latin1_supplement`.
   *
   * \tparam Renderer the type of the renderer.
   *
   * \param renderer the renderer that will be used to create the glyph textures.
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  void add_latin1(Renderer& renderer)
  {
    add_basic_latin(renderer);
    add_latin1_supplement(renderer);
  }

  /**
   * \brief Indicates whether or not the specified glyph has been cached.
   *
   * \param glyph the glyph to check.
   *
   * \return `true` if the specified glyph has been cached; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto has(const unicode glyph) const noexcept -> bool
  {
    return m_glyphs.count(glyph);
  }

  /**
   * \brief Returns the data associated with the specified glyph.
   *
   * \pre `glyph` **must** have been previously cached.
   *
   * \param glyph the desired glyph to lookup the data for.
   *
   * \return the cached texture and metrics associated with the glyph.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto at(const unicode glyph) const -> const glyph_data&
  {
    return m_glyphs.at(glyph);
  }

  /**
   * \brief Returns the data associated with the specified glyph.
   *
   * \note This function is equivalent to calling `at`.
   *
   * \pre `glyph` **must** have been previously cached.
   *
   * \param glyph the desired glyph to lookup the data for.
   *
   * \return the cached texture and metrics associated with the glyph.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto operator[](unicode glyph) const -> const glyph_data&
  {
    return at(glyph);
  }

  /**
   * \brief Returns the data associated with the specified glyph, if it exists.
   *
   * \details This function is a non-throwing alternative to the `at()` and `operator[]`
   * functions.
   *
   * \note Do not store the returned pointer for longer than absolutely necessary, it may
   * get invalidated upon modification of the font cache.
   *
   * \param glyph the desired glyph to lookup the data for.
   *
   * \return a pointer to the associated glyph data; a null pointer if no matching data
   * was found.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto try_at(const unicode glyph) const -> const glyph_data*
  {
    if (const auto it = m_glyphs.find(glyph); it != m_glyphs.end()) {
      return &it->second;
    }
    else {
      return nullptr;
    }
  }

  /// \} End of glyph texture caching

  /**
   * \brief Returns the font used by the cache.
   *
   * \return a reference to the internal font.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get_font() noexcept -> font&
  {
    return m_font;
  }

  /**
   * \copydoc get_font
   */
  [[nodiscard]] auto get_font() const noexcept -> const font&
  {
    return m_font;
  }

 private:
  font m_font;
  std::unordered_map<unicode, glyph_data> m_glyphs;
  std::unordered_map<id_type, texture> m_strings;

  /**
   * \brief Creates and returns a texture for the specified glyph.
   *
   * \details The glyph is rendered with `TTF_RenderGlyph_Blended`.
   *
   * \param renderer the renderer that will be used.
   * \param glyph the Unicode glyph that will be rendered.
   *
   * \return a texture that represents the specified glyph.
   *
   * \since 5.0.0
   */
  template <typename Renderer>
  [[nodiscard]] auto create_glyph_texture(Renderer& renderer, const unicode glyph) -> texture
  {
    const auto color = renderer.get_color().get();
    const surface src{TTF_RenderGlyph_Blended(m_font.get(), glyph, color)};
    return texture{renderer, src};
  }

  void store(const id_type id, texture&& texture)
  {
    if (const auto it = m_strings.find(id); it != m_strings.end()) {
      m_strings.erase(it);
    }
    m_strings.try_emplace(id, std::move(texture));
  }
};

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_NO_SDL_TTF
#endif  // CENTURION_FONT_CACHE_HEADER
// #include "surface.hpp"

// #include "texture.hpp"

// #include "unicode_string.hpp"


namespace cen {

/// \addtogroup video
/// \{

template <typename T>
class basic_renderer;

/**
 * \typedef renderer
 *
 * \brief Represents an owning renderer.
 *
 * \since 5.0.0
 */
using renderer = basic_renderer<detail::owning_type>;

/**
 * \typedef renderer_handle
 *
 * \brief Represents a non-owning renderer.
 *
 * \since 5.0.0
 */
using renderer_handle = basic_renderer<detail::handle_type>;

/**
 * \class basic_renderer
 *
 * \brief Provides 2D-rendering that is potentially hardware-accelerated.
 *
 * \ownerhandle `renderer`/`renderer_handle`
 *
 * \details Rendering primitives such as points, rectangles, lines and circles are
 * supported. The owning version of this class, `renderer`, features an extended API
 * compared to its non-owning counterpart, with support for font handling and translated
 * rendering.
 *
 * \details Three different text encodings are supported: UTF-8, Latin-1 and Unicode. Each
 * of these encodings can be rendered in four different styles: "blended", "shaded",
 * "solid" and "blended and wrapped". All of the text rendering functions feature the same
 * names except for a distinguishing suffix, i.e. `_utf8`, `_latin1` or `_unicode`.
 *   - Blended: The best looking option but also the slowest. Uses anti-aliasing.
 *   - Blended and wrapped: Same as blended, but the text will be wrapped to fit a
 *     specified width.
 *   - Solid: The fastest option. Doesn't use anti-aliasing so it will look a bit harsh.
 *   - Shaded: The same as blended, but with a colored rectangle behind it.
 *
 * \note Each window can feature at most one associated renderer.
 *
 * \since 5.0.0
 *
 * \see `renderer`
 * \see `renderer_handle`
 * \see `renderer_info`
 * \see `get_renderer()`
 * \see `make_window_and_renderer()`
 */
template <typename T>
class basic_renderer final
{
 public:
  /**
   * \enum renderer_flags
   *
   * \brief Represents different renderer features.
   *
   * \details Values of this enum are intended to be used to create flag bitmasks, that
   * can be used when creating renderers.
   *
   * \see `SDL_RendererFlags`
   *
   * \since 6.0.0
   */
  enum renderer_flags : u32
  {
    software = SDL_RENDERER_SOFTWARE,              ///< Software renderer
    accelerated = SDL_RENDERER_ACCELERATED,        ///< Hardware-accelerated
    target_textures = SDL_RENDERER_TARGETTEXTURE,  ///< Supports target textures
    vsync = SDL_RENDERER_PRESENTVSYNC              ///< Renderer Uses VSync
  };

  /// \name Construction
  /// \{

  // clang-format off

  /**
   * \brief Creates a renderer based on a pointer to an SDL renderer.
   *
   * \note The supplied pointer will be claimed by the renderer if the created renderer is owning.
   *
   * \param renderer a pointer to the associated SDL renderer.
   *
   * \since 3.0.0
   */
  explicit basic_renderer(maybe_owner<SDL_Renderer*> renderer) noexcept(!detail::is_owning<T>())
      : m_renderer{renderer}
  {
    if constexpr (detail::is_owning<T>())
    {
      if (!get())
      {
        throw cen_error{"Cannot create renderer from null pointer!"};
      }
    }
  }

  // clang-format on

  /**
   * \brief Creates an owning renderer based on the supplied window.
   *
   * \param window the associated window instance.
   * \param flags the renderer flags that will be used, see `renderer_flags`.
   *
   * \throws sdl_error if something goes wrong when creating the renderer.
   *
   * \since 4.0.0
   */
  template <typename Window, typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_renderer(const Window& window, const u32 flags = default_flags())
      : m_renderer{SDL_CreateRenderer(window.get(), -1, flags)}
  {
    if (!get()) {
      throw sdl_error{};
    }
  }

  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit basic_renderer(const renderer& owner) noexcept : m_renderer{owner.get()}
  {}

  /// \} End of construction

  /**
   * \brief Clears the rendering target with the currently selected color.
   *
   * \return `success` if the rendering target was successfully cleared; `failure`
   * otherwise.
   *
   * \since 3.0.0
   */
  auto clear() noexcept -> result
  {
    return SDL_RenderClear(get()) == 0;
  }

  /**
   * \brief Clears the rendering target with the specified color.
   *
   * \note This function doesn't change the currently selected color.
   *
   * \param color the color that will be used to clear the rendering target.
   *
   * \since 5.0.0
   */
  void clear_with(const color& color) noexcept
  {
    const auto oldColor = get_color();
    set_color(color);

    clear();
    set_color(oldColor);
  }

  /**
   * \brief Applies the previous rendering calls to the rendering target.
   *
   * \since 3.0.0
   */
  void present() noexcept
  {
    SDL_RenderPresent(get());
  }

  /**
   * \brief Captures a snapshot of the current rendering target as a surface.
   *
   * \note The correct pixel format supplied to this function can easily be obtained using
   * the `basic_window::get_pixel_format()` function.
   *
   * \param format the pixel format that will be used by the surface.
   *
   * \return a surface that mirrors the pixel data of the current render target.
   *
   * \throws sdl_error if something goes wrong.
   *
   * \since 5.3.0
   */
  [[nodiscard]] auto capture(const pixel_format format) const -> surface
  {
    surface image{output_size(), format};

    if (!image.lock()) {
      throw sdl_error{};
    }

    if (SDL_RenderReadPixels(get(), nullptr, 0, image.pixels(), image.pitch()) == -1) {
      throw sdl_error{};
    }

    image.unlock();
    return image;
  }

  /// \name Primitive rendering
  /// \{

  /**
   * \brief Fills the entire rendering target with the currently selected color.
   *
   * \details This function is different from `clear()` and `clear_with()` in that it can
   * be used as an intermediate rendering command (just like all rendering functions). An
   * example of a use case of this function could be for rendering a transparent
   * background for game menus.
   *
   * \since 5.1.0
   */
  void fill() noexcept
  {
    fill_rect<int>({{}, output_size()});
  }

  /**
   * \brief Fills the entire rendering target with the specified color.
   *
   * \note This function does not affect the currently set color.
   *
   * \copydetails fill()
   */
  void fill_with(const color& color) noexcept
  {
    const auto oldColor = get_color();

    set_color(color);
    fill();

    set_color(oldColor);
  }

  /**
   * \brief Renders the outline of a rectangle in the currently selected color.
   *
   * \tparam U the representation type used by the rectangle.
   *
   * \param rect the rectangle that will be rendered.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename U>
  auto draw_rect(const basic_rect<U>& rect) noexcept -> result
  {
    if constexpr (basic_rect<U>::isIntegral) {
      return SDL_RenderDrawRect(get(), rect.data()) == 0;
    }
    else {
      return SDL_RenderDrawRectF(get(), rect.data()) == 0;
    }
  }

  /**
   * \brief Renders a filled rectangle in the currently selected color.
   *
   * \tparam U the representation type used by the rectangle.
   *
   * \param rect the rectangle that will be rendered.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename U>
  auto fill_rect(const basic_rect<U>& rect) noexcept -> result
  {
    if constexpr (basic_rect<U>::isIntegral) {
      return SDL_RenderFillRect(get(), rect.data()) == 0;
    }
    else {
      return SDL_RenderFillRectF(get(), rect.data()) == 0;
    }
  }

  /**
   * \brief Renders a line between the supplied points, in the currently selected color.
   *
   * \tparam U The representation type used by the points.
   *
   * \param start the start point of the line.
   * \param end the end point of the line.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename U>
  auto draw_line(const basic_point<U>& start, const basic_point<U>& end) noexcept -> result
  {
    if constexpr (basic_point<U>::isIntegral) {
      return SDL_RenderDrawLine(get(), start.x(), start.y(), end.x(), end.y()) == 0;
    }
    else {
      return SDL_RenderDrawLineF(get(), start.x(), start.y(), end.x(), end.y()) == 0;
    }
  }

  /**
   * \brief Renders a collection of lines.
   *
   * \details This function requires the the `Container` type provides the public member
   * `value_type` and subsequently, that the `value_type` in turn provides a `value_type`
   * member. The former would correspond to the actual point type, and the latter
   * corresponds to either `int` or `float`.
   *
   * \warning `Container` *must* be a collection that stores its data contiguously! The
   * behaviour of this function is undefined if this condition isn't met.
   *
   * \tparam Container the container type. Must store its elements contiguously, such as
   * `std::vector` or `std::array`.
   *
   * \param container the container that holds the points that will be used to render the
   * line.
   *
   * \return `success` if the lines were successfully rendered; `failure` otherwise.
   *
   * \since 5.0.0
   */
  template <typename Container>
  auto draw_lines(const Container& container) noexcept -> result
  {
    using point_t = typename Container::value_type;  // a point of int or float
    using value_t = typename point_t::value_type;    // either int or float

    if (!container.empty()) {
      const auto& front = container.front();
      const auto* first = front.data();

      if constexpr (std::is_same_v<value_t, int>) {
        return SDL_RenderDrawLines(get(), first, isize(container)) == 0;
      }
      else {
        return SDL_RenderDrawLinesF(get(), first, isize(container)) == 0;
      }
    }
    else {
      return failure;
    }
  }

  /**
   * \brief Renders a point using the currently selected color.
   *
   * \tparam U the representation type used by the point.
   *
   * \param point the point that will be rendered.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 6.0.0
   */
  template <typename U>
  auto draw_point(const basic_point<U>& point) noexcept -> result
  {
    if constexpr (basic_point<U>::isIntegral) {
      return SDL_RenderDrawPoint(get(), point.x(), point.y()) == 0;
    }
    else {
      return SDL_RenderDrawPointF(get(), point.x(), point.y()) == 0;
    }
  }

  /**
   * \brief Renders a circle using the currently selected color.
   *
   * \tparam U the representation type used by the point.
   *
   * \param position the position of the rendered circle.
   * \param radius the radius of the rendered circle.
   *
   * \since 6.0.0
   */
  template <typename U>
  void draw_circle(const basic_point<U>& position, const float radius) noexcept
  {
    using value_t = typename basic_point<U>::value_type;

    auto error = -radius;
    auto x = radius - 0.5f;
    auto y = 0.5f;

    const auto cx = static_cast<float>(position.x()) - 0.5f;
    const auto cy = static_cast<float>(position.y()) - 0.5f;

    while (x >= y) {
      draw_point<value_t>({static_cast<value_t>(cx + x), static_cast<value_t>(cy + y)});
      draw_point<value_t>({static_cast<value_t>(cx + y), static_cast<value_t>(cy + x)});

      if (x != 0) {
        draw_point<value_t>({static_cast<value_t>(cx - x), static_cast<value_t>(cy + y)});
        draw_point<value_t>({static_cast<value_t>(cx + y), static_cast<value_t>(cy - x)});
      }

      if (y != 0) {
        draw_point<value_t>({static_cast<value_t>(cx + x), static_cast<value_t>(cy - y)});
        draw_point<value_t>({static_cast<value_t>(cx - y), static_cast<value_t>(cy + x)});
      }

      if (x != 0 && y != 0) {
        draw_point<value_t>({static_cast<value_t>(cx - x), static_cast<value_t>(cy - y)});
        draw_point<value_t>({static_cast<value_t>(cx - y), static_cast<value_t>(cy - x)});
      }

      error += y;
      ++y;
      error += y;

      if (error >= 0) {
        --x;
        error -= x;
        error -= x;
      }
    }
  }

  /**
   * \brief Renders a filled circle using the currently selected color.
   *
   * \param center the position of the rendered circle.
   * \param radius the radius of the rendered circle.
   *
   * \since 6.0.0
   */
  void fill_circle(const fpoint center, const float radius)
  {
    const auto cx = center.x();
    const auto cy = center.y();

    for (auto dy = 1.0f; dy <= radius; dy += 1.0f) {
      const auto dx = std::floor(std::sqrt((2.0f * radius * dy) - (dy * dy)));
      draw_line<float>({cx - dx, cy + dy - radius}, {cx + dx, cy + dy - radius});
      draw_line<float>({cx - dx, cy - dy + radius}, {cx + dx, cy - dy + radius});
    }
  }

  /// \} End of primitive rendering

  /// \name Translated primitive rendering
  /// \{

  /**
   * \brief Renders an outlined rectangle in the currently selected color.
   *
   * \details The rendered rectangle will be translated using the current translation
   * viewport.
   *
   * \tparam R the representation type used by the rectangle.
   *
   * \param rect the rectangle that will be rendered.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.1.0
   */
  template <typename R, typename TT = T, detail::is_owner<TT> = 0>
  auto draw_rect_t(const basic_rect<R>& rect) noexcept -> result
  {
    return draw_rect(translate(rect));
  }

  /**
   * \brief Renders a filled rectangle in the currently selected color.
   *
   * \details The rendered rectangle will be translated using the current translation
   * viewport.
   *
   * \tparam R the representation type used by the rectangle.
   *
   * \param rect the rectangle that will be rendered.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.1.0
   */
  template <typename R, typename TT = T, detail::is_owner<TT> = 0>
  auto fill_rect_t(const basic_rect<R>& rect) noexcept -> result
  {
    return fill_rect(translate(rect));
  }

  /**
   * \brief Renders a point using the currently selected color.
   *
   * \details The rendered point will be translated using the current translation
   * viewport.
   *
   * \tparam U the representation
   *
   * \param point the point that will be rendered.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 6.0.0
   */
  template <typename U, typename TT = T, detail::is_owner<TT> = 0>
  auto draw_point_t(const basic_point<U>& point) noexcept -> result
  {
    return draw_point(translate(point));
  }

  /**
   * \brief Renders a circle with the currently selected color.
   *
   * \details The rendered circle will be translated using the current translation
   * viewport.
   *
   * \tparam U the precision used by the point.
   *
   * \param position the position of the rendered circle.
   * \param radius the radius of the rendered circle.
   *
   * \since 6.0.0
   */
  template <typename U, typename TT = T, detail::is_owner<TT> = 0>
  void draw_circle_t(const basic_point<U>& position, const float radius) noexcept
  {
    draw_circle(translate(position), radius);
  }

  /**
   * \brief Renders a filled circle with the currently selected color.
   *
   * \details The rendered circle will be translated using the current translation
   * viewport.
   *
   * \param center the center of the rendered circle.
   * \param radius the radius of the rendered circle.
   *
   * \since 6.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  void fill_circle_t(const fpoint center, const float radius)
  {
    fill_circle(translate(center), radius);
  }

  /// \} End of translated primitive rendering

  /// \name Text rendering
  /// \{

#ifndef CENTURION_NO_SDL_TTF

  /**
   * \brief Creates and returns a texture of blended UTF-8 text.
   *
   * \pre `str` can't be null.
   *
   * \details Attempts to render the UTF-8 text in the supplied font using the currently
   * selected color and returns a texture that contains the result. Use the returned
   * texture to actually render the text to the screen.
   *
   * This function renders the text at the highest quality and uses anti-aliasing. Use
   * this when you want high quality text, but beware that this is the slowest
   * alternative.
   *
   * \param str the UTF-8 text that will be rendered.
   * \param font the font that the text will be rendered in.
   *
   * \return a texture that contains the rendered text.
   *
   * \see `TTF_RenderUTF8_Blended`
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto render_blended_utf8(const not_null<str> str, const font& font) -> texture
  {
    assert(str);
    return render_text(TTF_RenderUTF8_Blended(font.get(), str, get_color().get()));
  }

  /**
   * \see render_blended_utf8()
   * \since 5.3.0
   */
  [[nodiscard]] auto render_blended_utf8(const std::string& str, const font& font) -> texture
  {
    return render_blended_utf8(str.c_str(), font);
  }

  /**
   * \brief Creates and returns a texture of blended and wrapped UTF-8 text.
   *
   * \pre `str` can't be null.
   *
   * \details Attempts to render the UTF-8 text in the supplied font using the currently
   * selected color and returns a texture that contains the result. Use the returned
   * texture to actually render the text to the screen.
   *
   * This function renders the text at the highest quality and uses anti-aliasing. Use
   * this when you want high quality text, but beware that this is the slowest
   * alternative. This function will wrap the supplied text to fit the specified width.
   * Furthermore, you can also manually control the line breaks by inserting newline
   * characters at the desired breakpoints.
   *
   * \param str the UTF-8 text that will be rendered. You can insert newline characters in
   * the string to indicate breakpoints.
   * \param font the font that the text will be rendered in.
   * \param wrap the width in pixels after which the text will be wrapped.
   *
   * \return a texture that contains the rendered text.
   *
   * \see `TTF_RenderUTF8_Blended_Wrapped`
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto render_blended_wrapped_utf8(const not_null<str> str,
                                                 const font& font,
                                                 const u32 wrap) -> texture
  {
    assert(str);
    return render_text(
        TTF_RenderUTF8_Blended_Wrapped(font.get(), str, get_color().get(), wrap));
  }

  /**
   * \see render_blended_wrapped_utf8()
   * \since 5.3.0
   */
  [[nodiscard]] auto render_blended_wrapped_utf8(const std::string& str,
                                                 const font& font,
                                                 const u32 wrap) -> texture
  {
    return render_blended_wrapped_utf8(str.c_str(), font, wrap);
  }

  /**
   * \brief Creates and returns a texture of shaded UTF-8 text.
   *
   * \pre `str` can't be null.
   *
   * \details Attempts to render the UTF-8 text in the supplied font using the currently
   * selected color and returns a texture that contains the result. Use the returned
   * texture to actually render the text to the screen.
   *
   * This function renders the text using anti-aliasing and with a box behind the text.
   * This alternative is probably a bit slower than rendering solid text but about as fast
   * as blended text. Use this function when you want nice text, and can live with a box
   * around it.
   *
   * \param str the UTF-8 text that will be rendered.
   * \param font the font that the text will be rendered in.
   * \param background the background color used for the box.
   *
   * \return a texture that contains the rendered text.
   *
   * \see `TTF_RenderUTF8_Shaded`
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto render_shaded_utf8(const not_null<str> str,
                                        const font& font,
                                        const color& background) -> texture
  {
    assert(str);
    return render_text(
        TTF_RenderUTF8_Shaded(font.get(), str, get_color().get(), background.get()));
  }

  /**
   * \see render_shaded_utf8()
   * \since 5.3.0
   */
  [[nodiscard]] auto render_shaded_utf8(const std::string& str,
                                        const font& font,
                                        const color& background) -> texture
  {
    return render_shaded_utf8(str.c_str(), font, background);
  }

  /**
   * \brief Creates and returns a texture of solid UTF-8 text.
   *
   * \pre `str` can't be null.
   *
   * \details Attempts to render the UTF-8 text in the supplied font using the currently
   * selected color and returns a texture that contains the result. Use the returned
   * texture to actually render the text to the screen.
   *
   * This function is the fastest at rendering text to a texture. It doesn't use
   * anti-aliasing so the text isn't very smooth. Use this function when quality isn't as
   * big of a concern and speed is important.
   *
   * \param str the UTF-8 text that will be rendered.
   * \param font the font that the text will be rendered in.
   *
   * \return a texture that contains the rendered text.
   *
   * \see `TTF_RenderText_Solid`
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto render_solid_utf8(const not_null<str> str, const font& font) -> texture
  {
    assert(str);
    return render_text(TTF_RenderUTF8_Solid(font.get(), str, get_color().get()));
  }

  /**
   * \see render_solid_utf8()
   * \since 5.3.0
   */
  [[nodiscard]] auto render_solid_utf8(const std::string& str, const font& font) -> texture
  {
    return render_solid_utf8(str.c_str(), font);
  }

  /**
   * \brief Creates and returns a texture of blended Latin-1 text.
   *
   * \pre `str` can't be null.
   *
   * \details Attempts to render the Latin-1 text in the supplied font using the currently
   * selected color and returns a texture that contains the result. Use the returned
   * texture to actually render the text to the screen.
   *
   * This function renders the text at the highest quality and uses anti-aliasing. Use
   * this when you want high quality text, but beware that this is the slowest
   * alternative.
   *
   * \param str the Latin-1 text that will be rendered.
   * \param font the font that the text will be rendered in.
   *
   * \return a texture that contains the rendered text.
   *
   * \see `TTF_RenderText_Blended`
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto render_blended_latin1(const not_null<str> str, const font& font)
      -> texture
  {
    assert(str);
    return render_text(TTF_RenderText_Blended(font.get(), str, get_color().get()));
  }

  /**
   * \see render_blended_latin1()
   * \since 5.3.0
   */
  [[nodiscard]] auto render_blended_latin1(const std::string& str, const font& font) -> texture
  {
    return render_blended_latin1(str.c_str(), font);
  }

  /**
   * \brief Creates and returns a texture of blended and wrapped Latin-1 text.
   *
   * \pre `str` can't be null.
   *
   * \details Attempts to render the Latin-1 text in the supplied font using the currently
   * selected color and returns a texture that contains the result. Use the returned
   * texture to actually render the text to the screen.
   *
   * This function renders the text at the highest quality and uses anti-aliasing. Use
   * this when you want high quality text, but beware that this is the slowest
   * alternative. This function will wrap the supplied text to fit the specified width.
   * Furthermore, you can also manually control the line breaks by inserting newline
   * characters at the desired breakpoints.
   *
   * \param str the Latin-1 text that will be rendered. You can insert newline characters
   * in the string to indicate breakpoints.
   * \param font the font that the text will be rendered in.
   * \param wrap the width in pixels after which the text will be wrapped.
   *
   * \return a texture that contains the rendered text.
   *
   * \see `TTF_RenderText_Blended_Wrapped`
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto render_blended_wrapped_latin1(const not_null<str> str,
                                                   const font& font,
                                                   const u32 wrap) -> texture
  {
    assert(str);
    return render_text(
        TTF_RenderText_Blended_Wrapped(font.get(), str, get_color().get(), wrap));
  }

  /**
   * \see render_blended_wrapped_latin1()
   * \since 5.3.0
   */
  [[nodiscard]] auto render_blended_wrapped_latin1(const std::string& str,
                                                   const font& font,
                                                   const u32 wrap) -> texture
  {
    return render_blended_wrapped_latin1(str.c_str(), font, wrap);
  }

  /**
   * \brief Creates and returns a texture of shaded Latin-1 text.
   *
   * \pre `str` can't be null.
   *
   * \details Attempts to render the Latin-1 text in the supplied font using the currently
   * selected color and returns a texture that contains the result. Use the returned
   * texture to actually render the text to the screen.
   *
   * This function renders the text using anti-aliasing and with a box behind the text.
   * This alternative is probably a bit slower than rendering solid text but about as fast
   * as blended text. Use this function when you want nice text, and can live with a box
   * around it.
   *
   * \param str the Latin-1 text that will be rendered.
   * \param font the font that the text will be rendered in.
   * \param background the background color used for the box.
   *
   * \return a texture that contains the rendered text.
   *
   * \see `TTF_RenderText_Shaded`
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto render_shaded_latin1(const not_null<str> str,
                                          const font& font,
                                          const color& background) -> texture
  {
    assert(str);
    return render_text(
        TTF_RenderText_Shaded(font.get(), str, get_color().get(), background.get()));
  }

  /**
   * \see render_shaded_latin1()
   * \since 5.3.0
   */
  [[nodiscard]] auto render_shaded_latin1(const std::string& str,
                                          const font& font,
                                          const color& background) -> texture
  {
    return render_shaded_latin1(str.c_str(), font, background);
  }

  /**
   * \brief Creates and returns a texture of solid Latin-1 text.
   *
   * \pre `str` can't be null.
   *
   * \details Attempts to render the specified text in the supplied font using the
   * currently selected color and return the texture that contains the result. Use the
   * returned texture to actually render the text to the screen.
   *
   * This function is the fastest at rendering text to a texture. It doesn't use
   * anti-aliasing so the text isn't very smooth. Use this function when quality isn't as
   * big of a concern and speed is important.
   *
   * \param str the Latin-1 text that will be rendered.
   * \param font the font that the text will be rendered in.
   *
   * \return a texture that contains the rendered text.
   *
   * \see `TTF_RenderText_Solid`
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto render_solid_latin1(const not_null<str> str, const font& font) -> texture
  {
    assert(str);
    return render_text(TTF_RenderText_Solid(font.get(), str, get_color().get()));
  }

  /**
   * \see render_solid_latin1()
   * \since 5.3.0
   */
  [[nodiscard]] auto render_solid_latin1(const std::string& str, const font& font) -> texture
  {
    return render_solid_latin1(str.c_str(), font);
  }

  /**
   * \brief Creates and returns a texture of blended Unicode text.
   *
   * \details Attempts to render the Unicode text in the supplied font using the currently
   * selected color and returns a texture that contains the result. Use the returned
   * texture to actually render the text to the screen.
   *
   * This function renders the text at the highest quality and uses anti-aliasing. Use
   * this when you want high quality text, but beware that this is the slowest
   * alternative.
   *
   * \param str the Unicode text that will be rendered.
   * \param font the font that the text will be rendered in.
   *
   * \return a texture that contains the rendered text.
   *
   * \see `TTF_RenderUNICODE_Blended`
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto render_blended_unicode(const unicode_string& str, const font& font)
      -> texture
  {
    return render_text(TTF_RenderUNICODE_Blended(font.get(), str.data(), get_color().get()));
  }

  /**
   * \brief Creates and returns a texture of blended and wrapped Unicode text.
   *
   * \details Attempts to render the Unicode text in the supplied font using the currently
   * selected color and returns a texture that contains the result. Use the returned
   * texture to actually render the text to the screen.
   *
   * This function renders the text at the highest quality and uses anti-aliasing. Use
   * this when you want high quality text, but beware that this is the slowest
   * alternative. This function will wrap the supplied text to fit the specified width.
   * Furthermore, you can also manually control the line breaks by inserting newline
   * characters at the desired breakpoints.
   *
   * \param str the Unicode text that will be rendered. You can insert newline characters
   * in the string to indicate breakpoints.
   * \param font the font that the text will be rendered in.
   * \param wrap the width in pixels after which the text will be wrapped.
   *
   * \return a texture that contains the rendered text.
   *
   * \see `TTF_RenderUNICODE_Blended_Wrapped`
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto render_blended_wrapped_unicode(const unicode_string& str,
                                                    const font& font,
                                                    const u32 wrap) -> texture
  {
    return render_text(
        TTF_RenderUNICODE_Blended_Wrapped(font.get(), str.data(), get_color().get(), wrap));
  }

  /**
   * \brief Creates and returns a texture of shaded Unicode text.
   *
   * \details Attempts to render the Unicode text in the supplied font using the currently
   * selected color and returns a texture that contains the result. Use the returned
   * texture to actually render the text to the screen.
   *
   * This function renders the text using anti-aliasing and with a box behind the text.
   * This alternative is probably a bit slower than rendering solid text but about as fast
   * as blended text. Use this function when you want nice text, and can live with a box
   * around it.
   *
   * \param str the Unicode text that will be rendered.
   * \param font the font that the text will be rendered in.
   * \param background the background color used for the box.
   *
   * \return a texture that contains the rendered text.
   *
   * \see `TTF_RenderUNICODE_Shaded`
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto render_shaded_unicode(const unicode_string& str,
                                           const font& font,
                                           const color& background) -> texture
  {
    return render_text(
        TTF_RenderUNICODE_Shaded(font.get(), str.data(), get_color().get(), background.get()));
  }

  /**
   * \brief Creates and returns a texture of solid Unicode text.
   *
   * \details Attempts to render the specified text in the supplied font using the
   * currently selected color and return the texture that contains the result. Use the
   * returned texture to actually render the text to the screen.
   *
   * This function is the fastest at rendering text to a texture. It doesn't use
   * anti-aliasing so the text isn't very smooth. Use this function when quality isn't as
   * big of a concern and speed is important.
   *
   * \param str the Unicode text that will be rendered.
   * \param font the font that the text will be rendered in.
   *
   * \return a texture that contains the rendered text.
   *
   * \see `TTF_RenderUNICODE_Solid`
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto render_solid_unicode(const unicode_string& str, const font& font)
      -> texture
  {
    return render_text(TTF_RenderUNICODE_Solid(font.get(), str.data(), get_color().get()));
  }

  /**
   * \brief Renders a glyph at the specified position.
   *
   * \note This function has no effect if the glyph doesn't exist in the cache.
   *
   * \param cache the font cache that will be used.
   * \param glyph the glyph, in unicode, that will be rendered.
   * \param position the position of the rendered glyph.
   *
   * \return the x-coordinate of the next glyph to be rendered after the current glyph, or
   * the same x-coordinate if no glyph was rendered.
   *
   * \since 5.0.0
   */
  auto render_glyph(const font_cache& cache, const unicode glyph, const ipoint position) -> int
  {
    if (const auto* data = cache.try_at(glyph)) {
      const auto& [texture, metrics] = *data;

      const auto outline = cache.get_font().outline();

      // SDL_ttf handles the y-axis alignment
      const auto x = position.x() + metrics.minX - outline;
      const auto y = position.y() - outline;

      render(texture, ipoint{x, y});

      return x + metrics.advance;
    }
    else {
      return position.x();
    }
  }

  /**
   * \brief Renders a string.
   *
   * \details This function will not apply any clever conversions on the supplied string.
   * The string is literally iterated, character-by-character, and each character is
   * rendered using the `render_glyph` function.
   *
   * \pre Every character in the string must correspond to a valid Unicode glyph.
   *
   * \note This function is sensitive to newline-characters, and will render strings that
   * contain such characters appropriately.
   *
   * \tparam String the type of the string, must be iterable and provide `unicode`
   * characters.
   *
   * \param cache the font cache that will be used.
   * \param str the string that will be rendered.
   * \param position the position of the rendered text.
   *
   * \since 5.0.0
   */
  template <typename String>
  void render_text(const font_cache& cache, const String& str, ipoint position)
  {
    const auto& font = cache.get_font();

    const auto originalX = position.x();
    const auto lineSkip = font.line_skip();

    for (const unicode glyph : str) {
      if (glyph == '\n') {
        position.set_x(originalX);
        position.set_y(position.y() + lineSkip);
      }
      else {
        const auto x = render_glyph(cache, glyph, position);
        position.set_x(x);
      }
    }
  }

#endif  // CENTURION_NO_SDL_TTF

  /// \} End of text rendering

  /// \name Texture rendering
  /// \{

  /**
   * \brief Renders a texture at the specified position.
   *
   * \tparam P the representation type used by the point.
   * \tparam U the ownership tag of the texture.
   *
   * \param texture the texture that will be rendered.
   * \param position the position of the rendered texture.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename P, typename U>
  auto render(const basic_texture<U>& texture, const basic_point<P>& position) noexcept
      -> result
  {
    if constexpr (basic_point<P>::isFloating) {
      const auto size = cast<cen::farea>(texture.size());
      const SDL_FRect dst{position.x(), position.y(), size.width, size.height};
      return SDL_RenderCopyF(get(), texture.get(), nullptr, &dst) == 0;
    }
    else {
      const SDL_Rect dst{position.x(), position.y(), texture.width(), texture.height()};
      return SDL_RenderCopy(get(), texture.get(), nullptr, &dst) == 0;
    }
  }

  /**
   * \brief Renders a texture according to the specified rectangle.
   *
   * \tparam P the representation type used by the rectangle.
   * \tparam U the ownership tag of the texture.
   *
   * \param texture the texture that will be rendered.
   * \param destination the position and size of the rendered texture.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename P, typename U>
  auto render(const basic_texture<U>& texture, const basic_rect<P>& destination) noexcept
      -> result
  {
    if constexpr (basic_rect<P>::isFloating) {
      return SDL_RenderCopyF(get(), texture.get(), nullptr, destination.data()) == 0;
    }
    else {
      return SDL_RenderCopy(get(), texture.get(), nullptr, destination.data()) == 0;
    }
  }

  /**
   * \brief Renders a texture.
   *
   * \remarks This should be your preferred function of rendering textures. This function
   * is efficient and simple.
   *
   * \tparam P the representation type used by the rectangle.
   * \tparam U the ownership tag of the texture.
   *
   * \param texture the texture that will be rendered.
   * \param source the cutout out of the texture that will be rendered.
   * \param destination the position and size of the rendered texture.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename P, typename U>
  auto render(const basic_texture<U>& texture,
              const irect& source,
              const basic_rect<P>& destination) noexcept -> result
  {
    if constexpr (basic_rect<P>::isFloating) {
      return SDL_RenderCopyF(get(), texture.get(), source.data(), destination.data()) == 0;
    }
    else {
      return SDL_RenderCopy(get(), texture.get(), source.data(), destination.data()) == 0;
    }
  }

  /**
   * \brief Renders a texture.
   *
   * \tparam P the representation type used by the rectangle.
   * \tparam U the ownership tag of the texture.
   *
   * \param texture the texture that will be rendered.
   * \param source the cutout out of the texture that will be rendered.
   * \param destination the position and size of the rendered texture.
   * \param angle the clockwise angle, in degrees, with which the rendered texture will be
   * rotated.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename P, typename U>
  auto render(const basic_texture<U>& texture,
              const irect& source,
              const basic_rect<P>& destination,
              const double angle) noexcept -> result
  {
    if constexpr (basic_rect<P>::isFloating) {
      return SDL_RenderCopyExF(get(),
                               texture.get(),
                               source.data(),
                               destination.data(),
                               angle,
                               nullptr,
                               SDL_FLIP_NONE) == 0;
    }
    else {
      return SDL_RenderCopyEx(get(),
                              texture.get(),
                              source.data(),
                              destination.data(),
                              angle,
                              nullptr,
                              SDL_FLIP_NONE) == 0;
    }
  }

  /**
   * \brief Renders a texture.
   *
   * \tparam R the representation type used by the destination rectangle.
   * \tparam P the representation type used by the center point.
   * \tparam U the ownership tag of the texture.
   *
   * \param texture the texture that will be rendered.
   * \param source the cutout out of the texture that will be rendered.
   * \param destination the position and size of the rendered texture.
   * \param angle the clockwise angle, in degrees, with which the rendered texture will be
   * rotated.
   * \param center specifies the point around which the rendered texture will be rotated.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename R, typename P, typename U>
  auto render(const basic_texture<U>& texture,
              const irect& source,
              const basic_rect<R>& destination,
              const double angle,
              const basic_point<P>& center) noexcept -> result
  {
    static_assert(std::is_same_v<typename basic_rect<R>::value_type,
                                 typename basic_point<P>::value_type>,
                  "Destination rectangle and center point must have the same "
                  "value types (int or float)!");

    if constexpr (basic_rect<R>::isFloating) {
      return SDL_RenderCopyExF(get(),
                               texture.get(),
                               source.data(),
                               destination.data(),
                               angle,
                               center.data(),
                               SDL_FLIP_NONE) == 0;
    }
    else {
      return SDL_RenderCopyEx(get(),
                              texture.get(),
                              source.data(),
                              destination.data(),
                              angle,
                              center.data(),
                              SDL_FLIP_NONE) == 0;
    }
  }

  /**
   * \brief Renders a texture.
   *
   * \tparam R the representation type used by the destination rectangle.
   * \tparam P the representation type used by the center point.
   * \tparam U the ownership tag of the texture.
   *
   * \param texture the texture that will be rendered.
   * \param source the cutout out of the texture that will be rendered.
   * \param destination the position and size of the rendered texture.
   * \param angle the clockwise angle, in degrees, with which the rendered texture will be
   * rotated.
   * \param center specifies the point around which the rendered texture will be rotated.
   * \param flip specifies how the rendered texture will be flipped.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename R, typename P, typename U>
  auto render(const basic_texture<U>& texture,
              const irect& source,
              const basic_rect<R>& destination,
              const double angle,
              const basic_point<P>& center,
              const SDL_RendererFlip flip) noexcept -> result
  {
    static_assert(std::is_same_v<typename basic_rect<R>::value_type,
                                 typename basic_point<P>::value_type>,
                  "Destination rectangle and center point must have the same "
                  "value types (int or float)!");

    if constexpr (basic_rect<R>::isFloating) {
      return SDL_RenderCopyExF(get(),
                               texture.get(),
                               source.data(),
                               destination.data(),
                               angle,
                               center.data(),
                               flip) == 0;
    }
    else {
      return SDL_RenderCopyEx(get(),
                              texture.get(),
                              source.data(),
                              destination.data(),
                              angle,
                              center.data(),
                              flip) == 0;
    }
  }

  /// \} End of texture rendering

  /// \name Translated texture rendering.
  /// \{

  /**
   * \brief Renders a texture at the specified position.
   *
   * \details The rendered texture will be translated using the translation viewport.
   *
   * \tparam U the ownership tag of the texture.
   * \tparam P The representation type used by the point.
   *
   * \param texture the texture that will be rendered.
   * \param position the position (pre-translation) of the rendered texture.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename P, typename U, typename TT = T, detail::is_owner<TT> = 0>
  auto render_t(const basic_texture<U>& texture, const basic_point<P>& position) noexcept
      -> result
  {
    return render(texture, translate(position));
  }

  /**
   * \brief Renders a texture according to the specified rectangle.
   *
   * \details The rendered texture will be translated using the translation viewport.
   *
   * \tparam P the representation type used by the destination rectangle.
   * \tparam U the ownership tag of the texture.
   *
   * \param texture the texture that will be rendered.
   * \param destination the position (pre-translation) and size of the rendered texture.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename P, typename U, typename TT = T, detail::is_owner<TT> = 0>
  auto render_t(const basic_texture<U>& texture, const basic_rect<P>& destination) noexcept
      -> result
  {
    return render(texture, translate(destination));
  }

  /**
   * \brief Renders a texture.
   *
   * \details The rendered texture will be translated using the translation viewport.
   *
   * \remarks This should be your preferred function of rendering textures. This
   * function is efficient and simple.
   *
   * \tparam P the representation type used by the destination rectangle.
   * \tparam U the ownership tag of the texture.
   *
   * \param texture the texture that will be rendered.
   * \param source the cutout out of the texture that will be rendered.
   * \param destination the position (pre-translation) and size of the rendered texture.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename P, typename U, typename TT = T, detail::is_owner<TT> = 0>
  auto render_t(const basic_texture<U>& texture,
                const irect& source,
                const basic_rect<P>& destination) noexcept -> result
  {
    return render(texture, source, translate(destination));
  }

  /**
   * \brief Renders a texture.
   *
   * \details The rendered texture will be translated using the translation viewport.
   *
   * \tparam U the ownership tag of the texture.
   * \tparam P the representation type used by the destination rectangle.
   *
   * \param texture the texture that will be rendered.
   * \param source the cutout out of the texture that will be rendered.
   * \param destination the position (pre-translation) and size of the rendered texture.
   * \param angle the clockwise angle, in degrees, with which the rendered texture will be
   * rotated.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename P, typename U, typename TT = T, detail::is_owner<TT> = 0>
  auto render_t(const basic_texture<U>& texture,
                const irect& source,
                const basic_rect<P>& destination,
                const double angle) noexcept -> result
  {
    return render(texture, source, translate(destination), angle);
  }

  /**
   * \brief Renders a texture.
   *
   * \details The rendered texture will be translated using the translation viewport.
   *
   * \tparam R the representation type used by the destination rectangle.
   * \tparam P the representation type used by the center-of-rotation point.
   * \tparam U the ownership tag of the texture.
   *
   * \param texture the texture that will be rendered.
   * \param source the cutout out of the texture that will be rendered.
   * \param destination the position (pre-translation) and size of the rendered texture.
   * \param angle the clockwise angle, in degrees, with which the rendered texture will be
   * rotated.
   * \param center specifies the point around which the rendered texture will be rotated.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename R, typename P, typename U, typename TT = T, detail::is_owner<TT> = 0>
  auto render_t(const basic_texture<U>& texture,
                const irect& source,
                const basic_rect<R>& destination,
                const double angle,
                const basic_point<P>& center) noexcept -> result
  {
    return render(texture, source, translate(destination), angle, center);
  }

  /**
   * \brief Renders a texture.
   *
   * \tparam R the representation type used by the destination rectangle.
   * \tparam P the representation type used by the center-of-rotation point.
   * \tparam U the ownership tag of the texture.
   *
   * \param texture the texture that will be rendered.
   * \param source the cutout out of the texture that will be rendered.
   * \param destination the position (pre-translation) and size of the rendered texture.
   * \param angle the clockwise angle, in degrees, with which the rendered texture will be
   * rotated.
   * \param center specifies the point around which the rendered texture will be rotated.
   * \param flip specifies how the rendered texture will be flipped.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename R, typename P, typename U, typename TT = T, detail::is_owner<TT> = 0>
  auto render_t(const basic_texture<U>& texture,
                const irect& source,
                const basic_rect<R>& destination,
                const double angle,
                const basic_point<P>& center,
                const SDL_RendererFlip flip) noexcept -> result
  {
    return render(texture, source, translate(destination), angle, center, flip);
  }

  /// \} End of translated texture rendering

  /// \name Translation viewport
  /// \{

  /**
   * \brief Sets the translation viewport that will be used by the renderer.
   *
   * \details This function should be called before calling any of the `_t` rendering
   * methods, for automatic translation.
   *
   * \param viewport the rectangle that will be used as the translation viewport.
   *
   * \since 3.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  void set_translation_viewport(const frect& viewport) noexcept
  {
    m_renderer.translation = viewport;
  }

  /**
   * \brief Returns the translation viewport that is currently being used.
   *
   * \details Set to (0, 0, 0, 0) by default.
   *
   * \return the translation viewport that is currently being used.
   *
   * \since 3.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] auto translation_viewport() const noexcept -> const frect&
  {
    return m_renderer.translation;
  }

  /// \} End of translation viewport

  /// \name Font handling
  /// \{

#ifndef CENTURION_NO_SDL_TTF

  /**
   * \brief Adds a font to the renderer.
   *
   * \note This function overwrites any previously stored font associated with the
   * specified ID.
   *
   * \param id the key that will be associated with the font.
   * \param font the font that will be added.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  void add_font(const usize id, font&& font)
  {
    auto& fonts = m_renderer.fonts;
    if (const auto it = fonts.find(id); it != fonts.end()) {
      fonts.erase(it);
    }
    fonts.try_emplace(id, std::move(font));
  }

  /**
   * \brief Creates a font and adds it to the renderer.
   *
   * \note This function overwrites any previously stored font associated with the
   * specified ID.
   *
   * \tparam Args the types of the arguments that will be forwarded.
   *
   * \param id the key that will be associated with the font.
   * \param args the arguments that will be forwarded to the `font` constructor.
   *
   * \since 5.0.0
   */
  template <typename... Args, typename TT = T, detail::is_owner<TT> = 0>
  void emplace_font(const usize id, Args&&... args)
  {
    auto& fonts = m_renderer.fonts;
    if (const auto it = fonts.find(id); it != fonts.end()) {
      fonts.erase(it);
    }
    fonts.try_emplace(id, std::forward<Args>(args)...);
  }

  /**
   * \brief Removes the font associated with the specified key.
   *
   * \details This function has no effect if there is no font associated with the
   * specified key.
   *
   * \param id the key associated with the font that will be removed.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  void remove_font(const usize id)
  {
    m_renderer.fonts.erase(id);
  }

  /**
   * \brief Returns the font associated with the specified name.
   *
   * \pre There must be a font associated with the specified ID.
   *
   * \param id the key associated with the desired font.
   *
   * \return the font associated with the specified name.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] auto get_font(const usize id) -> font&
  {
    return m_renderer.fonts.at(id);
  }

  /// \copydoc get_font
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] auto get_font(const usize id) const -> const font&
  {
    return m_renderer.fonts.at(id);
  }

  /**
   * \brief Indicates whether or not the renderer has a font associated with the specified
   * key.
   *
   * \param id the key that will be checked.
   *
   * \return `true` if the renderer has a font associated with the key; `false` otherwise.
   *
   * \since 4.1.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] auto has_font(const usize id) const -> bool
  {
    return m_renderer.fonts.find(id) != m_renderer.fonts.end();
  }

#endif  // CENTURION_NO_SDL_TTF

  /// \} // end of font handling

  /// \name Setters
  /// \{

  /**
   * \brief Sets the color that will be used by the renderer.
   *
   * \param color the color that will be used by the renderer.
   *
   * \return `success` if the color was successfully set; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_color(const color& color) noexcept -> result
  {
    return SDL_SetRenderDrawColor(get(),
                                  color.red(),
                                  color.green(),
                                  color.blue(),
                                  color.alpha()) == 0;
  }

  /**
   * \brief Sets the clipping area rectangle.
   *
   * \details Clipping is disabled by default.
   *
   * \param area the clip area rectangle; or `std::nullopt` to disable clipping.
   *
   * \return `success` if the clip was successfully set; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_clip(const std::optional<irect> area) noexcept -> result
  {
    return SDL_RenderSetClipRect(get(), area ? area->data() : nullptr) == 0;
  }

  /**
   * \brief Sets the viewport that will be used by the renderer.
   *
   * \param viewport the viewport that will be used by the renderer.
   *
   * \return `success` if the viewport was successfully set; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_viewport(const irect viewport) noexcept -> result
  {
    return SDL_RenderSetViewport(get(), viewport.data()) == 0;
  }

  /**
   * \brief Sets the blend mode that will be used by the renderer.
   *
   * \param mode the blend mode that will be used by the renderer.
   *
   * \return `success` if the blend mode was successfully set; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_blend_mode(const blend_mode mode) noexcept -> result
  {
    return SDL_SetRenderDrawBlendMode(get(), static_cast<SDL_BlendMode>(mode)) == 0;
  }

  /**
   * \brief Sets the rendering target of the renderer.
   *
   * \pre `target` must be a texture that can be used as a render target.
   *
   * \param target the texture that will be used as a rendering target.
   *
   * \return `success` if the rendering target was successfully set; `failure` otherwise.
   *
   * \since 3.0.0
   */
  template <typename U>
  auto set_target(basic_texture<U>& target) noexcept -> result
  {
    assert(target.is_target());
    return SDL_SetRenderTarget(get(), target.get()) == 0;
  }

  /**
   * \brief Resets the rendering target to the default.
   *
   * \return `success` if the rendering target was successfully reset; `failure`
   * otherwise.
   *
   * \since 6.0.0
   */
  auto reset_target() noexcept -> result
  {
    return SDL_SetRenderTarget(get(), nullptr) == 0;
  }

  /**
   * \brief Sets the rendering scale.
   *
   * \pre `xScale` must be greater than zero.
   * \pre `yScale` must be greater than zero.
   *
   * \param xScale the x-axis scale that will be used.
   * \param yScale the y-axis scale that will be used.
   *
   * \return `success` if the scale was successfully set; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_scale(const float xScale, const float yScale) noexcept -> result
  {
    assert(xScale > 0);
    assert(yScale > 0);
    return SDL_RenderSetScale(get(), xScale, yScale) == 0;
  }

  /**
   * \brief Sets the logical size used by the renderer.
   *
   * \pre The supplied width and height must be greater than or equal to zero.
   *
   * \details This function is useful for resolution-independent rendering.
   *
   * \remarks This is also known as virtual size.
   *
   * \param size the logical width and height that will be used.
   *
   * \return `success` if the logical size was successfully set; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_logical_size(const iarea size) noexcept -> result
  {
    assert(size.width >= 0);
    assert(size.height >= 0);
    return SDL_RenderSetLogicalSize(get(), size.width, size.height) == 0;
  }

  /**
   * \brief Sets whether or not to force integer scaling for the logical viewport.
   *
   * \details This function can be useful to combat visual artefacts when doing
   * floating-point rendering.
   *
   * \param enabled `true` if integer scaling should be used; `false` otherwise.
   *
   * \return `success` if the option was successfully changed; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_logical_integer_scaling(const bool enabled) noexcept -> result
  {
    return SDL_RenderSetIntegerScale(get(), detail::convert_bool(enabled)) == 0;
  }

  /// \} End of setters

  /// \name Queries
  /// \{

  /**
   * \brief Returns a handle to the current render target.
   *
   * \return a handle to the current render target; empty if using the default target.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get_render_target() noexcept -> texture_handle
  {
    return texture_handle{SDL_GetRenderTarget(get())};
  }

  /**
   * \brief Returns the logical width that the renderer uses.
   *
   * \details By default, this property is set to 0.
   *
   * \return the logical width that the renderer uses.
   *
   * \see renderer::logical_size
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto logical_width() const noexcept -> int
  {
    int width{};
    SDL_RenderGetLogicalSize(get(), &width, nullptr);
    return width;
  }

  /**
   * \brief Returns the logical height that the renderer uses.
   *
   * \details By default, this property is set to 0.
   *
   * \return the logical height that the renderer uses.
   *
   * \see renderer::logical_size
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto logical_height() const noexcept -> int
  {
    int height{};
    SDL_RenderGetLogicalSize(get(), nullptr, &height);
    return height;
  }

  /**
   * \brief Returns the size of the logical (virtual) viewport.
   *
   * \note calling this function once is faster than calling both `logical_width` and
   * `logical_height` for obtaining the size.
   *
   * \return the size of the logical (virtual) viewport.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto logical_size() const noexcept -> iarea
  {
    iarea size{};
    SDL_RenderGetLogicalSize(get(), &size.width, &size.height);
    return size;
  }

  /**
   * \brief Returns the x-axis scale that the renderer uses.
   *
   * \return the x-axis scale that the renderer uses.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto x_scale() const noexcept -> float
  {
    float xScale{};
    SDL_RenderGetScale(get(), &xScale, nullptr);
    return xScale;
  }

  /**
   * \brief Returns the y-axis scale that the renderer uses.
   *
   * \return the y-axis scale that the renderer uses.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto y_scale() const noexcept -> float
  {
    float yScale{};
    SDL_RenderGetScale(get(), nullptr, &yScale);
    return yScale;
  }

  /**
   * \brief Returns the x- and y-scale used by the renderer.
   *
   * \note calling this function once is faster than calling both `x_scale` and `y_scale`
   * for obtaining the scale.
   *
   * \return the x- and y-scale used by the renderer.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto scale() const noexcept -> std::pair<float, float>
  {
    float xScale{};
    float yScale{};
    SDL_RenderGetScale(get(), &xScale, &yScale);
    return {xScale, yScale};
  }

  /**
   * \brief Returns the current clipping rectangle, if there is one active.
   *
   * \return the current clipping rectangle; or `std::nullopt` if there is none.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto clip() const noexcept -> std::optional<irect>
  {
    irect rect{};
    SDL_RenderGetClipRect(get(), rect.data());
    if (!rect.has_area()) {
      return std::nullopt;
    }
    else {
      return rect;
    }
  }

  /**
   * \brief Returns the output width of the renderer.
   *
   * \return the output width of the renderer.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto output_width() const noexcept -> int
  {
    int width{};
    SDL_GetRendererOutputSize(get(), &width, nullptr);
    return width;
  }

  /**
   * \brief Returns the output height of the renderer.
   *
   * \return the output height of the renderer.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto output_height() const noexcept -> int
  {
    int height{};
    SDL_GetRendererOutputSize(get(), nullptr, &height);
    return height;
  }

  /**
   * \brief Returns the output size of the renderer.
   *
   * \note calling this function once is faster than calling `output_width` and
   * `output_height` for obtaining the output size.
   *
   * \return the current output size of the renderer.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto output_size() const noexcept -> iarea
  {
    iarea size{};
    SDL_GetRendererOutputSize(get(), &size.width, &size.height);
    return size;
  }

  /**
   * \brief Returns the blend mode that is being used by the renderer.
   *
   * \return the blend mode that is being used.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get_blend_mode() const noexcept -> blend_mode
  {
    SDL_BlendMode mode{};
    SDL_GetRenderDrawBlendMode(get(), &mode);
    return static_cast<blend_mode>(mode);
  }

  /**
   * \brief Indicates whether or not the renderer uses integer scaling values for logical
   * viewports.
   *
   * \details By default, this property is set to false.
   *
   * \return `true` if the renderer uses integer scaling for logical viewports; `false`
   * otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_using_integer_logical_scaling() const noexcept -> bool
  {
    return SDL_RenderGetIntegerScale(get());
  }

  /**
   * \brief Indicates whether or not clipping is enabled.
   *
   * \details This is disabled by default.
   *
   * \return `true` if clipping is enabled; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_clipping_enabled() const noexcept -> bool
  {
    return SDL_RenderIsClipEnabled(get());
  }

  /**
   * \brief Returns the currently selected rendering color.
   *
   * \return the currently selected rendering color.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto get_color() const noexcept -> color
  {
    u8 red{};
    u8 green{};
    u8 blue{};
    u8 alpha{};
    SDL_GetRenderDrawColor(get(), &red, &green, &blue, &alpha);
    return {red, green, blue, alpha};
  }

  /**
   * \brief Returns the viewport that the renderer uses.
   *
   * \return the viewport that the renderer uses.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto viewport() const noexcept -> irect
  {
    irect viewport{};
    SDL_RenderGetViewport(get(), viewport.data());
    return viewport;
  }

  /**
   * \brief Returns a pointer to the associated SDL renderer.
   *
   * \warning Don't take ownership of the returned pointer!
   *
   * \return a pointer to the associated SDL_Renderer.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_Renderer*
  {
    if constexpr (detail::is_owning<T>()) {
      return m_renderer.ptr.get();
    }
    else {
      return m_renderer;
    }
  }

  /**
   * \brief Returns the default flags used when creating renderers.
   *
   * \return the default renderer flags.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr static auto default_flags() noexcept -> u32
  {
    return accelerated | vsync;
  }

  /// \} End of queries

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not the handle holds a non-null pointer.
   *
   * \warning It's undefined behaviour to invoke other member functions that use the
   * internal pointer if this function returns `false`.
   *
   * \return `true` if the handle holds a non-null pointer; `false` otherwise.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit operator bool() const noexcept
  {
    return m_renderer != nullptr;
  }

  /// \} End of conversions

 private:
  struct deleter final
  {
    void operator()(SDL_Renderer* renderer) noexcept
    {
      SDL_DestroyRenderer(renderer);
    }
  };

  struct owning_data final
  {
    /*implicit*/ owning_data(SDL_Renderer* ptr) : ptr{ptr}  // NOLINT
    {}

    std::unique_ptr<SDL_Renderer, deleter> ptr;
    frect translation{};

#ifndef CENTURION_NO_SDL_TTF
    std::unordered_map<usize, font> fonts{};
#endif  // CENTURION_NO_SDL_TTF
  };

  std::conditional_t<T::value, owning_data, SDL_Renderer*> m_renderer;

  [[nodiscard]] auto render_text(owner<SDL_Surface*> s) -> texture
  {
    surface surface{s};
    texture texture{SDL_CreateTextureFromSurface(get(), surface.get())};
    return texture;
  }

  template <typename U, typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] auto translate(const basic_point<U>& point) const noexcept -> basic_point<U>
  {
    using value_type = typename basic_point<U>::value_type;

    const auto& translation = m_renderer.translation;
    const auto x = point.x() - static_cast<value_type>(translation.x());
    const auto y = point.y() - static_cast<value_type>(translation.y());

    return basic_point<U>{x, y};
  }

  template <typename U, typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] auto translate(const basic_rect<U>& rect) const noexcept -> basic_rect<U>
  {
    return basic_rect<U>{translate(rect.position()), rect.size()};
  }
};

/// \name String conversions
/// \{

template <typename T>
[[nodiscard]] auto to_string(const basic_renderer<T>& renderer) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("renderer{{data: {}}}", detail::address_of(renderer.get()));
#else
  return "renderer{data: " + detail::address_of(renderer.get()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

template <typename T>
auto operator<<(std::ostream& stream, const basic_renderer<T>& renderer) -> std::ostream&
{
  return stream << to_string(renderer);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_RENDERER_HEADER

// #include "centurion/video/renderer_info.hpp"
#ifndef CENTURION_RENDERER_INFO_HEADER
#define CENTURION_RENDERER_INFO_HEADER

#include <SDL.h>

#include <cassert>   // assert
#include <optional>  // optional
#include <ostream>   // ostream
#include <string>    // string, string_literals

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/str.hpp"

// #include "../core/str_or_na.hpp"
#ifndef CENTURION_STR_OR_NA_HEADER
#define CENTURION_STR_OR_NA_HEADER

// #include "not_null.hpp"
#ifndef CENTURION_NOT_NULL_HEADER
#define CENTURION_NOT_NULL_HEADER

// #include "sfinae.hpp"


namespace cen {

/**
 * \typedef not_null
 *
 * \ingroup core
 *
 * \brief Tag used to indicate that a pointer cannot be null.
 *
 * \note This alias is equivalent to `T`, it is a no-op.
 *
 * \since 5.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using not_null = T;

}  // namespace cen

#endif  // CENTURION_NOT_NULL_HEADER

// #include "str.hpp"


namespace cen {

/// \addtogroup core
/// \{

/**
 * \brief Simply returns the string if it isn't null, returning a placeholder otherwise.
 *
 * \note This is mainly used in `to_string()` overloads.
 *
 * \param string the string that will be checked.
 *
 * \return the supplied string if it isn't null; "n/a" otherwise.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto str_or_na(const str string) noexcept -> not_null<str>
{
  return string ? string : "n/a";
}

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_OR_NA_HEADER

// #include "../math/area.hpp"

// #include "pixel_format.hpp"

// #include "renderer.hpp"
#ifndef CENTURION_RENDERER_HEADER
#define CENTURION_RENDERER_HEADER

#include <SDL.h>

#include <cassert>        // assert
#include <cmath>          // floor, sqrt
#include <memory>         // unique_ptr
#include <optional>       // optional
#include <ostream>        // ostream
#include <string>         // string
#include <type_traits>    // conditional_t
#include <unordered_map>  // unordered_map
#include <utility>        // move, forward, pair

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/integers.hpp"

// #include "../core/not_null.hpp"

// #include "../core/owner.hpp"

// #include "../core/result.hpp"

// #include "../core/str.hpp"

// #include "../detail/address_of.hpp"

// #include "../detail/convert_bool.hpp"

// #include "../detail/owner_handle_api.hpp"

// #include "../math/rect.hpp"

// #include "blend_mode.hpp"

// #include "color.hpp"

// #include "colors.hpp"

// #include "font.hpp"

// #include "font_cache.hpp"

// #include "surface.hpp"

// #include "texture.hpp"

// #include "unicode_string.hpp"


namespace cen {

/// \addtogroup video
/// \{

template <typename T>
class basic_renderer;

/**
 * \typedef renderer
 *
 * \brief Represents an owning renderer.
 *
 * \since 5.0.0
 */
using renderer = basic_renderer<detail::owning_type>;

/**
 * \typedef renderer_handle
 *
 * \brief Represents a non-owning renderer.
 *
 * \since 5.0.0
 */
using renderer_handle = basic_renderer<detail::handle_type>;

/**
 * \class basic_renderer
 *
 * \brief Provides 2D-rendering that is potentially hardware-accelerated.
 *
 * \ownerhandle `renderer`/`renderer_handle`
 *
 * \details Rendering primitives such as points, rectangles, lines and circles are
 * supported. The owning version of this class, `renderer`, features an extended API
 * compared to its non-owning counterpart, with support for font handling and translated
 * rendering.
 *
 * \details Three different text encodings are supported: UTF-8, Latin-1 and Unicode. Each
 * of these encodings can be rendered in four different styles: "blended", "shaded",
 * "solid" and "blended and wrapped". All of the text rendering functions feature the same
 * names except for a distinguishing suffix, i.e. `_utf8`, `_latin1` or `_unicode`.
 *   - Blended: The best looking option but also the slowest. Uses anti-aliasing.
 *   - Blended and wrapped: Same as blended, but the text will be wrapped to fit a
 *     specified width.
 *   - Solid: The fastest option. Doesn't use anti-aliasing so it will look a bit harsh.
 *   - Shaded: The same as blended, but with a colored rectangle behind it.
 *
 * \note Each window can feature at most one associated renderer.
 *
 * \since 5.0.0
 *
 * \see `renderer`
 * \see `renderer_handle`
 * \see `renderer_info`
 * \see `get_renderer()`
 * \see `make_window_and_renderer()`
 */
template <typename T>
class basic_renderer final
{
 public:
  /**
   * \enum renderer_flags
   *
   * \brief Represents different renderer features.
   *
   * \details Values of this enum are intended to be used to create flag bitmasks, that
   * can be used when creating renderers.
   *
   * \see `SDL_RendererFlags`
   *
   * \since 6.0.0
   */
  enum renderer_flags : u32
  {
    software = SDL_RENDERER_SOFTWARE,              ///< Software renderer
    accelerated = SDL_RENDERER_ACCELERATED,        ///< Hardware-accelerated
    target_textures = SDL_RENDERER_TARGETTEXTURE,  ///< Supports target textures
    vsync = SDL_RENDERER_PRESENTVSYNC              ///< Renderer Uses VSync
  };

  /// \name Construction
  /// \{

  // clang-format off

  /**
   * \brief Creates a renderer based on a pointer to an SDL renderer.
   *
   * \note The supplied pointer will be claimed by the renderer if the created renderer is owning.
   *
   * \param renderer a pointer to the associated SDL renderer.
   *
   * \since 3.0.0
   */
  explicit basic_renderer(maybe_owner<SDL_Renderer*> renderer) noexcept(!detail::is_owning<T>())
      : m_renderer{renderer}
  {
    if constexpr (detail::is_owning<T>())
    {
      if (!get())
      {
        throw cen_error{"Cannot create renderer from null pointer!"};
      }
    }
  }

  // clang-format on

  /**
   * \brief Creates an owning renderer based on the supplied window.
   *
   * \param window the associated window instance.
   * \param flags the renderer flags that will be used, see `renderer_flags`.
   *
   * \throws sdl_error if something goes wrong when creating the renderer.
   *
   * \since 4.0.0
   */
  template <typename Window, typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_renderer(const Window& window, const u32 flags = default_flags())
      : m_renderer{SDL_CreateRenderer(window.get(), -1, flags)}
  {
    if (!get()) {
      throw sdl_error{};
    }
  }

  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit basic_renderer(const renderer& owner) noexcept : m_renderer{owner.get()}
  {}

  /// \} End of construction

  /**
   * \brief Clears the rendering target with the currently selected color.
   *
   * \return `success` if the rendering target was successfully cleared; `failure`
   * otherwise.
   *
   * \since 3.0.0
   */
  auto clear() noexcept -> result
  {
    return SDL_RenderClear(get()) == 0;
  }

  /**
   * \brief Clears the rendering target with the specified color.
   *
   * \note This function doesn't change the currently selected color.
   *
   * \param color the color that will be used to clear the rendering target.
   *
   * \since 5.0.0
   */
  void clear_with(const color& color) noexcept
  {
    const auto oldColor = get_color();
    set_color(color);

    clear();
    set_color(oldColor);
  }

  /**
   * \brief Applies the previous rendering calls to the rendering target.
   *
   * \since 3.0.0
   */
  void present() noexcept
  {
    SDL_RenderPresent(get());
  }

  /**
   * \brief Captures a snapshot of the current rendering target as a surface.
   *
   * \note The correct pixel format supplied to this function can easily be obtained using
   * the `basic_window::get_pixel_format()` function.
   *
   * \param format the pixel format that will be used by the surface.
   *
   * \return a surface that mirrors the pixel data of the current render target.
   *
   * \throws sdl_error if something goes wrong.
   *
   * \since 5.3.0
   */
  [[nodiscard]] auto capture(const pixel_format format) const -> surface
  {
    surface image{output_size(), format};

    if (!image.lock()) {
      throw sdl_error{};
    }

    if (SDL_RenderReadPixels(get(), nullptr, 0, image.pixels(), image.pitch()) == -1) {
      throw sdl_error{};
    }

    image.unlock();
    return image;
  }

  /// \name Primitive rendering
  /// \{

  /**
   * \brief Fills the entire rendering target with the currently selected color.
   *
   * \details This function is different from `clear()` and `clear_with()` in that it can
   * be used as an intermediate rendering command (just like all rendering functions). An
   * example of a use case of this function could be for rendering a transparent
   * background for game menus.
   *
   * \since 5.1.0
   */
  void fill() noexcept
  {
    fill_rect<int>({{}, output_size()});
  }

  /**
   * \brief Fills the entire rendering target with the specified color.
   *
   * \note This function does not affect the currently set color.
   *
   * \copydetails fill()
   */
  void fill_with(const color& color) noexcept
  {
    const auto oldColor = get_color();

    set_color(color);
    fill();

    set_color(oldColor);
  }

  /**
   * \brief Renders the outline of a rectangle in the currently selected color.
   *
   * \tparam U the representation type used by the rectangle.
   *
   * \param rect the rectangle that will be rendered.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename U>
  auto draw_rect(const basic_rect<U>& rect) noexcept -> result
  {
    if constexpr (basic_rect<U>::isIntegral) {
      return SDL_RenderDrawRect(get(), rect.data()) == 0;
    }
    else {
      return SDL_RenderDrawRectF(get(), rect.data()) == 0;
    }
  }

  /**
   * \brief Renders a filled rectangle in the currently selected color.
   *
   * \tparam U the representation type used by the rectangle.
   *
   * \param rect the rectangle that will be rendered.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename U>
  auto fill_rect(const basic_rect<U>& rect) noexcept -> result
  {
    if constexpr (basic_rect<U>::isIntegral) {
      return SDL_RenderFillRect(get(), rect.data()) == 0;
    }
    else {
      return SDL_RenderFillRectF(get(), rect.data()) == 0;
    }
  }

  /**
   * \brief Renders a line between the supplied points, in the currently selected color.
   *
   * \tparam U The representation type used by the points.
   *
   * \param start the start point of the line.
   * \param end the end point of the line.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename U>
  auto draw_line(const basic_point<U>& start, const basic_point<U>& end) noexcept -> result
  {
    if constexpr (basic_point<U>::isIntegral) {
      return SDL_RenderDrawLine(get(), start.x(), start.y(), end.x(), end.y()) == 0;
    }
    else {
      return SDL_RenderDrawLineF(get(), start.x(), start.y(), end.x(), end.y()) == 0;
    }
  }

  /**
   * \brief Renders a collection of lines.
   *
   * \details This function requires the the `Container` type provides the public member
   * `value_type` and subsequently, that the `value_type` in turn provides a `value_type`
   * member. The former would correspond to the actual point type, and the latter
   * corresponds to either `int` or `float`.
   *
   * \warning `Container` *must* be a collection that stores its data contiguously! The
   * behaviour of this function is undefined if this condition isn't met.
   *
   * \tparam Container the container type. Must store its elements contiguously, such as
   * `std::vector` or `std::array`.
   *
   * \param container the container that holds the points that will be used to render the
   * line.
   *
   * \return `success` if the lines were successfully rendered; `failure` otherwise.
   *
   * \since 5.0.0
   */
  template <typename Container>
  auto draw_lines(const Container& container) noexcept -> result
  {
    using point_t = typename Container::value_type;  // a point of int or float
    using value_t = typename point_t::value_type;    // either int or float

    if (!container.empty()) {
      const auto& front = container.front();
      const auto* first = front.data();

      if constexpr (std::is_same_v<value_t, int>) {
        return SDL_RenderDrawLines(get(), first, isize(container)) == 0;
      }
      else {
        return SDL_RenderDrawLinesF(get(), first, isize(container)) == 0;
      }
    }
    else {
      return failure;
    }
  }

  /**
   * \brief Renders a point using the currently selected color.
   *
   * \tparam U the representation type used by the point.
   *
   * \param point the point that will be rendered.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 6.0.0
   */
  template <typename U>
  auto draw_point(const basic_point<U>& point) noexcept -> result
  {
    if constexpr (basic_point<U>::isIntegral) {
      return SDL_RenderDrawPoint(get(), point.x(), point.y()) == 0;
    }
    else {
      return SDL_RenderDrawPointF(get(), point.x(), point.y()) == 0;
    }
  }

  /**
   * \brief Renders a circle using the currently selected color.
   *
   * \tparam U the representation type used by the point.
   *
   * \param position the position of the rendered circle.
   * \param radius the radius of the rendered circle.
   *
   * \since 6.0.0
   */
  template <typename U>
  void draw_circle(const basic_point<U>& position, const float radius) noexcept
  {
    using value_t = typename basic_point<U>::value_type;

    auto error = -radius;
    auto x = radius - 0.5f;
    auto y = 0.5f;

    const auto cx = static_cast<float>(position.x()) - 0.5f;
    const auto cy = static_cast<float>(position.y()) - 0.5f;

    while (x >= y) {
      draw_point<value_t>({static_cast<value_t>(cx + x), static_cast<value_t>(cy + y)});
      draw_point<value_t>({static_cast<value_t>(cx + y), static_cast<value_t>(cy + x)});

      if (x != 0) {
        draw_point<value_t>({static_cast<value_t>(cx - x), static_cast<value_t>(cy + y)});
        draw_point<value_t>({static_cast<value_t>(cx + y), static_cast<value_t>(cy - x)});
      }

      if (y != 0) {
        draw_point<value_t>({static_cast<value_t>(cx + x), static_cast<value_t>(cy - y)});
        draw_point<value_t>({static_cast<value_t>(cx - y), static_cast<value_t>(cy + x)});
      }

      if (x != 0 && y != 0) {
        draw_point<value_t>({static_cast<value_t>(cx - x), static_cast<value_t>(cy - y)});
        draw_point<value_t>({static_cast<value_t>(cx - y), static_cast<value_t>(cy - x)});
      }

      error += y;
      ++y;
      error += y;

      if (error >= 0) {
        --x;
        error -= x;
        error -= x;
      }
    }
  }

  /**
   * \brief Renders a filled circle using the currently selected color.
   *
   * \param center the position of the rendered circle.
   * \param radius the radius of the rendered circle.
   *
   * \since 6.0.0
   */
  void fill_circle(const fpoint center, const float radius)
  {
    const auto cx = center.x();
    const auto cy = center.y();

    for (auto dy = 1.0f; dy <= radius; dy += 1.0f) {
      const auto dx = std::floor(std::sqrt((2.0f * radius * dy) - (dy * dy)));
      draw_line<float>({cx - dx, cy + dy - radius}, {cx + dx, cy + dy - radius});
      draw_line<float>({cx - dx, cy - dy + radius}, {cx + dx, cy - dy + radius});
    }
  }

  /// \} End of primitive rendering

  /// \name Translated primitive rendering
  /// \{

  /**
   * \brief Renders an outlined rectangle in the currently selected color.
   *
   * \details The rendered rectangle will be translated using the current translation
   * viewport.
   *
   * \tparam R the representation type used by the rectangle.
   *
   * \param rect the rectangle that will be rendered.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.1.0
   */
  template <typename R, typename TT = T, detail::is_owner<TT> = 0>
  auto draw_rect_t(const basic_rect<R>& rect) noexcept -> result
  {
    return draw_rect(translate(rect));
  }

  /**
   * \brief Renders a filled rectangle in the currently selected color.
   *
   * \details The rendered rectangle will be translated using the current translation
   * viewport.
   *
   * \tparam R the representation type used by the rectangle.
   *
   * \param rect the rectangle that will be rendered.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.1.0
   */
  template <typename R, typename TT = T, detail::is_owner<TT> = 0>
  auto fill_rect_t(const basic_rect<R>& rect) noexcept -> result
  {
    return fill_rect(translate(rect));
  }

  /**
   * \brief Renders a point using the currently selected color.
   *
   * \details The rendered point will be translated using the current translation
   * viewport.
   *
   * \tparam U the representation
   *
   * \param point the point that will be rendered.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 6.0.0
   */
  template <typename U, typename TT = T, detail::is_owner<TT> = 0>
  auto draw_point_t(const basic_point<U>& point) noexcept -> result
  {
    return draw_point(translate(point));
  }

  /**
   * \brief Renders a circle with the currently selected color.
   *
   * \details The rendered circle will be translated using the current translation
   * viewport.
   *
   * \tparam U the precision used by the point.
   *
   * \param position the position of the rendered circle.
   * \param radius the radius of the rendered circle.
   *
   * \since 6.0.0
   */
  template <typename U, typename TT = T, detail::is_owner<TT> = 0>
  void draw_circle_t(const basic_point<U>& position, const float radius) noexcept
  {
    draw_circle(translate(position), radius);
  }

  /**
   * \brief Renders a filled circle with the currently selected color.
   *
   * \details The rendered circle will be translated using the current translation
   * viewport.
   *
   * \param center the center of the rendered circle.
   * \param radius the radius of the rendered circle.
   *
   * \since 6.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  void fill_circle_t(const fpoint center, const float radius)
  {
    fill_circle(translate(center), radius);
  }

  /// \} End of translated primitive rendering

  /// \name Text rendering
  /// \{

#ifndef CENTURION_NO_SDL_TTF

  /**
   * \brief Creates and returns a texture of blended UTF-8 text.
   *
   * \pre `str` can't be null.
   *
   * \details Attempts to render the UTF-8 text in the supplied font using the currently
   * selected color and returns a texture that contains the result. Use the returned
   * texture to actually render the text to the screen.
   *
   * This function renders the text at the highest quality and uses anti-aliasing. Use
   * this when you want high quality text, but beware that this is the slowest
   * alternative.
   *
   * \param str the UTF-8 text that will be rendered.
   * \param font the font that the text will be rendered in.
   *
   * \return a texture that contains the rendered text.
   *
   * \see `TTF_RenderUTF8_Blended`
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto render_blended_utf8(const not_null<str> str, const font& font) -> texture
  {
    assert(str);
    return render_text(TTF_RenderUTF8_Blended(font.get(), str, get_color().get()));
  }

  /**
   * \see render_blended_utf8()
   * \since 5.3.0
   */
  [[nodiscard]] auto render_blended_utf8(const std::string& str, const font& font) -> texture
  {
    return render_blended_utf8(str.c_str(), font);
  }

  /**
   * \brief Creates and returns a texture of blended and wrapped UTF-8 text.
   *
   * \pre `str` can't be null.
   *
   * \details Attempts to render the UTF-8 text in the supplied font using the currently
   * selected color and returns a texture that contains the result. Use the returned
   * texture to actually render the text to the screen.
   *
   * This function renders the text at the highest quality and uses anti-aliasing. Use
   * this when you want high quality text, but beware that this is the slowest
   * alternative. This function will wrap the supplied text to fit the specified width.
   * Furthermore, you can also manually control the line breaks by inserting newline
   * characters at the desired breakpoints.
   *
   * \param str the UTF-8 text that will be rendered. You can insert newline characters in
   * the string to indicate breakpoints.
   * \param font the font that the text will be rendered in.
   * \param wrap the width in pixels after which the text will be wrapped.
   *
   * \return a texture that contains the rendered text.
   *
   * \see `TTF_RenderUTF8_Blended_Wrapped`
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto render_blended_wrapped_utf8(const not_null<str> str,
                                                 const font& font,
                                                 const u32 wrap) -> texture
  {
    assert(str);
    return render_text(
        TTF_RenderUTF8_Blended_Wrapped(font.get(), str, get_color().get(), wrap));
  }

  /**
   * \see render_blended_wrapped_utf8()
   * \since 5.3.0
   */
  [[nodiscard]] auto render_blended_wrapped_utf8(const std::string& str,
                                                 const font& font,
                                                 const u32 wrap) -> texture
  {
    return render_blended_wrapped_utf8(str.c_str(), font, wrap);
  }

  /**
   * \brief Creates and returns a texture of shaded UTF-8 text.
   *
   * \pre `str` can't be null.
   *
   * \details Attempts to render the UTF-8 text in the supplied font using the currently
   * selected color and returns a texture that contains the result. Use the returned
   * texture to actually render the text to the screen.
   *
   * This function renders the text using anti-aliasing and with a box behind the text.
   * This alternative is probably a bit slower than rendering solid text but about as fast
   * as blended text. Use this function when you want nice text, and can live with a box
   * around it.
   *
   * \param str the UTF-8 text that will be rendered.
   * \param font the font that the text will be rendered in.
   * \param background the background color used for the box.
   *
   * \return a texture that contains the rendered text.
   *
   * \see `TTF_RenderUTF8_Shaded`
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto render_shaded_utf8(const not_null<str> str,
                                        const font& font,
                                        const color& background) -> texture
  {
    assert(str);
    return render_text(
        TTF_RenderUTF8_Shaded(font.get(), str, get_color().get(), background.get()));
  }

  /**
   * \see render_shaded_utf8()
   * \since 5.3.0
   */
  [[nodiscard]] auto render_shaded_utf8(const std::string& str,
                                        const font& font,
                                        const color& background) -> texture
  {
    return render_shaded_utf8(str.c_str(), font, background);
  }

  /**
   * \brief Creates and returns a texture of solid UTF-8 text.
   *
   * \pre `str` can't be null.
   *
   * \details Attempts to render the UTF-8 text in the supplied font using the currently
   * selected color and returns a texture that contains the result. Use the returned
   * texture to actually render the text to the screen.
   *
   * This function is the fastest at rendering text to a texture. It doesn't use
   * anti-aliasing so the text isn't very smooth. Use this function when quality isn't as
   * big of a concern and speed is important.
   *
   * \param str the UTF-8 text that will be rendered.
   * \param font the font that the text will be rendered in.
   *
   * \return a texture that contains the rendered text.
   *
   * \see `TTF_RenderText_Solid`
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto render_solid_utf8(const not_null<str> str, const font& font) -> texture
  {
    assert(str);
    return render_text(TTF_RenderUTF8_Solid(font.get(), str, get_color().get()));
  }

  /**
   * \see render_solid_utf8()
   * \since 5.3.0
   */
  [[nodiscard]] auto render_solid_utf8(const std::string& str, const font& font) -> texture
  {
    return render_solid_utf8(str.c_str(), font);
  }

  /**
   * \brief Creates and returns a texture of blended Latin-1 text.
   *
   * \pre `str` can't be null.
   *
   * \details Attempts to render the Latin-1 text in the supplied font using the currently
   * selected color and returns a texture that contains the result. Use the returned
   * texture to actually render the text to the screen.
   *
   * This function renders the text at the highest quality and uses anti-aliasing. Use
   * this when you want high quality text, but beware that this is the slowest
   * alternative.
   *
   * \param str the Latin-1 text that will be rendered.
   * \param font the font that the text will be rendered in.
   *
   * \return a texture that contains the rendered text.
   *
   * \see `TTF_RenderText_Blended`
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto render_blended_latin1(const not_null<str> str, const font& font)
      -> texture
  {
    assert(str);
    return render_text(TTF_RenderText_Blended(font.get(), str, get_color().get()));
  }

  /**
   * \see render_blended_latin1()
   * \since 5.3.0
   */
  [[nodiscard]] auto render_blended_latin1(const std::string& str, const font& font) -> texture
  {
    return render_blended_latin1(str.c_str(), font);
  }

  /**
   * \brief Creates and returns a texture of blended and wrapped Latin-1 text.
   *
   * \pre `str` can't be null.
   *
   * \details Attempts to render the Latin-1 text in the supplied font using the currently
   * selected color and returns a texture that contains the result. Use the returned
   * texture to actually render the text to the screen.
   *
   * This function renders the text at the highest quality and uses anti-aliasing. Use
   * this when you want high quality text, but beware that this is the slowest
   * alternative. This function will wrap the supplied text to fit the specified width.
   * Furthermore, you can also manually control the line breaks by inserting newline
   * characters at the desired breakpoints.
   *
   * \param str the Latin-1 text that will be rendered. You can insert newline characters
   * in the string to indicate breakpoints.
   * \param font the font that the text will be rendered in.
   * \param wrap the width in pixels after which the text will be wrapped.
   *
   * \return a texture that contains the rendered text.
   *
   * \see `TTF_RenderText_Blended_Wrapped`
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto render_blended_wrapped_latin1(const not_null<str> str,
                                                   const font& font,
                                                   const u32 wrap) -> texture
  {
    assert(str);
    return render_text(
        TTF_RenderText_Blended_Wrapped(font.get(), str, get_color().get(), wrap));
  }

  /**
   * \see render_blended_wrapped_latin1()
   * \since 5.3.0
   */
  [[nodiscard]] auto render_blended_wrapped_latin1(const std::string& str,
                                                   const font& font,
                                                   const u32 wrap) -> texture
  {
    return render_blended_wrapped_latin1(str.c_str(), font, wrap);
  }

  /**
   * \brief Creates and returns a texture of shaded Latin-1 text.
   *
   * \pre `str` can't be null.
   *
   * \details Attempts to render the Latin-1 text in the supplied font using the currently
   * selected color and returns a texture that contains the result. Use the returned
   * texture to actually render the text to the screen.
   *
   * This function renders the text using anti-aliasing and with a box behind the text.
   * This alternative is probably a bit slower than rendering solid text but about as fast
   * as blended text. Use this function when you want nice text, and can live with a box
   * around it.
   *
   * \param str the Latin-1 text that will be rendered.
   * \param font the font that the text will be rendered in.
   * \param background the background color used for the box.
   *
   * \return a texture that contains the rendered text.
   *
   * \see `TTF_RenderText_Shaded`
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto render_shaded_latin1(const not_null<str> str,
                                          const font& font,
                                          const color& background) -> texture
  {
    assert(str);
    return render_text(
        TTF_RenderText_Shaded(font.get(), str, get_color().get(), background.get()));
  }

  /**
   * \see render_shaded_latin1()
   * \since 5.3.0
   */
  [[nodiscard]] auto render_shaded_latin1(const std::string& str,
                                          const font& font,
                                          const color& background) -> texture
  {
    return render_shaded_latin1(str.c_str(), font, background);
  }

  /**
   * \brief Creates and returns a texture of solid Latin-1 text.
   *
   * \pre `str` can't be null.
   *
   * \details Attempts to render the specified text in the supplied font using the
   * currently selected color and return the texture that contains the result. Use the
   * returned texture to actually render the text to the screen.
   *
   * This function is the fastest at rendering text to a texture. It doesn't use
   * anti-aliasing so the text isn't very smooth. Use this function when quality isn't as
   * big of a concern and speed is important.
   *
   * \param str the Latin-1 text that will be rendered.
   * \param font the font that the text will be rendered in.
   *
   * \return a texture that contains the rendered text.
   *
   * \see `TTF_RenderText_Solid`
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto render_solid_latin1(const not_null<str> str, const font& font) -> texture
  {
    assert(str);
    return render_text(TTF_RenderText_Solid(font.get(), str, get_color().get()));
  }

  /**
   * \see render_solid_latin1()
   * \since 5.3.0
   */
  [[nodiscard]] auto render_solid_latin1(const std::string& str, const font& font) -> texture
  {
    return render_solid_latin1(str.c_str(), font);
  }

  /**
   * \brief Creates and returns a texture of blended Unicode text.
   *
   * \details Attempts to render the Unicode text in the supplied font using the currently
   * selected color and returns a texture that contains the result. Use the returned
   * texture to actually render the text to the screen.
   *
   * This function renders the text at the highest quality and uses anti-aliasing. Use
   * this when you want high quality text, but beware that this is the slowest
   * alternative.
   *
   * \param str the Unicode text that will be rendered.
   * \param font the font that the text will be rendered in.
   *
   * \return a texture that contains the rendered text.
   *
   * \see `TTF_RenderUNICODE_Blended`
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto render_blended_unicode(const unicode_string& str, const font& font)
      -> texture
  {
    return render_text(TTF_RenderUNICODE_Blended(font.get(), str.data(), get_color().get()));
  }

  /**
   * \brief Creates and returns a texture of blended and wrapped Unicode text.
   *
   * \details Attempts to render the Unicode text in the supplied font using the currently
   * selected color and returns a texture that contains the result. Use the returned
   * texture to actually render the text to the screen.
   *
   * This function renders the text at the highest quality and uses anti-aliasing. Use
   * this when you want high quality text, but beware that this is the slowest
   * alternative. This function will wrap the supplied text to fit the specified width.
   * Furthermore, you can also manually control the line breaks by inserting newline
   * characters at the desired breakpoints.
   *
   * \param str the Unicode text that will be rendered. You can insert newline characters
   * in the string to indicate breakpoints.
   * \param font the font that the text will be rendered in.
   * \param wrap the width in pixels after which the text will be wrapped.
   *
   * \return a texture that contains the rendered text.
   *
   * \see `TTF_RenderUNICODE_Blended_Wrapped`
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto render_blended_wrapped_unicode(const unicode_string& str,
                                                    const font& font,
                                                    const u32 wrap) -> texture
  {
    return render_text(
        TTF_RenderUNICODE_Blended_Wrapped(font.get(), str.data(), get_color().get(), wrap));
  }

  /**
   * \brief Creates and returns a texture of shaded Unicode text.
   *
   * \details Attempts to render the Unicode text in the supplied font using the currently
   * selected color and returns a texture that contains the result. Use the returned
   * texture to actually render the text to the screen.
   *
   * This function renders the text using anti-aliasing and with a box behind the text.
   * This alternative is probably a bit slower than rendering solid text but about as fast
   * as blended text. Use this function when you want nice text, and can live with a box
   * around it.
   *
   * \param str the Unicode text that will be rendered.
   * \param font the font that the text will be rendered in.
   * \param background the background color used for the box.
   *
   * \return a texture that contains the rendered text.
   *
   * \see `TTF_RenderUNICODE_Shaded`
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto render_shaded_unicode(const unicode_string& str,
                                           const font& font,
                                           const color& background) -> texture
  {
    return render_text(
        TTF_RenderUNICODE_Shaded(font.get(), str.data(), get_color().get(), background.get()));
  }

  /**
   * \brief Creates and returns a texture of solid Unicode text.
   *
   * \details Attempts to render the specified text in the supplied font using the
   * currently selected color and return the texture that contains the result. Use the
   * returned texture to actually render the text to the screen.
   *
   * This function is the fastest at rendering text to a texture. It doesn't use
   * anti-aliasing so the text isn't very smooth. Use this function when quality isn't as
   * big of a concern and speed is important.
   *
   * \param str the Unicode text that will be rendered.
   * \param font the font that the text will be rendered in.
   *
   * \return a texture that contains the rendered text.
   *
   * \see `TTF_RenderUNICODE_Solid`
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto render_solid_unicode(const unicode_string& str, const font& font)
      -> texture
  {
    return render_text(TTF_RenderUNICODE_Solid(font.get(), str.data(), get_color().get()));
  }

  /**
   * \brief Renders a glyph at the specified position.
   *
   * \note This function has no effect if the glyph doesn't exist in the cache.
   *
   * \param cache the font cache that will be used.
   * \param glyph the glyph, in unicode, that will be rendered.
   * \param position the position of the rendered glyph.
   *
   * \return the x-coordinate of the next glyph to be rendered after the current glyph, or
   * the same x-coordinate if no glyph was rendered.
   *
   * \since 5.0.0
   */
  auto render_glyph(const font_cache& cache, const unicode glyph, const ipoint position) -> int
  {
    if (const auto* data = cache.try_at(glyph)) {
      const auto& [texture, metrics] = *data;

      const auto outline = cache.get_font().outline();

      // SDL_ttf handles the y-axis alignment
      const auto x = position.x() + metrics.minX - outline;
      const auto y = position.y() - outline;

      render(texture, ipoint{x, y});

      return x + metrics.advance;
    }
    else {
      return position.x();
    }
  }

  /**
   * \brief Renders a string.
   *
   * \details This function will not apply any clever conversions on the supplied string.
   * The string is literally iterated, character-by-character, and each character is
   * rendered using the `render_glyph` function.
   *
   * \pre Every character in the string must correspond to a valid Unicode glyph.
   *
   * \note This function is sensitive to newline-characters, and will render strings that
   * contain such characters appropriately.
   *
   * \tparam String the type of the string, must be iterable and provide `unicode`
   * characters.
   *
   * \param cache the font cache that will be used.
   * \param str the string that will be rendered.
   * \param position the position of the rendered text.
   *
   * \since 5.0.0
   */
  template <typename String>
  void render_text(const font_cache& cache, const String& str, ipoint position)
  {
    const auto& font = cache.get_font();

    const auto originalX = position.x();
    const auto lineSkip = font.line_skip();

    for (const unicode glyph : str) {
      if (glyph == '\n') {
        position.set_x(originalX);
        position.set_y(position.y() + lineSkip);
      }
      else {
        const auto x = render_glyph(cache, glyph, position);
        position.set_x(x);
      }
    }
  }

#endif  // CENTURION_NO_SDL_TTF

  /// \} End of text rendering

  /// \name Texture rendering
  /// \{

  /**
   * \brief Renders a texture at the specified position.
   *
   * \tparam P the representation type used by the point.
   * \tparam U the ownership tag of the texture.
   *
   * \param texture the texture that will be rendered.
   * \param position the position of the rendered texture.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename P, typename U>
  auto render(const basic_texture<U>& texture, const basic_point<P>& position) noexcept
      -> result
  {
    if constexpr (basic_point<P>::isFloating) {
      const auto size = cast<cen::farea>(texture.size());
      const SDL_FRect dst{position.x(), position.y(), size.width, size.height};
      return SDL_RenderCopyF(get(), texture.get(), nullptr, &dst) == 0;
    }
    else {
      const SDL_Rect dst{position.x(), position.y(), texture.width(), texture.height()};
      return SDL_RenderCopy(get(), texture.get(), nullptr, &dst) == 0;
    }
  }

  /**
   * \brief Renders a texture according to the specified rectangle.
   *
   * \tparam P the representation type used by the rectangle.
   * \tparam U the ownership tag of the texture.
   *
   * \param texture the texture that will be rendered.
   * \param destination the position and size of the rendered texture.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename P, typename U>
  auto render(const basic_texture<U>& texture, const basic_rect<P>& destination) noexcept
      -> result
  {
    if constexpr (basic_rect<P>::isFloating) {
      return SDL_RenderCopyF(get(), texture.get(), nullptr, destination.data()) == 0;
    }
    else {
      return SDL_RenderCopy(get(), texture.get(), nullptr, destination.data()) == 0;
    }
  }

  /**
   * \brief Renders a texture.
   *
   * \remarks This should be your preferred function of rendering textures. This function
   * is efficient and simple.
   *
   * \tparam P the representation type used by the rectangle.
   * \tparam U the ownership tag of the texture.
   *
   * \param texture the texture that will be rendered.
   * \param source the cutout out of the texture that will be rendered.
   * \param destination the position and size of the rendered texture.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename P, typename U>
  auto render(const basic_texture<U>& texture,
              const irect& source,
              const basic_rect<P>& destination) noexcept -> result
  {
    if constexpr (basic_rect<P>::isFloating) {
      return SDL_RenderCopyF(get(), texture.get(), source.data(), destination.data()) == 0;
    }
    else {
      return SDL_RenderCopy(get(), texture.get(), source.data(), destination.data()) == 0;
    }
  }

  /**
   * \brief Renders a texture.
   *
   * \tparam P the representation type used by the rectangle.
   * \tparam U the ownership tag of the texture.
   *
   * \param texture the texture that will be rendered.
   * \param source the cutout out of the texture that will be rendered.
   * \param destination the position and size of the rendered texture.
   * \param angle the clockwise angle, in degrees, with which the rendered texture will be
   * rotated.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename P, typename U>
  auto render(const basic_texture<U>& texture,
              const irect& source,
              const basic_rect<P>& destination,
              const double angle) noexcept -> result
  {
    if constexpr (basic_rect<P>::isFloating) {
      return SDL_RenderCopyExF(get(),
                               texture.get(),
                               source.data(),
                               destination.data(),
                               angle,
                               nullptr,
                               SDL_FLIP_NONE) == 0;
    }
    else {
      return SDL_RenderCopyEx(get(),
                              texture.get(),
                              source.data(),
                              destination.data(),
                              angle,
                              nullptr,
                              SDL_FLIP_NONE) == 0;
    }
  }

  /**
   * \brief Renders a texture.
   *
   * \tparam R the representation type used by the destination rectangle.
   * \tparam P the representation type used by the center point.
   * \tparam U the ownership tag of the texture.
   *
   * \param texture the texture that will be rendered.
   * \param source the cutout out of the texture that will be rendered.
   * \param destination the position and size of the rendered texture.
   * \param angle the clockwise angle, in degrees, with which the rendered texture will be
   * rotated.
   * \param center specifies the point around which the rendered texture will be rotated.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename R, typename P, typename U>
  auto render(const basic_texture<U>& texture,
              const irect& source,
              const basic_rect<R>& destination,
              const double angle,
              const basic_point<P>& center) noexcept -> result
  {
    static_assert(std::is_same_v<typename basic_rect<R>::value_type,
                                 typename basic_point<P>::value_type>,
                  "Destination rectangle and center point must have the same "
                  "value types (int or float)!");

    if constexpr (basic_rect<R>::isFloating) {
      return SDL_RenderCopyExF(get(),
                               texture.get(),
                               source.data(),
                               destination.data(),
                               angle,
                               center.data(),
                               SDL_FLIP_NONE) == 0;
    }
    else {
      return SDL_RenderCopyEx(get(),
                              texture.get(),
                              source.data(),
                              destination.data(),
                              angle,
                              center.data(),
                              SDL_FLIP_NONE) == 0;
    }
  }

  /**
   * \brief Renders a texture.
   *
   * \tparam R the representation type used by the destination rectangle.
   * \tparam P the representation type used by the center point.
   * \tparam U the ownership tag of the texture.
   *
   * \param texture the texture that will be rendered.
   * \param source the cutout out of the texture that will be rendered.
   * \param destination the position and size of the rendered texture.
   * \param angle the clockwise angle, in degrees, with which the rendered texture will be
   * rotated.
   * \param center specifies the point around which the rendered texture will be rotated.
   * \param flip specifies how the rendered texture will be flipped.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename R, typename P, typename U>
  auto render(const basic_texture<U>& texture,
              const irect& source,
              const basic_rect<R>& destination,
              const double angle,
              const basic_point<P>& center,
              const SDL_RendererFlip flip) noexcept -> result
  {
    static_assert(std::is_same_v<typename basic_rect<R>::value_type,
                                 typename basic_point<P>::value_type>,
                  "Destination rectangle and center point must have the same "
                  "value types (int or float)!");

    if constexpr (basic_rect<R>::isFloating) {
      return SDL_RenderCopyExF(get(),
                               texture.get(),
                               source.data(),
                               destination.data(),
                               angle,
                               center.data(),
                               flip) == 0;
    }
    else {
      return SDL_RenderCopyEx(get(),
                              texture.get(),
                              source.data(),
                              destination.data(),
                              angle,
                              center.data(),
                              flip) == 0;
    }
  }

  /// \} End of texture rendering

  /// \name Translated texture rendering.
  /// \{

  /**
   * \brief Renders a texture at the specified position.
   *
   * \details The rendered texture will be translated using the translation viewport.
   *
   * \tparam U the ownership tag of the texture.
   * \tparam P The representation type used by the point.
   *
   * \param texture the texture that will be rendered.
   * \param position the position (pre-translation) of the rendered texture.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename P, typename U, typename TT = T, detail::is_owner<TT> = 0>
  auto render_t(const basic_texture<U>& texture, const basic_point<P>& position) noexcept
      -> result
  {
    return render(texture, translate(position));
  }

  /**
   * \brief Renders a texture according to the specified rectangle.
   *
   * \details The rendered texture will be translated using the translation viewport.
   *
   * \tparam P the representation type used by the destination rectangle.
   * \tparam U the ownership tag of the texture.
   *
   * \param texture the texture that will be rendered.
   * \param destination the position (pre-translation) and size of the rendered texture.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename P, typename U, typename TT = T, detail::is_owner<TT> = 0>
  auto render_t(const basic_texture<U>& texture, const basic_rect<P>& destination) noexcept
      -> result
  {
    return render(texture, translate(destination));
  }

  /**
   * \brief Renders a texture.
   *
   * \details The rendered texture will be translated using the translation viewport.
   *
   * \remarks This should be your preferred function of rendering textures. This
   * function is efficient and simple.
   *
   * \tparam P the representation type used by the destination rectangle.
   * \tparam U the ownership tag of the texture.
   *
   * \param texture the texture that will be rendered.
   * \param source the cutout out of the texture that will be rendered.
   * \param destination the position (pre-translation) and size of the rendered texture.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename P, typename U, typename TT = T, detail::is_owner<TT> = 0>
  auto render_t(const basic_texture<U>& texture,
                const irect& source,
                const basic_rect<P>& destination) noexcept -> result
  {
    return render(texture, source, translate(destination));
  }

  /**
   * \brief Renders a texture.
   *
   * \details The rendered texture will be translated using the translation viewport.
   *
   * \tparam U the ownership tag of the texture.
   * \tparam P the representation type used by the destination rectangle.
   *
   * \param texture the texture that will be rendered.
   * \param source the cutout out of the texture that will be rendered.
   * \param destination the position (pre-translation) and size of the rendered texture.
   * \param angle the clockwise angle, in degrees, with which the rendered texture will be
   * rotated.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename P, typename U, typename TT = T, detail::is_owner<TT> = 0>
  auto render_t(const basic_texture<U>& texture,
                const irect& source,
                const basic_rect<P>& destination,
                const double angle) noexcept -> result
  {
    return render(texture, source, translate(destination), angle);
  }

  /**
   * \brief Renders a texture.
   *
   * \details The rendered texture will be translated using the translation viewport.
   *
   * \tparam R the representation type used by the destination rectangle.
   * \tparam P the representation type used by the center-of-rotation point.
   * \tparam U the ownership tag of the texture.
   *
   * \param texture the texture that will be rendered.
   * \param source the cutout out of the texture that will be rendered.
   * \param destination the position (pre-translation) and size of the rendered texture.
   * \param angle the clockwise angle, in degrees, with which the rendered texture will be
   * rotated.
   * \param center specifies the point around which the rendered texture will be rotated.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename R, typename P, typename U, typename TT = T, detail::is_owner<TT> = 0>
  auto render_t(const basic_texture<U>& texture,
                const irect& source,
                const basic_rect<R>& destination,
                const double angle,
                const basic_point<P>& center) noexcept -> result
  {
    return render(texture, source, translate(destination), angle, center);
  }

  /**
   * \brief Renders a texture.
   *
   * \tparam R the representation type used by the destination rectangle.
   * \tparam P the representation type used by the center-of-rotation point.
   * \tparam U the ownership tag of the texture.
   *
   * \param texture the texture that will be rendered.
   * \param source the cutout out of the texture that will be rendered.
   * \param destination the position (pre-translation) and size of the rendered texture.
   * \param angle the clockwise angle, in degrees, with which the rendered texture will be
   * rotated.
   * \param center specifies the point around which the rendered texture will be rotated.
   * \param flip specifies how the rendered texture will be flipped.
   *
   * \return `success` if the rendering was successful; `failure` otherwise.
   *
   * \since 4.0.0
   */
  template <typename R, typename P, typename U, typename TT = T, detail::is_owner<TT> = 0>
  auto render_t(const basic_texture<U>& texture,
                const irect& source,
                const basic_rect<R>& destination,
                const double angle,
                const basic_point<P>& center,
                const SDL_RendererFlip flip) noexcept -> result
  {
    return render(texture, source, translate(destination), angle, center, flip);
  }

  /// \} End of translated texture rendering

  /// \name Translation viewport
  /// \{

  /**
   * \brief Sets the translation viewport that will be used by the renderer.
   *
   * \details This function should be called before calling any of the `_t` rendering
   * methods, for automatic translation.
   *
   * \param viewport the rectangle that will be used as the translation viewport.
   *
   * \since 3.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  void set_translation_viewport(const frect& viewport) noexcept
  {
    m_renderer.translation = viewport;
  }

  /**
   * \brief Returns the translation viewport that is currently being used.
   *
   * \details Set to (0, 0, 0, 0) by default.
   *
   * \return the translation viewport that is currently being used.
   *
   * \since 3.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] auto translation_viewport() const noexcept -> const frect&
  {
    return m_renderer.translation;
  }

  /// \} End of translation viewport

  /// \name Font handling
  /// \{

#ifndef CENTURION_NO_SDL_TTF

  /**
   * \brief Adds a font to the renderer.
   *
   * \note This function overwrites any previously stored font associated with the
   * specified ID.
   *
   * \param id the key that will be associated with the font.
   * \param font the font that will be added.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  void add_font(const usize id, font&& font)
  {
    auto& fonts = m_renderer.fonts;
    if (const auto it = fonts.find(id); it != fonts.end()) {
      fonts.erase(it);
    }
    fonts.try_emplace(id, std::move(font));
  }

  /**
   * \brief Creates a font and adds it to the renderer.
   *
   * \note This function overwrites any previously stored font associated with the
   * specified ID.
   *
   * \tparam Args the types of the arguments that will be forwarded.
   *
   * \param id the key that will be associated with the font.
   * \param args the arguments that will be forwarded to the `font` constructor.
   *
   * \since 5.0.0
   */
  template <typename... Args, typename TT = T, detail::is_owner<TT> = 0>
  void emplace_font(const usize id, Args&&... args)
  {
    auto& fonts = m_renderer.fonts;
    if (const auto it = fonts.find(id); it != fonts.end()) {
      fonts.erase(it);
    }
    fonts.try_emplace(id, std::forward<Args>(args)...);
  }

  /**
   * \brief Removes the font associated with the specified key.
   *
   * \details This function has no effect if there is no font associated with the
   * specified key.
   *
   * \param id the key associated with the font that will be removed.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  void remove_font(const usize id)
  {
    m_renderer.fonts.erase(id);
  }

  /**
   * \brief Returns the font associated with the specified name.
   *
   * \pre There must be a font associated with the specified ID.
   *
   * \param id the key associated with the desired font.
   *
   * \return the font associated with the specified name.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] auto get_font(const usize id) -> font&
  {
    return m_renderer.fonts.at(id);
  }

  /// \copydoc get_font
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] auto get_font(const usize id) const -> const font&
  {
    return m_renderer.fonts.at(id);
  }

  /**
   * \brief Indicates whether or not the renderer has a font associated with the specified
   * key.
   *
   * \param id the key that will be checked.
   *
   * \return `true` if the renderer has a font associated with the key; `false` otherwise.
   *
   * \since 4.1.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] auto has_font(const usize id) const -> bool
  {
    return m_renderer.fonts.find(id) != m_renderer.fonts.end();
  }

#endif  // CENTURION_NO_SDL_TTF

  /// \} // end of font handling

  /// \name Setters
  /// \{

  /**
   * \brief Sets the color that will be used by the renderer.
   *
   * \param color the color that will be used by the renderer.
   *
   * \return `success` if the color was successfully set; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_color(const color& color) noexcept -> result
  {
    return SDL_SetRenderDrawColor(get(),
                                  color.red(),
                                  color.green(),
                                  color.blue(),
                                  color.alpha()) == 0;
  }

  /**
   * \brief Sets the clipping area rectangle.
   *
   * \details Clipping is disabled by default.
   *
   * \param area the clip area rectangle; or `std::nullopt` to disable clipping.
   *
   * \return `success` if the clip was successfully set; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_clip(const std::optional<irect> area) noexcept -> result
  {
    return SDL_RenderSetClipRect(get(), area ? area->data() : nullptr) == 0;
  }

  /**
   * \brief Sets the viewport that will be used by the renderer.
   *
   * \param viewport the viewport that will be used by the renderer.
   *
   * \return `success` if the viewport was successfully set; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_viewport(const irect viewport) noexcept -> result
  {
    return SDL_RenderSetViewport(get(), viewport.data()) == 0;
  }

  /**
   * \brief Sets the blend mode that will be used by the renderer.
   *
   * \param mode the blend mode that will be used by the renderer.
   *
   * \return `success` if the blend mode was successfully set; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_blend_mode(const blend_mode mode) noexcept -> result
  {
    return SDL_SetRenderDrawBlendMode(get(), static_cast<SDL_BlendMode>(mode)) == 0;
  }

  /**
   * \brief Sets the rendering target of the renderer.
   *
   * \pre `target` must be a texture that can be used as a render target.
   *
   * \param target the texture that will be used as a rendering target.
   *
   * \return `success` if the rendering target was successfully set; `failure` otherwise.
   *
   * \since 3.0.0
   */
  template <typename U>
  auto set_target(basic_texture<U>& target) noexcept -> result
  {
    assert(target.is_target());
    return SDL_SetRenderTarget(get(), target.get()) == 0;
  }

  /**
   * \brief Resets the rendering target to the default.
   *
   * \return `success` if the rendering target was successfully reset; `failure`
   * otherwise.
   *
   * \since 6.0.0
   */
  auto reset_target() noexcept -> result
  {
    return SDL_SetRenderTarget(get(), nullptr) == 0;
  }

  /**
   * \brief Sets the rendering scale.
   *
   * \pre `xScale` must be greater than zero.
   * \pre `yScale` must be greater than zero.
   *
   * \param xScale the x-axis scale that will be used.
   * \param yScale the y-axis scale that will be used.
   *
   * \return `success` if the scale was successfully set; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_scale(const float xScale, const float yScale) noexcept -> result
  {
    assert(xScale > 0);
    assert(yScale > 0);
    return SDL_RenderSetScale(get(), xScale, yScale) == 0;
  }

  /**
   * \brief Sets the logical size used by the renderer.
   *
   * \pre The supplied width and height must be greater than or equal to zero.
   *
   * \details This function is useful for resolution-independent rendering.
   *
   * \remarks This is also known as virtual size.
   *
   * \param size the logical width and height that will be used.
   *
   * \return `success` if the logical size was successfully set; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_logical_size(const iarea size) noexcept -> result
  {
    assert(size.width >= 0);
    assert(size.height >= 0);
    return SDL_RenderSetLogicalSize(get(), size.width, size.height) == 0;
  }

  /**
   * \brief Sets whether or not to force integer scaling for the logical viewport.
   *
   * \details This function can be useful to combat visual artefacts when doing
   * floating-point rendering.
   *
   * \param enabled `true` if integer scaling should be used; `false` otherwise.
   *
   * \return `success` if the option was successfully changed; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_logical_integer_scaling(const bool enabled) noexcept -> result
  {
    return SDL_RenderSetIntegerScale(get(), detail::convert_bool(enabled)) == 0;
  }

  /// \} End of setters

  /// \name Queries
  /// \{

  /**
   * \brief Returns a handle to the current render target.
   *
   * \return a handle to the current render target; empty if using the default target.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get_render_target() noexcept -> texture_handle
  {
    return texture_handle{SDL_GetRenderTarget(get())};
  }

  /**
   * \brief Returns the logical width that the renderer uses.
   *
   * \details By default, this property is set to 0.
   *
   * \return the logical width that the renderer uses.
   *
   * \see renderer::logical_size
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto logical_width() const noexcept -> int
  {
    int width{};
    SDL_RenderGetLogicalSize(get(), &width, nullptr);
    return width;
  }

  /**
   * \brief Returns the logical height that the renderer uses.
   *
   * \details By default, this property is set to 0.
   *
   * \return the logical height that the renderer uses.
   *
   * \see renderer::logical_size
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto logical_height() const noexcept -> int
  {
    int height{};
    SDL_RenderGetLogicalSize(get(), nullptr, &height);
    return height;
  }

  /**
   * \brief Returns the size of the logical (virtual) viewport.
   *
   * \note calling this function once is faster than calling both `logical_width` and
   * `logical_height` for obtaining the size.
   *
   * \return the size of the logical (virtual) viewport.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto logical_size() const noexcept -> iarea
  {
    iarea size{};
    SDL_RenderGetLogicalSize(get(), &size.width, &size.height);
    return size;
  }

  /**
   * \brief Returns the x-axis scale that the renderer uses.
   *
   * \return the x-axis scale that the renderer uses.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto x_scale() const noexcept -> float
  {
    float xScale{};
    SDL_RenderGetScale(get(), &xScale, nullptr);
    return xScale;
  }

  /**
   * \brief Returns the y-axis scale that the renderer uses.
   *
   * \return the y-axis scale that the renderer uses.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto y_scale() const noexcept -> float
  {
    float yScale{};
    SDL_RenderGetScale(get(), nullptr, &yScale);
    return yScale;
  }

  /**
   * \brief Returns the x- and y-scale used by the renderer.
   *
   * \note calling this function once is faster than calling both `x_scale` and `y_scale`
   * for obtaining the scale.
   *
   * \return the x- and y-scale used by the renderer.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto scale() const noexcept -> std::pair<float, float>
  {
    float xScale{};
    float yScale{};
    SDL_RenderGetScale(get(), &xScale, &yScale);
    return {xScale, yScale};
  }

  /**
   * \brief Returns the current clipping rectangle, if there is one active.
   *
   * \return the current clipping rectangle; or `std::nullopt` if there is none.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto clip() const noexcept -> std::optional<irect>
  {
    irect rect{};
    SDL_RenderGetClipRect(get(), rect.data());
    if (!rect.has_area()) {
      return std::nullopt;
    }
    else {
      return rect;
    }
  }

  /**
   * \brief Returns the output width of the renderer.
   *
   * \return the output width of the renderer.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto output_width() const noexcept -> int
  {
    int width{};
    SDL_GetRendererOutputSize(get(), &width, nullptr);
    return width;
  }

  /**
   * \brief Returns the output height of the renderer.
   *
   * \return the output height of the renderer.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto output_height() const noexcept -> int
  {
    int height{};
    SDL_GetRendererOutputSize(get(), nullptr, &height);
    return height;
  }

  /**
   * \brief Returns the output size of the renderer.
   *
   * \note calling this function once is faster than calling `output_width` and
   * `output_height` for obtaining the output size.
   *
   * \return the current output size of the renderer.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto output_size() const noexcept -> iarea
  {
    iarea size{};
    SDL_GetRendererOutputSize(get(), &size.width, &size.height);
    return size;
  }

  /**
   * \brief Returns the blend mode that is being used by the renderer.
   *
   * \return the blend mode that is being used.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get_blend_mode() const noexcept -> blend_mode
  {
    SDL_BlendMode mode{};
    SDL_GetRenderDrawBlendMode(get(), &mode);
    return static_cast<blend_mode>(mode);
  }

  /**
   * \brief Indicates whether or not the renderer uses integer scaling values for logical
   * viewports.
   *
   * \details By default, this property is set to false.
   *
   * \return `true` if the renderer uses integer scaling for logical viewports; `false`
   * otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_using_integer_logical_scaling() const noexcept -> bool
  {
    return SDL_RenderGetIntegerScale(get());
  }

  /**
   * \brief Indicates whether or not clipping is enabled.
   *
   * \details This is disabled by default.
   *
   * \return `true` if clipping is enabled; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_clipping_enabled() const noexcept -> bool
  {
    return SDL_RenderIsClipEnabled(get());
  }

  /**
   * \brief Returns the currently selected rendering color.
   *
   * \return the currently selected rendering color.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto get_color() const noexcept -> color
  {
    u8 red{};
    u8 green{};
    u8 blue{};
    u8 alpha{};
    SDL_GetRenderDrawColor(get(), &red, &green, &blue, &alpha);
    return {red, green, blue, alpha};
  }

  /**
   * \brief Returns the viewport that the renderer uses.
   *
   * \return the viewport that the renderer uses.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto viewport() const noexcept -> irect
  {
    irect viewport{};
    SDL_RenderGetViewport(get(), viewport.data());
    return viewport;
  }

  /**
   * \brief Returns a pointer to the associated SDL renderer.
   *
   * \warning Don't take ownership of the returned pointer!
   *
   * \return a pointer to the associated SDL_Renderer.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_Renderer*
  {
    if constexpr (detail::is_owning<T>()) {
      return m_renderer.ptr.get();
    }
    else {
      return m_renderer;
    }
  }

  /**
   * \brief Returns the default flags used when creating renderers.
   *
   * \return the default renderer flags.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr static auto default_flags() noexcept -> u32
  {
    return accelerated | vsync;
  }

  /// \} End of queries

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not the handle holds a non-null pointer.
   *
   * \warning It's undefined behaviour to invoke other member functions that use the
   * internal pointer if this function returns `false`.
   *
   * \return `true` if the handle holds a non-null pointer; `false` otherwise.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit operator bool() const noexcept
  {
    return m_renderer != nullptr;
  }

  /// \} End of conversions

 private:
  struct deleter final
  {
    void operator()(SDL_Renderer* renderer) noexcept
    {
      SDL_DestroyRenderer(renderer);
    }
  };

  struct owning_data final
  {
    /*implicit*/ owning_data(SDL_Renderer* ptr) : ptr{ptr}  // NOLINT
    {}

    std::unique_ptr<SDL_Renderer, deleter> ptr;
    frect translation{};

#ifndef CENTURION_NO_SDL_TTF
    std::unordered_map<usize, font> fonts{};
#endif  // CENTURION_NO_SDL_TTF
  };

  std::conditional_t<T::value, owning_data, SDL_Renderer*> m_renderer;

  [[nodiscard]] auto render_text(owner<SDL_Surface*> s) -> texture
  {
    surface surface{s};
    texture texture{SDL_CreateTextureFromSurface(get(), surface.get())};
    return texture;
  }

  template <typename U, typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] auto translate(const basic_point<U>& point) const noexcept -> basic_point<U>
  {
    using value_type = typename basic_point<U>::value_type;

    const auto& translation = m_renderer.translation;
    const auto x = point.x() - static_cast<value_type>(translation.x());
    const auto y = point.y() - static_cast<value_type>(translation.y());

    return basic_point<U>{x, y};
  }

  template <typename U, typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] auto translate(const basic_rect<U>& rect) const noexcept -> basic_rect<U>
  {
    return basic_rect<U>{translate(rect.position()), rect.size()};
  }
};

/// \name String conversions
/// \{

template <typename T>
[[nodiscard]] auto to_string(const basic_renderer<T>& renderer) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("renderer{{data: {}}}", detail::address_of(renderer.get()));
#else
  return "renderer{data: " + detail::address_of(renderer.get()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

template <typename T>
auto operator<<(std::ostream& stream, const basic_renderer<T>& renderer) -> std::ostream&
{
  return stream << to_string(renderer);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_RENDERER_HEADER


namespace cen {

/// \addtogroup video
/// \{

/**
 * \class renderer_info
 *
 * \brief Provides information about a renderer.
 *
 * \see `get_info()`
 *
 * \since 6.0.0
 */
class renderer_info final
{
  template <typename T>
  friend auto get_info(const basic_renderer<T>& renderer) noexcept
      -> std::optional<renderer_info>;

 public:
  /**
   * \brief Returns a mask of all of the supported renderer flags.
   *
   * \return a mask of the supported renderer flags.
   *
   * \see `basic_renderer::renderer_flags`
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto supported_flags() const noexcept -> u32
  {
    return m_info.flags;
  }

  /**
   * \brief Indicates whether or not the renderer supports VSync.
   *
   * \return `true` if the renderer has VSync support; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto has_vsync() const noexcept -> bool
  {
    return supported_flags() & SDL_RENDERER_PRESENTVSYNC;
  }

  /**
   * \brief Indicates whether or not the renderer supports target textures.
   *
   * \return `true` if the renderer has target texture support; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto has_target_textures() const noexcept -> bool
  {
    return supported_flags() & SDL_RENDERER_TARGETTEXTURE;
  }

  /**
   * \brief Indicates whether or not the renderer supports hardware acceleration.
   *
   * \return `true` if the renderer has hardware acceleration support; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto has_hardware_acceleration() const noexcept -> bool
  {
    return supported_flags() & SDL_RENDERER_ACCELERATED;
  }

  /**
   * \brief Indicates whether or not the renderer supports software rendering.
   *
   * \return `true` if the renderer has software rendering support; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto has_software_renderer() const noexcept -> bool
  {
    return supported_flags() & SDL_RENDERER_SOFTWARE;
  }

  /**
   * \brief Returns the name associated with the renderer.
   *
   * \return the name of the renderer.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto name() const noexcept -> str
  {
    return m_info.name;
  }

  /**
   * \brief Returns the number of supported pixel formats.
   *
   * \return the amount of available pixel formats.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto format_count() const noexcept -> u32
  {
    return m_info.num_texture_formats;
  }

  /**
   * \brief Returns the supported pixel format at the specified index.
   *
   * \pre `index` must be must be smaller than `pixel_format_count()`.
   *
   * \param index the index of the desired pixel format.
   *
   * \return the supported pixel format at the specified index.,
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto format(const usize index) const noexcept -> pixel_format
  {
    assert(index < format_count());
    return static_cast<pixel_format>(m_info.texture_formats[index]);
  }

  /**
   * \brief Returns the maximum supported width of textures.
   *
   * \return the maximum texture width.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto max_texture_width() const noexcept -> int
  {
    return m_info.max_texture_width;
  }

  /**
   * \brief Returns the maximum supported height of textures.
   *
   * \return the maximum texture height.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto max_texture_height() const noexcept -> int
  {
    return m_info.max_texture_height;
  }

  /**
   * \brief Returns the maximum supported size of textures.
   *
   * \return the maximum texture size.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto max_texture_size() const noexcept -> iarea
  {
    return {max_texture_width(), max_texture_height()};
  }

 private:
  SDL_RendererInfo m_info;

  /**
   * \brief Creates a `renderer_info` instance from an existing SDL info instance.
   *
   * \param info the information that will be copied.
   *
   * \since 6.0.0
   */
  explicit renderer_info(const SDL_RendererInfo info) noexcept : m_info{info}
  {}
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a `renderer_info` instance.
 *
 * \param info the renderer info instance that will be converted.
 *
 * \return a string that represents the `renderer_info` instance.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto to_string(const renderer_info& info) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("renderer_info{{name: {}}}", str_or_na(info.name()));
#else
  using namespace std::string_literals;
  return "renderer_info{name: "s + str_or_na(info.name()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a `renderer_info` instance.
 *
 * \param stream the stream that will be used.
 * \param info the `renderer_info` instance that will be printed.
 *
 * \return the used stream.
 *
 * \since 6.0.0
 */
inline auto operator<<(std::ostream& stream, const renderer_info& info) -> std::ostream&
{
  return stream << to_string(info);
}

/// \} End of streaming

/**
 * \brief Returns information about a renderer.
 *
 * \tparam T the ownership semantics of the renderer.
 *
 * \param renderer the renderer to obtain information about.
 *
 * \return information about the supplied renderer; `std::nullopt` if something goes
 * wrong.
 *
 * \since 6.0.0
 */
template <typename T>
[[nodiscard]] auto get_info(const basic_renderer<T>& renderer) noexcept
    -> std::optional<renderer_info>
{
  SDL_RendererInfo info;
  if (SDL_GetRendererInfo(renderer.get(), &info) == 0) {
    return renderer_info{info};
  }
  else {
    return std::nullopt;
  }
}

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_RENDERER_INFO_HEADER

// #include "centurion/video/scale_mode.hpp"
#ifndef CENTURION_SCALE_MODE_HEADER
#define CENTURION_SCALE_MODE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup video
/// \{

#if SDL_VERSION_ATLEAST(2, 0, 12)

/**
 * \enum scale_mode
 *
 * \brief Represents different texture scale modes.
 *
 * \since 4.0.0
 *
 * \see `SDL_ScaleMode`
 */
enum class scale_mode
{
  nearest = SDL_ScaleModeNearest,  ///< Represents nearest pixel sampling.
  linear = SDL_ScaleModeLinear,    ///< Represents linear filtering.
  best = SDL_ScaleModeBest         ///< Represents anisotropic filtering.
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied scale mode.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(scale_mode::linear) == "linear"`.
 *
 * \param mode the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const scale_mode mode) -> std::string_view
{
  switch (mode) {
    case scale_mode::nearest:
      return "nearest";

    case scale_mode::linear:
      return "linear";

    case scale_mode::best:
      return "best";

    default:
      throw cen_error{"Did not recognize scale mode!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a scale mode enumerator.
 *
 * \param stream the output stream that will be used.
 * \param mode the enumerator that will be printed.
 *
 * \see `to_string(scale_mode)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const scale_mode mode) -> std::ostream&
{
  return stream << to_string(mode);
}

/// \} End of streaming

/// \name Scale mode comparison operators
/// \{

/**
 * \brief Indicates whether or not the two scale mode values are the same.
 *
 * \param lhs the lhs scale mode value.
 * \param rhs the rhs scale mode value.
 *
 * \return `true` if the scale mode values are the same; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator==(const scale_mode lhs, const SDL_ScaleMode rhs) noexcept
    -> bool
{
  return static_cast<SDL_ScaleMode>(lhs) == rhs;
}

/// \copydoc operator==(scale_mode, SDL_ScaleMode)
[[nodiscard]] constexpr auto operator==(const SDL_ScaleMode lhs, const scale_mode rhs) noexcept
    -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the two scale mode values aren't the same.
 *
 * \param lhs the lhs scale mode value.
 * \param rhs the rhs scale mode value.
 *
 * \return `true` if the scale mode values aren't the same; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator!=(const scale_mode lhs, const SDL_ScaleMode rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(scale_mode, SDL_ScaleMode)
[[nodiscard]] constexpr auto operator!=(const SDL_ScaleMode lhs, const scale_mode rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \} End of scale mode comparison operators

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_SCALE_MODE_HEADER

// #include "centurion/video/screen.hpp"
#ifndef CENTURION_SCREEN_HEADER
#define CENTURION_SCREEN_HEADER

#include <SDL.h>

#include <optional>     // optional
#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/str.hpp"

// #include "../math/area.hpp"

// #include "../math/rect.hpp"

// #include "pixel_format.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \struct dpi_info
 *
 * \brief Provides diagonal, horizontal and vertical DPI values.
 *
 * \since 5.0.0
 */
struct dpi_info final
{
  float diagonal{};    ///< The diagonal DPI value.
  float horizontal{};  ///< The horizontal DPI value.
  float vertical{};    ///< The vertical DPI value.
};

/**
 * \enum screen_orientation
 *
 * \brief Represents different screen orientations.
 *
 * \since 5.0.0
 *
 * \see SDL_DisplayOrientation
 */
enum class screen_orientation : int
{
  unknown = SDL_ORIENTATION_UNKNOWN,
  landscape = SDL_ORIENTATION_LANDSCAPE,
  landscape_flipped = SDL_ORIENTATION_LANDSCAPE_FLIPPED,
  portrait = SDL_ORIENTATION_PORTRAIT,
  portrait_flipped = SDL_ORIENTATION_PORTRAIT_FLIPPED
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied screen orientation.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(screen_orientation::landscape) == "landscape"`.
 *
 * \param orientation the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const screen_orientation orientation)
    -> std::string_view
{
  switch (orientation) {
    case screen_orientation::unknown:
      return "unknown";

    case screen_orientation::landscape:
      return "landscape";

    case screen_orientation::landscape_flipped:
      return "landscape_flipped";

    case screen_orientation::portrait:
      return "portrait";

    case screen_orientation::portrait_flipped:
      return "portrait_flipped";

    default:
      throw cen_error{"Did not recognize screen orientation!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a screen orientation enumerator.
 *
 * \param stream the output stream that will be used.
 * \param orientation the enumerator that will be printed.
 *
 * \see `to_string(screen_orientation)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const screen_orientation orientation)
    -> std::ostream&
{
  return stream << to_string(orientation);
}

/// \} End of streaming

/**
 * \brief Sets whether or not screen savers are enabled.
 *
 * \note By default, screen savers are disabled.
 *
 * \param enabled `true` if screen savers should be enabled; `false` otherwise.
 *
 * \since 4.0.0
 */
inline void set_screen_saver_enabled(const bool enabled) noexcept
{
  if (enabled) {
    SDL_EnableScreenSaver();
  }
  else {
    SDL_DisableScreenSaver();
  }
}

/**
 * \brief Indicates whether or not screen savers are enabled.
 *
 * \note By default, screen savers are disabled.
 *
 * \return `true` if screen savers are enabled; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] inline auto is_screen_saver_enabled() noexcept -> bool
{
  return SDL_IsScreenSaverEnabled();
}

/// \} End of group video

}  // namespace cen

/// \addtogroup video
/// \{

/**
 * \namespace cen::screen
 *
 * \brief Contains functions that provide information about screen(s).
 *
 * \since 5.0.0
 */
namespace cen::screen {

/**
 * \brief Returns the amount of available displays.
 *
 * \return the number of available displays.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto count() noexcept -> int
{
  return SDL_GetNumVideoDisplays();
}

/**
 * \brief Returns the name of a display.
 *
 * \param index the index of the queried display, in the range [0,
 * `cen::screen::count()`].
 *
 * \return the name of the specified display, might be null.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto name(const int index = 0) noexcept -> str
{
  return SDL_GetDisplayName(index);
}

/**
 * \brief Returns the orientation of the specified display.
 *
 * \param index the index of the queried display, in the range [0,
 * `cen::screen::count()`].
 *
 * \return the orientation of the specified display.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto get_orientation(const int index = 0) noexcept -> screen_orientation
{
  return static_cast<screen_orientation>(SDL_GetDisplayOrientation(index));
}

/// \name Display mode queries
/// \{

/**
 * \brief Returns the desktop display mode.
 *
 * \param index the index of the queried display, in the range [0,
 * `cen::screen::count()`].
 *
 * \return the desktop display mode; `std::nullopt` if something goes wrong.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto display_mode(const int index = 0) noexcept
    -> std::optional<SDL_DisplayMode>
{
  SDL_DisplayMode mode{};
  if (SDL_GetDesktopDisplayMode(index, &mode) == 0) {
    return mode;
  }
  else {
    return std::nullopt;
  }
}

/**
 * \brief Returns the refresh rate of the screen.
 *
 * \param index the index of the queried display, in the range [0,
 * `cen::screen::count()`].
 *
 * \return the refresh rate of the screen; `std::nullopt` if something goes wrong.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto refresh_rate(const int index = 0) noexcept -> std::optional<int>
{
  if (const auto mode = display_mode(index)) {
    return mode->refresh_rate;
  }
  else {
    return std::nullopt;
  }
}

/**
 * \brief Returns the pixel format of the desktop display mode.
 *
 * \note This function returns the pixel format used by the desktop display mode, i.e. the
 * fullscreen display mode, so it might not be accurate for non-fullscreen windows.
 *
 * \param index the index of the queried display, in the range [0,
 * `cen::screen::count()`].
 *
 * \return the pixel format of the desktop display mode; `std::nullopt` if something goes
 * wrong.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto get_pixel_format(const int index = 0) noexcept
    -> std::optional<pixel_format>
{
  if (const auto mode = display_mode(index)) {
    return static_cast<pixel_format>(mode->format);
  }
  else {
    return std::nullopt;
  }
}

/**
 * \brief Returns the width of the screen.
 *
 * \param index the index of the queried display, in the range [0,
 * `cen::screen::count()`].
 *
 * \return the width of the screen; `std::nullopt` if something goes wrong.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto width(const int index = 0) noexcept -> std::optional<int>
{
  if (const auto mode = display_mode(index)) {
    return display_mode(index)->w;
  }
  else {
    return std::nullopt;
  }
}

/**
 * \brief Returns the height of the screen.
 *
 * \param index the index of the queried display, in the range [0,
 * `cen::screen::count()`].
 *
 * \return the height of the screen; `std::nullopt` if something goes wrong.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto height(const int index = 0) noexcept -> std::optional<int>
{
  if (const auto mode = display_mode(index)) {
    return display_mode(index)->h;
  }
  else {
    return std::nullopt;
  }
}

/**
 * \brief Returns the size of the screen.
 *
 * \param index the index of the queried display, in the range [0,
 * `cen::screen::count()`].
 *
 * \return the size of the screen; `std::nullopt` if something goes wrong.
 *
 * \since 4.1.0
 */
[[nodiscard]] inline auto size(const int index = 0) noexcept -> std::optional<iarea>
{
  if (const auto mode = display_mode(index)) {
    return iarea{mode->w, mode->h};
  }
  else {
    return std::nullopt;
  }
}

/**
 * \brief Returns DPI information about a display.
 *
 * \param index the index of the queried display, in the range [0,
 * `cen::screen::count()`].
 *
 * \return DPI information about the specified display; `std::nullopt` if something went
 * wrong.
 *
 * \see SDL_GetDisplayDPI
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto dpi(const int index = 0) noexcept -> std::optional<dpi_info>
{
  dpi_info info;
  if (SDL_GetDisplayDPI(index, &info.diagonal, &info.horizontal, &info.vertical) == 0) {
    return info;
  }
  else {
    return std::nullopt;
  }
}

/**
 * \brief Returns vertical DPI information about a display.
 *
 * \param index the index of the queried display, in the range [0,
 * `cen::screen::count()`].
 *
 * \return the vertical DPI information about the specified display; `std::nullopt` if
 * something went wrong.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto vertical_dpi(const int index = 0) noexcept -> std::optional<float>
{
  if (const auto info = dpi(index)) {
    return info->vertical;
  }
  else {
    return std::nullopt;
  }
}

/**
 * \brief Returns diagonal DPI information about a display.
 *
 * \param index the index of the queried display, in the range [0,
 * `cen::screen::count()`].
 *
 * \return the diagonal DPI information about the specified display; `std::nullopt` if
 * something went wrong.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto diagonal_dpi(const int index = 0) noexcept -> std::optional<float>
{
  if (const auto info = dpi(index)) {
    return info->diagonal;
  }
  else {
    return std::nullopt;
  }
}

/**
 * \brief Returns horizontal DPI information about a display.
 *
 * \param index the index of the queried display, in the range [0,
 * `cen::screen::count()`].
 *
 * \return the horizontal DPI information about the specified display; `std::nullopt` if
 * something went wrong.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto horizontal_dpi(const int index = 0) noexcept -> std::optional<float>
{
  if (const auto info = dpi(index)) {
    return info->horizontal;
  }
  else {
    return std::nullopt;
  }
}

/**
 * \brief Returns the bounds of a display.
 *
 * \param index the index of the queried display, in the range [0,
 * `cen::screen::count()`].
 *
 * \return the bounds of the specified display; `std::nullopt` if something went wrong.
 *
 * \see SDL_GetDisplayBounds
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto bounds(const int index = 0) noexcept -> std::optional<irect>
{
  irect result;
  if (SDL_GetDisplayBounds(index, result.data()) == 0) {
    return result;
  }
  else {
    return std::nullopt;
  }
}

/**
 * \brief Returns the usable bounds of a display.
 *
 * \param index the index of the queried display, in the range [0,
 * `cen::screen::count()`].
 *
 * \return the usable bounds of the specified display; `std::nullopt` if something went
 * wrong.
 *
 * \see SDL_GetDisplayUsableBounds
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto usable_bounds(const int index = 0) noexcept -> std::optional<irect>
{
  irect result;
  if (SDL_GetDisplayUsableBounds(index, result.data()) == 0) {
    return result;
  }
  else {
    return std::nullopt;
  }
}

/// \} End of display mode queries

}  // namespace cen::screen

/// \} End of group video

#endif  // CENTURION_SCREEN_HEADER
// #include "centurion/video/surface.hpp"
#ifndef CENTURION_SURFACE_HEADER
#define CENTURION_SURFACE_HEADER

#include <SDL.h>

// #include "../compiler/features.hpp"


#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#include <cassert>  // assert
#include <ostream>  // ostream
#include <string>   // string, to_string

#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/not_null.hpp"

// #include "../core/owner.hpp"

// #include "../core/result.hpp"

// #include "../core/str.hpp"

// #include "../core/to_underlying.hpp"

// #include "../detail/address_of.hpp"

// #include "../detail/owner_handle_api.hpp"

// #include "../math/area.hpp"

// #include "../math/rect.hpp"

// #include "blend_mode.hpp"

// #include "color.hpp"

// #include "pixel_format_info.hpp"


namespace cen {

/// \addtogroup video
/// \{

template <typename T>
class basic_surface;

/**
 * \typedef surface
 *
 * \brief Represents an owning surface.
 *
 * \since 5.0.0
 */
using surface = basic_surface<detail::owning_type>;

/**
 * \typedef surface_handle
 *
 * \brief Represents a non-owning surface.
 *
 * \since 5.0.0
 */
using surface_handle = basic_surface<detail::handle_type>;

/**
 * \class basic_surface
 *
 * \brief Represents a non-accelerated image.
 *
 * \ownerhandle `surface`/`surface_handle`
 *
 * \details Surfaces are often used for icons and snapshots, or as an "intermediate"
 * representation that can be manipulated, unlike textures. There is no support
 * for directly rendering surfaces. However, surfaces can be converted to textures, which
 * in turn can be rendered.
 *
 * \note Unlike most other Centurion components, surfaces can be copied.
 *
 * \since 4.0.0
 *
 * \see `surface`
 * \see `surface_handle`
 */
template <typename T>
class basic_surface final
{
 public:
  /// \name Construction
  /// \{

  // clang-format off

  /**
   * \brief Creates a surface from a pointer to an SDL surface.
   *
   * \note Depending on the type of the surface, ownership of the supplied SDL
   * surface might be claimed.
   *
   * \param surface a pointer to the associated surface.
   *
   * \since 4.0.0
   */
  explicit basic_surface(maybe_owner<SDL_Surface*> surface) noexcept(!detail::is_owning<T>())
      : m_surface{surface}
  {
    if constexpr (detail::is_owning<T>())
    {
      if (!m_surface)
      {
        throw cen_error{"Cannot create surface from null pointer!"};
      }
    }
  }

  // clang-format on

#ifndef CENTURION_NO_SDL_IMAGE

  /**
   * \brief Creates a surface based on the image at the specified path.
   *
   * \tparam BB dummy parameter for SFINAE.
   *
   * \param file the file path of the image file that will be loaded, can't
   * be null.
   *
   * \throws img_error if the surface cannot be created.
   *
   * \since 4.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_surface(const not_null<str> file) : m_surface{IMG_Load(file)}
  {
    if (!m_surface) {
      throw img_error{};
    }
  }

  /**
   * \brief Creates a surface based on the image at the specified path.
   *
   * \tparam BB dummy parameter for SFINAE.
   *
   * \param file the file path of the image file that will be loaded.
   *
   * \throws img_error if the surface cannot be created.
   *
   * \since 5.3.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_surface(const std::string& file) : basic_surface{file.c_str()}
  {}

#endif  // CENTURION_NO_SDL_IMAGE

  /**
   * \brief Creates a surface with the specified dimensions and pixel format.
   *
   * \tparam BB dummy parameter for SFINAE.
   *
   * \param size the size of the surface.
   * \param pixelFormat the pixel format that will be used by the surface.
   *
   * \throws sdl_error if the surface cannot be created.
   *
   * \since 5.3.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  basic_surface(const iarea size, const pixel_format pixelFormat)
      : m_surface{SDL_CreateRGBSurfaceWithFormat(0,
                                                 size.width,
                                                 size.height,
                                                 0,
                                                 to_underlying(pixelFormat))}
  {
    if (!m_surface) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates and returns a surface with the specified characteristics.
   *
   * \tparam BB dummy parameter for SFINAE.
   *
   * \param file the file path of the image that the surface will be based on.
   * \param blendMode the blend mode that will be used.
   * \param pixelFormat the pixel format that will be used.
   *
   * \return an owning surface, with the specified blend mode and pixel format.
   *
   * \since 5.2.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto with_format(const not_null<str> file,
                                        const blend_mode blendMode,
                                        const pixel_format pixelFormat) -> basic_surface
  {
    assert(file);

    basic_surface source{file};
    source.set_blend_mode(blendMode);

    return source.convert(pixelFormat);
  }

  /**
   * \see with_format()
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto with_format(const std::string& file,
                                        const blend_mode blendMode,
                                        const pixel_format pixelFormat) -> basic_surface
  {
    return with_format(file.c_str(), blendMode, pixelFormat);
  }

  /**
   * \brief Creates and returns a surface based on a BMP file.
   *
   * \tparam BB dummy parameter for SFINAE.
   *
   * \param file the path to the BMP file that contains the surface data.
   *
   * \return the created surface.
   *
   * \throws sdl_error if the surface couldn't be loaded.
   *
   * \since 5.3.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto from_bmp(const not_null<str> file) -> basic_surface
  {
    assert(file);
    return basic_surface{SDL_LoadBMP(file)};
  }

  /**
   * \see from_bmp()
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto from_bmp(const std::string& file) -> basic_surface
  {
    return from_bmp(file.c_str());
  }

  /**
   * \brief Creates a copy of the supplied surface.
   *
   * \param other the surface that will be copied.
   *
   * \since 4.0.0
   */
  basic_surface(const basic_surface& other) noexcept(!detail::is_owning<T>())
  {
    if constexpr (detail::is_owning<T>()) {
      copy(other);
    }
    else {
      m_surface = other.get();
    }
  }

  /**
   * \brief Creates a surface by moving the supplied surface.
   *
   * \param other the surface that will be moved.
   *
   * \since 4.0.0
   */
  basic_surface(basic_surface&& other) noexcept = default;

  /// \} End of construction

  /**
   * \brief Copies the supplied surface.
   *
   * \param other the surface that will be copied.
   *
   * \throws sdl_error if the supplied surface couldn't be copied.
   *
   * \since 4.0.0
   */
  auto operator=(const basic_surface& other) noexcept(!detail::is_owning<T>())
      -> basic_surface&
  {
    if (this != &other) {
      if constexpr (detail::is_owning<T>()) {
        copy(other);
      }
      else {
        m_surface = other.get();
      }
    }
    return *this;
  }

  /**
   * \brief Moves the supplied surface into this surface.
   *
   * \param other the surface that will be moved.
   *
   * \return the surface that claimed the supplied surface.
   *
   * \since 4.0.0
   */
  auto operator=(basic_surface&& other) noexcept -> basic_surface& = default;

  /// \name Save functions
  /// \{

  /**
   * \brief Saves the surface as a BMP image.
   *
   * \param file the file path that the surface data will be saved at.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.3.0
   */
  auto save_as_bmp(const not_null<str> file) const noexcept -> result
  {
    assert(file);
    return SDL_SaveBMP(get(), file) != -1;
  }

  /**
   * \see save_as_bmp()
   * \since 6.0.0
   */
  auto save_as_bmp(const std::string& file) const noexcept -> result  // NOLINT
  {
    return save_as_bmp(file.c_str());
  }

#ifndef CENTURION_NO_SDL_IMAGE

  /**
   * \brief Saves the surface as a PNG image.
   *
   * \param file the file path that the surface data will be saved at.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 6.0.0
   */
  auto save_as_png(const not_null<str> file) const noexcept -> result
  {
    assert(file);
    return IMG_SavePNG(get(), file) != -1;
  }

  /**
   * \see save_as_png()
   * \since 6.0.0
   */
  auto save_as_png(const std::string& file) const noexcept -> result  // NOLINT
  {
    return save_as_png(file.c_str());
  }

  /**
   * \brief Saves the surface as a JPG image.
   *
   * \note The quality parameter is supplied to libjpeg in the SDL
   * implementation, but the limitations on its values are unknown at the time
   * of writing.
   *
   * \param file the file path that the surface data will be saved at.
   * \param quality the quality of the JPG image.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 6.0.0
   */
  auto save_as_jpg(const not_null<str> file, const int quality) const noexcept -> result
  {
    assert(file);
    return IMG_SaveJPG(get(), file, quality) != -1;
  }

  /**
   * \see save_as_jpg()
   * \since 6.0.0
   */
  auto save_as_jpg(const std::string& file, const int quality) const noexcept -> result
  {
    return save_as_jpg(file.c_str(), quality);
  }

#endif  // CENTURION_NO_SDL_IMAGE

  /// \} End of save functions

  /// \name Locking
  /// \{

  /**
   * \brief Attempts to lock the surface, so that the associated pixel data can
   * be modified.
   *
   * \details This function has no effect if `must_lock()` returns `false`.
   *
   * \return `success` if the locking of the surface was successful or if
   * locking isn't required for modifying the surface; `failure` if something
   * went wrong.
   *
   * \since 4.0.0
   */
  auto lock() noexcept -> result
  {
    if (must_lock()) {
      return SDL_LockSurface(m_surface) == 0;
    }
    else {
      return true;
    }
  }

  /**
   * \brief Unlocks the surface.
   *
   * \details This function has no effect if `must_lock()` returns `false`.
   *
   * \since 4.0.0
   */
  void unlock() noexcept
  {
    if (must_lock()) {
      SDL_UnlockSurface(m_surface);
    }
  }

  /**
   * \brief Indicates whether or not the surface must be locked before modifying
   * the pixel data associated with the surface.
   *
   * \return `true` if the surface must be locked before modification; `false`
   * otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto must_lock() const noexcept -> bool
  {
    return SDL_MUSTLOCK(m_surface);
  }

  /// \} End of locking

  /// \name Setters
  /// \{

  /**
   * \brief Sets the color of the pixel at the specified coordinate.
   *
   * \details This function has no effect if the coordinate is out-of-bounds or if
   * something goes wrong when attempting to modify the pixel data.
   *
   * \param pixel the pixel that will be changed.
   * \param color the new color of the pixel.
   *
   * \since 4.0.0
   */
  void set_pixel(const ipoint pixel, const color& color) noexcept
  {
    if (!in_bounds(pixel) || !lock()) {
      return;
    }

    const int nPixels = (m_surface->pitch / 4) * height();
    const int index = (pixel.y() * width()) + pixel.x();

    if ((index >= 0) && (index < nPixels)) {
      const auto info = format_info();
      auto* pixels = reinterpret_cast<u32*>(m_surface->pixels);
      pixels[index] = info.rgba_to_pixel(color);
    }

    unlock();
  }

  /**
   * \brief Sets the alpha component modulation value.
   *
   * \param alpha the new alpha component value, in the range [0, 255].
   *
   * \since 4.0.0
   */
  void set_alpha(const u8 alpha) noexcept
  {
    SDL_SetSurfaceAlphaMod(m_surface, alpha);
  }

  /**
   * \brief Sets the color modulation that will be used by the surface.
   *
   * \param color the color that represents the color modulation that will be
   * used.
   *
   * \since 4.0.0
   */
  void set_color_mod(const color& color) noexcept
  {
    SDL_SetSurfaceColorMod(m_surface, color.red(), color.green(), color.blue());
  }

  /**
   * \brief Sets the blend mode that will be used by the surface.
   *
   * \param mode the blend mode that will be used.
   *
   * \since 4.0.0
   */
  void set_blend_mode(const blend_mode mode) noexcept
  {
    SDL_SetSurfaceBlendMode(m_surface, static_cast<SDL_BlendMode>(mode));
  }

  /**
   * \brief Sets the value of the RLE acceleration hint.
   *
   * \param enabled `true` if the RLE optimization hint should be enabled;
   * `false` otherwise.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \see is_rle_enabled()
   *
   * \since 5.2.0
   */
  auto set_rle_hint(const bool enabled) noexcept -> result
  {
    return SDL_SetSurfaceRLE(m_surface, enabled ? 1 : 0) == 0;
  }

  /// \} End of setters

  /// \name Getters
  /// \{

  /**
   * \brief Returns the alpha component modulation of the surface.
   *
   * \return the alpha modulation value, in the range [0, 255].
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto alpha() const noexcept -> u8
  {
    u8 alpha{0xFF};
    SDL_GetSurfaceAlphaMod(m_surface, &alpha);
    return alpha;
  }

  /**
   * \brief Returns the color modulation of the surface.
   *
   * \return a color that represents the color modulation of the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto color_mod() const noexcept -> color
  {
    u8 red{};
    u8 green{};
    u8 blue{};
    SDL_GetSurfaceColorMod(m_surface, &red, &green, &blue);
    return color{red, green, blue};
  }

  /**
   * \brief Returns the blend mode that is being used by the surface.
   *
   * \return the blend mode that the surface uses.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get_blend_mode() const noexcept -> blend_mode
  {
    SDL_BlendMode mode{};
    SDL_GetSurfaceBlendMode(m_surface, &mode);
    return static_cast<blend_mode>(mode);
  }

  /**
   * \brief Creates and returns a surface based on this surface with the
   * specified pixel format.
   *
   * \param format the pixel format that will be used by the new surface.
   *
   * \return a surface based on this surface with the specified
   * pixel format.
   *
   * \throws sdl_error if the surface cannot be created.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto convert(const pixel_format format) const -> basic_surface
  {
    if (auto* converted = SDL_ConvertSurfaceFormat(m_surface, to_underlying(format), 0)) {
      basic_surface result{converted};
      result.set_blend_mode(get_blend_mode());
      return result;
    }
    else {
      throw sdl_error{};
    }
  }

  /**
   * \brief Returns the width of the surface.
   *
   * \return the width of the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto width() const noexcept -> int
  {
    return m_surface->w;
  }

  /**
   * \brief Returns the height of the surface.
   *
   * \return the height of the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto height() const noexcept -> int
  {
    return m_surface->h;
  }

  /**
   * \brief Returns the size of the surface.
   *
   * \return the size of the surface.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto size() const noexcept -> iarea
  {
    return iarea{width(), height()};
  }

  /**
   * \brief Returns the pitch (the length of a row of pixels in bytes) of the
   * surface.
   *
   * \return the pitch of the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto pitch() const noexcept -> int
  {
    return m_surface->pitch;
  }

  /**
   * \brief Returns a pointer to the pixel data of the surface.
   *
   * \details It's possible to modify the surface through the returned pointer.
   *
   * \return a pointer to the pixel data of the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto pixels() noexcept -> void*
  {
    return m_surface->pixels;
  }

  /**
   * \brief Returns a pointer to the pixel data of the surface.
   *
   * \return a pointer to the pixel data of the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto pixels() const noexcept -> const void*
  {
    return m_surface->pixels;
  }

  /**
   * \brief Returns a pointer to the pixel data of the surface.
   *
   * \return a pointer to the pixel data of the surface.
   *
   * \since 5.3.0
   */
  [[nodiscard]] auto data() noexcept -> void*
  {
    return pixels();
  }

  /**
   * \copydoc data()
   */
  [[nodiscard]] auto data() const noexcept -> const void*
  {
    return pixels();
  }

  /**
   * \brief Returns the pixel format info associated with the surface.
   *
   * \return the associated pixel format info.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto format_info() const noexcept -> pixel_format_info_handle
  {
    return pixel_format_info_handle{m_surface->format};
  }

  /**
   * \brief Returns the clipping information associated with the surface.
   *
   * \return the clipping information associated with the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto clip() const noexcept -> irect
  {
    const auto rect = m_surface->clip_rect;
    return {{rect.x, rect.y}, {rect.w, rect.h}};
  }

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Indicates whether or not the surface is RLE-enabled.
   *
   * \return `true` if the surface is RLE-enabled; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto is_rle_enabled() const noexcept -> bool
  {
    return SDL_HasSurfaceRLE(m_surface) == SDL_TRUE;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Returns a pointer to the associated `SDL_Surface`.
   *
   * \warning Don't take ownership of the returned pointer!
   *
   * \return a pointer to the associated `SDL_Surface`.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_Surface*
  {
    return m_surface.get();
  }

  /// \} End of getters

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not a surface handle holds a non-null pointer.
   *
   * \tparam BB dummy parameter for SFINAE.
   *
   * \return `true` if the surface handle holds a non-null pointer; `false`
   * otherwise.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit operator bool() const noexcept
  {
    return m_surface != nullptr;
  }

  /**
   * \brief Converts to `SDL_Surface*`.
   *
   * \return a pointer to the associated `SDL_Surface`.
   *
   * \since 4.0.0
   */
  [[nodiscard]] explicit operator SDL_Surface*() noexcept
  {
    return get();
  }

  /**
   * \brief Converts to `const SDL_Surface*`.
   *
   * \return a pointer to the associated `SDL_Surface`.
   *
   * \since 4.0.0
   */
  [[nodiscard]] explicit operator const SDL_Surface*() const noexcept
  {
    return get();
  }

  /// \} End of conversions

 private:
  struct deleter final
  {
    void operator()(SDL_Surface* surface) noexcept
    {
      SDL_FreeSurface(surface);
    }
  };
  detail::pointer_manager<T, SDL_Surface, deleter> m_surface;

  /**
   * \brief Copies the contents of the supplied surface instance into this
   * instance.
   *
   * \param other the instance that will be copied.
   *
   * \throws sdl_error if the surface cannot be copied.
   *
   * \since 4.0.0
   */
  void copy(const basic_surface& other)
  {
    m_surface.reset(other.copy_surface());
  }

  /**
   * \brief Indicates whether or not the supplied point is within the bounds of
   * the surface.
   *
   * \param point the point that will be checked.
   *
   * \return `true` if the point is within the bounds of the surface; `false`
   * otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto in_bounds(const ipoint point) const noexcept -> bool
  {
    return !(point.x() < 0 || point.y() < 0 || point.x() >= width() || point.y() >= height());
  }

  /**
   * \brief Creates and returns copy of the associated `SDL_Surface`.
   *
   * \return a copy of the associated `SDL_Surface`, the returned pointer won't
   * be null.
   *
   * \throws sdl_error if the copy couldn't be created.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto copy_surface() const -> owner<SDL_Surface*>
  {
    if (auto* copy = SDL_DuplicateSurface(m_surface)) {
      return copy;
    }
    else {
      throw sdl_error{};
    }
  }

#ifdef CENTURION_MOCK_FRIENDLY_MODE

 public:
  basic_surface() = default;
#endif  // CENTURION_MOCK_FRIENDLY_MODE
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a surface.
 *
 * \param surface the surface that will be converted.
 *
 * \return a textual representation of the surface.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_surface<T>& surface) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("surface{{data: {}, width: {}, height: {}}}",
                     detail::address_of(surface.get()),
                     surface.width(),
                     surface.height());
#else
  return "surface{data: " + detail::address_of(surface.get()) +
         ", width: " + std::to_string(surface.width()) +
         ", height: " + std::to_string(surface.height()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a surface.
 *
 * \param stream the stream that will be used.
 * \param surface the surface that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_surface<T>& surface) -> std::ostream&
{
  return stream << to_string(surface);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_SURFACE_HEADER

// #include "centurion/video/system_cursor.hpp"
#ifndef CENTURION_SYSTEM_CURSOR_HEADER
#define CENTURION_SYSTEM_CURSOR_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum system_cursor
 *
 * \brief Represents the various available system cursors.
 *
 * \since 4.0.0
 *
 * \see `SDL_SystemCursor`
 * \see `system_cursor_count()`
 */
enum class system_cursor
{
  arrow = SDL_SYSTEM_CURSOR_ARROW,
  ibeam = SDL_SYSTEM_CURSOR_IBEAM,
  wait = SDL_SYSTEM_CURSOR_WAIT,
  crosshair = SDL_SYSTEM_CURSOR_CROSSHAIR,
  wait_arrow = SDL_SYSTEM_CURSOR_WAITARROW,
  arrow_nw_se = SDL_SYSTEM_CURSOR_SIZENWSE,
  arrow_ne_sw = SDL_SYSTEM_CURSOR_SIZENESW,
  arrow_w_e = SDL_SYSTEM_CURSOR_SIZEWE,
  arrow_n_s = SDL_SYSTEM_CURSOR_SIZENS,
  arrow_all = SDL_SYSTEM_CURSOR_SIZEALL,
  no = SDL_SYSTEM_CURSOR_NO,
  hand = SDL_SYSTEM_CURSOR_HAND
};

/**
 * \brief Returns the number of available system cursors.
 *
 * \return the number of system cursors.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto system_cursor_count() noexcept -> int
{
  return SDL_NUM_SYSTEM_CURSORS;
}

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied system cursor.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(system_cursor::hand) == "hand"`.
 *
 * \param cursor the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const system_cursor cursor) -> std::string_view
{
  switch (cursor) {
    case system_cursor::arrow:
      return "arrow";

    case system_cursor::ibeam:
      return "ibeam";

    case system_cursor::wait:
      return "wait";

    case system_cursor::crosshair:
      return "crosshair";

    case system_cursor::wait_arrow:
      return "wait_arrow";

    case system_cursor::arrow_nw_se:
      return "arrow_nw_se";

    case system_cursor::arrow_ne_sw:
      return "arrow_ne_sw";

    case system_cursor::arrow_w_e:
      return "arrow_w_e";

    case system_cursor::arrow_n_s:
      return "arrow_n_s";

    case system_cursor::arrow_all:
      return "arrow_all";

    case system_cursor::no:
      return "no";

    case system_cursor::hand:
      return "hand";

    default:
      throw cen_error{"Did not recognize system cursor!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a system cursor enumerator.
 *
 * \param stream the output stream that will be used.
 * \param cursor the enumerator that will be printed.
 *
 * \see `to_string(system_cursor)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const system_cursor cursor) -> std::ostream&
{
  return stream << to_string(cursor);
}

/// \} End of streaming

/// \name System cursor comparison operators
/// \{

/**
 * \brief Indicates whether or not two system cursor values are the same.
 *
 * \param lhs the left-hand side system cursor value.
 * \param rhs the right-hand side system cursor value.
 *
 * \return `true` if the system cursor values are the same; `false` otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator==(const system_cursor lhs,
                                        const SDL_SystemCursor rhs) noexcept -> bool
{
  return static_cast<SDL_SystemCursor>(lhs) == rhs;
}

/// \copydoc operator==(system_cursor, SDL_SystemCursor)
[[nodiscard]] constexpr auto operator==(const SDL_SystemCursor lhs,
                                        const system_cursor rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two system cursor values aren't the same.
 *
 * \param lhs the left-hand side system cursor value.
 * \param rhs the right-hand side system cursor value.
 *
 * \return `true` if the system cursor values aren't the same; `false`
 * otherwise.
 *
 * \since 4.0.0
 */
[[nodiscard]] constexpr auto operator!=(const system_cursor lhs,
                                        const SDL_SystemCursor rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(system_cursor, SDL_SystemCursor)
[[nodiscard]] constexpr auto operator!=(const SDL_SystemCursor lhs,
                                        const system_cursor rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of system cursor comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_SYSTEM_CURSOR_HEADER

// #include "centurion/video/texture.hpp"
#ifndef CENTURION_TEXTURE_HEADER
#define CENTURION_TEXTURE_HEADER

#include <SDL.h>

// #include "../compiler/features.hpp"


#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#include <cassert>  // assert
#include <ostream>  // ostream
#include <string>   // string, to_string

#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/not_null.hpp"

// #include "../core/owner.hpp"

// #include "../core/result.hpp"

// #include "../core/str.hpp"

// #include "../detail/address_of.hpp"

// #include "../detail/owner_handle_api.hpp"

// #include "../math/area.hpp"

// #include "../math/point.hpp"

// #include "blend_mode.hpp"

// #include "color.hpp"

// #include "pixel_format_info.hpp"

// #include "scale_mode.hpp"

// #include "surface.hpp"

// #include "texture_access.hpp"


namespace cen {

/// \addtogroup video
/// \{

template <typename T>
class basic_texture;

using texture = basic_texture<detail::owning_type>;
using texture_handle = basic_texture<detail::handle_type>;

/**
 * \class basic_texture
 *
 * \brief Represents an hardware-accelerated image, intended to be rendered using the
 * `basic_renderer` class.
 *
 * \ownerhandle `texture`/`texture_handle`
 *
 * \since 3.0.0
 *
 * \see `texture`
 * \see `texture_handle`
 */
template <typename T>
class basic_texture final
{
 public:
  /// \name Construction
  /// \{

  // clang-format off

  /**
   * \brief Creates an texture from a pre-existing SDL texture.
   *
   * \param source a pointer to the associated SDL texture.
   *
   * \throws cen_error if the supplied pointer is null *and* the texture is owning.
   *
   * \since 3.0.0
   */
  explicit basic_texture(maybe_owner<SDL_Texture*> source) noexcept(!detail::is_owning<T>())
      : m_texture{source}
  {
    if constexpr (detail::is_owning<T>())
    {
      if (!m_texture)
      {
        throw cen_error{"Cannot create texture from null pointer!"};
      }
    }
  }

  // clang-format on

  /**
   * \brief Creates a handle to texture instance.
   *
   * \param owner the associated owning texture.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit basic_texture(texture& owner) noexcept : m_texture{owner.get()}
  {}

#ifndef CENTURION_NO_SDL_IMAGE

  /**
   * \brief Creates a texture based the image at the specified path.
   *
   * \tparam Renderer the type of the renderer, e.g. `renderer` or `renderer_handle`.
   *
   * \param renderer the renderer that will be used to create the texture.
   * \param path the file path of the texture, can't be null.
   *
   * \throws img_error if the texture cannot be loaded.
   *
   * \since 4.0.0
   */
  template <typename Renderer, typename TT = T, detail::is_owner<TT> = 0>
  basic_texture(const Renderer& renderer, const not_null<str> path)
      : m_texture{IMG_LoadTexture(renderer.get(), path)}
  {
    if (!m_texture) {
      throw img_error{};
    }
  }

  /**
   * \brief Creates a texture based the image at the specified path.
   *
   * \tparam Renderer the type of the renderer, e.g. `renderer` or `renderer_handle`.
   *
   * \param renderer the renderer that will be used to create the texture.
   * \param path the file path of the texture.
   *
   * \throws img_error if the texture cannot be loaded.
   *
   * \since 5.3.0
   */
  template <typename Renderer, typename TT = T, detail::is_owner<TT> = 0>
  basic_texture(const Renderer& renderer, const std::string& path)
      : basic_texture{renderer, path.c_str()}
  {}

#endif  // CENTURION_NO_SDL_IMAGE

  /**
   * \brief Creates an texture that is a copy of the supplied surface.
   *
   * \tparam Renderer the type of the renderer, e.g. `renderer` or `renderer_handle`.
   *
   * \param renderer the renderer that will be used to create the texture.
   * \param surface the surface that the texture will be based on.
   *
   * \throws sdl_error if the texture cannot be loaded.
   *
   * \since 4.0.0
   */
  template <typename Renderer, typename TT = T, detail::is_owner<TT> = 0>
  basic_texture(const Renderer& renderer, const surface& surface)
      : m_texture{SDL_CreateTextureFromSurface(renderer.get(), surface.get())}
  {
    if (!m_texture) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates an texture with the specified characteristics.
   *
   * \tparam Renderer the type of the renderer, e.g. `renderer` or `renderer_handle`.
   *
   * \param renderer the associated renderer instance.
   * \param format the pixel format of the created texture.
   * \param access the access of the created texture.
   * \param size the size of the texture.
   *
   * \throws sdl_error if the texture cannot be created.
   *
   * \since 4.0.0
   */
  template <typename Renderer, typename TT = T, detail::is_owner<TT> = 0>
  basic_texture(const Renderer& renderer,
                const pixel_format format,
                const texture_access access,
                const iarea size)
      : m_texture{SDL_CreateTexture(renderer.get(),
                                    to_underlying(format),
                                    to_underlying(access),
                                    size.width,
                                    size.height)}
  {
    if (!m_texture) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates and returns a texture with streaming access.
   *
   * \details The created texture is based on the image at the specified path with the
   * `streaming` texture access.
   *
   * \tparam Renderer the type of the renderer, e.g. `renderer` or `renderer_handle`.
   *
   * \param renderer the renderer that will be used to create the texture.
   * \param path the path of the image file to base the texture on, can't be null.
   * \param format the pixel format that will be used by the texture.
   *
   * \throws cen_error if something goes wrong.
   *
   * \return a texture with `streaming` texture access.
   *
   * \since 4.0.0
   */
  template <typename Renderer, typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto streaming(const Renderer& renderer,
                                      const not_null<str> path,
                                      const pixel_format format) -> basic_texture
  {
    assert(path);

    constexpr auto blendMode = blend_mode::blend;
    const auto surface = cen::surface::with_format(path, blendMode, format);

    basic_texture texture{renderer, format, texture_access::streaming, surface.size()};
    texture.set_blend_mode(blendMode);

    u32* pixels{};
    if (!texture.lock(&pixels)) {
      throw sdl_error{};
    }

    const auto maxCount =
        static_cast<usize>(surface.pitch()) * static_cast<usize>(surface.height());
    SDL_memcpy(pixels, surface.pixels(), maxCount);

    texture.unlock();

    return texture;
  }

  /**
   * \see streaming()
   * \since 5.3.0
   */
  template <typename Renderer, typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto streaming(const Renderer& renderer,
                                      const std::string& path,
                                      const pixel_format format) -> basic_texture
  {
    return streaming(renderer, path.c_str(), format);
  }

  /// \} End of construction

  /// \name Setters
  /// \{

  /**
   * \brief Sets the color of the pixel at the specified coordinate.
   *
   * \details This function has no effect if the texture access isn't `streaming` or if
   * the coordinate is out-of-bounds.
   *
   * \param pixel the pixel that will be changed.
   * \param color the new color of the pixel.
   *
   * \since 4.0.0
   */
  void set_pixel(const ipoint pixel, const color& color)
  {
    if (access() != texture_access::streaming || (pixel.x() < 0) || (pixel.y() < 0) ||
        (pixel.x() >= width()) || (pixel.y() >= height()))
    {
      return;
    }

    u32* pixels{};
    int pitch{};
    if (!lock(&pixels, &pitch)) {
      return;
    }

    const int nPixels = (pitch / 4) * height();
    const int index = (pixel.y() * width()) + pixel.x();

    if ((index >= 0) && (index < nPixels)) {
      const pixel_format_info info{format()};
      pixels[index] = info.rgba_to_pixel(color);
    }

    unlock();
  }

  /**
   * \brief Sets the alpha value of the texture.
   *
   * \param alpha the alpha value, in the range [0, 255].
   *
   * \since 3.0.0
   */
  void set_alpha(const u8 alpha) noexcept
  {
    SDL_SetTextureAlphaMod(m_texture, alpha);
  }

  /**
   * \brief Sets the blend mode that will be used by the texture.
   *
   * \param mode the blend mode that will be used.
   *
   * \since 3.0.0
   */
  void set_blend_mode(const blend_mode mode) noexcept
  {
    SDL_SetTextureBlendMode(m_texture, static_cast<SDL_BlendMode>(mode));
  }

  /**
   * \brief Sets the color modulation of the texture.
   *
   * \note The alpha component in the color struct is ignored by this function.
   *
   * \param color the color that will be used to modulate the color of the texture.
   *
   * \since 3.0.0
   */
  void set_color_mod(const color& color) noexcept
  {
    SDL_SetTextureColorMod(m_texture, color.red(), color.green(), color.blue());
  }

#if SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Sets the scale mode that will be used by the texture.
   *
   * \param mode the scale mode that will be used.
   *
   * \since 4.0.0
   */
  void set_scale_mode(const scale_mode mode) noexcept
  {
    SDL_SetTextureScaleMode(m_texture, static_cast<SDL_ScaleMode>(mode));
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

  /// \} End of setters

  /// \name Getters
  /// \{

  /**
   * \brief Returns the pixel format that is used by the texture.
   *
   * \return the pixel format that is used by the texture.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto format() const noexcept -> pixel_format
  {
    u32 format{};
    SDL_QueryTexture(m_texture, &format, nullptr, nullptr, nullptr);
    return static_cast<pixel_format>(format);
  }

  /**
   * \brief Returns the texture access of the texture.
   *
   * \return the texture access of the texture.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto access() const noexcept -> texture_access
  {
    int access{};
    SDL_QueryTexture(m_texture, nullptr, &access, nullptr, nullptr);
    return static_cast<texture_access>(access);
  }

  /**
   * \brief Returns the width of the texture.
   *
   * \return the width of the texture.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto width() const noexcept -> int
  {
    const auto [width, height] = size();
    return width;
  }

  /**
   * \brief Returns the height of the texture.
   *
   * \return the height of the texture.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto height() const noexcept -> int
  {
    const auto [width, height] = size();
    return height;
  }

  /**
   * \brief Returns the size of the texture.
   *
   * \return the size of the texture.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto size() const noexcept -> iarea
  {
    int width{};
    int height{};
    SDL_QueryTexture(m_texture, nullptr, nullptr, &width, &height);
    return {width, height};
  }

  /**
   * \brief Indicates whether or not the texture is a possible render target.
   *
   * \return `true` if the texture is a possible render target; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_target() const noexcept -> bool
  {
    return access() == texture_access::target;
  }

  /**
   * \brief Indicates whether or not the texture has static texture access.
   *
   * \return `true` if the texture has static texture access; `false` otherwise.
   *
   * \since 5.1.0
   */
  [[nodiscard]] auto is_no_lock() const noexcept -> bool
  {
    return access() == texture_access::no_lock;
  }

  /**
   * \brief Indicates whether or not the texture has streaming texture access.
   *
   * \return `true` if the texture has streaming texture access; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_streaming() const noexcept -> bool
  {
    return access() == texture_access::streaming;
  }

  /**
   * \brief Returns the alpha value of the texture.
   *
   * \return the alpha value of the texture.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto alpha() const noexcept -> u8
  {
    u8 alpha{};
    SDL_GetTextureAlphaMod(m_texture, &alpha);
    return alpha;
  }

  /**
   * \brief Returns the blend mode of the texture.
   *
   * \return the blend mode of the texture.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto get_blend_mode() const noexcept -> blend_mode
  {
    SDL_BlendMode mode{};
    SDL_GetTextureBlendMode(m_texture, &mode);
    return static_cast<blend_mode>(mode);
  }

  /**
   * \brief Returns the color modulation of the texture.
   *
   * \return the modulation of the texture.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto color_mod() const noexcept -> color
  {
    u8 red{};
    u8 green{};
    u8 blue{};
    SDL_GetTextureColorMod(m_texture, &red, &green, &blue);
    return {red, green, blue, 0xFF};
  }

#if SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Returns the scale mode that is used by the texture.
   *
   * \return the scale mode that is used by the texture.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get_scale_mode() const noexcept -> scale_mode
  {
    SDL_ScaleMode mode{};
    SDL_GetTextureScaleMode(m_texture, &mode);
    return static_cast<scale_mode>(mode);
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

  /**
   * \brief Releases ownership of the associated SDL texture and returns a pointer to it.
   *
   * \warning Usage of this function should be considered dangerous, since you might run
   * into memory leak issues. You **must** call `SDL_DestroyTexture` on the returned
   * pointer to free the associated memory.
   *
   * \return a pointer to the associated SDL texture.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] auto release() noexcept -> owner<SDL_Texture*>
  {
    return m_texture.release();
  }

  /**
   * \brief Returns a pointer to the associated `SDL_Texture`.
   *
   * \return a pointer to the associated `SDL_Texture`.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_Texture*
  {
    return m_texture.get();
  }

  /// \} End of getters

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not a texture handle holds a non-null pointer.
   *
   * \return `true` if the handle holds a non-null pointer; `false` otherwise.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit operator bool() const noexcept
  {
    return m_texture != nullptr;
  }

  /**
   * \brief Converts to `SDL_Texture*`.
   *
   * \return a pointer to the associated `SDL_Texture`.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit operator SDL_Texture*() noexcept
  {
    return m_texture;
  }

  /**
   * \brief Converts to `const SDL_Texture*`.
   *
   * \return a pointer to the associated `SDL_Texture`.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit operator const SDL_Texture*() const noexcept
  {
    return m_texture;
  }

  /// \} End of conversions

 private:
  struct deleter final
  {
    void operator()(SDL_Texture* texture) noexcept
    {
      SDL_DestroyTexture(texture);
    }
  };
  detail::pointer_manager<T, SDL_Texture, deleter> m_texture;

  /**
   * \brief Locks the texture for write-only pixel access.
   *
   * \remarks This function is only applicable if the texture access of the texture is
   * `Streaming`.
   *
   * \param pixels this will be filled with a pointer to the locked pixels.
   * \param pitch This is filled in with the pitch of the locked pixels, can safely be
   * null if it isn't needed.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 4.0.0
   */
  auto lock(u32** pixels, int* pitch = nullptr) noexcept -> result
  {
    if (pitch) {
      return SDL_LockTexture(m_texture, nullptr, reinterpret_cast<void**>(pixels), pitch) == 0;
    }
    else {
      int dummyPitch;
      return SDL_LockTexture(m_texture,
                             nullptr,
                             reinterpret_cast<void**>(pixels),
                             &dummyPitch) == 0;
    }
  }

  /**
   * \brief Unlocks the texture.
   *
   * \since 4.0.0
   */
  void unlock() noexcept
  {
    SDL_UnlockTexture(m_texture);
  }
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a texture.
 *
 * \param texture the texture that will be converted.
 *
 * \return a string that represents the texture.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_texture<T>& texture) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("texture{{data: {}, width: {}, height: {}}}",
                     detail::address_of(texture.get()),
                     texture.width(),
                     texture.height());
#else
  return "texture{data: " + detail::address_of(texture.get()) +
         ", width: " + std::to_string(texture.width()) +
         ", height: " + std::to_string(texture.height()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a texture.
 *
 * \param stream the stream that will be used.
 * \param texture the texture that will be printed
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_texture<T>& texture) -> std::ostream&
{
  return stream << to_string(texture);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_TEXTURE_HEADER
// #include "centurion/video/texture_access.hpp"
#ifndef CENTURION_TEXTURE_ACCESS_HEADER
#define CENTURION_TEXTURE_ACCESS_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum texture_access
 *
 * \brief Represents different texture access modes.
 *
 * \note The `no_lock` enumerator is also referred to as "static" texture access.
 *
 * \since 3.0.0
 *
 * \see `SDL_TextureAccess`
 */
enum class texture_access : int
{
  // clang-format off
  no_lock = SDL_TEXTUREACCESS_STATIC,       ///< Texture changes rarely and isn't lockable.
  streaming = SDL_TEXTUREACCESS_STREAMING,  ///< Texture changes frequently and is lockable.
  target = SDL_TEXTUREACCESS_TARGET         ///< Texture can be used as a render target.
  // clang-format on
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied texture access.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(texture_access::streaming) == "streaming"`.
 *
 * \param access the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const texture_access access) -> std::string_view
{
  switch (access) {
    case texture_access::no_lock:
      return "no_lock";

    case texture_access::streaming:
      return "streaming";

    case texture_access::target:
      return "target";

    default:
      throw cen_error{"Did not recognize texture access!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a texture access enumerator.
 *
 * \param stream the output stream that will be used.
 * \param access the enumerator that will be printed.
 *
 * \see `to_string(texture_access)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const texture_access access) -> std::ostream&
{
  return stream << to_string(access);
}

/// \} End of streaming

/// \name Texture access comparison operators
/// \{

/**
 * \brief Indicates whether or not the two texture access values are the same.
 *
 * \param lhs the lhs texture access value.
 * \param rhs the rhs texture access value.
 *
 * \return `true` if the texture access values are the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const texture_access lhs,
                                        const SDL_TextureAccess rhs) noexcept -> bool
{
  return static_cast<SDL_TextureAccess>(lhs) == rhs;
}

/// \copydoc operator==(texture_access, SDL_TextureAccess)
[[nodiscard]] constexpr auto operator==(const SDL_TextureAccess lhs,
                                        const texture_access rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the two texture access values aren't the same.
 *
 * \param lhs the lhs texture access value.
 * \param rhs the rhs texture access value.
 *
 * \return `true` if the texture access values aren't the same; `false`
 * otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator!=(const texture_access lhs,
                                        const SDL_TextureAccess rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(texture_access, SDL_TextureAccess)
[[nodiscard]] constexpr auto operator!=(const SDL_TextureAccess lhs,
                                        const texture_access rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of texture access comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_TEXTURE_ACCESS_HEADER

// #include "centurion/video/unicode_string.hpp"
#ifndef CENTURION_UNICODE_STRING_HEADER
#define CENTURION_UNICODE_STRING_HEADER

#include <cassert>           // assert
#include <initializer_list>  // initializer_list
#include <type_traits>       // is_same_v, decay_t
#include <vector>            // vector

// #include "../compiler/compiler.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \typedef unicode
 *
 * \brief The representation of Unicode glyphs.
 *
 * \since 5.0.0
 */
using unicode = u16;

/**
 * \class unicode_string
 *
 * \brief Represents a null-terminated string encoded in unicode.
 *
 * \serializable
 *
 * \details This class is a wrapper around a `std::vector<unicode>`, that provides a
 * similar interface to that of `std::string`.
 */
class unicode_string final
{
 public:
  using value_type = std::vector<unicode>::value_type;

  using pointer = std::vector<unicode>::pointer;
  using const_pointer = std::vector<unicode>::const_pointer;

  using reference = std::vector<unicode>::reference;
  using const_reference = std::vector<unicode>::const_reference;

  using iterator = std::vector<unicode>::iterator;
  using const_iterator = std::vector<unicode>::const_iterator;

  using reverse_iterator = std::vector<unicode>::reverse_iterator;
  using const_reverse_iterator = std::vector<unicode>::const_reverse_iterator;

  using size_type = std::vector<unicode>::size_type;
  using difference_type = std::vector<unicode>::difference_type;

  /// \name Construction
  /// \{

  /**
   * \brief Creates an empty Unicode string.
   *
   * \since 5.0.0
   */
  unicode_string()
  {
    m_data.push_back(0);
  }

  /**
   * \brief Creates a Unicode string based on the supplied values.
   *
   * \param codes the list of glyphs that will be used.
   *
   * \since 5.0.0
   */
  unicode_string(std::initializer_list<unicode> codes)
  {
    reserve(codes.size() + 1);
    m_data.insert(m_data.end(), codes.begin(), codes.end());
    m_data.push_back(0);
  }

  /// \} End of construction

  /**
   * \brief Reserves enough memory to hold the specified amount of elements.
   *
   * \details Use this function to optimize additions to the string when you know or can
   * approximate the amount of elements that will be added. This can reduce the amount of
   * unnecessary allocations and copies of the underlying array.
   *
   * \param n the amount of elements to allocate memory for.
   *
   * \since 5.0.0
   */
  void reserve(const size_type n)
  {
    m_data.reserve(n);
  }

  /**
   * \brief Appends a Unicode glyph to the end of the string.
   *
   * \param ch the glyph that will be appended.
   *
   * \since 5.0.0
   */
  void append(const unicode ch)
  {
    m_data.insert(m_data.end() - 1, ch);
  }

  /**
   * \brief Appends a series of glyphs to the string.
   *
   * \tparam First the type of the first glyph, always `unicode`.
   * \tparam Character the types of the other glyphs, always `unicode`.
   *
   * \param code the pack of glyphs that will be added, cannot be empty.
   *
   * \since 5.0.0
   */
  template <typename... Character>
  void append(Character... code)
  {
    static_assert(sizeof...(Character) != 0, "Function requires at least 1 argument!");
    static_assert((std::is_same_v<unicode, std::decay_t<Character>> && ...),
                  "Cannot append values that aren't of type \"unicode\"!");
    (append(code), ...);
  }

  /// \copydoc append(unicode)
  void operator+=(const unicode ch)
  {
    append(ch);
  }

  /**
   * \brief Removes the last element from the string.
   *
   * \details This function has no effect if the string is empty.
   *
   * \since 5.0.0
   */
  void pop_back()
  {
    if (!empty()) {
      m_data.erase(m_data.end() - 2);
    }
  }

  /**
   * \brief Returns the number of elements stored in the string.
   *
   * \note This function does *not* include the null-terminator.
   *
   * \return the number of elements in the string.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto size() const noexcept -> size_type
  {
    return m_data.size() - 1;
  }

  /**
   * \brief Returns the capacity of the string.
   *
   * \return the capacity of the string (the amount of elements that can be stored before
   * needing to allocate more memory).
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto capacity() const noexcept -> size_type
  {
    return m_data.capacity();
  }

  /**
   * \brief Indicates whether or not the string is empty.
   *
   * \note The string is considered empty if the only element is the null-terminator.
   *
   * \return `true` if the string is empty; `false` otherwise.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto empty() const noexcept -> bool
  {
    return m_data.size() == 1;
  }

  /**
   * \brief Returns a pointer to the first glyph.
   *
   * \return a pointer to the first glyph.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto data() noexcept -> pointer
  {
    return m_data.data();
  }

  /// \copydoc data
  [[nodiscard]] auto data() const noexcept -> const_pointer
  {
    return m_data.data();
  }

  /**
   * \brief Returns an iterator that points to the first element in the string.
   *
   * \details Iteration using the iterator is done consecutively, as you would expect.
   *
   * \return an iterator that points to the first element in the string.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto begin() noexcept -> iterator
  {
    return m_data.begin();
  }

  /// \copydoc begin
  [[nodiscard]] auto begin() const noexcept -> const_iterator
  {
    return m_data.begin();
  }

  /**
   * \brief Returns an iterator that points one-past the last element in the string.
   *
   * \note The null-terminator is purposefully skipped.
   *
   * \return an iterator that points one-past the last element in the string.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto end() noexcept -> iterator
  {
    return m_data.end() - 1;
  }

  /// \copydoc end
  [[nodiscard]] auto end() const noexcept -> const_iterator
  {
    return m_data.end() - 1;
  }

  /**
   * \brief Returns the element at the specified index.
   *
   * \details This function will throw an exception if the supplied index is
   * out-of-bounds.
   *
   * \param index the index of the desired element.
   *
   * \return the element at the specified index.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto at(const size_type index) -> reference
  {
    return m_data.at(index);
  }

  /// \copydoc at
  [[nodiscard]] auto at(const size_type index) const -> const_reference
  {
    return m_data.at(index);
  }

  /**
   * \brief Returns the element at the specified index.
   *
   * \pre `index` **must** be in the range [0, `size()`);
   *
   * \details This function will does *not* perform bounds-checking. However, in
   * debug-mode, an assertion will abort the program if the supplied index is
   * out-of-bounds.
   *
   * \param index the index of the desired element.
   *
   * \return the element at the specified index.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto operator[](const size_type index) noexcept(on_msvc()) -> reference
  {
    assert(index < m_data.size());
    return m_data[index];
  }

  /// \copydoc operator[]
  [[nodiscard]] auto operator[](const size_type index) const noexcept(on_msvc())
      -> const_reference
  {
    assert(index < m_data.size());
    return m_data[index];
  }

  /**
   * \brief Serializes the string.
   *
   * \details This function expects that the archive provides an overloaded `operator()`,
   * used for serializing data. This API is based on the Cereal serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the string.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_data);
  }

 private:
  std::vector<unicode> m_data;
};

/// \name Unicode string comparison operators
/// \{

/**
 * \brief Indicates whether or not two Unicode strings are the same.
 *
 * \param lhs the left-hand side string.
 * \param rhs the right-hand side string.
 *
 * \return `true` if the strings are the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto operator==(const unicode_string& lhs, const unicode_string& rhs)
    -> bool
{
  if (lhs.size() != rhs.size()) {
    return false;
  }

  for (unicode_string::size_type index = 0; index < lhs.size(); ++index) {
    const auto a = lhs.at(index);
    const auto b = rhs.at(index);
    if (a != b) {
      return false;
    }
  }

  return true;
}

/**
 * \brief Indicates whether or not two Unicode strings aren't the same.
 *
 * \param lhs the left-hand side string.
 * \param rhs the right-hand side string.
 *
 * \return `true` if the strings are the same; `false` otherwise.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto operator!=(const unicode_string& lhs, const unicode_string& rhs)
    -> bool
{
  return !(lhs == rhs);
}

/// \} End of unicode string comparison operators

namespace literals {

/**
 * \brief Creates a `unicode` value from a `char`.
 *
 * \param c the character used to create the unicode value.
 *
 * \return a `unicode` value.
 *
 * \since 5.0.0
 */
constexpr auto operator""_uni(const char c) noexcept -> unicode
{
  return static_cast<unicode>(c);
}

/**
 * \brief Creates a `unicode` value from a integral value.
 *
 * \param i the integer used to create the unicode value.
 *
 * \return a `unicode` value.
 *
 * \since 5.0.0
 */
constexpr auto operator""_uni(const ulonglong i) noexcept -> unicode
{
  return static_cast<unicode>(i);
}

}  // namespace literals

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_UNICODE_STRING_HEADER

// #include "centurion/video/vulkan/vk_core.hpp"
#ifndef CENTURION_VULKAN_HEADER
#define CENTURION_VULKAN_HEADER

#ifndef CENTURION_NO_VULKAN

#include <SDL.h>
#include <SDL_vulkan.h>

#include <cassert>   // assert
#include <memory>    // unique_ptr
#include <optional>  // optional
#include <vector>    // vector

// #include "../../core/integers.hpp"
#ifndef CENTURION_INTEGERS_HEADER
#define CENTURION_INTEGERS_HEADER

#include <SDL.h>

#include <cstddef>  // size_t

namespace cen {

/// \addtogroup core
/// \{

/// \name Integer aliases
/// \{

using usize = std::size_t;

/// Alias for an unsigned integer.
using uint = unsigned int;

/// Alias for the type used for integer literal operators.
using ulonglong = unsigned long long;

/// Alias for a 64-bit unsigned integer.
using u64 = Uint64;

/// Alias for a 32-bit unsigned integer.
using u32 = Uint32;

/// Alias for a 16-bit unsigned integer.
using u16 = Uint16;

/// Alias for an 8-bit unsigned integer.
using u8 = Uint8;

/// Alias for a 64-bit signed integer.
using i64 = Sint64;

/// Alias for a 32-bit signed integer.
using i32 = Sint32;

/// Alias for a 16-bit signed integer.
using i16 = Sint16;

/// Alias for an 8-bit signed integer.
using i8 = Sint8;

/// \} End of integer aliases

// clang-format off

/**
 * \brief Obtains the size of a container as an `int`.
 *
 * \tparam T a "container" that provides a `size()` member function.
 *
 * \param container the container to query the size of.
 *
 * \return the size of the container as an `int` value.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto isize(const T& container) noexcept(noexcept(container.size()))
    -> int
{
  return static_cast<int>(container.size());
}

// clang-format on

namespace literals {

/**
 * \brief Creates an 8-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u8(const ulonglong value) noexcept -> u8
{
  return static_cast<u8>(value);
}

/**
 * \brief Creates a 16-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u16(const ulonglong value) noexcept -> u16
{
  return static_cast<u16>(value);
}

/**
 * \brief Creates a 32-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u32(const ulonglong value) noexcept -> u32
{
  return static_cast<u32>(value);
}

/**
 * \brief Creates a 64-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u64(const ulonglong value) noexcept -> u64
{
  return static_cast<u64>(value);
}

/**
 * \brief Creates an 8-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i8(const ulonglong value) noexcept -> i8
{
  return static_cast<i8>(value);
}

/**
 * \brief Creates a 16-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i16(const ulonglong value) noexcept -> i16
{
  return static_cast<i16>(value);
}

/**
 * \brief Creates a 32-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i32(const ulonglong value) noexcept -> i32
{
  return static_cast<i32>(value);
}

/**
 * \brief Creates a 64-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i64(const ulonglong value) noexcept -> i64
{
  return static_cast<i64>(value);
}

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_INTEGERS_HEADER

// #include "../../core/result.hpp"
#ifndef CENTURION_RESULT_HEADER
#define CENTURION_RESULT_HEADER

#include <ostream>  // ostream
#include <string>   // string

namespace cen {

/// \addtogroup core
/// \{

/**
 * \class result
 *
 * \brief A simple indicator for the result of different operations.
 *
 * \details The idea behind this class is to make results of various operations
 * unambiguous. Quite an amount of functions in the library may fail, and earlier versions
 * of Centurion would usually return a `bool` in those cases, where `true` and `false`
 * would indicate success and failure, respectively. This class is a development of that
 * practice. For instance, this class is contextually convertible to `bool`, where a
 * successful result is still converted to `true`, and vice versa. However, this class
 * also enables explicit checks against `success` and `failure` constants, which makes
 * code very easy to read and unambiguous.
 * \code{cpp}
 *   cen::window window;
 *
 *   if (window.set_opacity(0.4f))
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::success)
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::failure)
 *   {
 *     // Failure!
 *   }
 * \endcode
 *
 * \see `success`
 * \see `failure`
 *
 * \since 6.0.0
 */
class result final
{
 public:
  /**
   * \brief Creates a result.
   *
   * \param success `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  constexpr result(const bool success) noexcept  // NOLINT implicit
      : m_success{success}
  {}

  /// \name Comparison operators
  /// \{

  /**
   * \brief Indicates whether or not two results have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results are equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator==(const result other) const noexcept -> bool
  {
    return m_success == other.m_success;
  }

  /**
   * \brief Indicates whether or not two results don't have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results aren't equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator!=(const result other) const noexcept -> bool
  {
    return !(*this == other);
  }

  /// \} End of comparison operators

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not the result is successful.
   *
   * \return `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr explicit operator bool() const noexcept
  {
    return m_success;
  }

  /// \} End of conversions

 private:
  bool m_success{};
};

/// Represents a successful result.
/// \since 6.0.0
inline constexpr result success{true};

/// Represents a failure of some kind.
/// \since 6.0.0
inline constexpr result failure{false};

/// \name String conversions
/// \{

/**
 * \brief Returns a string that represents a result value.
 *
 * \note The returned string is in a slightly different format compared to other Centurion
 * components.
 *
 * \param result the value that will be converted.
 *
 * \return `"success"` for a successful result; `"failure"` otherwise.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto to_string(const result result) -> std::string
{
  return result ? "success" : "failure";
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a result value using a stream.
 *
 * \param stream the stream that will be used.
 * \param result the result value that will be printed.
 *
 * \return the used stream.
 *
 * \since 6.0.0
 */
inline auto operator<<(std::ostream& stream, const result result) -> std::ostream&
{
  return stream << to_string(result);
}

/// \} End of streaming

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_RESULT_HEADER

// #include "../../core/str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER

// #include "../window.hpp"
#ifndef CENTURION_WINDOW_HEADER
#define CENTURION_WINDOW_HEADER

#include <SDL.h>

#include <cassert>   // assert
#include <optional>  // optional
#include <ostream>   // ostream
#include <string>    // string, to_string

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER

// #include "../core/integers.hpp"
#ifndef CENTURION_INTEGERS_HEADER
#define CENTURION_INTEGERS_HEADER

#include <SDL.h>

#include <cstddef>  // size_t

namespace cen {

/// \addtogroup core
/// \{

/// \name Integer aliases
/// \{

using usize = std::size_t;

/// Alias for an unsigned integer.
using uint = unsigned int;

/// Alias for the type used for integer literal operators.
using ulonglong = unsigned long long;

/// Alias for a 64-bit unsigned integer.
using u64 = Uint64;

/// Alias for a 32-bit unsigned integer.
using u32 = Uint32;

/// Alias for a 16-bit unsigned integer.
using u16 = Uint16;

/// Alias for an 8-bit unsigned integer.
using u8 = Uint8;

/// Alias for a 64-bit signed integer.
using i64 = Sint64;

/// Alias for a 32-bit signed integer.
using i32 = Sint32;

/// Alias for a 16-bit signed integer.
using i16 = Sint16;

/// Alias for an 8-bit signed integer.
using i8 = Sint8;

/// \} End of integer aliases

// clang-format off

/**
 * \brief Obtains the size of a container as an `int`.
 *
 * \tparam T a "container" that provides a `size()` member function.
 *
 * \param container the container to query the size of.
 *
 * \return the size of the container as an `int` value.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto isize(const T& container) noexcept(noexcept(container.size()))
    -> int
{
  return static_cast<int>(container.size());
}

// clang-format on

namespace literals {

/**
 * \brief Creates an 8-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u8(const ulonglong value) noexcept -> u8
{
  return static_cast<u8>(value);
}

/**
 * \brief Creates a 16-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u16(const ulonglong value) noexcept -> u16
{
  return static_cast<u16>(value);
}

/**
 * \brief Creates a 32-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u32(const ulonglong value) noexcept -> u32
{
  return static_cast<u32>(value);
}

/**
 * \brief Creates a 64-bit unsigned integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit unsigned integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_u64(const ulonglong value) noexcept -> u64
{
  return static_cast<u64>(value);
}

/**
 * \brief Creates an 8-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return an 8-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i8(const ulonglong value) noexcept -> i8
{
  return static_cast<i8>(value);
}

/**
 * \brief Creates a 16-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 16-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i16(const ulonglong value) noexcept -> i16
{
  return static_cast<i16>(value);
}

/**
 * \brief Creates a 32-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 32-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i32(const ulonglong value) noexcept -> i32
{
  return static_cast<i32>(value);
}

/**
 * \brief Creates a 64-bit signed integer.
 *
 * \param value the value that will be converted.
 *
 * \return a 64-bit signed integer.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto operator""_i64(const ulonglong value) noexcept -> i64
{
  return static_cast<i64>(value);
}

}  // namespace literals

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_INTEGERS_HEADER

// #include "../core/not_null.hpp"
#ifndef CENTURION_NOT_NULL_HEADER
#define CENTURION_NOT_NULL_HEADER

// #include "sfinae.hpp"
#ifndef CENTURION_SFINAE_HEADER
#define CENTURION_SFINAE_HEADER

#include <type_traits>  // enable_if_t, is_same_v, is_integral_v, is_floating_point_v, ...

namespace cen {

/// \addtogroup core
/// \{

// clang-format off

/// Enables a template if the type is either integral of floating-point, but not a boolean.
template <typename T>
using enable_if_number_t = std::enable_if_t<!std::is_same_v<T, bool> &&
                                            (std::is_integral_v<T> ||
                                             std::is_floating_point_v<T>), int>;

// clang-format on

/// Enables a template if the type is a pointer.
template <typename T>
using enable_if_pointer_v = std::enable_if_t<std::is_pointer_v<T>, int>;

/// Enables a template if T is convertible to any of the specified types.
template <typename T, typename... Args>
using enable_if_convertible_t = std::enable_if_t<(std::is_convertible_v<T, Args> || ...), int>;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_SFINAE_HEADER


namespace cen {

/**
 * \typedef not_null
 *
 * \ingroup core
 *
 * \brief Tag used to indicate that a pointer cannot be null.
 *
 * \note This alias is equivalent to `T`, it is a no-op.
 *
 * \since 5.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using not_null = T;

}  // namespace cen

#endif  // CENTURION_NOT_NULL_HEADER

// #include "../core/owner.hpp"
#ifndef CENTURION_OWNER_HEADER
#define CENTURION_OWNER_HEADER

// #include "sfinae.hpp"


namespace cen {

/**
 * \typedef owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote ownership of raw pointers directly in code.
 *
 * \details If a function takes an `owner<T*>` as a parameter, then the function will
 * claim ownership of that pointer. Subsequently, if a function returns an `owner<T*>`,
 * then ownership is transferred to the caller.
 */
template <typename T, enable_if_pointer_v<T> = 0>
using owner = T;

/**
 * \typedef maybe_owner
 *
 * \ingroup core
 *
 * \brief Tag used to denote conditional ownership of raw pointers directly in code.
 *
 * \details This is primarily used in constructors of owner/handle classes, where the
 * owner version will claim ownership of the pointer, whilst the handle does not.
 *
 * \since 6.0.0
 */
template <typename T, enable_if_pointer_v<T> = 0>
using maybe_owner = T;

}  // namespace cen

#endif  // CENTURION_OWNER_HEADER
// #include "../core/result.hpp"
#ifndef CENTURION_RESULT_HEADER
#define CENTURION_RESULT_HEADER

#include <ostream>  // ostream
#include <string>   // string

namespace cen {

/// \addtogroup core
/// \{

/**
 * \class result
 *
 * \brief A simple indicator for the result of different operations.
 *
 * \details The idea behind this class is to make results of various operations
 * unambiguous. Quite an amount of functions in the library may fail, and earlier versions
 * of Centurion would usually return a `bool` in those cases, where `true` and `false`
 * would indicate success and failure, respectively. This class is a development of that
 * practice. For instance, this class is contextually convertible to `bool`, where a
 * successful result is still converted to `true`, and vice versa. However, this class
 * also enables explicit checks against `success` and `failure` constants, which makes
 * code very easy to read and unambiguous.
 * \code{cpp}
 *   cen::window window;
 *
 *   if (window.set_opacity(0.4f))
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::success)
 *   {
 *     // Success!
 *   }
 *
 *   if (window.set_opacity(0.4f) == cen::failure)
 *   {
 *     // Failure!
 *   }
 * \endcode
 *
 * \see `success`
 * \see `failure`
 *
 * \since 6.0.0
 */
class result final
{
 public:
  /**
   * \brief Creates a result.
   *
   * \param success `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  constexpr result(const bool success) noexcept  // NOLINT implicit
      : m_success{success}
  {}

  /// \name Comparison operators
  /// \{

  /**
   * \brief Indicates whether or not two results have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results are equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator==(const result other) const noexcept -> bool
  {
    return m_success == other.m_success;
  }

  /**
   * \brief Indicates whether or not two results don't have the same success value.
   *
   * \param other the other result.
   *
   * \return `true` if the results aren't equal; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr auto operator!=(const result other) const noexcept -> bool
  {
    return !(*this == other);
  }

  /// \} End of comparison operators

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not the result is successful.
   *
   * \return `true` if the result is successful; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] constexpr explicit operator bool() const noexcept
  {
    return m_success;
  }

  /// \} End of conversions

 private:
  bool m_success{};
};

/// Represents a successful result.
/// \since 6.0.0
inline constexpr result success{true};

/// Represents a failure of some kind.
/// \since 6.0.0
inline constexpr result failure{false};

/// \name String conversions
/// \{

/**
 * \brief Returns a string that represents a result value.
 *
 * \note The returned string is in a slightly different format compared to other Centurion
 * components.
 *
 * \param result the value that will be converted.
 *
 * \return `"success"` for a successful result; `"failure"` otherwise.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto to_string(const result result) -> std::string
{
  return result ? "success" : "failure";
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a result value using a stream.
 *
 * \param stream the stream that will be used.
 * \param result the result value that will be printed.
 *
 * \return the used stream.
 *
 * \since 6.0.0
 */
inline auto operator<<(std::ostream& stream, const result result) -> std::ostream&
{
  return stream << to_string(result);
}

/// \} End of streaming

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_RESULT_HEADER

// #include "../core/str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER

// #include "../detail/address_of.hpp"
#ifndef CENTURION_DETAIL_ADDRESS_OF_HEADER
#define CENTURION_DETAIL_ADDRESS_OF_HEADER

#include <sstream>  // stringstream
#include <string>   // string

// #include "../compiler/compiler.hpp"
#ifndef CENTURION_COMPILER_HEADER
#define CENTURION_COMPILER_HEADER

#include <SDL.h>

namespace cen {

/// \addtogroup compiler
/// \{

/**
 * \brief Indicates whether or not a "debug" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a debug build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_debug_build() noexcept -> bool
{
#ifndef NDEBUG
  return true;
#else
  return false;
#endif  // NDEBUG
}

/**
 * \brief Indicates whether or not a "release" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a release build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_release_build() noexcept -> bool
{
  return !is_debug_build();
}

/**
 * \brief Indicates whether or not the compiler is MSVC.
 *
 * \return `true` if MSVC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_msvc() noexcept -> bool
{
#ifdef _MSC_VER
  return true;
#else
  return false;
#endif  // _MSC_VER
}

/**
 * \brief Indicates whether or not the compiler is GCC.
 *
 * \return `true` if GCC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_gcc() noexcept -> bool
{
#ifdef __GNUC__
  return true;
#else
  return false;
#endif  // __GNUC__
}

/**
 * \brief Indicates whether or not the compiler is Clang.
 *
 * \return `true` if Clang is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_clang() noexcept -> bool
{
#ifdef __clang__
  return true;
#else
  return false;
#endif  // __clang__
}

/**
 * \brief Indicates whether or not the compiler is Emscripten.
 *
 * \return `true` if Emscripten is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_emscripten() noexcept -> bool
{
#ifdef __EMSCRIPTEN__
  return true;
#else
  return false;
#endif  // __EMSCRIPTEN__
}

/**
 * \brief Indicates whether or not the compiler is Intel C++.
 *
 * \return `true` if Intel C++ is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_intel_cpp() noexcept -> bool
{
#ifdef __INTEL_COMPILER
  return true;
#else
  return false;
#endif  // __INTEL_COMPILER
}

/// \} End of compiler group

}  // namespace cen

#endif  // CENTURION_COMPILER_HEADER


/// \cond FALSE
namespace cen::detail {

/**
 * \brief Returns a string that represents the memory address of the supplied pointer.
 *
 * \details The empty string is returned if the supplied pointer is null.
 *
 * \tparam T the type of the pointer.
 * \param ptr the pointer that will be converted.
 *
 * \return a string that represents the memory address of the supplied pointer.
 *
 * \since 3.0.0
 */
[[nodiscard]] inline auto address_of(const void* ptr) -> std::string
{
  if (ptr) {
    std::stringstream stream;

    if constexpr (on_msvc()) {
      stream << "0x";  // Only MSVC seems to omit this, add it for consistency
    }

    stream << ptr;
    return stream.str();
  }
  else {
    return std::string{};
  }
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_ADDRESS_OF_HEADER

// #include "../detail/clamp.hpp"
#ifndef CENTURION_DETAIL_CLAMP_HEADER
#define CENTURION_DETAIL_CLAMP_HEADER

#include <cassert>  // assert

/// \cond FALSE
namespace cen::detail {

// clang-format off

/**
 * \brief Clamps a value to be within the range [min, max].
 *
 * \pre `min` must be less than or equal to `max`.
 *
 * \note The standard library provides `std::clamp`, but it isn't mandated to be
 * `noexcept` (although MSVC does mark it as `noexcept`), which is the reason this
 * function exists.
 *
 * \tparam T the type of the values.
 *
 * \param value the value that will be clamped.
 * \param min the minimum value (inclusive).
 * \param max the maximum value (inclusive).
 *
 * \return the clamped value.
 *
 * \since 5.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto clamp(const T& value,
                                   const T& min,
                                   const T& max)
    noexcept(noexcept(value < min) && noexcept(value > max)) -> T
{
  assert(min <= max);
  if (value < min)
  {
    return min;
  }
  else if (value > max)
  {
    return max;
  }
  else
  {
    return value;
  }
}

// clang-format on

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_CLAMP_HEADER

// #include "../detail/convert_bool.hpp"
#ifndef CENTURION_DETAIL_CONVERT_BOOL_HEADER
#define CENTURION_DETAIL_CONVERT_BOOL_HEADER

#include <SDL.h>

/// \cond FALSE
namespace cen::detail {

/**
 * \brief Returns the corresponding `SDL_bool` value for the supplied boolean value.
 *
 * \param b the boolean value that will be converted.
 *
 * \return `SDL_TRUE` for `true`; `SDL_FALSE` for `false`.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto convert_bool(const bool b) noexcept -> SDL_bool
{
  return b ? SDL_TRUE : SDL_FALSE;
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_CONVERT_BOOL_HEADER

// #include "../detail/max.hpp"
#ifndef CENTURION_DETAIL_MAX_HEADER
#define CENTURION_DETAIL_MAX_HEADER

/// \cond FALSE
namespace cen::detail {

template <typename T>
[[nodiscard]] constexpr auto max(const T& a, const T& b) noexcept(noexcept(a < b)) -> T
{
  return (a < b) ? b : a;
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_MAX_HEADER

// #include "../detail/owner_handle_api.hpp"
#ifndef CENTURION_DETAIL_OWNER_HANDLE_API_HEADER
#define CENTURION_DETAIL_OWNER_HANDLE_API_HEADER

#include <cassert>      // assert
#include <memory>       // unique_ptr
#include <type_traits>  // enable_if_t, is_same_v, true_type, false_type

// #include "../core/exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER


/// \cond FALSE
namespace cen::detail {

using owning_type = std::true_type;
using handle_type = std::false_type;

template <typename T>
using is_owner = std::enable_if_t<std::is_same_v<T, owning_type>, int>;

template <typename T>
using is_handle = std::enable_if_t<std::is_same_v<T, handle_type>, int>;

template <typename T>
[[nodiscard]] constexpr auto is_owning() noexcept -> bool
{
  return std::is_same_v<T, owning_type>;
}

template <typename B, typename Type, typename Deleter>
class pointer_manager final
{
  using managed_ptr = std::unique_ptr<Type, Deleter>;
  using raw_ptr = Type*;
  using pointer_type = std::conditional_t<B::value, managed_ptr, raw_ptr>;

 public:
  pointer_manager() noexcept = default;

  explicit pointer_manager(Type* ptr) noexcept : m_ptr{ptr}
  {}

  template <typename BB = B, is_owner<BB> = 0>
  void reset(Type* ptr) noexcept
  {
    m_ptr.reset(ptr);
  }

  auto operator->() noexcept -> Type*
  {
    return get();
  }

  auto operator->() const noexcept -> const Type*
  {
    return get();
  }

  auto operator*() noexcept -> Type&
  {
    assert(m_ptr);
    return *m_ptr;
  }

  auto operator*() const noexcept -> const Type&
  {
    assert(m_ptr);
    return *m_ptr;
  }

  explicit operator bool() const noexcept
  {
    return m_ptr != nullptr;
  }

  /*implicit*/ operator Type*() const noexcept
  {
    return get();
  }

  template <typename BB = B, is_owner<BB> = 0>
  [[nodiscard]] auto release() noexcept -> Type*
  {
    return m_ptr.release();
  }

  [[nodiscard]] auto get() const noexcept -> Type*
  {
    if constexpr (B::value) {
      return m_ptr.get();
    }
    else {
      return m_ptr;
    }
  }

 private:
  pointer_type m_ptr{};
};

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_OWNER_HANDLE_API_HEADER

// #include "../math/area.hpp"
#ifndef CENTURION_AREA_HEADER
#define CENTURION_AREA_HEADER

#include <ostream>      // ostream
#include <string>       // string, to_string
#include <type_traits>  // is_integral_v, is_floating_point_v, is_same_v

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/cast.hpp"
#ifndef CENTURION_CAST_HEADER
#define CENTURION_CAST_HEADER

namespace cen {

/**
 * \brief Casts a value to a value of another type.
 *
 * \ingroup core
 *
 * \details This is the default implementation, which simply attempts to use
 * `static_cast`. The idea is that this function will be specialized for various Centurion
 * and SDL types. This is useful because it isn't always possible to implement conversion
 * operators as members.
 *
 * \tparam To the type of the value that will be converted.
 * \tparam From the type that the value will be casted to.
 *
 * \param from the value that will be converted.
 *
 * \return the result of casting the supplied value to the specified type.
 *
 * \since 5.0.0
 */
template <typename To, typename From>
[[nodiscard]] constexpr auto cast(const From& from) noexcept -> To
{
  return static_cast<To>(from);
}

}  // namespace cen

#endif  // CENTURION_CAST_HEADER


namespace cen {

/// \addtogroup math
/// \{

template <typename T>
struct basic_area;

/**
 * \typedef iarea
 *
 * \brief An alias for `int` areas.
 *
 * \since 4.1.0
 */
using iarea = basic_area<int>;

/**
 * \typedef farea
 *
 * \brief An alias for `float` areas.
 *
 * \since 4.1.0
 */
using farea = basic_area<float>;

/**
 * \typedef darea
 *
 * \brief An alias for `double` areas.
 *
 * \since 4.1.0
 */
using darea = basic_area<double>;

/**
 * \struct basic_area
 *
 * \brief Simply represents an area with a width and height.
 *
 * \serializable
 *
 * \tparam T the type of the components of the area. Must be either an integral or
 * floating-point type. Can't be `bool`.
 *
 * \since 4.0.0
 *
 * \see `iarea`
 * \see `farea`
 * \see `darea`
 */
template <typename T>
struct basic_area final
{
  static_assert(std::is_integral_v<T> || std::is_floating_point_v<T>);
  static_assert(!std::is_same_v<T, bool>);

  using value_type = T;

  T width{0};   ///< The width of the area.
  T height{0};  ///< The height of the area.

#if CENTURION_HAS_FEATURE_SPACESHIP

  [[nodiscard]] constexpr auto operator==(const basic_area&) const noexcept -> bool = default;

#endif  // CENTURION_HAS_FEATURE_SPACESHIP
};

/// \name Area-related functions
/// \{

/**
 * \brief Creates an area instance with automatically deduced precision.
 *
 * \tparam T the deduced type of the width and height values.
 *
 * \param width the width of the area.
 * \param height the height of the area.
 *
 * \return an area instance with the specified width and height.
 *
 * \since 6.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto area(const T width, const T height) noexcept -> basic_area<T>
{
  return {width, height};
}

/**
 * \brief Returns the size (width x height) of an area.
 *
 * \tparam T the representation type.
 *
 * \param area the area instance that will be calculated.
 *
 * \return the size of the area.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto area_of(const basic_area<T> area) noexcept -> T
{
  return area.width * area.height;
}

/// \} End of area-related functions

/**
 * \brief Serializes an area instance.
 *
 * \details This function expects that the archive provides an overloaded `operator()`,
 * used for serializing data. This API is based on the Cereal serialization library.
 *
 * \tparam Archive the type of the archive.
 * \tparam T the type of the area components.
 *
 * \param archive the archive used to serialize the area.
 * \param area the area that will be serialized.
 *
 * \since 5.3.0
 */
template <typename Archive, typename T>
void serialize(Archive& archive, basic_area<T>& area)
{
  archive(area.width, area.height);
}

/// \name Area cast specializations
/// \{

template <>
[[nodiscard]] constexpr auto cast(const iarea& from) noexcept -> darea
{
  return {static_cast<double>(from.width), static_cast<double>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const iarea& from) noexcept -> farea
{
  return {static_cast<float>(from.width), static_cast<float>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const farea& from) noexcept -> darea
{
  return {static_cast<double>(from.width), static_cast<double>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const farea& from) noexcept -> iarea
{
  return {static_cast<int>(from.width), static_cast<int>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const darea& from) noexcept -> farea
{
  return {static_cast<float>(from.width), static_cast<float>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const darea& from) noexcept -> iarea
{
  return {static_cast<int>(from.width), static_cast<int>(from.height)};
}

/// \} End of area cast specializations

/// \name Area comparison operators
/// \{

#if !CENTURION_HAS_FEATURE_SPACESHIP

/**
 * \brief Indicates whether or not two areas are considered to be equal.
 *
 * \param lhs the left-hand side area.
 * \param rhs the right-hand side area.
 *
 * \return `true` if the areas are equal; `false` otherwise.
 *
 * \since 4.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator==(const basic_area<T>& lhs,
                                        const basic_area<T>& rhs) noexcept -> bool
{
  return (lhs.width == rhs.width) && (lhs.height == rhs.height);
}

/**
 * \brief Indicates whether or not two areas aren't considered to be equal.
 *
 * \param lhs the left-hand side area.
 * \param rhs the right-hand side area.
 *
 * \return `true` if the areas aren't equal; `false` otherwise.
 *
 * \since 4.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator!=(const basic_area<T>& lhs,
                                        const basic_area<T>& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

#endif  // CENTURION_HAS_FEATURE_SPACESHIP

/// \} End of area comparison operators

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of an area.
 *
 * \tparam T the type of the area components.
 *
 * \param area the area that will be converted.
 *
 * \return a string that represents the area.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_area<T>& area) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("area{{width: {}, height: {}}}", area.width, area.height);
#else
  return "area{width: " + std::to_string(area.width) +
         ", height: " + std::to_string(area.height) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of an area using a stream.
 *
 * \tparam T the type of the area components.
 *
 * \param stream the stream that will be used.
 * \param area the are that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_area<T>& area) -> std::ostream&
{
  return stream << to_string(area);
}

/// \} End of streaming

/// \} End of group math

}  // namespace cen

#endif  // CENTURION_AREA_HEADER
// #include "../math/rect.hpp"
#ifndef CENTURION_RECTANGLE_HEADER
#define CENTURION_RECTANGLE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string>       // string, to_string
#include <type_traits>  // conditional_t, is_integral_v, is_floating_point_v, ...

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/cast.hpp"

// #include "../core/sfinae.hpp"
#ifndef CENTURION_SFINAE_HEADER
#define CENTURION_SFINAE_HEADER

#include <type_traits>  // enable_if_t, is_same_v, is_integral_v, is_floating_point_v, ...

namespace cen {

/// \addtogroup core
/// \{

// clang-format off

/// Enables a template if the type is either integral of floating-point, but not a boolean.
template <typename T>
using enable_if_number_t = std::enable_if_t<!std::is_same_v<T, bool> &&
                                            (std::is_integral_v<T> ||
                                             std::is_floating_point_v<T>), int>;

// clang-format on

/// Enables a template if the type is a pointer.
template <typename T>
using enable_if_pointer_v = std::enable_if_t<std::is_pointer_v<T>, int>;

/// Enables a template if T is convertible to any of the specified types.
template <typename T, typename... Args>
using enable_if_convertible_t = std::enable_if_t<(std::is_convertible_v<T, Args> || ...), int>;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_SFINAE_HEADER

// #include "../detail/max.hpp"
#ifndef CENTURION_DETAIL_MAX_HEADER
#define CENTURION_DETAIL_MAX_HEADER

/// \cond FALSE
namespace cen::detail {

template <typename T>
[[nodiscard]] constexpr auto max(const T& a, const T& b) noexcept(noexcept(a < b)) -> T
{
  return (a < b) ? b : a;
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_MAX_HEADER

// #include "../detail/min.hpp"
#ifndef CENTURION_DETAIL_MIN_HEADER
#define CENTURION_DETAIL_MIN_HEADER

/// \cond FALSE
namespace cen::detail {

template <typename T>
[[nodiscard]] constexpr auto min(const T& a, const T& b) noexcept(noexcept(a < b)) -> T
{
  return (a < b) ? a : b;
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_MIN_HEADER

// #include "area.hpp"
#ifndef CENTURION_AREA_HEADER
#define CENTURION_AREA_HEADER

#include <ostream>      // ostream
#include <string>       // string, to_string
#include <type_traits>  // is_integral_v, is_floating_point_v, is_same_v

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/cast.hpp"


namespace cen {

/// \addtogroup math
/// \{

template <typename T>
struct basic_area;

/**
 * \typedef iarea
 *
 * \brief An alias for `int` areas.
 *
 * \since 4.1.0
 */
using iarea = basic_area<int>;

/**
 * \typedef farea
 *
 * \brief An alias for `float` areas.
 *
 * \since 4.1.0
 */
using farea = basic_area<float>;

/**
 * \typedef darea
 *
 * \brief An alias for `double` areas.
 *
 * \since 4.1.0
 */
using darea = basic_area<double>;

/**
 * \struct basic_area
 *
 * \brief Simply represents an area with a width and height.
 *
 * \serializable
 *
 * \tparam T the type of the components of the area. Must be either an integral or
 * floating-point type. Can't be `bool`.
 *
 * \since 4.0.0
 *
 * \see `iarea`
 * \see `farea`
 * \see `darea`
 */
template <typename T>
struct basic_area final
{
  static_assert(std::is_integral_v<T> || std::is_floating_point_v<T>);
  static_assert(!std::is_same_v<T, bool>);

  using value_type = T;

  T width{0};   ///< The width of the area.
  T height{0};  ///< The height of the area.

#if CENTURION_HAS_FEATURE_SPACESHIP

  [[nodiscard]] constexpr auto operator==(const basic_area&) const noexcept -> bool = default;

#endif  // CENTURION_HAS_FEATURE_SPACESHIP
};

/// \name Area-related functions
/// \{

/**
 * \brief Creates an area instance with automatically deduced precision.
 *
 * \tparam T the deduced type of the width and height values.
 *
 * \param width the width of the area.
 * \param height the height of the area.
 *
 * \return an area instance with the specified width and height.
 *
 * \since 6.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto area(const T width, const T height) noexcept -> basic_area<T>
{
  return {width, height};
}

/**
 * \brief Returns the size (width x height) of an area.
 *
 * \tparam T the representation type.
 *
 * \param area the area instance that will be calculated.
 *
 * \return the size of the area.
 *
 * \since 5.3.0
 */
template <typename T>
[[nodiscard]] constexpr auto area_of(const basic_area<T> area) noexcept -> T
{
  return area.width * area.height;
}

/// \} End of area-related functions

/**
 * \brief Serializes an area instance.
 *
 * \details This function expects that the archive provides an overloaded `operator()`,
 * used for serializing data. This API is based on the Cereal serialization library.
 *
 * \tparam Archive the type of the archive.
 * \tparam T the type of the area components.
 *
 * \param archive the archive used to serialize the area.
 * \param area the area that will be serialized.
 *
 * \since 5.3.0
 */
template <typename Archive, typename T>
void serialize(Archive& archive, basic_area<T>& area)
{
  archive(area.width, area.height);
}

/// \name Area cast specializations
/// \{

template <>
[[nodiscard]] constexpr auto cast(const iarea& from) noexcept -> darea
{
  return {static_cast<double>(from.width), static_cast<double>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const iarea& from) noexcept -> farea
{
  return {static_cast<float>(from.width), static_cast<float>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const farea& from) noexcept -> darea
{
  return {static_cast<double>(from.width), static_cast<double>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const farea& from) noexcept -> iarea
{
  return {static_cast<int>(from.width), static_cast<int>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const darea& from) noexcept -> farea
{
  return {static_cast<float>(from.width), static_cast<float>(from.height)};
}

template <>
[[nodiscard]] constexpr auto cast(const darea& from) noexcept -> iarea
{
  return {static_cast<int>(from.width), static_cast<int>(from.height)};
}

/// \} End of area cast specializations

/// \name Area comparison operators
/// \{

#if !CENTURION_HAS_FEATURE_SPACESHIP

/**
 * \brief Indicates whether or not two areas are considered to be equal.
 *
 * \param lhs the left-hand side area.
 * \param rhs the right-hand side area.
 *
 * \return `true` if the areas are equal; `false` otherwise.
 *
 * \since 4.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator==(const basic_area<T>& lhs,
                                        const basic_area<T>& rhs) noexcept -> bool
{
  return (lhs.width == rhs.width) && (lhs.height == rhs.height);
}

/**
 * \brief Indicates whether or not two areas aren't considered to be equal.
 *
 * \param lhs the left-hand side area.
 * \param rhs the right-hand side area.
 *
 * \return `true` if the areas aren't equal; `false` otherwise.
 *
 * \since 4.1.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator!=(const basic_area<T>& lhs,
                                        const basic_area<T>& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

#endif  // CENTURION_HAS_FEATURE_SPACESHIP

/// \} End of area comparison operators

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of an area.
 *
 * \tparam T the type of the area components.
 *
 * \param area the area that will be converted.
 *
 * \return a string that represents the area.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_area<T>& area) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("area{{width: {}, height: {}}}", area.width, area.height);
#else
  return "area{width: " + std::to_string(area.width) +
         ", height: " + std::to_string(area.height) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of an area using a stream.
 *
 * \tparam T the type of the area components.
 *
 * \param stream the stream that will be used.
 * \param area the are that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_area<T>& area) -> std::ostream&
{
  return stream << to_string(area);
}

/// \} End of streaming

/// \} End of group math

}  // namespace cen

#endif  // CENTURION_AREA_HEADER
// #include "point.hpp"
#ifndef CENTURION_POINT_HEADER
#define CENTURION_POINT_HEADER

#include <SDL.h>

#include <cmath>        // sqrt, abs, round
#include <ostream>      // ostream
#include <string>       // string, to_string
#include <type_traits>  // conditional_t, is_integral_v, is_floating_point_v, ...

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/cast.hpp"

// #include "../core/sfinae.hpp"


namespace cen {

/// \addtogroup math
/// \{

/**
 * \brief Provides traits used by the `basic_point` class.
 *
 * \tparam T the representation type. Must be convertible to `int` or `float`.
 *
 * \since 5.0.0
 *
 * \see `basic_point`
 * \see `ipoint`
 * \see `fpoint`
 */
template <typename T, enable_if_convertible_t<T, int, float> = 0>
class point_traits final
{
 public:
  /**
   * \var isIntegral
   *
   * \brief Indicates whether or not the point is based on an integral type.
   *
   * \since 5.0.0
   */
  inline constexpr static bool isIntegral = std::is_integral_v<T>;

  /**
   * \var isFloating
   *
   * \brief Indicates whether or not the point is based on a floating-point
   * type.
   *
   * \since 5.0.0
   */
  inline constexpr static bool isFloating = std::is_floating_point_v<T>;

  /**
   * \typedef value_type
   *
   * \brief The actual representation type, i.e. `int` or `float`.
   *
   * \since 5.0.0
   */
  using value_type = std::conditional_t<isIntegral, int, float>;

  /**
   * \typedef point_type
   *
   * \brief The SDL point type, i.e. `SDL_Point` or `SDL_FPoint`.
   *
   * \since 5.0.0
   */
  using point_type = std::conditional_t<isIntegral, SDL_Point, SDL_FPoint>;
};

template <typename T>
class basic_point;

/**
 * \typedef ipoint
 *
 * \brief Alias for an `int`-based point.
 *
 * \details This type corresponds to `SDL_Point`.
 *
 * \since 5.0.0
 */
using ipoint = basic_point<int>;

/**
 * \typedef fpoint
 *
 * \brief Alias for a `float`-based point.
 *
 * \details This type corresponds to `SDL_FPoint`.
 *
 * \since 5.0.0
 */
using fpoint = basic_point<float>;

/**
 * \class basic_point
 *
 * \brief Represents a two-dimensional point.
 *
 * \serializable
 *
 * \details This class is designed as a wrapper for `SDL_Point` and `SDL_FPoint`. The
 * representation is specified by the type parameter.
 *
 * \note This point class will only use `int` or `float` as the actual internal
 * representation.
 *
 * \tparam T the representation type. Must be convertible to `int` or `float`.
 *
 * \since 5.0.0
 *
 * \see `ipoint`
 * \see `fpoint`
 * \see `point()`
 * \see `distance()`
 */
template <typename T>
class basic_point final
{
 public:
  /// \copydoc point_traits::isIntegral
  inline constexpr static bool isIntegral = point_traits<T>::isIntegral;

  /// \copydoc point_traits::isFloating
  inline constexpr static bool isFloating = point_traits<T>::isFloating;

  /// \copydoc point_traits::value_type
  using value_type = typename point_traits<T>::value_type;

  /// \copydoc point_traits::point_type
  using point_type = typename point_traits<T>::point_type;

  /// \name Construction
  /// \{

  /**
   * \brief Creates a zero-initialized point.
   *
   * \since 5.0.0
   */
  constexpr basic_point() noexcept = default;

  /**
   * \brief Creates a point with the specified coordinates.
   *
   * \param x the x-coordinate that will be used.
   * \param y the y-coordinate that will be used.
   *
   * \since 5.0.0
   */
  constexpr basic_point(const value_type x, const value_type y) noexcept
  {
    m_point.x = x;
    m_point.y = y;
  };

  /// \} End of construction

  /// \name Setters
  /// \{

  /**
   * \brief Sets the x-coordinate of the point.
   *
   * \param x the new x-coordinate.
   *
   * \since 5.0.0
   */
  constexpr void set_x(const value_type x) noexcept
  {
    m_point.x = x;
  }

  /**
   * \brief Sets the y-coordinate of the point.
   *
   * \param y the new y-coordinate.
   *
   * \since 5.0.0
   */
  constexpr void set_y(const value_type y) noexcept
  {
    m_point.y = y;
  }

  /// \} End of setters

  /// \name Getters
  /// \{

  /**
   * \brief Returns the x-coordinate of the point.
   *
   * \return the x-coordinate.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto x() const noexcept -> value_type
  {
    return m_point.x;
  }

  /**
   * \brief Returns the y-coordinate of the point.
   *
   * \return the y-coordinate.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto y() const noexcept -> value_type
  {
    return m_point.y;
  }

  /**
   * \brief Returns the internal point representation.
   *
   * \return a reference to the internal representation.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto get() noexcept -> point_type&
  {
    return m_point;
  }

  /// \copydoc get
  [[nodiscard]] constexpr auto get() const noexcept -> const point_type&
  {
    return m_point;
  }

  /**
   * \brief Returns a pointer to the internal point representation.
   *
   * \note Don't cache the returned pointer.
   *
   * \return a pointer to the point representation.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto data() noexcept -> point_type*
  {
    return &m_point;
  }

  /// \copydoc data
  [[nodiscard]] auto data() const noexcept -> const point_type*
  {
    return &m_point;
  }

  /// \} End of getters

  /// \name Conversions
  /// \{

  /**
   * \brief Converts to the internal representation.
   *
   * \return a copy of the internal point.
   *
   * \see `cen::cast`
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr explicit operator point_type() const noexcept
  {
    return m_point;
  }

  /// \copydoc data()
  [[nodiscard]] explicit operator point_type*() noexcept
  {
    return data();
  }

  /// \copydoc data()
  [[nodiscard]] explicit operator const point_type*() const noexcept
  {
    return data();
  }

  /// \} End of conversions

  /**
   * \brief Serializes the point.
   *
   * \details This function expects that the archive provides an overloaded `operator()`,
   * used for serializing data. This API is based on the Cereal serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the point.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_point.x, m_point.y);
  }

 private:
  point_type m_point{0, 0};
};

/// \name Point-related functions
/// \{

/**
 * \brief Creates a point instance with automatically deduced precision.
 *
 * \note The only supported precisions for points are `int` and `float`, so this function
 * will cast the supplied values to the corresponding type. For example, if you supply two
 * doubles to this function, the returned point will use float as the precision.
 *
 * \tparam T the deduced precision type, must be a numerical type other than `bool`.
 *
 * \param x the x-coordinate of the point.
 * \param y the y-coordinate of the point.
 *
 * \return the created point.
 *
 * \since 6.0.0
 */
template <typename T, enable_if_number_t<T> = 0>
[[nodiscard]] constexpr auto point(const T x, const T y) noexcept
    -> basic_point<typename point_traits<T>::value_type>
{
  using value_type = typename point_traits<T>::value_type;
  return basic_point<value_type>{static_cast<value_type>(x), static_cast<value_type>(y)};
}

/**
 * \brief Returns the distance between two points.
 *
 * \tparam T the representation type used by the points.
 *
 * \param from the first point.
 * \param to the second point.
 *
 * \return the distance between the two points.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto distance(const basic_point<T> from, const basic_point<T> to) noexcept ->
    typename point_traits<T>::value_type
{
  if constexpr (basic_point<T>::isIntegral) {
    const auto xDiff = std::pow(from.x() - to.x(), 2);
    const auto yDiff = std::pow(from.y() - to.y(), 2);
    const auto dist = std::sqrt(xDiff + yDiff);
    return static_cast<int>(std::round(dist));
  }
  else {
    return std::sqrt(std::pow(from.x() - to.x(), 2) + std::pow(from.y() - to.y(), 2));
  }
}

/// \} End of point-related functions

/// \name String conversions
/// \{

[[nodiscard]] inline auto to_string(const ipoint point) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("ipoint{{x: {}, y: {}}}", point.x(), point.y());
#else
  return "ipoint{x: " + std::to_string(point.x()) + ", y: " + std::to_string(point.y()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

[[nodiscard]] inline auto to_string(const fpoint point) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("fpoint{{x: {}, y: {}}}", point.x(), point.y());
#else
  return "fpoint{x: " + std::to_string(point.x()) + ", y: " + std::to_string(point.y()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

template <typename T>
auto operator<<(std::ostream& stream, const basic_point<T>& point) -> std::ostream&
{
  return stream << to_string(point);
}

/// \} End of streaming

/// \name Point cast specializations
/// \{

/**
 * \brief Converts an `fpoint` instance to the corresponding `ipoint`.
 *
 * \details This function casts the coordinates of the supplied point to `int`, and uses
 * the obtained values to create an `ipoint` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `ipoint` instance that corresponds to the supplied `fpoint`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const fpoint& from) noexcept -> ipoint
{
  const auto x = static_cast<int>(from.x());
  const auto y = static_cast<int>(from.y());
  return ipoint{x, y};
}

/**
 * \brief Converts an `ipoint` instance to the corresponding `fpoint`.
 *
 * \details This function casts the coordinates of the supplied point to `float`, and uses
 * the obtained values to create an `fpoint` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `fpoint` instance that corresponds to the supplied `ipoint`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const ipoint& from) noexcept -> fpoint
{
  const auto x = static_cast<float>(from.x());
  const auto y = static_cast<float>(from.y());
  return fpoint{x, y};
}

/**
 * \brief Converts an `SDL_FPoint` instance to the corresponding `SDL_Point`.
 *
 * \details This function casts the coordinates of the supplied point to `int`, and uses
 * the obtained values to create an `SDL_Point` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `SDL_Point` instance that corresponds to the supplied `SDL_FPoint`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const SDL_FPoint& from) noexcept -> SDL_Point
{
  const auto x = static_cast<int>(from.x);
  const auto y = static_cast<int>(from.y);
  return SDL_Point{x, y};
}

/**
 * \brief Converts an `SDL_Point` instance to the corresponding `SDL_FPoint`.
 *
 * \details This function casts the coordinates of the supplied point to `float`, and uses
 * the obtained values to create an `SDL_FPoint` instance.
 *
 * \param from the point that will be converted.
 *
 * \return an `SDL_FPoint` instance that corresponds to the supplied `SDL_Point`.
 *
 * \since 5.0.0
 */
template <>
[[nodiscard]] constexpr auto cast(const SDL_Point& from) noexcept -> SDL_FPoint
{
  const auto x = static_cast<float>(from.x);
  const auto y = static_cast<float>(from.y);
  return SDL_FPoint{x, y};
}

/// \} End of point cast specializations

/// \name Point addition and subtraction operators
/// \{

template <typename T>
[[nodiscard]] constexpr auto operator+(const basic_point<T>& lhs,
                                       const basic_point<T>& rhs) noexcept -> basic_point<T>
{
  return {lhs.x() + rhs.x(), lhs.y() + rhs.y()};
}

template <typename T>
[[nodiscard]] constexpr auto operator-(const basic_point<T>& lhs,
                                       const basic_point<T>& rhs) noexcept -> basic_point<T>
{
  return {lhs.x() - rhs.x(), lhs.y() - rhs.y()};
}

/// \} End of point addition and subtraction operators

/// \name Point comparison operators
/// \{

template <typename T>
[[nodiscard]] constexpr auto operator==(const basic_point<T> lhs,
                                        const basic_point<T> rhs) noexcept -> bool
{
  return (lhs.x() == rhs.x()) && (lhs.y() == rhs.y());
}

template <typename T>
[[nodiscard]] constexpr auto operator!=(const basic_point<T> lhs,
                                        const basic_point<T> rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of point comparison operators

/// \} End of group math

}  // namespace cen

#endif  // CENTURION_POINT_HEADER

namespace cen {

/// \addtogroup math
/// \{

/**
 * \class rect_traits
 *
 * \brief Provides rectangle traits used by `basic_rect`.
 *
 * \note Whilst it is possible to supply a type that isn't `int` or `float`, rectangles
 * will always use one of them as the representation type.
 *
 * \tparam T the representation type, must be convertible to `int` or `float`.
 *
 * \see `basic_rect`
 * \see `irect`
 * \see `frect`
 *
 * \since 5.0.0
 */
template <typename T, enable_if_convertible_t<T, int, float> = 0>
class rect_traits final
{
 public:
  inline constexpr static bool isIntegral = std::is_integral_v<T>;
  inline constexpr static bool isFloating = std::is_floating_point_v<T>;

  using value_type = std::conditional_t<isIntegral, int, float>;
  using point_type = std::conditional_t<isIntegral, ipoint, fpoint>;
  using area_type = std::conditional_t<isIntegral, iarea, farea>;
  using rect_type = std::conditional_t<isIntegral, SDL_Rect, SDL_FRect>;
};

template <typename T>
class basic_rect;

/**
 * \typedef irect
 *
 * \brief Alias for an `int`-based rectangle.
 *
 * \since 5.0.0
 */
using irect = basic_rect<int>;

/**
 * \typedef frect
 *
 * \brief Alias for a `float`-based rectangle.
 *
 * \since 5.0.0
 */
using frect = basic_rect<float>;

/**
 * \class basic_rect
 *
 * \brief A simple rectangle implementation, based on either `SDL_Rect` or `SDL_FRect`.
 *
 * \serializable
 *
 * \tparam T the representation type. Must be convertible to either `int` or `float`.
 *
 * \see `irect`
 * \see `frect`
 * \see `rect()`
 * \see `intersects()`
 * \see `collides()`
 * \see `get_union()`
 *
 * \since 4.0.0
 */
template <typename T>
class basic_rect final
{
 public:
  /**
   * \brief Indicates whether or not the rectangle is based on an integral type.
   *
   * \since 5.0.0
   */
  inline constexpr static bool isIntegral = rect_traits<T>::isIntegral;

  /**
   * \brief Indicates whether or not the rectangle is based on a floating-point
   * type.
   *
   * \since 5.0.0
   */
  inline constexpr static bool isFloating = rect_traits<T>::isFloating;

  /**
   * \typedef value_type
   *
   * \brief The representation type, i.e. `int` or `float`.
   *
   * \since 5.0.0
   */
  using value_type = typename rect_traits<T>::value_type;

  /**
   * \typedef point_type
   *
   * \brief The point type used, i.e. `ipoint` or `fpoint`.
   *
   * \since 5.0.0
   */
  using point_type = typename rect_traits<T>::point_type;

  /**
   * \typedef area_type
   *
   * \brief The area type used, i.e. `iarea` or `farea`.
   *
   * \since 5.0.0
   */
  using area_type = typename rect_traits<T>::area_type;

  /**
   * \typedef rect_type
   *
   * \brief The underlying SDL rectangle type, i.e. `SDL_Rect` or `SDL_FRect`.
   *
   * \since 5.0.0
   */
  using rect_type = typename rect_traits<T>::rect_type;

  /// \name Construction
  /// \{

  /**
   * \brief Creates a rectangle with the components (0, 0, 0, 0).
   *
   * \since 4.0.0
   */
  constexpr basic_rect() noexcept = default;

  /**
   * \brief Creates a rectangle based on an SDL rectangle.
   *
   * \param rect the rectangle that will be copied.
   *
   * \since 5.3.0
   */
  constexpr explicit basic_rect(const rect_type& rect) noexcept : m_rect{rect}
  {}

  /**
   * \brief Creates a rectangle with the supplied position and size.
   *
   * \param position the position of the rectangle.
   * \param size the size of the rectangle.
   *
   * \since 4.1.0
   */
  constexpr basic_rect(const point_type& position, const area_type& size) noexcept
      : m_rect{position.x(), position.y(), size.width, size.height}
  {}

  /**
   * \brief Creates a rectangle with the supplied position and size.
   *
   * \param x the x-coordinate of the rectangle.
   * \param y the y-coordinate of the rectangle.
   * \param width the width of the rectangle.
   * \param height the height of the rectangle.
   *
   * \since 5.3.0
   */
  constexpr basic_rect(const value_type x,
                       const value_type y,
                       const value_type width,
                       const value_type height) noexcept
      : m_rect{x, y, width, height}
  {}

  /// \} End of construction

  /// \name Setters
  /// \{

  /**
   * \brief Sets the x-coordinate of the rectangle.
   *
   * \param x the new x-coordinate of the rectangle.
   *
   * \since 4.0.0
   */
  constexpr void set_x(const value_type x) noexcept
  {
    m_rect.x = x;
  }

  /**
   * \brief Sets the y-coordinate of the rectangle.
   *
   * \param y the new y-coordinate of the rectangle.
   *
   * \since 4.0.0
   */
  constexpr void set_y(const value_type y) noexcept
  {
    m_rect.y = y;
  }

  /**
   * \brief Sets the maximum x-coordinate of the rectangle.
   *
   * \note This function preserves the width of the rectangle.
   *
   * \param maxX the new maximum x-coordinate of the rectangle.
   *
   * \since 5.1.0
   */
  constexpr void set_max_x(const value_type maxX) noexcept
  {
    m_rect.x = maxX - m_rect.w;
  }

  /**
   * \brief Sets the maximum y-coordinate of the rectangle.
   *
   * \note This function preserves the height of the rectangle.
   *
   * \param maxY the new maximum y-coordinate of the rectangle.
   *
   * \since 5.1.0
   */
  constexpr void set_max_y(const value_type maxY) noexcept
  {
    m_rect.y = maxY - m_rect.h;
  }

  /**
   * \brief Offsets the x-coordinate of the rectangle by the specified amount.
   *
   * \details This function is effectively equivalent to calling `set_x()` with the sum of
   * `x()` and `offset`.
   *
   * \param offset the offset to the x-coordinate of the rectangle.
   *
   * \since 6.0.0
   */
  constexpr void offset_x(const value_type offset) noexcept
  {
    m_rect.x += offset;
  }

  /**
   * \brief Offsets the y-coordinate of the rectangle by the specified amount.
   *
   * \details This function is effectively equivalent to calling `set_y()` with the sum of
   * `y()` and `offset`.
   *
   * \param offset the offset to the y-coordinate of the rectangle.
   *
   * \since 6.0.0
   */
  constexpr void offset_y(const value_type offset) noexcept
  {
    m_rect.y += offset;
  }

  /**
   * \brief Tweaks the width of the rectangle by the specified amount.
   *
   * \details This function is effectively equivalent to calling `set_width()` with the
   * sum of `width()` and `offset`.
   *
   * \param offset the offset to the width of the rectangle.
   *
   * \since 6.0.0
   */
  constexpr void offset_width(const value_type offset) noexcept
  {
    m_rect.w += offset;
  }

  /**
   * \brief Tweaks the height of the rectangle by the specified amount.
   *
   * \details This function is effectively equivalent to calling `set_height()` with the
   * sum of `height()` and `offset`.
   *
   * \param offset the offset to the height of the rectangle.
   *
   * \since 6.0.0
   */
  constexpr void offset_height(const value_type offset) noexcept
  {
    m_rect.h += offset;
  }

  /**
   * \brief Sets the position of the rectangle.
   *
   * \note Some frameworks have this kind of function change the size of the rectangle.
   * However, this function does *not* change the size of the rectangle.
   *
   * \param pos the new position of the rectangle.
   *
   * \since 5.1.0
   */
  constexpr void set_position(const point_type& pos) noexcept
  {
    m_rect.x = pos.x();
    m_rect.y = pos.y();
  }

  /**
   * \brief Sets the width of the rectangle.
   *
   * \param width the new width of the rectangle.
   *
   * \since 4.0.0
   */
  constexpr void set_width(const value_type width) noexcept
  {
    m_rect.w = width;
  }

  /**
   * \brief Sets the height of the rectangle.
   *
   * \param height the new height of the rectangle.
   *
   * \since 4.0.0
   */
  constexpr void set_height(const value_type height) noexcept
  {
    m_rect.h = height;
  }

  /**
   * \brief Sets the size of the rectangle.
   *
   * \param size the new size of the rectangle.
   *
   * \since 5.1.0
   */
  constexpr void set_size(const area_type& size) noexcept
  {
    m_rect.w = size.width;
    m_rect.h = size.height;
  };

  /// \} End of setters

  /// \name Queries
  /// \{

  /**
   * \brief Returns the x-coordinate of the rectangle.
   *
   * \return the x-coordinate of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto x() const noexcept -> value_type
  {
    return m_rect.x;
  }

  /**
   * \brief Returns the y-coordinate of the rectangle.
   *
   * \return the y-coordinate of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto y() const noexcept -> value_type
  {
    return m_rect.y;
  }

  /**
   * \brief Returns the position of the rectangle.
   *
   * \return the position of the rectangle.
   *
   * \since 4.1.0
   */
  [[nodiscard]] constexpr auto position() const noexcept -> point_type
  {
    return point_type{m_rect.x, m_rect.y};
  }

  /**
   * \brief Returns the width of the rectangle.
   *
   * \return the width of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto width() const noexcept -> value_type
  {
    return m_rect.w;
  }

  /**
   * \brief Returns the height of the rectangle.
   *
   * \return the height of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto height() const noexcept -> value_type
  {
    return m_rect.h;
  }

  /**
   * \brief Returns the size of the rectangle.
   *
   * \return the size of the rectangle.
   *
   * \since 4.1.0
   */
  [[nodiscard]] constexpr auto size() const noexcept -> area_type
  {
    return area_type{m_rect.w, m_rect.h};
  }

  /**
   * \brief Returns the maximum x-coordinate of the rectangle.
   *
   * \return the maximum x-coordinate of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto max_x() const noexcept -> value_type
  {
    return x() + width();
  }

  /**
   * \brief Returns the maximum y-coordinate of the rectangle.
   *
   * \return the maximum y-coordinate of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto max_y() const noexcept -> value_type
  {
    return y() + height();
  }

  /**
   * \brief Returns the x-coordinate of the center point of the rectangle.
   *
   * \return the x-coordinate of the center point of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto center_x() const noexcept -> value_type
  {
    return x() + (width() / static_cast<value_type>(2));
  }

  /**
   * \brief Returns the y-coordinate of the center point of the rectangle.
   *
   * \return the y-coordinate of the center point of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto center_y() const noexcept -> value_type
  {
    return y() + (height() / static_cast<value_type>(2));
  }

  /**
   * \brief Returns the center point of the rectangle.
   *
   * \return the center point of the rectangle.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto center() const noexcept -> point_type
  {
    return {center_x(), center_y()};
  }

  /**
   * \brief Returns the total area of the rectangle.
   *
   * \return the area of the rectangle.
   *
   * \since 4.2.0
   */
  [[nodiscard]] constexpr auto area() const noexcept -> value_type
  {
    return width() * height();
  }

  /**
   * \brief Indicates whether or not the rectangle contains the point.
   *
   * \param point the point that will be checked.
   *
   * \return `true` if the rectangle contains the point; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto contains(const point_type& point) const noexcept -> bool
  {
    const auto px = point.x();
    const auto py = point.y();
    return !(px < x() || py < y() || px > max_x() || py > max_y());
  }

  /**
   * \brief Indicates whether or not the rectangle has an area.
   *
   * \details The rectangle has an area if both the width and height are
   * greater than zero.
   *
   * \return `true` if the rectangle has an area; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] constexpr auto has_area() const noexcept -> bool
  {
    return (width() > 0) && (height() > 0);
  }

  /**
   * \brief Returns a pointer to the internal rectangle representation.
   *
   * \note Don't cache the returned pointer.
   *
   * \return a pointer to the rectangle representation.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto data() noexcept -> rect_type*
  {
    return &m_rect;
  }

  /**
   * \copydoc data()
   */
  [[nodiscard]] auto data() const noexcept -> const rect_type*
  {
    return &m_rect;
  }

  /**
   * \brief Returns the internal rectangle.
   *
   * \return a reference to the internal rectangle.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto get() noexcept -> rect_type&
  {
    return m_rect;
  }

  /**
   * \brief Returns the internal rectangle.
   *
   * \return a reference to the internal rectangle.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto get() const noexcept -> const rect_type&
  {
    return m_rect;
  }

  /// \} End of queries

  /// \name Conversions
  /// \{

  /**
   * \brief Returns a pointer to the internal rectangle.
   *
   * \return a pointer to the internal rectangle.
   *
   * \since 5.0.0
   */
  [[nodiscard]] explicit operator rect_type*() noexcept
  {
    return &m_rect;
  }

  /**
   * \brief Returns a pointer to the internal rectangle.
   *
   * \return a pointer to the internal rectangle.
   *
   * \since 5.0.0
   */
  [[nodiscard]] explicit operator const rect_type*() const noexcept
  {
    return &m_rect;
  }

  /// \} End of conversions

  /**
   * \brief Serializes the rectangle.
   *
   * \details This function expects that the archive provides an overloaded `operator()`,
   * used for serializing data. This API is based on the Cereal serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the rectangle.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_rect.x, m_rect.y, m_rect.w, m_rect.h);
  }

 private:
  rect_type m_rect{0, 0, 0, 0};
};

/// \name Rectangle functions
/// \{

/**
 * \brief Creates a rectangle with automatically deduced precision.
 *
 * \note The only supported precisions for rectangles are `int` and `float`, so this
 * function will cast the supplied values to the corresponding type. For example, if you
 * supply doubles to this function, the returned point will use float as the precision.
 *
 * \tparam T the deduced precision type.
 *
 * \param x the x-coordinate of the rectangle.
 * \param y the y-coordinate of the rectangle.
 * \param width the width of the rectangle.
 * \param height the height of the rectangle.
 *
 * \return a rectangle with the specified position and size.
 *
 * \since 6.0.0
 */
template <typename T, enable_if_number_t<T> = 0>
[[nodiscard]] constexpr auto rect(const T x, const T y, const T width, const T height) noexcept
    -> basic_rect<typename rect_traits<T>::value_type>
{
  using value_type = typename rect_traits<T>::value_type;
  return basic_rect<value_type>{static_cast<value_type>(x),
                                static_cast<value_type>(y),
                                static_cast<value_type>(width),
                                static_cast<value_type>(height)};
}

/**
 * \brief Indicates whether or not the two rectangles intersect.
 *
 * \details This function does *not* consider rectangles with overlapping borders as
 * intersecting. If you want such behaviour, see the `collides` function.
 *
 * \tparam T the representation type used by the rectangles.
 *
 * \param fst the first rectangle.
 * \param snd the second rectangle.
 *
 * \return `true` if the rectangles intersect; `false` otherwise.
 *
 * \see `collides`
 *
 * \since 4.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto intersects(const basic_rect<T>& fst,
                                        const basic_rect<T>& snd) noexcept -> bool
{
  return !(fst.x() >= snd.max_x() || fst.max_x() <= snd.x() || fst.y() >= snd.max_y() ||
           fst.max_y() <= snd.y());
}

/**
 * \brief Indicates whether or not two rectangles are colliding.
 *
 * \details This function considers rectangles with overlapping borders as colliding.
 *
 * \tparam T the representation type used by the rectangles.
 *
 * \param fst the first rectangle.
 * \param snd the second rectangle.
 *
 * \return `true` if the rectangles collide; `false` otherwise.
 *
 * \see `intersects`
 *
 * \since 4.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto collides(const basic_rect<T>& fst,
                                      const basic_rect<T>& snd) noexcept -> bool
{
  return !(fst.x() > snd.max_x() || fst.max_x() < snd.x() || fst.y() > snd.max_y() ||
           fst.max_y() < snd.y());
}

/**
 * \brief Returns the union of two rectangles.
 *
 * \details Returns a rectangle that represents the union of two rectangles.
 *
 * \tparam T the representation type used by the rectangles.
 *
 * \param fst the first rectangle.
 * \param snd the second rectangle.
 *
 * \return a rectangle that represents the union of the rectangles.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto get_union(const basic_rect<T>& fst,
                                       const basic_rect<T>& snd) noexcept -> basic_rect<T>
{
  const auto fstHasArea = fst.has_area();
  const auto sndHasArea = snd.has_area();

  if (!fstHasArea && !sndHasArea) {
    return {};
  }
  else if (!fstHasArea) {
    return snd;
  }
  else if (!sndHasArea) {
    return fst;
  }

  const auto x = detail::min(fst.x(), snd.x());
  const auto y = detail::min(fst.y(), snd.y());
  const auto maxX = detail::max(fst.max_x(), snd.max_x());
  const auto maxY = detail::max(fst.max_y(), snd.max_y());

  return {{x, y}, {maxX - x, maxY - y}};
}

/// \} End of rectangle functions

/// \name Rectangle comparison operators
/// \{

/**
 * \brief Indicates whether or not two rectangles are equal.
 *
 * \tparam T the representation type used by the rectangles.
 *
 * \param lhs the left-hand side rectangle.
 * \param rhs the right-hand side rectangle.
 *
 * \return `true` if the rectangles are equal; `false` otherwise.
 *
 * \since 4.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator==(const basic_rect<T>& lhs,
                                        const basic_rect<T>& rhs) noexcept -> bool
{
  return (lhs.x() == rhs.x()) && (lhs.y() == rhs.y()) && (lhs.width() == rhs.width()) &&
         (lhs.height() == rhs.height());
}

/**
 * \brief Indicates whether or not two rectangles aren't equal.
 *
 * \tparam T the representation type used by the rectangles.
 *
 * \param lhs the left-hand side rectangle.
 * \param rhs the right-hand side rectangle.
 *
 * \return `true` if the rectangles aren't equal; `false` otherwise.
 *
 * \since 4.0.0
 */
template <typename T>
[[nodiscard]] constexpr auto operator!=(const basic_rect<T>& lhs,
                                        const basic_rect<T>& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of rectangle comparison operators

/// \name Rectangle cast specializations
/// \{

template <>
[[nodiscard]] constexpr auto cast(const irect& from) noexcept -> frect
{
  const frect::point_type pos{static_cast<float>(from.x()), static_cast<float>(from.y())};
  const frect::area_type size{static_cast<float>(from.width()),
                              static_cast<float>(from.height())};
  return frect{pos, size};
}

template <>
[[nodiscard]] constexpr auto cast(const frect& from) noexcept -> irect
{
  const irect::point_type pos{static_cast<int>(from.x()), static_cast<int>(from.y())};
  const irect::area_type size{static_cast<int>(from.width()), static_cast<int>(from.height())};
  return irect{pos, size};
}

/// \} End of rectangle cast specializations

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a rectangle.
 *
 * \tparam T the representation type used by the rectangle.
 *
 * \param rect the rectangle that will be converted to a string.
 *
 * \return a textual representation of the rectangle.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_rect<T>& rect) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("rect{{x: {}, y: {}, width: {}, height: {}}}",
                     rect.x(),
                     rect.y(),
                     rect.width(),
                     rect.height());
#else
  return "rect{x: " + std::to_string(rect.x()) + ", y: " + std::to_string(rect.y()) +
         ", width: " + std::to_string(rect.width()) +
         ", height: " + std::to_string(rect.height()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a rectangle using a stream.
 *
 * \tparam T the representation type used by the rectangle.
 *
 * \param stream the stream that will be used.
 * \param rect the rectangle that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_rect<T>& rect) -> std::ostream&
{
  return stream << to_string(rect);
}

/// \} End of streaming

/// \} End of group math

}  // namespace cen

#endif  // CENTURION_RECTANGLE_HEADER
// #include "flash_op.hpp"
#ifndef CENTURION_FLASH_OP_HEADER
#define CENTURION_FLASH_OP_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


#if SDL_VERSION_ATLEAST(2, 0, 16)

namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum flash_op
 *
 * \brief Represents different window flash operations.
 *
 * \see `basic_window::flash()`
 * \see `to_string(flash_op)`
 *
 * \since 6.2.0
 */
enum class flash_op
{
  cancel = SDL_FLASH_CANCEL,               ///< Cancel any current flashing.
  briefly = SDL_FLASH_BRIEFLY,             ///< Briefly flash the window.
  until_focused = SDL_FLASH_UNTIL_FOCUSED  ///< Flash the window until it's focused.
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied window flash operation.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(flash_op::briefly) == "briefly"`.
 *
 * \param op the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const flash_op op) -> std::string_view
{
  switch (op) {
    case flash_op::cancel:
      return "cancel";

    case flash_op::briefly:
      return "briefly";

    case flash_op::until_focused:
      return "until_focused";

    default:
      throw cen_error{"Did not recognize window flash operation!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a window flash operation enumerator.
 *
 * \param stream the output stream that will be used.
 * \param op the enumerator that will be printed.
 *
 * \see `to_string(flash_op)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const flash_op op) -> std::ostream&
{
  return stream << to_string(op);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // SDL_VERSION_ATLEAST(2, 0, 16)

#endif  // CENTURION_FLASH_OP_HEADER

// #include "pixel_format.hpp"
#ifndef CENTURION_PIXEL_FORMAT_HEADER
#define CENTURION_PIXEL_FORMAT_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum pixel_format
 *
 * \brief Represents different pixel formats.
 *
 * \see `SDL_PixelFormatEnum`
 *
 * \since 3.1.0
 */
enum class pixel_format : u32
{
  unknown = SDL_PIXELFORMAT_UNKNOWN,

  index1lsb = SDL_PIXELFORMAT_INDEX1LSB,
  index1msb = SDL_PIXELFORMAT_INDEX1MSB,
  index4lsb = SDL_PIXELFORMAT_INDEX4LSB,
  index4msb = SDL_PIXELFORMAT_INDEX4MSB,
  index8 = SDL_PIXELFORMAT_INDEX8,

#if SDL_VERSION_ATLEAST(2, 0, 14)
  xrgb4444 = SDL_PIXELFORMAT_XRGB4444,
  xbgr4444 = SDL_PIXELFORMAT_XBGR4444,

  xrgb1555 = SDL_PIXELFORMAT_XRGB1555,
  xbgr1555 = SDL_PIXELFORMAT_XBGR1555,

  xrgb8888 = SDL_PIXELFORMAT_XRGB8888,
  xbgr8888 = SDL_PIXELFORMAT_XBGR8888,
#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  rgb332 = SDL_PIXELFORMAT_RGB332,
  rgb444 = SDL_PIXELFORMAT_RGB444,

#if SDL_VERSION_ATLEAST(2, 0, 12)
  bgr444 = SDL_PIXELFORMAT_BGR444,
#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

  rgb555 = SDL_PIXELFORMAT_RGB555,
  bgr555 = SDL_PIXELFORMAT_BGR555,

  argb4444 = SDL_PIXELFORMAT_ARGB4444,
  rgba4444 = SDL_PIXELFORMAT_RGBA4444,
  abgr4444 = SDL_PIXELFORMAT_ABGR4444,
  bgra4444 = SDL_PIXELFORMAT_BGRA4444,

  argb1555 = SDL_PIXELFORMAT_ARGB1555,
  rgba5551 = SDL_PIXELFORMAT_RGBA5551,
  abgr1555 = SDL_PIXELFORMAT_ABGR1555,
  bgra5551 = SDL_PIXELFORMAT_BGRA5551,

  rgb565 = SDL_PIXELFORMAT_RGB565,
  bgr565 = SDL_PIXELFORMAT_BGR565,

  rgb24 = SDL_PIXELFORMAT_RGB24,
  bgr24 = SDL_PIXELFORMAT_BGR24,

  rgb888 = SDL_PIXELFORMAT_RGB888,
  rgbx8888 = SDL_PIXELFORMAT_RGBX8888,
  bgr888 = SDL_PIXELFORMAT_BGR888,
  bgrx8888 = SDL_PIXELFORMAT_BGRX8888,

  argb8888 = SDL_PIXELFORMAT_ARGB8888,
  rgba8888 = SDL_PIXELFORMAT_RGBA8888,
  abgr8888 = SDL_PIXELFORMAT_ABGR8888,
  bgra8888 = SDL_PIXELFORMAT_BGRA8888,

  argb2101010 = SDL_PIXELFORMAT_ARGB2101010,

#if SDL_BYTEORDER == SDL_BIG_ENDIAN
  rgba32 = SDL_PIXELFORMAT_RGBA8888,
  argb32 = SDL_PIXELFORMAT_ARGB8888,
  bgra32 = SDL_PIXELFORMAT_BGRA8888,
  abgr32 = SDL_PIXELFORMAT_ABGR8888,
#else
  rgba32 = SDL_PIXELFORMAT_ABGR8888,
  argb32 = SDL_PIXELFORMAT_BGRA8888,
  bgra32 = SDL_PIXELFORMAT_ARGB8888,
  abgr32 = SDL_PIXELFORMAT_RGBA8888,
#endif

  yv12 = SDL_PIXELFORMAT_YV12,
  iyuv = SDL_PIXELFORMAT_IYUV,
  yuy2 = SDL_PIXELFORMAT_YUY2,
  uyvy = SDL_PIXELFORMAT_UYVY,
  yvyu = SDL_PIXELFORMAT_YVYU,
  nv12 = SDL_PIXELFORMAT_NV12,
  nv21 = SDL_PIXELFORMAT_NV21,
  external_oes = SDL_PIXELFORMAT_EXTERNAL_OES
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied pixel format.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(pixel_format::rgba8888) == "rgba8888"`.
 *
 * \param format the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const pixel_format format) -> std::string_view
{
  switch (format) {
    case pixel_format::unknown:
      return "unknown";

    case pixel_format::index1lsb:
      return "index1lsb";

    case pixel_format::index1msb:
      return "index1msb";

    case pixel_format::index4lsb:
      return "index4lsb";

    case pixel_format::index4msb:
      return "index4msb";

    case pixel_format::index8:
      return "index8";

    case pixel_format::rgb332:
      return "rgb332";

    case pixel_format::argb4444:
      return "argb4444";

    case pixel_format::rgba4444:
      return "rgba4444";

    case pixel_format::abgr4444:
      return "abgr4444";

    case pixel_format::bgra4444:
      return "bgra4444";

    case pixel_format::argb1555:
      return "argb1555";

    case pixel_format::rgba5551:
      return "rgba5551";

    case pixel_format::abgr1555:
      return "abgr1555";

    case pixel_format::bgra5551:
      return "bgra5551";

    case pixel_format::rgb565:
      return "rgb565";

    case pixel_format::bgr565:
      return "bgr565";

    case pixel_format::rgb24:
      return "rgb24";

    case pixel_format::bgr24:
      return "bgr24";

    case pixel_format::rgbx8888:
      return "rgbx8888";

    case pixel_format::bgrx8888:
      return "bgrx8888";

    case pixel_format::argb8888:
      return "argb8888";

    case pixel_format::rgba8888:
      return "rgba8888";

    case pixel_format::abgr8888:
      return "abgr8888";

    case pixel_format::bgra8888:
      return "bgra8888";

    case pixel_format::argb2101010:
      return "argb2101010";

    case pixel_format::yv12:
      return "yv12";

    case pixel_format::iyuv:
      return "iyuv";

    case pixel_format::yuy2:
      return "yuy2";

    case pixel_format::uyvy:
      return "uyvy";

    case pixel_format::yvyu:
      return "yvyu";

    case pixel_format::nv12:
      return "nv12";

    case pixel_format::nv21:
      return "nv21";

    case pixel_format::external_oes:
      return "external_oes";

#if SDL_VERSION_ATLEAST(2, 0, 14)

    case pixel_format::xrgb4444:
      return "xrgb4444";

    case pixel_format::xbgr4444:
      return "xbgr4444";

    case pixel_format::xrgb1555:
      return "xrgb1555";

    case pixel_format::xbgr1555:
      return "xbgr1555";

    case pixel_format::xrgb8888:
      return "xrgb8888";

    case pixel_format::xbgr8888:
      return "xbgr8888";

#elif SDL_VERSION_ATLEAST(2, 0, 12)

    case pixel_format::bgr444:  // Equal to xbgr4444
      return "bgr444";

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

    default:
      throw cen_error{"Did not recognize pixel format mode!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a pixel format enumerator.
 *
 * \param stream the output stream that will be used.
 * \param format the enumerator that will be printed.
 *
 * \see `to_string(pixel_format)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const pixel_format format) -> std::ostream&
{
  return stream << to_string(format);
}

/// \} End of streaming

/// \name Pixel format comparison operators
/// \{

/**
 * \brief Indicates whether or not the two pixel format values are the same.
 *
 * \param lhs the left-hand side pixel format value.
 * \param rhs the right-hand side pixel format value.
 *
 * \return `true` if the pixel format values are the same; `false` otherwise.
 *
 * \since 3.1.0
 */
[[nodiscard]] constexpr auto operator==(const pixel_format lhs,
                                        const SDL_PixelFormatEnum rhs) noexcept -> bool
{
  return static_cast<SDL_PixelFormatEnum>(lhs) == rhs;
}

/// \copydoc operator==(pixel_format, SDL_PixelFormatEnum)
[[nodiscard]] constexpr auto operator==(const SDL_PixelFormatEnum lhs,
                                        const pixel_format rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the two pixel format values aren't the same.
 *
 * \param lhs the left-hand side pixel format value.
 * \param rhs the right-hand side pixel format value.
 *
 * \return `true` if the pixel format values aren't the same; `false` otherwise.
 *
 * \since 3.1.0
 */
[[nodiscard]] constexpr auto operator!=(const pixel_format lhs,
                                        const SDL_PixelFormatEnum rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(pixel_format, SDL_PixelFormatEnum)
[[nodiscard]] constexpr auto operator!=(const SDL_PixelFormatEnum lhs,
                                        const pixel_format rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of pixel format comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_PIXEL_FORMAT_HEADER

// #include "surface.hpp"
#ifndef CENTURION_SURFACE_HEADER
#define CENTURION_SURFACE_HEADER

#include <SDL.h>

// #include "../compiler/features.hpp"


#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#include <cassert>  // assert
#include <ostream>  // ostream
#include <string>   // string, to_string

#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/not_null.hpp"

// #include "../core/owner.hpp"

// #include "../core/result.hpp"

// #include "../core/str.hpp"

// #include "../core/to_underlying.hpp"
#ifndef CENTURION_TO_UNDERLYING_HEADER
#define CENTURION_TO_UNDERLYING_HEADER

#include <type_traits>  // underlying_type_t, enable_if_t, is_enum_v

namespace cen {

/**
 * \brief Converts an enum value to an integral value using the underlying type.
 *
 * \ingroup core
 *
 * \note If you're using C++23, see `std::to_underlying()`.
 *
 * \tparam Enum the enum type.
 *
 * \param value the enum value that will be converted.
 *
 * \return the value of the enum, in the underlying type.
 *
 * \since 6.0.0
 */
template <typename Enum, std::enable_if_t<std::is_enum_v<Enum>, int> = 0>
[[nodiscard]] constexpr auto to_underlying(const Enum value) noexcept
    -> std::underlying_type_t<Enum>
{
  return static_cast<std::underlying_type_t<Enum>>(value);
}

}  // namespace cen

#endif  // CENTURION_TO_UNDERLYING_HEADER

// #include "../detail/address_of.hpp"

// #include "../detail/owner_handle_api.hpp"

// #include "../math/area.hpp"

// #include "../math/rect.hpp"

// #include "blend_mode.hpp"
#ifndef CENTURION_BLEND_MODE_HEADER
#define CENTURION_BLEND_MODE_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"

// #include "blend_factor.hpp"
#ifndef CENTURION_BLEND_FACTOR_HEADER
#define CENTURION_BLEND_FACTOR_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum blend_factor
 *
 * \brief Represents normalized factors used when multiplying pixel components.
 *
 * \see `blend_op`
 * \see `compose_blend_mode()`
 *
 * \since 6.3.0
 */
enum class blend_factor
{
  zero = SDL_BLENDFACTOR_ZERO,
  one = SDL_BLENDFACTOR_ONE,

  src_color = SDL_BLENDFACTOR_SRC_COLOR,
  one_minus_src_color = SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR,

  src_alpha = SDL_BLENDFACTOR_SRC_ALPHA,
  one_minus_src_alpha = SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA,

  dst_color = SDL_BLENDFACTOR_DST_COLOR,
  one_minus_dst_color = SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR,

  dst_alpha = SDL_BLENDFACTOR_DST_ALPHA,
  one_minus_dst_alpha = SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied blend factor.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(blend_factor::zero) == "zero"`.
 *
 * \param factor the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto to_string(const blend_factor factor) -> std::string_view
{
  switch (factor) {
    case blend_factor::zero:
      return "zero";

    case blend_factor::one:
      return "one";

    case blend_factor::src_color:
      return "src_color";

    case blend_factor::one_minus_src_color:
      return "one_minus_src_color";

    case blend_factor::src_alpha:
      return "src_alpha";

    case blend_factor::one_minus_src_alpha:
      return "one_minus_src_alpha";

    case blend_factor::dst_color:
      return "dst_color";

    case blend_factor::one_minus_dst_color:
      return "one_minus_dst_color";

    case blend_factor::dst_alpha:
      return "dst_alpha";

    case blend_factor::one_minus_dst_alpha:
      return "one_minus_dst_alpha";

    default:
      throw cen_error{"Did not recognize blend factor!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a blend factor enumerator.
 *
 * \param stream the output stream that will be used.
 * \param factor the enumerator that will be printed.
 *
 * \see `to_string(blend_factor)`
 *
 * \return the used stream.
 *
 * \since 6.3.0
 */
inline auto operator<<(std::ostream& stream, const blend_factor factor) -> std::ostream&
{
  return stream << to_string(factor);
}

/// \} End of streaming

/// \name Blend factor comparison operators
/// \{

/**
 * \brief Indicates whether or not two blend factor values are the same;
 *
 * \param lhs the left-hand side blend factor value.
 * \param rhs the right-hand side blend factor value.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto operator==(const blend_factor lhs,
                                        const SDL_BlendFactor rhs) noexcept -> bool
{
  return static_cast<SDL_BlendFactor>(lhs) == rhs;
}

/// \copydoc operator==(blend_factor, SDL_BlendFactor)
[[nodiscard]] constexpr auto operator==(const SDL_BlendFactor lhs,
                                        const blend_factor rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two blend factor values aren't the same;
 *
 * \param lhs the left-hand side blend factor value.
 * \param rhs the right-hand side blend factor value.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto operator!=(const blend_factor lhs,
                                        const SDL_BlendFactor rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(blend_factor, SDL_BlendFactor)
[[nodiscard]] constexpr auto operator!=(const SDL_BlendFactor lhs,
                                        const blend_factor rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of blend factor comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_BLEND_FACTOR_HEADER

// #include "blend_op.hpp"
#ifndef CENTURION_BLEND_OP_HEADER
#define CENTURION_BLEND_OP_HEADER

#include <SDL.h>

#include <ostream>      // ostream
#include <string_view>  // string_view

// #include "../core/exception.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum blend_op
 *
 * \brief Represents different strategies used when combining pixel components.
 *
 * \see `blend_factor`
 * \see `compose_blend_mode()`
 *
 * \since 6.3.0
 */
enum class blend_op
{
  add = SDL_BLENDOPERATION_ADD,
  sub = SDL_BLENDOPERATION_SUBTRACT,
  reverse_sub = SDL_BLENDOPERATION_REV_SUBTRACT,
  min = SDL_BLENDOPERATION_MINIMUM,
  max = SDL_BLENDOPERATION_MAXIMUM
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied blend operation.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(blend_op::add) == "add"`.
 *
 * \param op the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto to_string(const blend_op op) -> std::string_view
{
  switch (op) {
    case blend_op::add:
      return "add";

    case blend_op::sub:
      return "sub";

    case blend_op::reverse_sub:
      return "reverse_sub";

    case blend_op::min:
      return "min";

    case blend_op::max:
      return "max";

    default:
      throw cen_error{"Did not recognize blend operation!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a blend operation enumerator.
 *
 * \param stream the output stream that will be used.
 * \param op the enumerator that will be printed.
 *
 * \see `to_string(blend_op)`
 *
 * \return the used stream.
 *
 * \since 6.3.0
 */
inline auto operator<<(std::ostream& stream, const blend_op op) -> std::ostream&
{
  return stream << to_string(op);
}

/// \} End of streaming

/// \name Blend operation comparison operators
/// \{

/**
 * \brief Indicates whether or not two blend operation values are the same;
 *
 * \param lhs the left-hand side blend operation value.
 * \param rhs the right-hand side blend operation value.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto operator==(const blend_op lhs,
                                        const SDL_BlendOperation rhs) noexcept -> bool
{
  return static_cast<SDL_BlendOperation>(lhs) == rhs;
}

/// \copydoc operator==(blend_op, SDL_BlendOperation)
[[nodiscard]] constexpr auto operator==(const SDL_BlendOperation lhs,
                                        const blend_op rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two blend operation values aren't the same;
 *
 * \param lhs the left-hand side blend operation value.
 * \param rhs the right-hand side blend operation value.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 6.3.0
 */
[[nodiscard]] constexpr auto operator!=(const blend_op lhs,
                                        const SDL_BlendOperation rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(blend_op, SDL_BlendOperation)
[[nodiscard]] constexpr auto operator!=(const SDL_BlendOperation lhs,
                                        const blend_op rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of blend operation comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_BLEND_OP_HEADER

namespace cen {

/// \addtogroup video
/// \{

/**
 * \enum blend_mode
 *
 * \brief Provides values that represent various rendering blend modes.
 *
 * \since 3.0.0
 *
 * \see `SDL_BlendMode`
 */
enum class blend_mode
{
  none = SDL_BLENDMODE_NONE,    ///< Represents no blending.
  blend = SDL_BLENDMODE_BLEND,  ///< Represents alpha blending.
  add = SDL_BLENDMODE_ADD,      ///< Represents additive blending.
  mod = SDL_BLENDMODE_MOD,      ///< Represents color modulation.

#if SDL_VERSION_ATLEAST(2, 0, 12)

  mul = SDL_BLENDMODE_MUL,  ///< Represents color multiplication.

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

  invalid = SDL_BLENDMODE_INVALID  ///< Represents an invalid blend mode.
};

/**
 * \struct blend_task
 *
 * \brief Describes how a pair of blend mode factors will be combined.
 *
 * \see `compose_blend_mode()`
 *
 * \since 6.3.0
 */
struct blend_task final
{
  blend_factor src;  ///< The blend factor applied to the source pixels.
  blend_factor dst;  ///< The blend factor applied to the destination pixels.
  blend_op op;       ///< The operation used to combine the source and destination pixels.
};

/**
 * \brief Composes a custom blend mode.
 *
 * \param color the blend task descriptor used for RGB components.
 * \param alpha the blend task descriptor used for alpha components.
 *
 * \return the composed blend mode.
 *
 * \see `blend_task`
 * \see `blend_factor`
 * \see `blend_op`
 *
 * \see `SDL_ComposeCustomBlendMode()`
 * \see `basic_renderer::set_blend_mode()`
 * \see `basic_texture::set_blend_mode()`
 *
 * \since 6.3.0
 */
[[nodiscard]] inline auto compose_blend_mode(const blend_task& color,
                                             const blend_task& alpha) noexcept -> blend_mode
{
  const auto res = SDL_ComposeCustomBlendMode(static_cast<SDL_BlendFactor>(color.src),
                                              static_cast<SDL_BlendFactor>(color.dst),
                                              static_cast<SDL_BlendOperation>(color.op),
                                              static_cast<SDL_BlendFactor>(alpha.src),
                                              static_cast<SDL_BlendFactor>(alpha.dst),
                                              static_cast<SDL_BlendOperation>(alpha.op));
  return static_cast<blend_mode>(res);
}

/// \name String conversions
/// \{

/**
 * \brief Returns a textual version of the supplied blend mode.
 *
 * \details This function returns a string that mirrors the name of the enumerator, e.g.
 * `to_string(blend_mode::blend) == "blend"`.
 *
 * \param mode the enumerator that will be converted.
 *
 * \return a string that mirrors the name of the enumerator.
 *
 * \throws cen_error if the enumerator is not recognized.
 *
 * \since 6.2.0
 */
[[nodiscard]] constexpr auto to_string(const blend_mode mode) -> std::string_view
{
  switch (mode) {
    case blend_mode::none:
      return "none";

    case blend_mode::blend:
      return "blend";

    case blend_mode::add:
      return "add";

    case blend_mode::mod:
      return "mod";

    case blend_mode::invalid:
      return "invalid";

#if SDL_VERSION_ATLEAST(2, 0, 12)

    case blend_mode::mul:
      return "mul";

#endif  // SDL_VERSION_ATLEAST(2, 0, 12)

    default:
      throw cen_error{"Did not recognize blend mode!"};
  }
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a blend mode enumerator.
 *
 * \param stream the output stream that will be used.
 * \param mode the enumerator that will be printed.
 *
 * \see `to_string(blend_mode)`
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
inline auto operator<<(std::ostream& stream, const blend_mode mode) -> std::ostream&
{
  return stream << to_string(mode);
}

/// \} End of streaming

/// \name Blend mode comparison operators
/// \{

/**
 * \brief Indicates whether or not two blend mode values are the same;
 *
 * \param lhs the left-hand side blend mode value.
 * \param rhs the right-hand side blend mode value.
 *
 * \return `true` if the values are the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const blend_mode lhs, const SDL_BlendMode rhs) noexcept
    -> bool
{
  return static_cast<SDL_BlendMode>(lhs) == rhs;
}

/// \copydoc operator==(blend_mode, SDL_BlendMode)
[[nodiscard]] constexpr auto operator==(const SDL_BlendMode lhs, const blend_mode rhs) noexcept
    -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not two blend mode values aren't the same;
 *
 * \param lhs the left-hand side blend mode value.
 * \param rhs the right-hand side blend mode value.
 *
 * \return `true` if the values aren't the same; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator!=(const blend_mode lhs, const SDL_BlendMode rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(blend_mode, SDL_BlendMode)
[[nodiscard]] constexpr auto operator!=(const SDL_BlendMode lhs, const blend_mode rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \} End of blend mode comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_BLEND_MODE_HEADER

// #include "color.hpp"
#ifndef CENTURION_COLOR_HEADER
#define CENTURION_COLOR_HEADER

#include <SDL.h>

#include <cassert>      // assert
#include <cmath>        // round, abs, fmod, lerp
#include <iomanip>      // setfill, setw
#include <ios>          // uppercase, hex
#include <optional>     // optional
#include <ostream>      // ostream
#include <sstream>      // stringstream
#include <string>       // string, to_string
#include <string_view>  // string_view

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../compiler/compiler.hpp"
#ifndef CENTURION_COMPILER_HEADER
#define CENTURION_COMPILER_HEADER

#include <SDL.h>

namespace cen {

/// \addtogroup compiler
/// \{

/**
 * \brief Indicates whether or not a "debug" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a debug build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_debug_build() noexcept -> bool
{
#ifndef NDEBUG
  return true;
#else
  return false;
#endif  // NDEBUG
}

/**
 * \brief Indicates whether or not a "release" build mode is active.
 *
 * \note This is intended to be use with `if constexpr`-statements instead of raw `#ifdef`
 * conditional compilation, since the use of `if constexpr` prevents any branch to be
 * ill-formed, which avoids code rot.
 *
 * \return `true` if a release build mode is currently active; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto is_release_build() noexcept -> bool
{
  return !is_debug_build();
}

/**
 * \brief Indicates whether or not the compiler is MSVC.
 *
 * \return `true` if MSVC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_msvc() noexcept -> bool
{
#ifdef _MSC_VER
  return true;
#else
  return false;
#endif  // _MSC_VER
}

/**
 * \brief Indicates whether or not the compiler is GCC.
 *
 * \return `true` if GCC is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_gcc() noexcept -> bool
{
#ifdef __GNUC__
  return true;
#else
  return false;
#endif  // __GNUC__
}

/**
 * \brief Indicates whether or not the compiler is Clang.
 *
 * \return `true` if Clang is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_clang() noexcept -> bool
{
#ifdef __clang__
  return true;
#else
  return false;
#endif  // __clang__
}

/**
 * \brief Indicates whether or not the compiler is Emscripten.
 *
 * \return `true` if Emscripten is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_emscripten() noexcept -> bool
{
#ifdef __EMSCRIPTEN__
  return true;
#else
  return false;
#endif  // __EMSCRIPTEN__
}

/**
 * \brief Indicates whether or not the compiler is Intel C++.
 *
 * \return `true` if Intel C++ is detected as the current compiler; `false` otherwise.
 *
 * \since 5.3.0
 */
[[nodiscard]] constexpr auto on_intel_cpp() noexcept -> bool
{
#ifdef __INTEL_COMPILER
  return true;
#else
  return false;
#endif  // __INTEL_COMPILER
}

/// \} End of compiler group

}  // namespace cen

#endif  // CENTURION_COMPILER_HEADER

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../detail/clamp.hpp"

// #include "../detail/from_string.hpp"
#ifndef CENTURION_DETAIL_FROM_STRING_HEADER
#define CENTURION_DETAIL_FROM_STRING_HEADER

#include <charconv>      // from_chars
#include <optional>      // optional
#include <string>        // string, stof
#include <string_view>   // string_view
#include <system_error>  // errc
#include <type_traits>   // is_floating_point_v

// #include "../compiler/compiler.hpp"


/// \cond FALSE
namespace cen::detail {

template <typename T>
[[nodiscard]] auto from_string(const std::string_view str,
                               const int base = 10) noexcept(on_msvc()) -> std::optional<T>
{
  T value{};

  const auto begin = str.data();
  const auto end = str.data() + str.size();

  const char* mismatch = end;
  std::errc error{};

  if constexpr (std::is_floating_point_v<T>) {
    if constexpr (on_gcc() || on_clang()) {
      try {
        value = std::stof(std::string{str});
      }
      catch (...) {
        return std::nullopt;
      }
    }
    else {
      const auto [ptr, err] = std::from_chars(begin, end, value);
      mismatch = ptr;
      error = err;
    }
  }
  else {
    const auto [ptr, err] = std::from_chars(begin, end, value, base);
    mismatch = ptr;
    error = err;
  }

  if (mismatch == end && error == std::errc{}) {
    return value;
  }
  else {
    return std::nullopt;
  }
}

}  // namespace cen::detail
/// \endcond

#endif  // CENTURION_DETAIL_FROM_STRING_HEADER

// #include "../detail/lerp.hpp"
#ifndef CENTURION_DETAIL_LERP_HEADER
#define CENTURION_DETAIL_LERP_HEADER

#include <cmath>  // lerp

// #include "../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER


/// \cond FALSE

namespace cen::detail {

[[nodiscard]] constexpr auto lerp(const float a, const float b, const float bias) noexcept
    -> float
{
#if CENTURION_HAS_FEATURE_LERP
  return std::lerp(a, b, bias);
#else
  return (a * (1.0f - bias)) + (b * bias);
#endif  // CENTURION_HAS_FEATURE_LERP
}

}  // namespace cen::detail

/// \endcond

#endif  // CENTURION_DETAIL_LERP_HEADER


namespace cen {

/// \addtogroup video
/// \{

/**
 * \class color
 *
 * \brief An 8-bit accuracy RGBA color.
 *
 * \serializable
 *
 * \details This class is designed to interact with the SDL colors, i.e. `SDL_Color` and
 * `SDL_MessageBoxColor`. For convenience, there are approximately 140 color constants
 * provided in the `colors` namespace,
 *
 * \since 3.0.0
 */
class color final
{
 public:
  /// \name Construction
  /// \{

  /**
   * \brief Creates a color. The created color will be equal to #000000FF.
   *
   * \since 3.0.0
   */
  constexpr color() noexcept = default;

  /**
   * \brief Creates a color.
   *
   * \param red the red component value, in the range [0, 255].
   * \param green the green component value, in the range [0, 255].
   * \param blue the blue component value, in the range [0, 255].
   * \param alpha the alpha component value, in the rage [0, 255]. Defaults to 255.
   *
   * \since 3.0.0
   */
  constexpr color(const u8 red, const u8 green, const u8 blue, const u8 alpha = max()) noexcept
      : m_color{red, green, blue, alpha}
  {}

  /**
   * \brief Creates a color that is a copy of the supplied `SDL_Color`.
   *
   * \param color the `SDL_Color` that will be copied.
   *
   * \since 3.0.0
   */
  constexpr explicit color(const SDL_Color& color) noexcept : m_color{color}
  {}

  /**
   * \brief Creates a color that is a copy of the supplied SDL_MessageBoxColor.
   *
   * \details Message box colors don't have an alpha component so the created color will
   * feature an alpha value of 255.
   *
   * \param color the message box color that will be copied.
   *
   * \since 3.0.0
   */
  constexpr explicit color(const SDL_MessageBoxColor& color) noexcept
      : m_color{color.r, color.g, color.b, max()}
  {}

  /**
   * \brief Creates a color from HSV-encoded values.
   *
   * \note The values will be clamped to be within their respective ranges.
   *
   * \param hue the hue of the color, in the range [0, 360].
   * \param saturation the saturation of the color, in the range [0, 100].
   * \param value the value of the color, in the range [0, 100].
   *
   * \return an RGBA color converted from the HSV values.
   *
   * \since 5.3.0
   */
  [[nodiscard]] static auto from_hsv(float hue, float saturation, float value) -> color
  {
    hue = detail::clamp(hue, 0.0f, 360.0f);
    saturation = detail::clamp(saturation, 0.0f, 100.0f);
    value = detail::clamp(value, 0.0f, 100.0f);

    const auto v = (value / 100.0f);
    const auto chroma = v * (saturation / 100.0f);
    const auto hp = hue / 60.0f;

    const auto x = chroma * (1.0f - std::abs(std::fmod(hp, 2.0f) - 1.0f));

    float red{};
    float green{};
    float blue{};

    if (0 <= hp && hp <= 1) {
      red = chroma;
      green = x;
      blue = 0;
    }
    else if (1 < hp && hp <= 2) {
      red = x;
      green = chroma;
      blue = 0;
    }
    else if (2 < hp && hp <= 3) {
      red = 0;
      green = chroma;
      blue = x;
    }
    else if (3 < hp && hp <= 4) {
      red = 0;
      green = x;
      blue = chroma;
    }
    else if (4 < hp && hp <= 5) {
      red = x;
      green = 0;
      blue = chroma;
    }
    else if (5 < hp && hp <= 6) {
      red = chroma;
      green = 0;
      blue = x;
    }

    const auto m = v - chroma;

    const auto r = static_cast<u8>(std::round((red + m) * 255.0f));
    const auto g = static_cast<u8>(std::round((green + m) * 255.0f));
    const auto b = static_cast<u8>(std::round((blue + m) * 255.0f));

    return color{r, g, b};
  }

  /**
   * \brief Creates a color from HSL-encoded values.
   *
   * \note The values will be clamped to be within their respective ranges.
   *
   * \param hue the hue of the color, in the range [0, 360].
   * \param saturation the saturation of the color, in the range [0, 100].
   * \param lightness the lightness of the color, in the range [0, 100].
   *
   * \return an RGBA color converted from the HSL values.
   *
   * \since 5.3.0
   */
  [[nodiscard]] static auto from_hsl(float hue, float saturation, float lightness) -> color
  {
    hue = detail::clamp(hue, 0.0f, 360.0f);
    saturation = detail::clamp(saturation, 0.0f, 100.0f);
    lightness = detail::clamp(lightness, 0.0f, 100.0f);

    const auto s = saturation / 100.0f;
    const auto l = lightness / 100.0f;

    const auto chroma = (1.0f - std::abs(2.0f * l - 1.0f)) * s;
    const auto hp = hue / 60.0f;

    const auto x = chroma * (1.0f - std::abs(std::fmod(hp, 2.0f) - 1.0f));

    float red{};
    float green{};
    float blue{};

    if (0 <= hp && hp < 1) {
      red = chroma;
      green = x;
      blue = 0;
    }
    else if (1 <= hp && hp < 2) {
      red = x;
      green = chroma;
      blue = 0;
    }
    else if (2 <= hp && hp < 3) {
      red = 0;
      green = chroma;
      blue = x;
    }
    else if (3 <= hp && hp < 4) {
      red = 0;
      green = x;
      blue = chroma;
    }
    else if (4 <= hp && hp < 5) {
      red = x;
      green = 0;
      blue = chroma;
    }
    else if (5 <= hp && hp < 6) {
      red = chroma;
      green = 0;
      blue = x;
    }

    const auto m = l - (chroma / 2.0f);

    const auto r = static_cast<u8>(std::round((red + m) * 255.0f));
    const auto g = static_cast<u8>(std::round((green + m) * 255.0f));
    const auto b = static_cast<u8>(std::round((blue + m) * 255.0f));

    return color{r, g, b};
  }

  /**
   * \brief Creates a color from a hexadecimal RGB color string.
   *
   * \details The supplied string must feature a leading '#' character, and be 7
   * characters long.
   *
   * \param rgb the hexadecimal RGB color string, using the format "#RRGGBB".
   *
   * \return a corresponding color; `std::nullopt` if something goes wrong.
   *
   * \see `from_rgba()`
   * \see `from_argb()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] static auto from_rgb(const std::string_view rgb) -> std::optional<color>
  {
    if (rgb.length() != 7 || rgb.at(0) != '#') {
      return std::nullopt;
    }

    const auto noHash = rgb.substr(1);

    const auto rr = noHash.substr(0, 2);
    const auto gg = noHash.substr(2, 2);
    const auto bb = noHash.substr(4, 2);

    const auto red = detail::from_string<u8>(rr, 16);
    const auto green = detail::from_string<u8>(gg, 16);
    const auto blue = detail::from_string<u8>(bb, 16);

    if (red && green && blue) {
      return cen::color{*red, *green, *blue};
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Creates a color from a hexadecimal RGBA color string.
   *
   * \details The supplied string must feature a leading '#' character, and be 9
   * characters long.
   *
   * \param rgba the hexadecimal RGBA color string, using the format "#RRGGBBAA".
   *
   * \return a corresponding color; `std::nullopt` if something goes wrong.
   *
   * \see `from_rgb()`
   * \see `from_argb()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] static auto from_rgba(const std::string_view rgba) -> std::optional<color>
  {
    if (rgba.length() != 9 || rgba.at(0) != '#') {
      return std::nullopt;
    }

    const auto noHash = rgba.substr(1);

    const auto rr = noHash.substr(0, 2);
    const auto gg = noHash.substr(2, 2);
    const auto bb = noHash.substr(4, 2);
    const auto aa = noHash.substr(6, 2);

    const auto red = detail::from_string<u8>(rr, 16);
    const auto green = detail::from_string<u8>(gg, 16);
    const auto blue = detail::from_string<u8>(bb, 16);
    const auto alpha = detail::from_string<u8>(aa, 16);

    if (red && green && blue && alpha) {
      return cen::color{*red, *green, *blue, *alpha};
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Creates a color from a hexadecimal ARGB color string.
   *
   * \details The supplied string must feature a leading '#' character, and be 9
   * characters long.
   *
   * \param argb the hexadecimal ARGB color string, using the format "#AARRGGBB".
   *
   * \return a corresponding color; `std::nullopt` if something goes wrong.
   *
   * \see `from_rgb()`
   * \see `from_rgba()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] static auto from_argb(const std::string_view argb) -> std::optional<color>
  {
    if (argb.length() != 9 || argb.at(0) != '#') {
      return std::nullopt;
    }

    const auto noHash = argb.substr(1);

    const auto aa = noHash.substr(0, 2);
    const auto rr = noHash.substr(2, 2);
    const auto gg = noHash.substr(4, 2);
    const auto bb = noHash.substr(6, 2);

    const auto alpha = detail::from_string<u8>(aa, 16);
    const auto red = detail::from_string<u8>(rr, 16);
    const auto green = detail::from_string<u8>(gg, 16);
    const auto blue = detail::from_string<u8>(bb, 16);

    if (alpha && red && green && blue) {
      return cen::color{*red, *green, *blue, *alpha};
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Creates a color from normalized color component values.
   *
   * \note The color components will be clamped to the range [0, 1].
   *
   * \param red the red component value, in the range [0, 1].
   * \param green the green component value, in the range [0, 1].
   * \param blue the blue component value, in the range [0, 1].
   * \param alpha the alpha component value, in the range [0, 1].
   *
   * \return a color with the supplied color components.
   *
   * \since 6.1.0
   */
  [[nodiscard]] static auto from_norm(float red,
                                      float green,
                                      float blue,
                                      float alpha = 1.0f) noexcept(on_msvc()) -> color
  {
    red = detail::clamp(red, 0.0f, 1.0f);
    green = detail::clamp(green, 0.0f, 1.0f);
    blue = detail::clamp(blue, 0.0f, 1.0f);
    alpha = detail::clamp(alpha, 0.0f, 1.0f);

    const auto r = static_cast<u8>(std::round(red * 255.0f));
    const auto g = static_cast<u8>(std::round(green * 255.0f));
    const auto b = static_cast<u8>(std::round(blue * 255.0f));
    const auto a = static_cast<u8>(std::round(alpha * 255.0f));

    return color{r, g, b, a};
  }

  /// \} End of construction

  /// \name Setters
  /// \{

  /**
   * \brief Sets the value of the red component.
   *
   * \param red the new value of the red component.
   *
   * \since 3.0.0
   */
  constexpr void set_red(const u8 red) noexcept
  {
    m_color.r = red;
  }

  /**
   * \brief Sets the value of the green component.
   *
   * \param green the new value of the green component.
   *
   * \since 3.0.0
   */
  constexpr void set_green(const u8 green) noexcept
  {
    m_color.g = green;
  }

  /**
   * \brief Sets the value of the blue component.
   *
   * \param blue the new value of the blue component.
   *
   * \since 3.0.0
   */
  constexpr void set_blue(const u8 blue) noexcept
  {
    m_color.b = blue;
  }

  /**
   * \brief Sets the value of the alpha component.
   *
   * \param alpha the new value of the alpha component.
   *
   * \since 3.0.0
   */
  constexpr void set_alpha(const u8 alpha) noexcept
  {
    m_color.a = alpha;
  }

  /// \} End of setters

  /// \name Getters
  /// \{

  /**
   * \brief Returns the value of the red component.
   *
   * \return the value of the red component, in the range [0, 255].
   *
   * \since 3.0.0
   */
  [[nodiscard]] constexpr auto red() const noexcept -> u8
  {
    return m_color.r;
  }

  /**
   * \brief Returns the value of the green component.
   *
   * \return the value of the green component, in the range [0, 255].
   *
   * \since 3.0.0
   */
  [[nodiscard]] constexpr auto green() const noexcept -> u8
  {
    return m_color.g;
  }

  /**
   * \brief Returns the value of the blue component.
   *
   * \return the value of the blue component, in the range [0, 255].
   *
   * \since 3.0.0
   */
  [[nodiscard]] constexpr auto blue() const noexcept -> u8
  {
    return m_color.b;
  }

  /**
   * \brief Returns the value of the alpha component.
   *
   * \return the value of the alpha component, in the range [0, 255].
   *
   * \since 3.0.0
   */
  [[nodiscard]] constexpr auto alpha() const noexcept -> u8
  {
    return m_color.a;
  }

  /**
   * \brief Returns the normalized red component of the color.
   *
   * \return the red component value, in the range [0, 1].
   *
   * \since 6.1.0
   */
  [[nodiscard]] constexpr auto red_norm() const noexcept -> float
  {
    return static_cast<float>(m_color.r) / 255.0f;
  }

  /**
   * \brief Returns the normalized green component of the color.
   *
   * \return the green component value, in the range [0, 1].
   *
   * \since 6.1.0
   */
  [[nodiscard]] constexpr auto green_norm() const noexcept -> float
  {
    return static_cast<float>(m_color.g) / 255.0f;
  }

  /**
   * \brief Returns the normalized blue component of the color.
   *
   * \return the blue component value, in the range [0, 1].
   *
   * \since 6.1.0
   */
  [[nodiscard]] constexpr auto blue_norm() const noexcept -> float
  {
    return static_cast<float>(m_color.b) / 255.0f;
  }

  /**
   * \brief Returns the normalized alpha component of the color.
   *
   * \return the alpha component value, in the range [0, 1].
   *
   * \since 6.1.0
   */
  [[nodiscard]] constexpr auto alpha_norm() const noexcept -> float
  {
    return static_cast<float>(m_color.a) / 255.0f;
  }

  /**
   * \brief Returns a pointer to the internal SDL color.
   *
   * \warning Do not cache the returned pointer!
   *
   * \return a pointer to the internal color instance.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto data() noexcept -> SDL_Color*
  {
    return &m_color;
  }

  /// \copydoc data()
  [[nodiscard]] auto data() const noexcept -> const SDL_Color*
  {
    return &m_color;
  }

  /**
   * \brief Returns the internal color instance.
   *
   * \return a reference to the internal color.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get() const noexcept -> const SDL_Color&
  {
    return m_color;
  }

  /// \} End of getters

  /// \name Color string conversions
  /// \{

  /**
   * \brief Returns a hexadecimal RGB color string that represents the color.
   *
   * \details The returned string is guaranteed to use uppercase hexadecimal digits (A-F).
   *
   * \return a hexadecimal color string representation, on the format "#RRGGBB".
   *
   * \see `as_rgba()`
   * \see `as_argb()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto as_rgb() const -> std::string
  {
    std::stringstream stream;
    stream << std::setfill('0') << std::hex << std::uppercase;

    stream << '#';
    stream << std::setw(2) << +m_color.r;
    stream << std::setw(2) << +m_color.g;
    stream << std::setw(2) << +m_color.b;

    return stream.str();
  }

  /**
   * \brief Returns a hexadecimal RGBA color string that represents the color.
   *
   * \details The returned string is guaranteed to use uppercase hexadecimal digits (A-F).
   *
   * \return a hexadecimal color string representation, on the format "#RRGGBBAA".
   *
   * \see `as_rgb()`
   * \see `as_argb()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto as_rgba() const -> std::string
  {
    std::stringstream stream;
    stream << std::setfill('0') << std::hex << std::uppercase;

    stream << '#';
    stream << std::setw(2) << +m_color.r;
    stream << std::setw(2) << +m_color.g;
    stream << std::setw(2) << +m_color.b;
    stream << std::setw(2) << +m_color.a;

    return stream.str();
  }

  /**
   * \brief Returns a hexadecimal ARGB color string that represents the color.
   *
   * \details The returned string is guaranteed to use uppercase hexadecimal digits (A-F).
   *
   * \return a hexadecimal color string representation, on the format "#AARRGGBB".
   *
   * \see `as_rgb()`
   * \see `as_rgba()`
   *
   * \since 6.1.0
   */
  [[nodiscard]] auto as_argb() const -> std::string
  {
    std::stringstream stream;
    stream << std::setfill('0') << std::hex << std::uppercase;

    stream << '#';
    stream << std::setw(2) << +m_color.a;
    stream << std::setw(2) << +m_color.r;
    stream << std::setw(2) << +m_color.g;
    stream << std::setw(2) << +m_color.b;

    return stream.str();
  }

  /// \} End of color string conversions

  /// \name Conversions
  /// \{

  /**
   * \brief Converts the the color into an `SDL_Color`.
   *
   * \return an `SDL_Color` that is equivalent to this color.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit constexpr operator SDL_Color() const noexcept
  {
    return {red(), green(), blue(), alpha()};
  }

  /**
   * \brief Converts the the color into an `SDL_MessageBoxColor`.
   *
   * \note Message box colors don't feature an alpha value!
   *
   * \return an `SDL_MessageBoxColor` that is equivalent to this color.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit constexpr operator SDL_MessageBoxColor() const noexcept
  {
    return {red(), green(), blue()};
  }

  /**
   * \brief Converts the color to `SDL_Color*`.
   *
   * \warning The returned pointer is not to be freed or stored away!
   *
   * \return a pointer to the internal color instance.
   *
   * \since 4.0,0
   */
  [[nodiscard]] explicit operator SDL_Color*() noexcept
  {
    return &m_color;
  }

  /**
   * \brief Converts the color to `const SDL_Color*`.
   *
   * \warning The returned pointer is not to be freed or stored away!
   *
   * \return a pointer to the internal color instance.
   *
   * \since 4.0,0
   */
  [[nodiscard]] explicit operator const SDL_Color*() const noexcept
  {
    return &m_color;
  }

  /// \} End of conversions

  /**
   * \brief Serializes the color.
   *
   * \details This function expects that the archive provides an overloaded `operator()`,
   * used for serializing data. This API is based on the Cereal serialization library.
   *
   * \tparam Archive the type of the archive.
   *
   * \param archive the archive used to serialize the color.
   *
   * \since 5.3.0
   */
  template <typename Archive>
  void serialize(Archive& archive)
  {
    archive(m_color.r, m_color.g, m_color.b, m_color.a);
  }

  /**
   * \brief Returns a copy of the color with the specified alpha value.
   *
   * \param alpha the alpha component value that will be used by the new color.
   *
   * \return a color that is identical to the color except for the alpha component.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr auto with_alpha(const u8 alpha) const noexcept -> color
  {
    return {red(), green(), blue(), alpha};
  }

  /**
   * \brief Returns the maximum possible value of a color component.
   *
   * \return the maximum possible value of a color component.
   *
   * \since 5.0.0
   */
  [[nodiscard]] constexpr static auto max() noexcept -> u8
  {
    return 0xFF;
  }

 private:
  SDL_Color m_color{0, 0, 0, max()};
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of the color.
 *
 * \param color the color that will be converted.
 *
 * \return a textual representation of the color.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto to_string(const color& color) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("color{{r: {}, g: {}, b: {}: a: {}}}",
                     +color.red(),
                     +color.green(),
                     +color.blue(),
                     +color.alpha());
#else
  return "color{r: " + std::to_string(color.red()) + ", g: " + std::to_string(color.green()) +
         ", b: " + std::to_string(color.blue()) + ", a: " + std::to_string(color.alpha()) +
         "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a color.
 *
 * \param stream the stream that will be used.
 * \param color the color that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
inline auto operator<<(std::ostream& stream, const color& color) -> std::ostream&
{
  return stream << to_string(color);
}

/// \} End of streaming

/**
 * \brief Blends two colors according to the specified bias.
 *
 * \pre `bias` should be in the range [0, 1].
 *
 * \details This function applies a linear interpolation for each color component to
 * obtain the blended color. The bias parameter is the "alpha" for the interpolation,
 * which determines how the input colors are blended. For example, a bias of 0 or 1 will
 * simply result in the first or second color being returned, respectively.
 * Subsequently, a bias of 0.5 will blend the two colors evenly.
 *
 * \param a the first color.
 * \param b the second color.
 * \param bias the bias that determines how the colors are blended, in the range [0, 1].
 *
 * \return a color obtained by blending the two supplied colors.
 *
 * \todo Default the bias to 0.5 when the `double` overload has been removed.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto blend(const color& a, const color& b, const float bias) -> color
{
  assert(bias >= 0);
  assert(bias <= 1.0f);

  const auto red = detail::lerp(a.red_norm(), b.red_norm(), bias);
  const auto green = detail::lerp(a.green_norm(), b.green_norm(), bias);
  const auto blue = detail::lerp(a.blue_norm(), b.blue_norm(), bias);
  const auto alpha = detail::lerp(a.alpha_norm(), b.alpha_norm(), bias);

  return color::from_norm(red, green, blue, alpha);
}

/// \copydoc blend()
/// \deprecated Since 6.2.0, use the overload using a `float` bias parameter instead.
[[nodiscard, deprecated]] inline auto blend(const color& a,
                                            const color& b,
                                            const double bias = 0.5) -> color
{
  return blend(a, b, static_cast<float>(bias));
}

/// \name Color comparison operators
/// \{

/**
 * \brief Indicates whether or not the two colors are equal.
 *
 * \param lhs the left-hand side color.
 * \param rhs the right-hand side color.
 *
 * \return `true` if the colors are equal; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const color& lhs, const color& rhs) noexcept -> bool
{
  return (lhs.red() == rhs.red()) && (lhs.green() == rhs.green()) &&
         (lhs.blue() == rhs.blue()) && (lhs.alpha() == rhs.alpha());
}

/// \copydoc operator==(const color&, const color&)
[[nodiscard]] constexpr auto operator==(const color& lhs, const SDL_Color& rhs) noexcept
    -> bool
{
  return (lhs.red() == rhs.r) && (lhs.green() == rhs.g) && (lhs.blue() == rhs.b) &&
         (lhs.alpha() == rhs.a);
}

/// \copydoc operator==(const color&, const color&)
[[nodiscard]] constexpr auto operator==(const SDL_Color& lhs, const color& rhs) noexcept
    -> bool
{
  return rhs == lhs;
}

/**
 * \copybrief operator==(const color&, const color&)
 *
 * \note The alpha components are not taken into account.
 *
 * \param lhs the left-hand side color.
 * \param rhs the right-hand side color.
 *
 * \return `true` if the colors are equal; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator==(const color& lhs,
                                        const SDL_MessageBoxColor& rhs) noexcept -> bool
{
  return (lhs.red() == rhs.r) && (lhs.green() == rhs.g) && (lhs.blue() == rhs.b);
}

/// \copydoc operator==(const color&, const SDL_MessageBoxColor&)
[[nodiscard]] constexpr auto operator==(const SDL_MessageBoxColor& lhs,
                                        const color& rhs) noexcept -> bool
{
  return rhs == lhs;
}

/**
 * \brief Indicates whether or not the two colors aren't equal.
 *
 * \param lhs the left-hand side color.
 * \param rhs the right-hand side color.
 *
 * \return `true` if the colors aren't equal; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator!=(const color& lhs, const color& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const color&, const color&)
[[nodiscard]] constexpr auto operator!=(const color& lhs, const SDL_Color& rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const color&, const color&)
[[nodiscard]] constexpr auto operator!=(const SDL_Color& lhs, const color& rhs) noexcept
    -> bool
{
  return !(lhs == rhs);
}

/**
 * \copybrief operator!=(const color&, const color&)
 *
 * \note The alpha components are not taken into account.
 *
 * \param lhs the left-hand side color.
 * \param rhs the right-hand side color.
 *
 * \return `true` if the colors aren't equal; `false` otherwise.
 *
 * \since 3.0.0
 */
[[nodiscard]] constexpr auto operator!=(const color& lhs,
                                        const SDL_MessageBoxColor& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \copydoc operator!=(const color&, const SDL_MessageBoxColor&)
[[nodiscard]] constexpr auto operator!=(const SDL_MessageBoxColor& lhs,
                                        const color& rhs) noexcept -> bool
{
  return !(lhs == rhs);
}

/// \} End of color comparison operators

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_COLOR_HEADER

// #include "pixel_format_info.hpp"
#ifndef CENTURION_PIXEL_FORMAT_INFO_HEADER
#define CENTURION_PIXEL_FORMAT_INFO_HEADER

#include <SDL.h>

#include <ostream>  // ostream
#include <string>   // string, to_string

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/not_null.hpp"

// #include "../core/owner.hpp"

// #include "../core/str.hpp"

// #include "../core/to_underlying.hpp"

// #include "../detail/address_of.hpp"

// #include "../detail/owner_handle_api.hpp"

// #include "color.hpp"

// #include "pixel_format.hpp"


namespace cen {

/// \addtogroup video
/// \{

template <typename B>
class basic_pixel_format_info;

/**
 * \typedef pixel_format_info
 *
 * \brief Represents an owning pixel format info instance.
 *
 * \since 5.2.0
 */
using pixel_format_info = basic_pixel_format_info<detail::owning_type>;

/**
 * \typedef pixel_format_info_handle
 *
 * \brief Represents a non-owning pixel format info instance.
 *
 * \since 5.2.0
 */
using pixel_format_info_handle = basic_pixel_format_info<detail::handle_type>;

/**
 * \class basic_pixel_format_info
 *
 * \brief Provides information about a pixel format.
 *
 * \ownerhandle `pixel_format_info`/ `pixel_format_info_handle`
 *
 * \see `pixel_format`
 * \see `pixel_format_info`
 * \see `pixel_format_info_handle`
 * \see `SDL_PixelFormat`
 * \see `SDL_PixelFormatEnum`
 *
 * \since 5.2.0
 */
template <typename B>
class basic_pixel_format_info final
{
 public:
  /// \name Construction
  /// \{

  // clang-format off

  /**
   * \brief Creates a pixel format info instance based on an existing pointer.
   *
   * \note Ownership of the supplied pointer might be claimed, depending on the
   * ownership semantics of the class.
   *
   * \param format a pointer to the associated pixel format.
   *
   * \throws cen_error if the supplied pointer is null *and* the class has owning semantics.
   *
   * \since 5.2.0
   */
  explicit basic_pixel_format_info(maybe_owner<SDL_PixelFormat*> format) noexcept(!detail::is_owning<B>())
      : m_format{format}
  {
    if constexpr (detail::is_owning<B>())
    {
      if (!m_format)
      {
        throw cen_error{"Null pixel format!"};
      }
    }
  }

  // clang-format on

  /**
   * \brief Creates an owning instance based on a pixel format.
   *
   * \tparam BB dummy template parameter for SFINAE.
   *
   * \param format the associated pixel format.
   *
   * \throws sdl_error if the pixel format info could not be obtained.
   *
   * \since 5.2.0
   */
  template <typename BB = B, detail::is_owner<BB> = 0>
  explicit basic_pixel_format_info(const pixel_format format)
      : m_format{SDL_AllocFormat(to_underlying(format))}
  {
    if (!m_format) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates a handle based on an owning pixel format info instance.
   *
   * \param info the associated pixel format info instance.
   *
   * \since 5.2.0
   */
  template <typename BB = B, detail::is_handle<BB> = 0>
  explicit basic_pixel_format_info(const pixel_format_info& info) noexcept
      : m_format{info.get()}
  {}

  /// \} End of construction

  /// \name Pixel/RGB/RGBA conversions
  /// \{

  /**
   * \brief Returns a color that corresponds to a masked pixel value.
   *
   * \param pixel the masked pixel value.
   *
   * \return a color that corresponds to a pixel value, according to the format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto pixel_to_rgb(const u32 pixel) const noexcept -> color
  {
    u8 red{};
    u8 green{};
    u8 blue{};
    SDL_GetRGB(pixel, m_format, &red, &green, &blue);
    return color{red, green, blue};
  }

  /**
   * \brief Returns a color that corresponds to a masked pixel value.
   *
   * \param pixel the masked pixel value.
   *
   * \return a color that corresponds to a pixel value, according to the format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto pixel_to_rgba(const u32 pixel) const noexcept -> color
  {
    u8 red{};
    u8 green{};
    u8 blue{};
    u8 alpha{};
    SDL_GetRGBA(pixel, m_format, &red, &green, &blue, &alpha);
    return color{red, green, blue, alpha};
  }

  /**
   * \brief Returns a pixel color value based on the RGB values of a color.
   *
   * \note The alpha component is assumed to be `0xFF`, i.e. fully opaque.
   *
   * \param color the color that will be converted.
   *
   * \return a masked pixel color value, based on the pixel format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto rgb_to_pixel(const color& color) const noexcept -> u32
  {
    return SDL_MapRGB(m_format, color.red(), color.green(), color.blue());
  }

  /**
   * \brief Returns a pixel color value based on the RGBA values of a color.
   *
   * \param color the color that will be converted.
   *
   * \return a masked pixel color value, based on the pixel format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto rgba_to_pixel(const color& color) const noexcept -> u32
  {
    return SDL_MapRGBA(m_format, color.red(), color.green(), color.blue(), color.alpha());
  }

  /// \} End of pixel/RGB/RGBA conversions

  /// \name Queries
  /// \{

  /**
   * \brief Returns the associated pixel format.
   *
   * \return the associated pixel format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto format() const noexcept -> pixel_format
  {
    return static_cast<pixel_format>(m_format->format);
  }

  /**
   * \brief Returns a human-readable name associated with the format.
   *
   * \details This function never returns a null-pointer, instead it returns
   * "SDL_PIXELFORMAT_UNKNOWN" if the format is ill-formed.
   *
   * \return a human-readable name associated with the format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto name() const noexcept -> not_null<str>
  {
    return SDL_GetPixelFormatName(m_format->format);
  }

  /**
   * \brief Returns a pointer to the associated pixel format instance.
   *
   * \warning Do not claim ownership of the returned pointer.
   *
   * \return a pointer to the internal pixel format.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_PixelFormat*
  {
    return m_format.get();
  }

  /// \} End of queries

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not a handle holds a non-null pointer.
   *
   * \return `true` if the handle holds a non-null pointer; `false` otherwise.
   *
   * \since 5.2.0
   */
  template <typename BB = B, detail::is_handle<BB> = 0>
  [[nodiscard]] explicit operator bool() const noexcept
  {
    return m_format;
  }

  /// \} End of conversions

 private:
  struct deleter final
  {
    void operator()(SDL_PixelFormat* format) noexcept
    {
      SDL_FreeFormat(format);
    }
  };
  detail::pointer_manager<B, SDL_PixelFormat, deleter> m_format;
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a pixel format info instance.
 *
 * \tparam T the ownership semantics tag.
 *
 * \param info the pixel format info instance that will be converted.
 *
 * \return a string that represents the pixel format info.
 *
 * \since 6.2.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_pixel_format_info<T>& info) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("pixel_format_info{{data: {}, name: {}}}",
                     detail::address_of(info.get()),
                     info.name());
#else
  return "pixel_format_info{data: " + detail::address_of(info.get()) +
         ", name: " + info.name() + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a pixel format info instance.
 *
 * \tparam T the ownership semantics tag.
 *
 * \param stream the output stream that will be used.
 * \param info the pixel format info that will be printed.
 *
 * \return the used stream.
 *
 * \since 6.2.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_pixel_format_info<T>& info) -> std::ostream&
{
  return stream << to_string(info);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_PIXEL_FORMAT_INFO_HEADER


namespace cen {

/// \addtogroup video
/// \{

template <typename T>
class basic_surface;

/**
 * \typedef surface
 *
 * \brief Represents an owning surface.
 *
 * \since 5.0.0
 */
using surface = basic_surface<detail::owning_type>;

/**
 * \typedef surface_handle
 *
 * \brief Represents a non-owning surface.
 *
 * \since 5.0.0
 */
using surface_handle = basic_surface<detail::handle_type>;

/**
 * \class basic_surface
 *
 * \brief Represents a non-accelerated image.
 *
 * \ownerhandle `surface`/`surface_handle`
 *
 * \details Surfaces are often used for icons and snapshots, or as an "intermediate"
 * representation that can be manipulated, unlike textures. There is no support
 * for directly rendering surfaces. However, surfaces can be converted to textures, which
 * in turn can be rendered.
 *
 * \note Unlike most other Centurion components, surfaces can be copied.
 *
 * \since 4.0.0
 *
 * \see `surface`
 * \see `surface_handle`
 */
template <typename T>
class basic_surface final
{
 public:
  /// \name Construction
  /// \{

  // clang-format off

  /**
   * \brief Creates a surface from a pointer to an SDL surface.
   *
   * \note Depending on the type of the surface, ownership of the supplied SDL
   * surface might be claimed.
   *
   * \param surface a pointer to the associated surface.
   *
   * \since 4.0.0
   */
  explicit basic_surface(maybe_owner<SDL_Surface*> surface) noexcept(!detail::is_owning<T>())
      : m_surface{surface}
  {
    if constexpr (detail::is_owning<T>())
    {
      if (!m_surface)
      {
        throw cen_error{"Cannot create surface from null pointer!"};
      }
    }
  }

  // clang-format on

#ifndef CENTURION_NO_SDL_IMAGE

  /**
   * \brief Creates a surface based on the image at the specified path.
   *
   * \tparam BB dummy parameter for SFINAE.
   *
   * \param file the file path of the image file that will be loaded, can't
   * be null.
   *
   * \throws img_error if the surface cannot be created.
   *
   * \since 4.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_surface(const not_null<str> file) : m_surface{IMG_Load(file)}
  {
    if (!m_surface) {
      throw img_error{};
    }
  }

  /**
   * \brief Creates a surface based on the image at the specified path.
   *
   * \tparam BB dummy parameter for SFINAE.
   *
   * \param file the file path of the image file that will be loaded.
   *
   * \throws img_error if the surface cannot be created.
   *
   * \since 5.3.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_surface(const std::string& file) : basic_surface{file.c_str()}
  {}

#endif  // CENTURION_NO_SDL_IMAGE

  /**
   * \brief Creates a surface with the specified dimensions and pixel format.
   *
   * \tparam BB dummy parameter for SFINAE.
   *
   * \param size the size of the surface.
   * \param pixelFormat the pixel format that will be used by the surface.
   *
   * \throws sdl_error if the surface cannot be created.
   *
   * \since 5.3.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  basic_surface(const iarea size, const pixel_format pixelFormat)
      : m_surface{SDL_CreateRGBSurfaceWithFormat(0,
                                                 size.width,
                                                 size.height,
                                                 0,
                                                 to_underlying(pixelFormat))}
  {
    if (!m_surface) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates and returns a surface with the specified characteristics.
   *
   * \tparam BB dummy parameter for SFINAE.
   *
   * \param file the file path of the image that the surface will be based on.
   * \param blendMode the blend mode that will be used.
   * \param pixelFormat the pixel format that will be used.
   *
   * \return an owning surface, with the specified blend mode and pixel format.
   *
   * \since 5.2.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto with_format(const not_null<str> file,
                                        const blend_mode blendMode,
                                        const pixel_format pixelFormat) -> basic_surface
  {
    assert(file);

    basic_surface source{file};
    source.set_blend_mode(blendMode);

    return source.convert(pixelFormat);
  }

  /**
   * \see with_format()
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto with_format(const std::string& file,
                                        const blend_mode blendMode,
                                        const pixel_format pixelFormat) -> basic_surface
  {
    return with_format(file.c_str(), blendMode, pixelFormat);
  }

  /**
   * \brief Creates and returns a surface based on a BMP file.
   *
   * \tparam BB dummy parameter for SFINAE.
   *
   * \param file the path to the BMP file that contains the surface data.
   *
   * \return the created surface.
   *
   * \throws sdl_error if the surface couldn't be loaded.
   *
   * \since 5.3.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto from_bmp(const not_null<str> file) -> basic_surface
  {
    assert(file);
    return basic_surface{SDL_LoadBMP(file)};
  }

  /**
   * \see from_bmp()
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] static auto from_bmp(const std::string& file) -> basic_surface
  {
    return from_bmp(file.c_str());
  }

  /**
   * \brief Creates a copy of the supplied surface.
   *
   * \param other the surface that will be copied.
   *
   * \since 4.0.0
   */
  basic_surface(const basic_surface& other) noexcept(!detail::is_owning<T>())
  {
    if constexpr (detail::is_owning<T>()) {
      copy(other);
    }
    else {
      m_surface = other.get();
    }
  }

  /**
   * \brief Creates a surface by moving the supplied surface.
   *
   * \param other the surface that will be moved.
   *
   * \since 4.0.0
   */
  basic_surface(basic_surface&& other) noexcept = default;

  /// \} End of construction

  /**
   * \brief Copies the supplied surface.
   *
   * \param other the surface that will be copied.
   *
   * \throws sdl_error if the supplied surface couldn't be copied.
   *
   * \since 4.0.0
   */
  auto operator=(const basic_surface& other) noexcept(!detail::is_owning<T>())
      -> basic_surface&
  {
    if (this != &other) {
      if constexpr (detail::is_owning<T>()) {
        copy(other);
      }
      else {
        m_surface = other.get();
      }
    }
    return *this;
  }

  /**
   * \brief Moves the supplied surface into this surface.
   *
   * \param other the surface that will be moved.
   *
   * \return the surface that claimed the supplied surface.
   *
   * \since 4.0.0
   */
  auto operator=(basic_surface&& other) noexcept -> basic_surface& = default;

  /// \name Save functions
  /// \{

  /**
   * \brief Saves the surface as a BMP image.
   *
   * \param file the file path that the surface data will be saved at.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 5.3.0
   */
  auto save_as_bmp(const not_null<str> file) const noexcept -> result
  {
    assert(file);
    return SDL_SaveBMP(get(), file) != -1;
  }

  /**
   * \see save_as_bmp()
   * \since 6.0.0
   */
  auto save_as_bmp(const std::string& file) const noexcept -> result  // NOLINT
  {
    return save_as_bmp(file.c_str());
  }

#ifndef CENTURION_NO_SDL_IMAGE

  /**
   * \brief Saves the surface as a PNG image.
   *
   * \param file the file path that the surface data will be saved at.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 6.0.0
   */
  auto save_as_png(const not_null<str> file) const noexcept -> result
  {
    assert(file);
    return IMG_SavePNG(get(), file) != -1;
  }

  /**
   * \see save_as_png()
   * \since 6.0.0
   */
  auto save_as_png(const std::string& file) const noexcept -> result  // NOLINT
  {
    return save_as_png(file.c_str());
  }

  /**
   * \brief Saves the surface as a JPG image.
   *
   * \note The quality parameter is supplied to libjpeg in the SDL
   * implementation, but the limitations on its values are unknown at the time
   * of writing.
   *
   * \param file the file path that the surface data will be saved at.
   * \param quality the quality of the JPG image.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \since 6.0.0
   */
  auto save_as_jpg(const not_null<str> file, const int quality) const noexcept -> result
  {
    assert(file);
    return IMG_SaveJPG(get(), file, quality) != -1;
  }

  /**
   * \see save_as_jpg()
   * \since 6.0.0
   */
  auto save_as_jpg(const std::string& file, const int quality) const noexcept -> result
  {
    return save_as_jpg(file.c_str(), quality);
  }

#endif  // CENTURION_NO_SDL_IMAGE

  /// \} End of save functions

  /// \name Locking
  /// \{

  /**
   * \brief Attempts to lock the surface, so that the associated pixel data can
   * be modified.
   *
   * \details This function has no effect if `must_lock()` returns `false`.
   *
   * \return `success` if the locking of the surface was successful or if
   * locking isn't required for modifying the surface; `failure` if something
   * went wrong.
   *
   * \since 4.0.0
   */
  auto lock() noexcept -> result
  {
    if (must_lock()) {
      return SDL_LockSurface(m_surface) == 0;
    }
    else {
      return true;
    }
  }

  /**
   * \brief Unlocks the surface.
   *
   * \details This function has no effect if `must_lock()` returns `false`.
   *
   * \since 4.0.0
   */
  void unlock() noexcept
  {
    if (must_lock()) {
      SDL_UnlockSurface(m_surface);
    }
  }

  /**
   * \brief Indicates whether or not the surface must be locked before modifying
   * the pixel data associated with the surface.
   *
   * \return `true` if the surface must be locked before modification; `false`
   * otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto must_lock() const noexcept -> bool
  {
    return SDL_MUSTLOCK(m_surface);
  }

  /// \} End of locking

  /// \name Setters
  /// \{

  /**
   * \brief Sets the color of the pixel at the specified coordinate.
   *
   * \details This function has no effect if the coordinate is out-of-bounds or if
   * something goes wrong when attempting to modify the pixel data.
   *
   * \param pixel the pixel that will be changed.
   * \param color the new color of the pixel.
   *
   * \since 4.0.0
   */
  void set_pixel(const ipoint pixel, const color& color) noexcept
  {
    if (!in_bounds(pixel) || !lock()) {
      return;
    }

    const int nPixels = (m_surface->pitch / 4) * height();
    const int index = (pixel.y() * width()) + pixel.x();

    if ((index >= 0) && (index < nPixels)) {
      const auto info = format_info();
      auto* pixels = reinterpret_cast<u32*>(m_surface->pixels);
      pixels[index] = info.rgba_to_pixel(color);
    }

    unlock();
  }

  /**
   * \brief Sets the alpha component modulation value.
   *
   * \param alpha the new alpha component value, in the range [0, 255].
   *
   * \since 4.0.0
   */
  void set_alpha(const u8 alpha) noexcept
  {
    SDL_SetSurfaceAlphaMod(m_surface, alpha);
  }

  /**
   * \brief Sets the color modulation that will be used by the surface.
   *
   * \param color the color that represents the color modulation that will be
   * used.
   *
   * \since 4.0.0
   */
  void set_color_mod(const color& color) noexcept
  {
    SDL_SetSurfaceColorMod(m_surface, color.red(), color.green(), color.blue());
  }

  /**
   * \brief Sets the blend mode that will be used by the surface.
   *
   * \param mode the blend mode that will be used.
   *
   * \since 4.0.0
   */
  void set_blend_mode(const blend_mode mode) noexcept
  {
    SDL_SetSurfaceBlendMode(m_surface, static_cast<SDL_BlendMode>(mode));
  }

  /**
   * \brief Sets the value of the RLE acceleration hint.
   *
   * \param enabled `true` if the RLE optimization hint should be enabled;
   * `false` otherwise.
   *
   * \return `success` if nothing went wrong; `failure` otherwise.
   *
   * \see is_rle_enabled()
   *
   * \since 5.2.0
   */
  auto set_rle_hint(const bool enabled) noexcept -> result
  {
    return SDL_SetSurfaceRLE(m_surface, enabled ? 1 : 0) == 0;
  }

  /// \} End of setters

  /// \name Getters
  /// \{

  /**
   * \brief Returns the alpha component modulation of the surface.
   *
   * \return the alpha modulation value, in the range [0, 255].
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto alpha() const noexcept -> u8
  {
    u8 alpha{0xFF};
    SDL_GetSurfaceAlphaMod(m_surface, &alpha);
    return alpha;
  }

  /**
   * \brief Returns the color modulation of the surface.
   *
   * \return a color that represents the color modulation of the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto color_mod() const noexcept -> color
  {
    u8 red{};
    u8 green{};
    u8 blue{};
    SDL_GetSurfaceColorMod(m_surface, &red, &green, &blue);
    return color{red, green, blue};
  }

  /**
   * \brief Returns the blend mode that is being used by the surface.
   *
   * \return the blend mode that the surface uses.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get_blend_mode() const noexcept -> blend_mode
  {
    SDL_BlendMode mode{};
    SDL_GetSurfaceBlendMode(m_surface, &mode);
    return static_cast<blend_mode>(mode);
  }

  /**
   * \brief Creates and returns a surface based on this surface with the
   * specified pixel format.
   *
   * \param format the pixel format that will be used by the new surface.
   *
   * \return a surface based on this surface with the specified
   * pixel format.
   *
   * \throws sdl_error if the surface cannot be created.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto convert(const pixel_format format) const -> basic_surface
  {
    if (auto* converted = SDL_ConvertSurfaceFormat(m_surface, to_underlying(format), 0)) {
      basic_surface result{converted};
      result.set_blend_mode(get_blend_mode());
      return result;
    }
    else {
      throw sdl_error{};
    }
  }

  /**
   * \brief Returns the width of the surface.
   *
   * \return the width of the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto width() const noexcept -> int
  {
    return m_surface->w;
  }

  /**
   * \brief Returns the height of the surface.
   *
   * \return the height of the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto height() const noexcept -> int
  {
    return m_surface->h;
  }

  /**
   * \brief Returns the size of the surface.
   *
   * \return the size of the surface.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto size() const noexcept -> iarea
  {
    return iarea{width(), height()};
  }

  /**
   * \brief Returns the pitch (the length of a row of pixels in bytes) of the
   * surface.
   *
   * \return the pitch of the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto pitch() const noexcept -> int
  {
    return m_surface->pitch;
  }

  /**
   * \brief Returns a pointer to the pixel data of the surface.
   *
   * \details It's possible to modify the surface through the returned pointer.
   *
   * \return a pointer to the pixel data of the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto pixels() noexcept -> void*
  {
    return m_surface->pixels;
  }

  /**
   * \brief Returns a pointer to the pixel data of the surface.
   *
   * \return a pointer to the pixel data of the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto pixels() const noexcept -> const void*
  {
    return m_surface->pixels;
  }

  /**
   * \brief Returns a pointer to the pixel data of the surface.
   *
   * \return a pointer to the pixel data of the surface.
   *
   * \since 5.3.0
   */
  [[nodiscard]] auto data() noexcept -> void*
  {
    return pixels();
  }

  /**
   * \copydoc data()
   */
  [[nodiscard]] auto data() const noexcept -> const void*
  {
    return pixels();
  }

  /**
   * \brief Returns the pixel format info associated with the surface.
   *
   * \return the associated pixel format info.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto format_info() const noexcept -> pixel_format_info_handle
  {
    return pixel_format_info_handle{m_surface->format};
  }

  /**
   * \brief Returns the clipping information associated with the surface.
   *
   * \return the clipping information associated with the surface.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto clip() const noexcept -> irect
  {
    const auto rect = m_surface->clip_rect;
    return {{rect.x, rect.y}, {rect.w, rect.h}};
  }

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Indicates whether or not the surface is RLE-enabled.
   *
   * \return `true` if the surface is RLE-enabled; `false` otherwise.
   *
   * \since 5.2.0
   */
  [[nodiscard]] auto is_rle_enabled() const noexcept -> bool
  {
    return SDL_HasSurfaceRLE(m_surface) == SDL_TRUE;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Returns a pointer to the associated `SDL_Surface`.
   *
   * \warning Don't take ownership of the returned pointer!
   *
   * \return a pointer to the associated `SDL_Surface`.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_Surface*
  {
    return m_surface.get();
  }

  /// \} End of getters

  /// \name Conversions
  /// \{

  /**
   * \brief Indicates whether or not a surface handle holds a non-null pointer.
   *
   * \tparam BB dummy parameter for SFINAE.
   *
   * \return `true` if the surface handle holds a non-null pointer; `false`
   * otherwise.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit operator bool() const noexcept
  {
    return m_surface != nullptr;
  }

  /**
   * \brief Converts to `SDL_Surface*`.
   *
   * \return a pointer to the associated `SDL_Surface`.
   *
   * \since 4.0.0
   */
  [[nodiscard]] explicit operator SDL_Surface*() noexcept
  {
    return get();
  }

  /**
   * \brief Converts to `const SDL_Surface*`.
   *
   * \return a pointer to the associated `SDL_Surface`.
   *
   * \since 4.0.0
   */
  [[nodiscard]] explicit operator const SDL_Surface*() const noexcept
  {
    return get();
  }

  /// \} End of conversions

 private:
  struct deleter final
  {
    void operator()(SDL_Surface* surface) noexcept
    {
      SDL_FreeSurface(surface);
    }
  };
  detail::pointer_manager<T, SDL_Surface, deleter> m_surface;

  /**
   * \brief Copies the contents of the supplied surface instance into this
   * instance.
   *
   * \param other the instance that will be copied.
   *
   * \throws sdl_error if the surface cannot be copied.
   *
   * \since 4.0.0
   */
  void copy(const basic_surface& other)
  {
    m_surface.reset(other.copy_surface());
  }

  /**
   * \brief Indicates whether or not the supplied point is within the bounds of
   * the surface.
   *
   * \param point the point that will be checked.
   *
   * \return `true` if the point is within the bounds of the surface; `false`
   * otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto in_bounds(const ipoint point) const noexcept -> bool
  {
    return !(point.x() < 0 || point.y() < 0 || point.x() >= width() || point.y() >= height());
  }

  /**
   * \brief Creates and returns copy of the associated `SDL_Surface`.
   *
   * \return a copy of the associated `SDL_Surface`, the returned pointer won't
   * be null.
   *
   * \throws sdl_error if the copy couldn't be created.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto copy_surface() const -> owner<SDL_Surface*>
  {
    if (auto* copy = SDL_DuplicateSurface(m_surface)) {
      return copy;
    }
    else {
      throw sdl_error{};
    }
  }

#ifdef CENTURION_MOCK_FRIENDLY_MODE

 public:
  basic_surface() = default;
#endif  // CENTURION_MOCK_FRIENDLY_MODE
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a surface.
 *
 * \param surface the surface that will be converted.
 *
 * \return a textual representation of the surface.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_surface<T>& surface) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("surface{{data: {}, width: {}, height: {}}}",
                     detail::address_of(surface.get()),
                     surface.width(),
                     surface.height());
#else
  return "surface{data: " + detail::address_of(surface.get()) +
         ", width: " + std::to_string(surface.width()) +
         ", height: " + std::to_string(surface.height()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a surface.
 *
 * \param stream the stream that will be used.
 * \param surface the surface that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_surface<T>& surface) -> std::ostream&
{
  return stream << to_string(surface);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_SURFACE_HEADER


namespace cen {

/// \addtogroup video
/// \{

template <typename T>
class basic_window;

/**
 * \typedef window
 *
 * \brief Represents an owning window.
 *
 * \since 5.0.0
 */
using window = basic_window<detail::owning_type>;

/**
 * \typedef window_handle
 *
 * \brief Represents a non-owning window.
 *
 * \since 5.0.0
 */
using window_handle = basic_window<detail::handle_type>;

/**
 * \class basic_window
 *
 * \brief Represents an operating system window.
 *
 * \ownerhandle `window`/`window_handle`
 *
 * \since 5.0.0
 *
 * \see `window`
 * \see `window_handle`
 * \see `get_window()`
 * \see `get_grabbed_window()`
 * \see `mouse_focus_window()`
 * \see `keyboard_focus_window()`
 * \see `get_renderer()`
 * \see `make_window_and_renderer()`
 */
template <typename T>
class basic_window final
{
 public:
  /**
   * \enum window_flags
   *
   * \brief Represents different window features and options.
   *
   * \details Values of this enum are intended to be used to create flag bitmasks, that
   * can be used when creating windows and to obtain information from created windows.
   *
   * \see `SDL_WindowFlags`
   *
   * \since 6.0.0
   */
  enum window_flags : u32
  {
    fullscreen = SDL_WINDOW_FULLSCREEN,
    opengl = SDL_WINDOW_OPENGL,
    shown = SDL_WINDOW_SHOWN,
    hidden = SDL_WINDOW_HIDDEN,
    borderless = SDL_WINDOW_BORDERLESS,
    resizable = SDL_WINDOW_RESIZABLE,
    minimized = SDL_WINDOW_MINIMIZED,
    maximized = SDL_WINDOW_MAXIMIZED,
    input_grabbed = SDL_WINDOW_INPUT_GRABBED,
    input_focus = SDL_WINDOW_INPUT_FOCUS,
    mouse_focus = SDL_WINDOW_MOUSE_FOCUS,
    fullscreen_desktop = SDL_WINDOW_FULLSCREEN_DESKTOP,
    foreign = SDL_WINDOW_FOREIGN,
    high_dpi = SDL_WINDOW_ALLOW_HIGHDPI,
    mouse_capture = SDL_WINDOW_MOUSE_CAPTURE,
    always_on_top = SDL_WINDOW_ALWAYS_ON_TOP,
    skip_taskbar = SDL_WINDOW_SKIP_TASKBAR,
    utility = SDL_WINDOW_UTILITY,
    tooltip = SDL_WINDOW_TOOLTIP,
    popup_menu = SDL_WINDOW_POPUP_MENU,
    vulkan = SDL_WINDOW_VULKAN,

#if SDL_VERSION_ATLEAST(2, 0, 14)
    metal = SDL_WINDOW_METAL
#endif  // SDL_VERSION_ATLEAST(2, 0, 14)
  };

  /// \name Construction
  /// \{

  /**
   * \brief Creates a window from a pointer to an SDL window.
   *
   * \note If you're creating a `window` instance, then ownership of the pointer is
   * claimed. Furthermore, if you're creating a `window_handle`, ownership is *not*
   * claimed.
   *
   * \param window a pointer to the associated SDL window. Ownership of this pointer is
   * claimed if the window is owning.
   *
   * \since 5.0.0
   */
  explicit basic_window(maybe_owner<SDL_Window*> window) noexcept(!detail::is_owning<T>())
      : m_window{window}
  {
    if constexpr (detail::is_owning<T>()) {
      if (!m_window) {
        throw cen_error{"Cannot create window from null pointer!"};
      }
    }
  }

  /**
   * \brief Creates an owning window with the specified title and size.
   *
   * \details The window will be hidden by default.
   *
   * \param title the title of the window, can't be null.
   * \param size the size of the window, components must be greater than zero.
   * \param flags the window flags.
   *
   * \throws cen_error if the supplied width or height aren't greater than zero.
   * \throws sdl_error if the window cannot be created.
   *
   * \see `default_size()`
   * \see `default_flags()`
   *
   * \since 3.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_window(const not_null<str> title,
                        const iarea size = default_size(),
                        const u32 flags = default_flags())
  {
    assert(title);

    if (size.width < 1) {
      throw cen_error{"Bad window width!"};
    }
    else if (size.height < 1) {
      throw cen_error{"Bad window height!"};
    }

    m_window.reset(SDL_CreateWindow(title,
                                    SDL_WINDOWPOS_CENTERED,
                                    SDL_WINDOWPOS_CENTERED,
                                    size.width,
                                    size.height,
                                    flags));
    if (!m_window) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates an owning window with the specified title and size.
   *
   * \details The window will be hidden by default.
   *
   * \param title the title of the window.
   * \param size the size of the window, components must be greater than zero.
   * \param flags the window flags, see `window_flags`.
   *
   * \throws cen_error if the supplied width or height aren't greater than zero.
   * \throws sdl_error if the window cannot be created.
   *
   * \see `default_size()`
   * \see `default_flags()`
   *
   * \since 5.3.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_window(const std::string& title,
                        const iarea size = default_size(),
                        const u32 flags = default_flags())
      : basic_window{title.c_str(), size, flags}
  {}

  /**
   * \brief Creates a window.
   *
   * \details The window will use the size obtained from `default_size()` as its initial
   * size.
   *
   * \throws sdl_error if the window cannot be created.
   *
   * \since 3.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  basic_window() : basic_window{"Centurion window"}
  {}

  /**
   * \brief Creates a window handle based on an owning window.
   *
   * \param owner the owning window to base the handle on.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit basic_window(const window& owner) noexcept : m_window{owner.get()}
  {}

  /// \} End of construction

  /// \name Mutators
  /// \{

  /**
   * \brief Makes the window visible.
   *
   * \since 3.0.0
   */
  void show() noexcept
  {
    SDL_ShowWindow(m_window);
  }

  /**
   * \brief Makes the window invisible.
   *
   * \since 3.0.0
   */
  void hide() noexcept
  {
    SDL_HideWindow(m_window);
  }

  /**
   * \brief Raises this window above other windows and requests focus.
   *
   * \since 3.0.0
   */
  void raise() noexcept
  {
    SDL_RaiseWindow(m_window);
  }

  /**
   * \brief Maximizes the window.
   *
   * \since 3.1.0
   */
  void maximize() noexcept
  {
    SDL_MaximizeWindow(m_window);
  }

  /**
   * \brief Minimizes the window.
   *
   * \since 3.1.0
   */
  void minimize() noexcept
  {
    SDL_MinimizeWindow(m_window);
  }

  /**
   * \brief Restores the position and size of the window if it's minimized or maximized.
   *
   * \since 5.3.0
   */
  void restore() noexcept
  {
    SDL_RestoreWindow(m_window);
  }

  /**
   * \brief Updates the window surface.
   *
   * \return `success` if the surface was successfully updated; `failure` otherwise.
   *
   * \since 5.0.0
   */
  auto update_surface() noexcept -> result
  {
    return SDL_UpdateWindowSurface(m_window) == 0;
  }

#if SDL_VERSION_ATLEAST(2, 0, 16)

  /**
   * \brief Modifies the flash state of the window to acquire attention from the user.
   *
   * \param op the flash operation that will be performed.
   *
   * \return `success` if the operation was successful; `failure` otherwise.
   *
   * \since 6.2.0
   */
  auto flash(const flash_op op = flash_op::briefly) noexcept -> result
  {
    return SDL_FlashWindow(m_window, static_cast<SDL_FlashOperation>(op)) == 0;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 16)

  /// \} End of mutators

  /// \name Setters
  /// \{

  /**
   * \brief Sets whether or not the window is in fullscreen mode.
   *
   * \param enabled `true` if the window should be fullscreen; `false` for windowed mode.
   *
   * \return `success` if the display mode was changed; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_fullscreen(const bool enabled) noexcept -> result
  {
    return SDL_SetWindowFullscreen(m_window, enabled ? fullscreen : 0) == 0;
  }

  /**
   * \brief Sets whether or not the window is in fullscreen desktop mode.
   *
   * \details This mode is useful when you want to "fake" fullscreen mode.
   *
   * \param enabled `true` if the window should be fullscreen desktop; `false` for
   * windowed mode.
   *
   * \return `success` if the display mode was changed; `failure` otherwise.
   *
   * \since 4.0.0
   */
  auto set_fullscreen_desktop(const bool enabled) noexcept -> result
  {
    return SDL_SetWindowFullscreen(m_window, enabled ? fullscreen_desktop : 0) == 0;
  }

  /**
   * \brief Sets whether or not the window is decorated.
   *
   * \details This is enabled by default.
   *
   * \param decorated `true` if the window should be decorated; `false` otherwise.
   *
   * \since 3.0.0
   */
  void set_decorated(const bool decorated) noexcept
  {
    SDL_SetWindowBordered(m_window, detail::convert_bool(decorated));
  }

  /**
   * \brief Sets whether or not the window should be resizable.
   *
   * \param resizable `true` if the window should be resizable; `false` otherwise.
   *
   * \since 3.0.0
   */
  void set_resizable(const bool resizable) noexcept
  {
    SDL_SetWindowResizable(m_window, detail::convert_bool(resizable));
  }

  /**
   * \brief Sets the icon that will be used by the window.
   *
   * \param icon the surface that will serve as the icon of the window.
   *
   * \since 3.0.0
   */
  void set_icon(const surface& icon) noexcept
  {
    SDL_SetWindowIcon(m_window, icon.get());
  }

  /**
   * \brief Sets the title of the window.
   *
   * \param title the title of the window, can't be null.
   *
   * \since 3.0.0
   */
  void set_title(const not_null<str> title) noexcept
  {
    assert(title);
    SDL_SetWindowTitle(m_window, title);
  }

  /**
   * \brief Sets the title of the window.
   *
   * \param title the title of the window.
   *
   * \since 5.3.0
   */
  void set_title(const std::string& title) noexcept
  {
    set_title(title.c_str());
  }

  /**
   * \brief Sets the opacity of the window.
   *
   * \details The supplied opacity will be clamped to a value in the legal range.
   *
   * \param opacity the opacity, in the range [0, 1].
   *
   * \return `success` if the opacity was successfully set; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_opacity(const float opacity) noexcept -> result
  {
    return SDL_SetWindowOpacity(m_window, opacity) == 0;
  }

  /**
   * \brief Sets whether or not the mouse should be confined within the window.
   *
   * \brief This property is disabled by default.
   *
   * \param grab `true` if the mouse should be confined within the window; `false`
   * otherwise.
   *
   * \see `set_grab_keyboard()`
   *
   * \since 3.0.0
   */
  void set_grab_mouse(const bool grab) noexcept
  {
    SDL_SetWindowGrab(m_window, detail::convert_bool(grab));
  }

  /**
   * \brief Sets the overall brightness of the window.
   *
   * \note A brightness value outside the legal range will be clamped to the closest valid
   * value.
   *
   * \param brightness the brightness value, in the range [0, 1].
   *
   * \return `success` if the brightness was successfully set; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_brightness(const float brightness) noexcept -> result
  {
    return SDL_SetWindowBrightness(m_window, detail::clamp(brightness, 0.0f, 1.0f)) == 0;
  }

  /**
   * \brief Sets whether or not the mouse should be captured.
   *
   * \note A window might have to be visible in order for the mouse to be captured.
   *
   * \param capture `true` if the mouse should be captured; `false` otherwise.
   *
   * \return `success` on the mouse capture was successfully changed; `failure` otherwise.
   *
   * \since 5.0.0
   */
  static auto set_capturing_mouse(const bool capture) noexcept -> result
  {
    return SDL_CaptureMouse(detail::convert_bool(capture)) == 0;
  }

#if SDL_VERSION_ATLEAST(2, 0, 16)

  /**
   * \brief Sets whether or not the keyboard input should be grabbed by the window.
   *
   * \param grab `true` if the keyboard should be grabbed; `false` otherwise.
   *
   * \see `set_grab_mouse()`
   *
   * \since 6.2.0
   */
  void set_grab_keyboard(const bool grab) noexcept
  {
    SDL_SetWindowKeyboardGrab(m_window, detail::convert_bool(grab));
  }

  /**
   * \brief Sets whether or not a window is always on top of other windows.
   *
   * \param enabled `true` if the window should be on top of all other windows; `false`
   * otherwise.
   *
   * \since 6.2.0
   */
  void set_always_on_top(const bool enabled) noexcept
  {
    SDL_SetWindowAlwaysOnTop(m_window, detail::convert_bool(enabled));
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 16)

  /// \} End of setters

  /// \name Position functions
  /// \{

  /**
   * \brief Centers the window position relative to the screen.
   *
   * \note Windows are centered by default.
   *
   * \since 3.0.0
   */
  void center() noexcept
  {
    set_position({SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED});
  }

  /**
   * \brief Sets the x-coordinate of the window.
   *
   * \param x the new x-coordinate of the window.
   *
   * \since 6.0.0
   */
  void set_x(const int x) noexcept
  {
    set_position({x, y()});
  }

  /**
   * \brief Sets the y-coordinate of the window.
   *
   * \param y the new y-coordinate of the window.
   *
   * \since 6.0.0
   */
  void set_y(const int y) noexcept
  {
    set_position({x(), y});
  }

  /**
   * \brief Sets the position of the window.
   *
   * \note It's possible to use `SDL_WINDOWPOS_CENTERED` or `SDL_WINDOWPOS_UNDEFINED` as
   * any of the components of the point.
   *
   * \param position the new position of the window.
   *
   * \since 5.0.0
   */
  void set_position(const ipoint position) noexcept
  {
    SDL_SetWindowPosition(m_window, position.x(), position.y());
  }

  /**
   * \brief Returns the x-coordinate of the window position.
   *
   * \return the x-coordinate of the window position.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto x() const noexcept -> int
  {
    return position().x();
  }

  /**
   * \brief Returns the y-coordinate of the window position.
   *
   * \return the y-coordinate of the window position.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto y() const noexcept -> int
  {
    return position().y();
  }

  /**
   * \brief Returns the current position of the window.
   *
   * \note Windows are centered by default.
   *
   * \return the current position of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto position() const noexcept -> ipoint
  {
    int x{};
    int y{};
    SDL_GetWindowPosition(m_window, &x, &y);
    return {x, y};
  }

  /// \} End of position functions

  /// \name Size functions
  /// \{

  /**
   * \brief Sets the width of the window.
   *
   * \details The supplied width is capped to always be at least 1.
   *
   * \param width the new width of the window, must be greater than zero.
   *
   * \since 3.0.0
   */
  void set_width(const int width) noexcept
  {
    SDL_SetWindowSize(m_window, detail::max(width, 1), height());
  }

  /**
   * \brief Sets the height of the window.
   *
   * \details The supplied height is capped to always be at least 1.
   *
   * \param height the new height of the window, must be greater than zero.
   *
   * \since 3.0.0
   */
  void set_height(const int height) noexcept
  {
    SDL_SetWindowSize(m_window, width(), detail::max(height, 1));
  }

  /**
   * \brief Sets the size of the window.
   *
   * \pre The supplied width and height must be greater than zero.
   *
   * \param size the new size of the window.
   *
   * \since 5.0.0
   */
  void set_size(const iarea size) noexcept
  {
    assert(size.width > 0);
    assert(size.height > 0);
    SDL_SetWindowSize(m_window, size.width, size.height);
  }

  /**
   * \brief Sets the minimum size of the window.
   *
   * \pre The supplied width and height must be greater than zero.
   *
   * \param size the minimum size of the window.
   *
   * \since 3.0.0
   */
  void set_min_size(const iarea size) noexcept
  {
    assert(size.width > 0);
    assert(size.height > 0);
    SDL_SetWindowMinimumSize(m_window, size.width, size.height);
  }

  /**
   * \brief Sets the maximum size of the window.
   *
   * \pre The supplied width and height must be greater than zero.
   *
   * \param size the maximum size of the window.
   *
   * \since 3.0.0
   */
  void set_max_size(const iarea size) noexcept
  {
    assert(size.width > 0);
    assert(size.height > 0);
    SDL_SetWindowMaximumSize(m_window, size.width, size.height);
  }

  /**
   * \brief Returns the current width of the window.
   *
   * \return the current width of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto width() const noexcept -> int
  {
    return size().width;
  }

  /**
   * \brief Returns the current height of the window.
   *
   * \return the current height of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto height() const noexcept -> int
  {
    return size().height;
  }

  /**
   * \brief Returns the current size of the window.
   *
   * \note Calling this function is slightly faster than calling both `width` and `height`
   * to obtain the window size.
   *
   * \return the size of the window.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto size() const noexcept -> iarea
  {
    iarea size{};
    SDL_GetWindowSize(m_window, &size.width, &size.height);
    return size;
  }

  /**
   * \brief Returns the minimum size of the window.
   *
   * \return the minimum size of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto min_size() const noexcept -> iarea
  {
    iarea size{};
    SDL_GetWindowMinimumSize(m_window, &size.width, &size.height);
    return size;
  }

  /**
   * \brief Returns the maximum size of the window.
   *
   * \return the maximum size of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto max_size() const noexcept -> iarea
  {
    iarea size{};
    SDL_GetWindowMaximumSize(m_window, &size.width, &size.height);
    return size;
  }

  /**
   * \brief Returns the default size of a window.
   *
   * \note This function is only available for owning windows.
   *
   * \return the default size of a window.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] constexpr static auto default_size() noexcept -> iarea
  {
    return {800, 600};
  }

  /// \} End of size functions

  /// \name Flag queries
  /// \{

  /**
   * \brief Returns a mask that represents the flags associated with the window.
   *
   * \details You can check the returned mask using the `SDL_WindowFlags` enum.
   *
   * \return a mask that represents the flags associated with the window.
   *
   * \see `SDL_WindowFlags`
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto flags() const noexcept -> u32
  {
    return SDL_GetWindowFlags(m_window);
  }

  /**
   * \brief Indicates whether or not a flag is set.
   *
   * \details Some of the use cases of this function can be replaced by more explicit
   * functions, e.g. `is_fullscreen()` instead of `check_flag(SDL_WINDOW_FULLSCREEN)`.
   *
   * \param flag the flag that will be tested.
   *
   * \return `true` if the flag is set; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto check_flag(const SDL_WindowFlags flag) const noexcept -> bool
  {
    return static_cast<bool>(flags() & flag);
  }

  /**
   * \brief Indicates whether or not a flag is set.
   *
   * \details Some of the use cases of this function can be replaced by more explicit
   * functions, e.g. `is_fullscreen()` instead of `check_flag(cen::window::fullscreen)`.
   *
   * \param flag the flag that will be tested.
   *
   * \return `true` if the flag is set; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto check_flag(const window_flags flag) const noexcept -> bool
  {
    return static_cast<bool>(flags() & flag);
  }

  /**
   * \brief Indicates whether or not the window has grabbed the input focus.
   *
   * \return `true` if the window has grabbed input focus; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto has_grabbed_input() const noexcept -> bool
  {
    return check_flag(input_grabbed);
  }

  /**
   * \brief Indicates whether or not the window has input focus.
   *
   * \note The window might have to be visible for this to be true.
   *
   * \return `true` if the window has input focus; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto has_input_focus() const noexcept -> bool
  {
    return check_flag(input_focus);
  }

  /**
   * \brief Indicates whether or not the window has mouse focus.
   *
   * \return `true` if the window has mouse focus; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto has_mouse_focus() const noexcept -> bool
  {
    return check_flag(mouse_focus);
  }

  /**
   * \brief Indicates whether or not the window is borderless.
   *
   * \note This check is the opposite of `is_decorated()`.
   *
   * \details Windows are not borderless by default.
   *
   * \return `true` if the window is borderless; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_borderless() const noexcept -> bool
  {
    return check_flag(borderless);
  }

  /**
   * \brief Indicates whether or not the window is decorated.
   *
   * \note This check is the opposite of `is_borderless()`.
   *
   * \details Windows are decorated by default.
   *
   * \return `true` if the window is decorated; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_decorated() const noexcept -> bool
  {
    return !is_borderless();
  }

  /**
   * \brief Indicates whether or not the window is resizable.
   *
   * \details By default, this property is set to false.
   *
   * \return `true` if the window is resizable; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_resizable() const noexcept -> bool
  {
    return check_flag(resizable);
  }

  /**
   * \brief Indicates whether or the window supports high-DPI mode.
   *
   * \return `true` if the window supports high-DPI mode; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_high_dpi() const noexcept -> bool
  {
    return check_flag(high_dpi);
  }

  /**
   * \brief Indicates whether or not the window is in fullscreen mode.
   *
   * \return `true` if the window is in fullscreen mode; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_fullscreen() const noexcept -> bool
  {
    return check_flag(fullscreen);
  }

  /**
   * \brief Indicates whether or not the window is in fullscreen desktop mode.
   *
   * \return `true` if the window is in fullscreen desktop mode; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_fullscreen_desktop() const noexcept -> bool
  {
    return check_flag(fullscreen_desktop);
  }

  /**
   * \brief Indicates whether or not the window is visible.
   *
   * \return `true` if the window is visible; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_visible() const noexcept -> bool
  {
    return check_flag(shown);
  }

  /**
   * \brief Indicates whether or not the window is hidden.
   *
   * \return `true` if the window isn't visible; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_hidden() const noexcept -> bool
  {
    return check_flag(hidden);
  }

  /**
   * \brief Indicates whether or not the window is usable with an OpenGL-context.
   *
   * \return `true` if the window is compatible with an OpenGL-context; false otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_opengl() const noexcept -> bool
  {
    return check_flag(opengl);
  }

  /**
   * \brief Indicates whether or not the window is usable as a Vulkan surface.
   *
   * \return `true` if the window is is usable as a Vulkan surface; false otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_vulkan() const noexcept -> bool
  {
    return check_flag(vulkan);
  }

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Indicates whether or not the window can be used as a Metal view.
   *
   * \return `true` if the window can be used as a Metal view; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_metal() const noexcept -> bool
  {
    return check_flag(metal);
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Indicates whether or not the window wasn't created by SDL.
   *
   * \return `true` if the window wasn't created by SDL; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_foreign() const noexcept -> bool
  {
    return check_flag(foreign);
  }

  /**
   * \brief Indicates whether or not the window is capturing the mouse.
   *
   * \return `true` if the window is capturing the mouse; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_capturing_mouse() const noexcept -> bool
  {
    return check_flag(mouse_capture);
  }

  /**
   * \brief Indicates whether or not the window is minimized.
   *
   * \return `true` if the window is minimized; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_minimized() const noexcept -> bool
  {
    return check_flag(minimized);
  }

  /**
   * \brief Indicates whether or not the window is maximized.
   *
   * \return `true` if the window is maximized; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_maximized() const noexcept -> bool
  {
    return check_flag(maximized);
  }

  /**
   * \brief Indicates whether or not the window is set to be always on top of other
   * windows.
   *
   * \return `true` if the window is always on top of other windows; false otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_always_on_top() const noexcept -> bool
  {
    return check_flag(always_on_top);
  }

  /**
   * \brief Indicates whether or not the window is a "utility" window.
   *
   * \return `true` if window is a "utility" window; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_utility() const noexcept -> bool
  {
    return check_flag(utility);
  }

  /**
   * \brief Indicates whether or not the window is a tooltip.
   *
   * \return `true` if the window is a tooltip; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_tooltip() const noexcept -> bool
  {
    return check_flag(tooltip);
  }

  /**
   * \brief Indicates whether or not the window is a popup menu.
   *
   * \return `true` if the window is a popup menu; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_popup_menu() const noexcept -> bool
  {
    return check_flag(popup_menu);
  }

  /**
   * \brief Indicates whether or not the window is excluded from the taskbar.
   *
   * \return `true` if the window is excluded from the taskbar; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_excluded_from_taskbar() const noexcept -> bool
  {
    return check_flag(skip_taskbar);
  }

  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] constexpr static auto default_flags() noexcept -> u32
  {
    return hidden;
  }

  /// \} End of flag queries

  /// \name Getters
  /// \{

  /**
   * \brief Returns a numerical ID of the window.
   *
   * \return a numerical ID of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto id() const noexcept -> u32
  {
    return SDL_GetWindowID(m_window);
  }

  /**
   * \brief Returns the display index associated with the window.
   *
   * \return the display index associated with the window; `std::nullopt` if the display
   * index cannot be obtained.
   *
   * \since 3.1.0
   */
  [[nodiscard]] auto display_index() const noexcept -> std::optional<int>
  {
    const auto index = SDL_GetWindowDisplayIndex(m_window);
    if (index != -1) {
      return index;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the title of the window.
   *
   * \return the title of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto title() const -> std::string
  {
    return SDL_GetWindowTitle(m_window);
  }

  /**
   * \brief Returns the current brightness value of the window.
   *
   * \details The default value of this property is 1.
   *
   * \return the current brightness of the window, in the range [0, 1].
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto brightness() const noexcept -> float
  {
    return SDL_GetWindowBrightness(m_window);
  }

  /**
   * \brief Returns the opacity of the window.
   *
   * \return the opacity of the window, in the range [0, 1].
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto opacity() const noexcept -> float
  {
    float opacity{1};
    SDL_GetWindowOpacity(m_window, &opacity);
    return opacity;
  }

  /**
   * \brief Returns the pixel format of the window.
   *
   * \return the pixel format used by the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto get_pixel_format() const noexcept -> pixel_format
  {
    return static_cast<pixel_format>(SDL_GetWindowPixelFormat(m_window));
  }

  /**
   * \brief Returns a handle to the window framebuffer surface.
   *
   * \warning It is not possible use the framebuffer surface with the 3D or 2D rendering
   * APIs.
   *
   * \return a handle to the window surface, might not contain a valid surface pointer.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get_surface() noexcept -> surface_handle
  {
    return surface_handle{SDL_GetWindowSurface(m_window)};
  }

  /**
   * \brief Indicates whether or not the window is currently grabbing the mouse input.
   *
   * \return `true` if the window is grabbing the mouse; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto grabbing_mouse() const noexcept -> bool
  {
    return SDL_GetWindowGrab(m_window);
  }

  /**
   * \brief Indicates whether or not the screen keyboard is shown for the window.
   *
   * \return `true` if the screen keyboard is shown for the window; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_screen_keyboard_shown() const noexcept -> bool
  {
    return SDL_IsScreenKeyboardShown(get()) == SDL_TRUE;
  }

  /**
   * \brief Returns a pointer to the associated SDL window.
   *
   * \warning Don't take ownership of the returned pointer!
   *
   * \return a pointer to the associated SDL window.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_Window*
  {
    return m_window.get();
  }

  /// \} End of getters

  /// \name Conversions
  /// \{

  /**
   * \brief Converts to `SDL_Window*`.
   *
   * \return a pointer to the associated SDL window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit operator SDL_Window*() noexcept
  {
    return m_window.get();
  }

  /**
   * \brief Converts to `const SDL_Window*`.
   *
   * \return a pointer to the associated SDL window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit operator const SDL_Window*() const noexcept
  {
    return m_window.get();
  }

  /**
   * \brief Indicates whether or not the handle holds a non-null pointer.
   *
   * \note This function is only available for window handles.
   *
   * \warning It's undefined behaviour to invoke other member functions that use the
   * internal pointer if this function returns `false`.
   *
   * \return `true` if the handle holds a non-null pointer; `false` otherwise.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit operator bool() const noexcept
  {
    return m_window != nullptr;
  }

  /// \} End of conversions

 private:
  struct deleter final
  {
    void operator()(SDL_Window* window) noexcept
    {
      SDL_DestroyWindow(window);
    }
  };
  detail::pointer_manager<T, SDL_Window, deleter> m_window;
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a window.
 *
 * \param window the window that will be converted.
 *
 * \return a textual representation of the window.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_window<T>& window) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("window{{data: {}, width: {}, height: {}}}",
                     detail::address_of(window.get()),
                     window.width(),
                     window.height());
#else
  return "window{data: " + detail::address_of(window.get()) +
         ", width: " + std::to_string(window.width()) +
         ", height: " + std::to_string(window.height()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a window.
 *
 * \param stream the stream that will be used.
 * \param window the window that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_window<T>& window) -> std::ostream&
{
  return stream << to_string(window);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_WINDOW_HEADER


/**
 * \namespace cen::vk
 *
 * \brief Contains Vulkan-related components.
 *
 * \ingroup video
 *
 * \since 6.0.0
 */
namespace cen::vk {

/// \addtogroup video
/// \{

/// \name Vulkan functions
/// \{

/**
 * \brief Returns the address of the `vkGetInstanceProcAddr` function.
 *
 * \return the address of the `vkGetInstanceProcAddr` function.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto get_instance_proc_addr() noexcept -> void*
{
  return SDL_Vulkan_GetVkGetInstanceProcAddr();
}

/**
 * \brief Creates a rendering surface for a Vulkan window.
 *
 * \pre `window` must be a Vulkan window.
 *
 * \tparam T the ownership semantics of the window.
 *
 * \param window the Vulkan window.
 * \param instance the current Vulkan instance.
 * \param[out] outSurface the handle that will receive the handle of the created surface.
 *
 * \return `success` if the surface was succesfully created; `failure` otherwise.
 *
 * \since 6.0.0
 */
template <typename T>
auto create_surface(basic_window<T>& window,
                    VkInstance instance,
                    VkSurfaceKHR* outSurface) noexcept -> result
{
  assert(window.is_vulkan());
  return SDL_Vulkan_CreateSurface(window.get(), instance, outSurface) == SDL_TRUE;
}

/**
 * \brief Returns the extensions required to create a Vulkan surface.
 *
 * \return the required Vulkan extensions; `std::nullopt` if something goes wrong.
 *
 * \since 6.0.0
 */
inline auto required_extensions() -> std::optional<std::vector<str>>
{
  uint count{};
  if (!SDL_Vulkan_GetInstanceExtensions(nullptr, &count, nullptr)) {
    return std::nullopt;
  }

  std::vector<str> names(count);
  if (!SDL_Vulkan_GetInstanceExtensions(nullptr, &count, names.data())) {
    return std::nullopt;
  }

  return names;
}

/**
 * \brief Returns the size of the drawable surface associated with the window.
 *
 * \pre `window` must be a Vulkan window.
 *
 * \tparam T the ownership semantics of the window.
 *
 * \param window the Vulkan window that will be queried.
 *
 * \return the size of the window drawable.
 *
 * \since 6.0.0
 */
template <typename T>
[[nodiscard]] auto drawable_size(const basic_window<T>& window) noexcept -> iarea
{
  assert(window.is_vulkan());

  int width{};
  int height{};

  SDL_Vulkan_GetDrawableSize(window.get(), &width, &height);

  return {width, height};
}

/// \} End of Vulkan functions

/// \} End of group video

}  // namespace cen::vk

#endif  // CENTURION_NO_VULKAN
#endif  // CENTURION_VULKAN_HEADER

// #include "centurion/video/vulkan/vk_library.hpp"
#ifndef CENTURION_VK_LIBRARY_HEADER
#define CENTURION_VK_LIBRARY_HEADER

#ifndef CENTURION_NO_VULKAN

#include <SDL.h>
#include <SDL_vulkan.h>

// #include "../../compiler/features.hpp"
#ifndef CENTURION_FEATURES_HEADER
#define CENTURION_FEATURES_HEADER

/// \addtogroup compiler
/// \{

// Do we have general C++20 support?
#if __cplusplus >= 202002L
#define CENTURION_HAS_FEATURE_CPP20 1
#else
#define CENTURION_HAS_FEATURE_CPP20 0
#endif  // __cplusplus >= 202002L

// C++20 nodiscard constructors
#if nodiscard >= 201907L
#define CENTURION_NODISCARD_CTOR [[nodiscard]]
#else
#define CENTURION_NODISCARD_CTOR
#endif  // nodiscard >= 201907L

#ifdef __has_include

#if __has_include(<version>)
#include <version>
#endif  // __has_include(<version>)

#ifdef __cpp_lib_format
#define CENTURION_HAS_FEATURE_FORMAT 1
#else
#define CENTURION_HAS_FEATURE_FORMAT 0
#endif  // __cpp_lib_format

#ifdef __cpp_lib_concepts
#define CENTURION_HAS_FEATURE_CONCEPTS 1
#else
#define CENTURION_HAS_FEATURE_CONCEPTS 0
#endif  // __cpp_lib_concepts

#ifdef __cpp_lib_memory_resource
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 1
#else
#define CENTURION_HAS_FEATURE_MEMORY_RESOURCE 0
#endif  // __cpp_lib_memory_resource

#ifdef __cpp_lib_interpolate
#define CENTURION_HAS_FEATURE_LERP 1
#else
#define CENTURION_HAS_FEATURE_LERP 0
#endif  // __cpp_lib_interpolate

#ifdef __cpp_lib_three_way_comparison
#define CENTURION_HAS_FEATURE_SPACESHIP 1
#else
#define CENTURION_HAS_FEATURE_SPACESHIP 0
#endif  // __cpp_lib_three_way_comparison

#if __cpp_lib_chrono >= 201907L
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 1
#else
#define CENTURION_HAS_FEATURE_CHRONO_TIME_ZONES 0
#endif  // __cpp_lib_chrono >= 201907L

#if __cpp_lib_to_array >= 201907L
#define CENTURION_HAS_FEATURE_TO_ARRAY 1
#else
#define CENTURION_HAS_FEATURE_TO_ARRAY 0
#endif  // __cpp_lib_to_array >= 201907L

#endif  // __has_include

/// \} End of group compiler

#endif  // CENTURION_FEATURES_HEADER

// #include "../../core/exception.hpp"
#ifndef CENTURION_EXCEPTION_HEADER
#define CENTURION_EXCEPTION_HEADER

#include <SDL.h>

#ifndef CENTURION_NO_SDL_IMAGE
#include <SDL_image.h>
#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_MIXER
#include <SDL_mixer.h>
#endif  // CENTURION_NO_SDL_MIXER

#ifndef CENTURION_NO_SDL_TTF
#include <SDL_ttf.h>
#endif  // CENTURION_NO_SDL_TTF

#include <exception>  // exception

// #include "str.hpp"
#ifndef CENTURION_STR_HEADER
#define CENTURION_STR_HEADER

namespace cen {

/// \addtogroup core
/// \{

/**
 * \typedef str
 *
 * \brief Alias for a C-style string.
 *
 * \since 6.2.0
 */
using str = const char*;

/**
 * \typedef czstring
 *
 * \brief Alias for a const C-style null-terminated string.
 *
 * \deprecated Since 6.2.0, use `str` instead.
 */
using czstring [[deprecated]] = const char*;

/**
 * \typedef zstring
 * \deprecated Since 6.2.0.
 */
using zstring [[deprecated]] = char*;

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_STR_HEADER


namespace cen {

/// \addtogroup core
/// \{

/**
 * \class cen_error
 *
 * \brief The base of all exceptions explicitly thrown by the library.
 *
 * \since 3.0.0
 */
class cen_error : public std::exception
{
 public:
  cen_error() noexcept = default;

  /**
   * \param what the message of the exception, can safely be null.
   *
   * \since 3.0.0
   */
  explicit cen_error(const str what) noexcept : m_what{what ? what : m_what}
  {}

  [[nodiscard]] auto what() const noexcept -> str override
  {
    return m_what;
  }

 private:
  str m_what{"n/a"};
};

/**
 * \class sdl_error
 *
 * \brief Represents an error related to the core SDL2 library.
 *
 * \since 5.0.0
 */
class sdl_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `sdl_error` with the error message obtained from `SDL_GetError()`.
   *
   * \since 5.0.0
   */
  sdl_error() noexcept : cen_error{SDL_GetError()}
  {}

  /**
   * \brief Creates an `sdl_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit sdl_error(const str what) noexcept : cen_error{what}
  {}
};

#ifndef CENTURION_NO_SDL_IMAGE

/**
 * \class img_error
 *
 * \brief Represents an error related to the SDL2_image library.
 *
 * \since 5.0.0
 */
class img_error final : public cen_error
{
 public:
  /**
   * \brief Creates an `img_error` with the error message obtained from `IMG_GetError()`.
   *
   * \since 5.0.0
   */
  img_error() noexcept : cen_error{IMG_GetError()}
  {}

  /**
   * \brief Creates an `img_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit img_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_IMAGE

#ifndef CENTURION_NO_SDL_TTF

/**
 * \class ttf_error
 *
 * \brief Represents an error related to the SDL2_ttf library.
 *
 * \since 5.0.0
 */
class ttf_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `ttf_error` with the error message obtained from `TTF_GetError()`.
   *
   * \since 5.0.0
   */
  ttf_error() noexcept : cen_error{TTF_GetError()}
  {}

  /**
   * \brief Creates a `ttf_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit ttf_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_TTF

#ifndef CENTURION_NO_SDL_MIXER

/**
 * \class mix_error
 *
 * \brief Represents an error related to the SDL2_mixer library.
 *
 * \since 5.0.0
 */
class mix_error final : public cen_error
{
 public:
  /**
   * \brief Creates a `mix_error` with the error message obtained from `Mix_GetError()`.
   *
   * \since 5.0.0
   */
  mix_error() noexcept : cen_error{Mix_GetError()}
  {}

  /**
   * \brief Creates a `mix_error` with the specified error message.
   *
   * \param what the error message that will be used.
   *
   * \since 5.0.0
   */
  explicit mix_error(const str what) noexcept : cen_error{what}
  {}
};

#endif  // CENTURION_NO_SDL_MIXER

/// \} End of group core

}  // namespace cen

#endif  // CENTURION_EXCEPTION_HEADER

// #include "../../core/str.hpp"


namespace cen {

/// \addtogroup video
/// \{

/**
 * \class vk_library
 *
 * \brief Responsible for loading and unloading a Vulkan library.
 *
 * \since 6.0.0
 */
class vk_library final
{
 public:
  /**
   * \brief Loads a Vulkan library.
   *
   * \param path optional file path to a Vulkan library; a null path indicates that the
   * default library will be used.
   */
  CENTURION_NODISCARD_CTOR explicit vk_library(const str path = nullptr)
  {
    if (SDL_Vulkan_LoadLibrary(path) == -1) {
      throw sdl_error{};
    }
  }

  vk_library(const vk_library&) = delete;
  vk_library(vk_library&&) = delete;

  auto operator=(const vk_library&) -> vk_library& = delete;
  auto operator=(vk_library&&) -> vk_library& = delete;

  ~vk_library() noexcept
  {
    SDL_Vulkan_UnloadLibrary();
  }
};

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_NO_VULKAN
#endif  // CENTURION_VK_LIBRARY_HEADER

// #include "centurion/video/window.hpp"
#ifndef CENTURION_WINDOW_HEADER
#define CENTURION_WINDOW_HEADER

#include <SDL.h>

#include <cassert>   // assert
#include <optional>  // optional
#include <ostream>   // ostream
#include <string>    // string, to_string

// #include "../compiler/features.hpp"


#if CENTURION_HAS_FEATURE_FORMAT

#include <format>  // format

#endif  // CENTURION_HAS_FEATURE_FORMAT

// #include "../core/exception.hpp"

// #include "../core/integers.hpp"

// #include "../core/not_null.hpp"

// #include "../core/owner.hpp"

// #include "../core/result.hpp"

// #include "../core/str.hpp"

// #include "../detail/address_of.hpp"

// #include "../detail/clamp.hpp"

// #include "../detail/convert_bool.hpp"

// #include "../detail/max.hpp"

// #include "../detail/owner_handle_api.hpp"

// #include "../math/area.hpp"

// #include "../math/rect.hpp"

// #include "flash_op.hpp"

// #include "pixel_format.hpp"

// #include "surface.hpp"


namespace cen {

/// \addtogroup video
/// \{

template <typename T>
class basic_window;

/**
 * \typedef window
 *
 * \brief Represents an owning window.
 *
 * \since 5.0.0
 */
using window = basic_window<detail::owning_type>;

/**
 * \typedef window_handle
 *
 * \brief Represents a non-owning window.
 *
 * \since 5.0.0
 */
using window_handle = basic_window<detail::handle_type>;

/**
 * \class basic_window
 *
 * \brief Represents an operating system window.
 *
 * \ownerhandle `window`/`window_handle`
 *
 * \since 5.0.0
 *
 * \see `window`
 * \see `window_handle`
 * \see `get_window()`
 * \see `get_grabbed_window()`
 * \see `mouse_focus_window()`
 * \see `keyboard_focus_window()`
 * \see `get_renderer()`
 * \see `make_window_and_renderer()`
 */
template <typename T>
class basic_window final
{
 public:
  /**
   * \enum window_flags
   *
   * \brief Represents different window features and options.
   *
   * \details Values of this enum are intended to be used to create flag bitmasks, that
   * can be used when creating windows and to obtain information from created windows.
   *
   * \see `SDL_WindowFlags`
   *
   * \since 6.0.0
   */
  enum window_flags : u32
  {
    fullscreen = SDL_WINDOW_FULLSCREEN,
    opengl = SDL_WINDOW_OPENGL,
    shown = SDL_WINDOW_SHOWN,
    hidden = SDL_WINDOW_HIDDEN,
    borderless = SDL_WINDOW_BORDERLESS,
    resizable = SDL_WINDOW_RESIZABLE,
    minimized = SDL_WINDOW_MINIMIZED,
    maximized = SDL_WINDOW_MAXIMIZED,
    input_grabbed = SDL_WINDOW_INPUT_GRABBED,
    input_focus = SDL_WINDOW_INPUT_FOCUS,
    mouse_focus = SDL_WINDOW_MOUSE_FOCUS,
    fullscreen_desktop = SDL_WINDOW_FULLSCREEN_DESKTOP,
    foreign = SDL_WINDOW_FOREIGN,
    high_dpi = SDL_WINDOW_ALLOW_HIGHDPI,
    mouse_capture = SDL_WINDOW_MOUSE_CAPTURE,
    always_on_top = SDL_WINDOW_ALWAYS_ON_TOP,
    skip_taskbar = SDL_WINDOW_SKIP_TASKBAR,
    utility = SDL_WINDOW_UTILITY,
    tooltip = SDL_WINDOW_TOOLTIP,
    popup_menu = SDL_WINDOW_POPUP_MENU,
    vulkan = SDL_WINDOW_VULKAN,

#if SDL_VERSION_ATLEAST(2, 0, 14)
    metal = SDL_WINDOW_METAL
#endif  // SDL_VERSION_ATLEAST(2, 0, 14)
  };

  /// \name Construction
  /// \{

  /**
   * \brief Creates a window from a pointer to an SDL window.
   *
   * \note If you're creating a `window` instance, then ownership of the pointer is
   * claimed. Furthermore, if you're creating a `window_handle`, ownership is *not*
   * claimed.
   *
   * \param window a pointer to the associated SDL window. Ownership of this pointer is
   * claimed if the window is owning.
   *
   * \since 5.0.0
   */
  explicit basic_window(maybe_owner<SDL_Window*> window) noexcept(!detail::is_owning<T>())
      : m_window{window}
  {
    if constexpr (detail::is_owning<T>()) {
      if (!m_window) {
        throw cen_error{"Cannot create window from null pointer!"};
      }
    }
  }

  /**
   * \brief Creates an owning window with the specified title and size.
   *
   * \details The window will be hidden by default.
   *
   * \param title the title of the window, can't be null.
   * \param size the size of the window, components must be greater than zero.
   * \param flags the window flags.
   *
   * \throws cen_error if the supplied width or height aren't greater than zero.
   * \throws sdl_error if the window cannot be created.
   *
   * \see `default_size()`
   * \see `default_flags()`
   *
   * \since 3.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_window(const not_null<str> title,
                        const iarea size = default_size(),
                        const u32 flags = default_flags())
  {
    assert(title);

    if (size.width < 1) {
      throw cen_error{"Bad window width!"};
    }
    else if (size.height < 1) {
      throw cen_error{"Bad window height!"};
    }

    m_window.reset(SDL_CreateWindow(title,
                                    SDL_WINDOWPOS_CENTERED,
                                    SDL_WINDOWPOS_CENTERED,
                                    size.width,
                                    size.height,
                                    flags));
    if (!m_window) {
      throw sdl_error{};
    }
  }

  /**
   * \brief Creates an owning window with the specified title and size.
   *
   * \details The window will be hidden by default.
   *
   * \param title the title of the window.
   * \param size the size of the window, components must be greater than zero.
   * \param flags the window flags, see `window_flags`.
   *
   * \throws cen_error if the supplied width or height aren't greater than zero.
   * \throws sdl_error if the window cannot be created.
   *
   * \see `default_size()`
   * \see `default_flags()`
   *
   * \since 5.3.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  explicit basic_window(const std::string& title,
                        const iarea size = default_size(),
                        const u32 flags = default_flags())
      : basic_window{title.c_str(), size, flags}
  {}

  /**
   * \brief Creates a window.
   *
   * \details The window will use the size obtained from `default_size()` as its initial
   * size.
   *
   * \throws sdl_error if the window cannot be created.
   *
   * \since 3.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  basic_window() : basic_window{"Centurion window"}
  {}

  /**
   * \brief Creates a window handle based on an owning window.
   *
   * \param owner the owning window to base the handle on.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit basic_window(const window& owner) noexcept : m_window{owner.get()}
  {}

  /// \} End of construction

  /// \name Mutators
  /// \{

  /**
   * \brief Makes the window visible.
   *
   * \since 3.0.0
   */
  void show() noexcept
  {
    SDL_ShowWindow(m_window);
  }

  /**
   * \brief Makes the window invisible.
   *
   * \since 3.0.0
   */
  void hide() noexcept
  {
    SDL_HideWindow(m_window);
  }

  /**
   * \brief Raises this window above other windows and requests focus.
   *
   * \since 3.0.0
   */
  void raise() noexcept
  {
    SDL_RaiseWindow(m_window);
  }

  /**
   * \brief Maximizes the window.
   *
   * \since 3.1.0
   */
  void maximize() noexcept
  {
    SDL_MaximizeWindow(m_window);
  }

  /**
   * \brief Minimizes the window.
   *
   * \since 3.1.0
   */
  void minimize() noexcept
  {
    SDL_MinimizeWindow(m_window);
  }

  /**
   * \brief Restores the position and size of the window if it's minimized or maximized.
   *
   * \since 5.3.0
   */
  void restore() noexcept
  {
    SDL_RestoreWindow(m_window);
  }

  /**
   * \brief Updates the window surface.
   *
   * \return `success` if the surface was successfully updated; `failure` otherwise.
   *
   * \since 5.0.0
   */
  auto update_surface() noexcept -> result
  {
    return SDL_UpdateWindowSurface(m_window) == 0;
  }

#if SDL_VERSION_ATLEAST(2, 0, 16)

  /**
   * \brief Modifies the flash state of the window to acquire attention from the user.
   *
   * \param op the flash operation that will be performed.
   *
   * \return `success` if the operation was successful; `failure` otherwise.
   *
   * \since 6.2.0
   */
  auto flash(const flash_op op = flash_op::briefly) noexcept -> result
  {
    return SDL_FlashWindow(m_window, static_cast<SDL_FlashOperation>(op)) == 0;
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 16)

  /// \} End of mutators

  /// \name Setters
  /// \{

  /**
   * \brief Sets whether or not the window is in fullscreen mode.
   *
   * \param enabled `true` if the window should be fullscreen; `false` for windowed mode.
   *
   * \return `success` if the display mode was changed; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_fullscreen(const bool enabled) noexcept -> result
  {
    return SDL_SetWindowFullscreen(m_window, enabled ? fullscreen : 0) == 0;
  }

  /**
   * \brief Sets whether or not the window is in fullscreen desktop mode.
   *
   * \details This mode is useful when you want to "fake" fullscreen mode.
   *
   * \param enabled `true` if the window should be fullscreen desktop; `false` for
   * windowed mode.
   *
   * \return `success` if the display mode was changed; `failure` otherwise.
   *
   * \since 4.0.0
   */
  auto set_fullscreen_desktop(const bool enabled) noexcept -> result
  {
    return SDL_SetWindowFullscreen(m_window, enabled ? fullscreen_desktop : 0) == 0;
  }

  /**
   * \brief Sets whether or not the window is decorated.
   *
   * \details This is enabled by default.
   *
   * \param decorated `true` if the window should be decorated; `false` otherwise.
   *
   * \since 3.0.0
   */
  void set_decorated(const bool decorated) noexcept
  {
    SDL_SetWindowBordered(m_window, detail::convert_bool(decorated));
  }

  /**
   * \brief Sets whether or not the window should be resizable.
   *
   * \param resizable `true` if the window should be resizable; `false` otherwise.
   *
   * \since 3.0.0
   */
  void set_resizable(const bool resizable) noexcept
  {
    SDL_SetWindowResizable(m_window, detail::convert_bool(resizable));
  }

  /**
   * \brief Sets the icon that will be used by the window.
   *
   * \param icon the surface that will serve as the icon of the window.
   *
   * \since 3.0.0
   */
  void set_icon(const surface& icon) noexcept
  {
    SDL_SetWindowIcon(m_window, icon.get());
  }

  /**
   * \brief Sets the title of the window.
   *
   * \param title the title of the window, can't be null.
   *
   * \since 3.0.0
   */
  void set_title(const not_null<str> title) noexcept
  {
    assert(title);
    SDL_SetWindowTitle(m_window, title);
  }

  /**
   * \brief Sets the title of the window.
   *
   * \param title the title of the window.
   *
   * \since 5.3.0
   */
  void set_title(const std::string& title) noexcept
  {
    set_title(title.c_str());
  }

  /**
   * \brief Sets the opacity of the window.
   *
   * \details The supplied opacity will be clamped to a value in the legal range.
   *
   * \param opacity the opacity, in the range [0, 1].
   *
   * \return `success` if the opacity was successfully set; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_opacity(const float opacity) noexcept -> result
  {
    return SDL_SetWindowOpacity(m_window, opacity) == 0;
  }

  /**
   * \brief Sets whether or not the mouse should be confined within the window.
   *
   * \brief This property is disabled by default.
   *
   * \param grab `true` if the mouse should be confined within the window; `false`
   * otherwise.
   *
   * \see `set_grab_keyboard()`
   *
   * \since 3.0.0
   */
  void set_grab_mouse(const bool grab) noexcept
  {
    SDL_SetWindowGrab(m_window, detail::convert_bool(grab));
  }

  /**
   * \brief Sets the overall brightness of the window.
   *
   * \note A brightness value outside the legal range will be clamped to the closest valid
   * value.
   *
   * \param brightness the brightness value, in the range [0, 1].
   *
   * \return `success` if the brightness was successfully set; `failure` otherwise.
   *
   * \since 3.0.0
   */
  auto set_brightness(const float brightness) noexcept -> result
  {
    return SDL_SetWindowBrightness(m_window, detail::clamp(brightness, 0.0f, 1.0f)) == 0;
  }

  /**
   * \brief Sets whether or not the mouse should be captured.
   *
   * \note A window might have to be visible in order for the mouse to be captured.
   *
   * \param capture `true` if the mouse should be captured; `false` otherwise.
   *
   * \return `success` on the mouse capture was successfully changed; `failure` otherwise.
   *
   * \since 5.0.0
   */
  static auto set_capturing_mouse(const bool capture) noexcept -> result
  {
    return SDL_CaptureMouse(detail::convert_bool(capture)) == 0;
  }

#if SDL_VERSION_ATLEAST(2, 0, 16)

  /**
   * \brief Sets whether or not the keyboard input should be grabbed by the window.
   *
   * \param grab `true` if the keyboard should be grabbed; `false` otherwise.
   *
   * \see `set_grab_mouse()`
   *
   * \since 6.2.0
   */
  void set_grab_keyboard(const bool grab) noexcept
  {
    SDL_SetWindowKeyboardGrab(m_window, detail::convert_bool(grab));
  }

  /**
   * \brief Sets whether or not a window is always on top of other windows.
   *
   * \param enabled `true` if the window should be on top of all other windows; `false`
   * otherwise.
   *
   * \since 6.2.0
   */
  void set_always_on_top(const bool enabled) noexcept
  {
    SDL_SetWindowAlwaysOnTop(m_window, detail::convert_bool(enabled));
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 16)

  /// \} End of setters

  /// \name Position functions
  /// \{

  /**
   * \brief Centers the window position relative to the screen.
   *
   * \note Windows are centered by default.
   *
   * \since 3.0.0
   */
  void center() noexcept
  {
    set_position({SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED});
  }

  /**
   * \brief Sets the x-coordinate of the window.
   *
   * \param x the new x-coordinate of the window.
   *
   * \since 6.0.0
   */
  void set_x(const int x) noexcept
  {
    set_position({x, y()});
  }

  /**
   * \brief Sets the y-coordinate of the window.
   *
   * \param y the new y-coordinate of the window.
   *
   * \since 6.0.0
   */
  void set_y(const int y) noexcept
  {
    set_position({x(), y});
  }

  /**
   * \brief Sets the position of the window.
   *
   * \note It's possible to use `SDL_WINDOWPOS_CENTERED` or `SDL_WINDOWPOS_UNDEFINED` as
   * any of the components of the point.
   *
   * \param position the new position of the window.
   *
   * \since 5.0.0
   */
  void set_position(const ipoint position) noexcept
  {
    SDL_SetWindowPosition(m_window, position.x(), position.y());
  }

  /**
   * \brief Returns the x-coordinate of the window position.
   *
   * \return the x-coordinate of the window position.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto x() const noexcept -> int
  {
    return position().x();
  }

  /**
   * \brief Returns the y-coordinate of the window position.
   *
   * \return the y-coordinate of the window position.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto y() const noexcept -> int
  {
    return position().y();
  }

  /**
   * \brief Returns the current position of the window.
   *
   * \note Windows are centered by default.
   *
   * \return the current position of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto position() const noexcept -> ipoint
  {
    int x{};
    int y{};
    SDL_GetWindowPosition(m_window, &x, &y);
    return {x, y};
  }

  /// \} End of position functions

  /// \name Size functions
  /// \{

  /**
   * \brief Sets the width of the window.
   *
   * \details The supplied width is capped to always be at least 1.
   *
   * \param width the new width of the window, must be greater than zero.
   *
   * \since 3.0.0
   */
  void set_width(const int width) noexcept
  {
    SDL_SetWindowSize(m_window, detail::max(width, 1), height());
  }

  /**
   * \brief Sets the height of the window.
   *
   * \details The supplied height is capped to always be at least 1.
   *
   * \param height the new height of the window, must be greater than zero.
   *
   * \since 3.0.0
   */
  void set_height(const int height) noexcept
  {
    SDL_SetWindowSize(m_window, width(), detail::max(height, 1));
  }

  /**
   * \brief Sets the size of the window.
   *
   * \pre The supplied width and height must be greater than zero.
   *
   * \param size the new size of the window.
   *
   * \since 5.0.0
   */
  void set_size(const iarea size) noexcept
  {
    assert(size.width > 0);
    assert(size.height > 0);
    SDL_SetWindowSize(m_window, size.width, size.height);
  }

  /**
   * \brief Sets the minimum size of the window.
   *
   * \pre The supplied width and height must be greater than zero.
   *
   * \param size the minimum size of the window.
   *
   * \since 3.0.0
   */
  void set_min_size(const iarea size) noexcept
  {
    assert(size.width > 0);
    assert(size.height > 0);
    SDL_SetWindowMinimumSize(m_window, size.width, size.height);
  }

  /**
   * \brief Sets the maximum size of the window.
   *
   * \pre The supplied width and height must be greater than zero.
   *
   * \param size the maximum size of the window.
   *
   * \since 3.0.0
   */
  void set_max_size(const iarea size) noexcept
  {
    assert(size.width > 0);
    assert(size.height > 0);
    SDL_SetWindowMaximumSize(m_window, size.width, size.height);
  }

  /**
   * \brief Returns the current width of the window.
   *
   * \return the current width of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto width() const noexcept -> int
  {
    return size().width;
  }

  /**
   * \brief Returns the current height of the window.
   *
   * \return the current height of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto height() const noexcept -> int
  {
    return size().height;
  }

  /**
   * \brief Returns the current size of the window.
   *
   * \note Calling this function is slightly faster than calling both `width` and `height`
   * to obtain the window size.
   *
   * \return the size of the window.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto size() const noexcept -> iarea
  {
    iarea size{};
    SDL_GetWindowSize(m_window, &size.width, &size.height);
    return size;
  }

  /**
   * \brief Returns the minimum size of the window.
   *
   * \return the minimum size of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto min_size() const noexcept -> iarea
  {
    iarea size{};
    SDL_GetWindowMinimumSize(m_window, &size.width, &size.height);
    return size;
  }

  /**
   * \brief Returns the maximum size of the window.
   *
   * \return the maximum size of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto max_size() const noexcept -> iarea
  {
    iarea size{};
    SDL_GetWindowMaximumSize(m_window, &size.width, &size.height);
    return size;
  }

  /**
   * \brief Returns the default size of a window.
   *
   * \note This function is only available for owning windows.
   *
   * \return the default size of a window.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] constexpr static auto default_size() noexcept -> iarea
  {
    return {800, 600};
  }

  /// \} End of size functions

  /// \name Flag queries
  /// \{

  /**
   * \brief Returns a mask that represents the flags associated with the window.
   *
   * \details You can check the returned mask using the `SDL_WindowFlags` enum.
   *
   * \return a mask that represents the flags associated with the window.
   *
   * \see `SDL_WindowFlags`
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto flags() const noexcept -> u32
  {
    return SDL_GetWindowFlags(m_window);
  }

  /**
   * \brief Indicates whether or not a flag is set.
   *
   * \details Some of the use cases of this function can be replaced by more explicit
   * functions, e.g. `is_fullscreen()` instead of `check_flag(SDL_WINDOW_FULLSCREEN)`.
   *
   * \param flag the flag that will be tested.
   *
   * \return `true` if the flag is set; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto check_flag(const SDL_WindowFlags flag) const noexcept -> bool
  {
    return static_cast<bool>(flags() & flag);
  }

  /**
   * \brief Indicates whether or not a flag is set.
   *
   * \details Some of the use cases of this function can be replaced by more explicit
   * functions, e.g. `is_fullscreen()` instead of `check_flag(cen::window::fullscreen)`.
   *
   * \param flag the flag that will be tested.
   *
   * \return `true` if the flag is set; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto check_flag(const window_flags flag) const noexcept -> bool
  {
    return static_cast<bool>(flags() & flag);
  }

  /**
   * \brief Indicates whether or not the window has grabbed the input focus.
   *
   * \return `true` if the window has grabbed input focus; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto has_grabbed_input() const noexcept -> bool
  {
    return check_flag(input_grabbed);
  }

  /**
   * \brief Indicates whether or not the window has input focus.
   *
   * \note The window might have to be visible for this to be true.
   *
   * \return `true` if the window has input focus; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto has_input_focus() const noexcept -> bool
  {
    return check_flag(input_focus);
  }

  /**
   * \brief Indicates whether or not the window has mouse focus.
   *
   * \return `true` if the window has mouse focus; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto has_mouse_focus() const noexcept -> bool
  {
    return check_flag(mouse_focus);
  }

  /**
   * \brief Indicates whether or not the window is borderless.
   *
   * \note This check is the opposite of `is_decorated()`.
   *
   * \details Windows are not borderless by default.
   *
   * \return `true` if the window is borderless; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_borderless() const noexcept -> bool
  {
    return check_flag(borderless);
  }

  /**
   * \brief Indicates whether or not the window is decorated.
   *
   * \note This check is the opposite of `is_borderless()`.
   *
   * \details Windows are decorated by default.
   *
   * \return `true` if the window is decorated; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_decorated() const noexcept -> bool
  {
    return !is_borderless();
  }

  /**
   * \brief Indicates whether or not the window is resizable.
   *
   * \details By default, this property is set to false.
   *
   * \return `true` if the window is resizable; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_resizable() const noexcept -> bool
  {
    return check_flag(resizable);
  }

  /**
   * \brief Indicates whether or the window supports high-DPI mode.
   *
   * \return `true` if the window supports high-DPI mode; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_high_dpi() const noexcept -> bool
  {
    return check_flag(high_dpi);
  }

  /**
   * \brief Indicates whether or not the window is in fullscreen mode.
   *
   * \return `true` if the window is in fullscreen mode; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_fullscreen() const noexcept -> bool
  {
    return check_flag(fullscreen);
  }

  /**
   * \brief Indicates whether or not the window is in fullscreen desktop mode.
   *
   * \return `true` if the window is in fullscreen desktop mode; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_fullscreen_desktop() const noexcept -> bool
  {
    return check_flag(fullscreen_desktop);
  }

  /**
   * \brief Indicates whether or not the window is visible.
   *
   * \return `true` if the window is visible; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto is_visible() const noexcept -> bool
  {
    return check_flag(shown);
  }

  /**
   * \brief Indicates whether or not the window is hidden.
   *
   * \return `true` if the window isn't visible; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_hidden() const noexcept -> bool
  {
    return check_flag(hidden);
  }

  /**
   * \brief Indicates whether or not the window is usable with an OpenGL-context.
   *
   * \return `true` if the window is compatible with an OpenGL-context; false otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_opengl() const noexcept -> bool
  {
    return check_flag(opengl);
  }

  /**
   * \brief Indicates whether or not the window is usable as a Vulkan surface.
   *
   * \return `true` if the window is is usable as a Vulkan surface; false otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_vulkan() const noexcept -> bool
  {
    return check_flag(vulkan);
  }

#if SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Indicates whether or not the window can be used as a Metal view.
   *
   * \return `true` if the window can be used as a Metal view; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_metal() const noexcept -> bool
  {
    return check_flag(metal);
  }

#endif  // SDL_VERSION_ATLEAST(2, 0, 14)

  /**
   * \brief Indicates whether or not the window wasn't created by SDL.
   *
   * \return `true` if the window wasn't created by SDL; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_foreign() const noexcept -> bool
  {
    return check_flag(foreign);
  }

  /**
   * \brief Indicates whether or not the window is capturing the mouse.
   *
   * \return `true` if the window is capturing the mouse; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_capturing_mouse() const noexcept -> bool
  {
    return check_flag(mouse_capture);
  }

  /**
   * \brief Indicates whether or not the window is minimized.
   *
   * \return `true` if the window is minimized; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_minimized() const noexcept -> bool
  {
    return check_flag(minimized);
  }

  /**
   * \brief Indicates whether or not the window is maximized.
   *
   * \return `true` if the window is maximized; `false` otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_maximized() const noexcept -> bool
  {
    return check_flag(maximized);
  }

  /**
   * \brief Indicates whether or not the window is set to be always on top of other
   * windows.
   *
   * \return `true` if the window is always on top of other windows; false otherwise.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto is_always_on_top() const noexcept -> bool
  {
    return check_flag(always_on_top);
  }

  /**
   * \brief Indicates whether or not the window is a "utility" window.
   *
   * \return `true` if window is a "utility" window; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_utility() const noexcept -> bool
  {
    return check_flag(utility);
  }

  /**
   * \brief Indicates whether or not the window is a tooltip.
   *
   * \return `true` if the window is a tooltip; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_tooltip() const noexcept -> bool
  {
    return check_flag(tooltip);
  }

  /**
   * \brief Indicates whether or not the window is a popup menu.
   *
   * \return `true` if the window is a popup menu; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_popup_menu() const noexcept -> bool
  {
    return check_flag(popup_menu);
  }

  /**
   * \brief Indicates whether or not the window is excluded from the taskbar.
   *
   * \return `true` if the window is excluded from the taskbar; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_excluded_from_taskbar() const noexcept -> bool
  {
    return check_flag(skip_taskbar);
  }

  template <typename TT = T, detail::is_owner<TT> = 0>
  [[nodiscard]] constexpr static auto default_flags() noexcept -> u32
  {
    return hidden;
  }

  /// \} End of flag queries

  /// \name Getters
  /// \{

  /**
   * \brief Returns a numerical ID of the window.
   *
   * \return a numerical ID of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto id() const noexcept -> u32
  {
    return SDL_GetWindowID(m_window);
  }

  /**
   * \brief Returns the display index associated with the window.
   *
   * \return the display index associated with the window; `std::nullopt` if the display
   * index cannot be obtained.
   *
   * \since 3.1.0
   */
  [[nodiscard]] auto display_index() const noexcept -> std::optional<int>
  {
    const auto index = SDL_GetWindowDisplayIndex(m_window);
    if (index != -1) {
      return index;
    }
    else {
      return std::nullopt;
    }
  }

  /**
   * \brief Returns the title of the window.
   *
   * \return the title of the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto title() const -> std::string
  {
    return SDL_GetWindowTitle(m_window);
  }

  /**
   * \brief Returns the current brightness value of the window.
   *
   * \details The default value of this property is 1.
   *
   * \return the current brightness of the window, in the range [0, 1].
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto brightness() const noexcept -> float
  {
    return SDL_GetWindowBrightness(m_window);
  }

  /**
   * \brief Returns the opacity of the window.
   *
   * \return the opacity of the window, in the range [0, 1].
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto opacity() const noexcept -> float
  {
    float opacity{1};
    SDL_GetWindowOpacity(m_window, &opacity);
    return opacity;
  }

  /**
   * \brief Returns the pixel format of the window.
   *
   * \return the pixel format used by the window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto get_pixel_format() const noexcept -> pixel_format
  {
    return static_cast<pixel_format>(SDL_GetWindowPixelFormat(m_window));
  }

  /**
   * \brief Returns a handle to the window framebuffer surface.
   *
   * \warning It is not possible use the framebuffer surface with the 3D or 2D rendering
   * APIs.
   *
   * \return a handle to the window surface, might not contain a valid surface pointer.
   *
   * \since 5.0.0
   */
  [[nodiscard]] auto get_surface() noexcept -> surface_handle
  {
    return surface_handle{SDL_GetWindowSurface(m_window)};
  }

  /**
   * \brief Indicates whether or not the window is currently grabbing the mouse input.
   *
   * \return `true` if the window is grabbing the mouse; `false` otherwise.
   *
   * \since 3.0.0
   */
  [[nodiscard]] auto grabbing_mouse() const noexcept -> bool
  {
    return SDL_GetWindowGrab(m_window);
  }

  /**
   * \brief Indicates whether or not the screen keyboard is shown for the window.
   *
   * \return `true` if the screen keyboard is shown for the window; `false` otherwise.
   *
   * \since 6.0.0
   */
  [[nodiscard]] auto is_screen_keyboard_shown() const noexcept -> bool
  {
    return SDL_IsScreenKeyboardShown(get()) == SDL_TRUE;
  }

  /**
   * \brief Returns a pointer to the associated SDL window.
   *
   * \warning Don't take ownership of the returned pointer!
   *
   * \return a pointer to the associated SDL window.
   *
   * \since 4.0.0
   */
  [[nodiscard]] auto get() const noexcept -> SDL_Window*
  {
    return m_window.get();
  }

  /// \} End of getters

  /// \name Conversions
  /// \{

  /**
   * \brief Converts to `SDL_Window*`.
   *
   * \return a pointer to the associated SDL window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit operator SDL_Window*() noexcept
  {
    return m_window.get();
  }

  /**
   * \brief Converts to `const SDL_Window*`.
   *
   * \return a pointer to the associated SDL window.
   *
   * \since 3.0.0
   */
  [[nodiscard]] explicit operator const SDL_Window*() const noexcept
  {
    return m_window.get();
  }

  /**
   * \brief Indicates whether or not the handle holds a non-null pointer.
   *
   * \note This function is only available for window handles.
   *
   * \warning It's undefined behaviour to invoke other member functions that use the
   * internal pointer if this function returns `false`.
   *
   * \return `true` if the handle holds a non-null pointer; `false` otherwise.
   *
   * \since 5.0.0
   */
  template <typename TT = T, detail::is_handle<TT> = 0>
  explicit operator bool() const noexcept
  {
    return m_window != nullptr;
  }

  /// \} End of conversions

 private:
  struct deleter final
  {
    void operator()(SDL_Window* window) noexcept
    {
      SDL_DestroyWindow(window);
    }
  };
  detail::pointer_manager<T, SDL_Window, deleter> m_window;
};

/// \name String conversions
/// \{

/**
 * \brief Returns a textual representation of a window.
 *
 * \param window the window that will be converted.
 *
 * \return a textual representation of the window.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto to_string(const basic_window<T>& window) -> std::string
{
#if CENTURION_HAS_FEATURE_FORMAT
  return std::format("window{{data: {}, width: {}, height: {}}}",
                     detail::address_of(window.get()),
                     window.width(),
                     window.height());
#else
  return "window{data: " + detail::address_of(window.get()) +
         ", width: " + std::to_string(window.width()) +
         ", height: " + std::to_string(window.height()) + "}";
#endif  // CENTURION_HAS_FEATURE_FORMAT
}

/// \} End of string conversions

/// \name Streaming
/// \{

/**
 * \brief Prints a textual representation of a window.
 *
 * \param stream the stream that will be used.
 * \param window the window that will be printed.
 *
 * \return the used stream.
 *
 * \since 5.0.0
 */
template <typename T>
auto operator<<(std::ostream& stream, const basic_window<T>& window) -> std::ostream&
{
  return stream << to_string(window);
}

/// \} End of streaming

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_WINDOW_HEADER

// #include "centurion/video/window_utils.hpp"
#ifndef CENTURION_WINDOW_UTILS_HEADER
#define CENTURION_WINDOW_UTILS_HEADER

#include <SDL.h>

#include <utility>  // pair, make_pair, move

// #include "../core/integers.hpp"

// #include "../math/area.hpp"

// #include "renderer.hpp"

// #include "window.hpp"


namespace cen {

/// \addtogroup video
/// \{

/// \name Window functions
/// \{

/**
 * \brief Returns a handle to the currently grabbed window.
 *
 * \return a handle to the currently grabbed window, might not refer to a valid window if
 * there is no grabbed window.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto get_grabbed_window() noexcept -> window_handle
{
  return window_handle{SDL_GetGrabbedWindow()};
}

/**
 * \brief Returns a handle to the window that has mouse focus.
 *
 * \return a window handle.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto mouse_focus_window() noexcept -> window_handle
{
  return window_handle{SDL_GetMouseFocus()};
}

/**
 * \brief Returns a handle to the window that has keyboard focus.
 *
 * \return a window handle.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto keyboard_focus_window() noexcept -> window_handle
{
  return window_handle{SDL_GetKeyboardFocus()};
}

/**
 * \brief Returns a handle to the window associated with the specified ID.
 *
 * \param id the ID associated with the desired window.
 *
 * \return a handle to the window associated with the ID, might not refer to a valid
 * window if there no matching window.
 *
 * \since 5.0.0
 */
[[nodiscard]] inline auto get_window(const u32 id) noexcept -> window_handle
{
  return window_handle{SDL_GetWindowFromID(id)};
}

/**
 * \brief Returns a handle to the renderer associated with a window.
 *
 * \details The returned handle will be null if the supplied window doesn't have an
 * associated renderer.
 *
 * \note You should always check whether or not the returned handle contains a valid
 * renderer pointer before using it!
 *
 * \tparam T the type of the derived window.
 *
 * \param window the window associated with the desired renderer.
 *
 * \return a handle to the associated renderer, might not contain a valid renderer
 * pointer.
 *
 * \since 5.0.0
 */
template <typename T>
[[nodiscard]] auto get_renderer(const basic_window<T>& window) noexcept -> renderer_handle
{
  return renderer_handle{SDL_GetRenderer(window.get())};
}

/**
 * \brief Creates a window and an associated renderer.
 *
 * \details This function can be used as a slightly more concise way to create a window
 * and a renderer.
 * \code{cpp}
 *   auto [window, renderer] = cen::make_window_and_renderer();
 * \endcode
 *
 * \param size the size of the window.
 * \param flags the flags used by the window, see `basic_window::window_flags`.
 *
 * \return the created window and renderer.
 *
 * \since 6.0.0
 */
[[nodiscard]] inline auto make_window_and_renderer(const iarea size = window::default_size(),
                                                   const u32 flags = window::default_flags())
    -> std::pair<window, renderer>
{
  cen::window window{"Centurion window", size, flags};
  cen::renderer renderer{window};
  return std::make_pair(std::move(window), std::move(renderer));
}

/// \} End of window functions

/// \} End of group video

}  // namespace cen

#endif  // CENTURION_WINDOW_UTILS_HEADER

#endif  // CENTURION_CENTURION_HEADER
